; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonNetworkStreamPhaseGame.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?gs_bEmpireLanuageEnable@@3HA			; gs_bEmpireLanuageEnable
PUBLIC	??_C@_0BB@DGNNMOLK@RefreshAlignment?$AA@	; `string'
PUBLIC	??_C@_0BJ@GGFFBLPA@RefreshTargetBoardByName?$AA@ ; `string'
PUBLIC	??_C@_0BI@IJENFIMO@RefreshTargetBoardByVID?$AA@	; `string'
PUBLIC	??_C@_04IBBNLEM@Game?$AA@			; `string'
PUBLIC	??_C@_0BD@FLFBFOOJ@RefreshTargetBoard?$AA@	; `string'
PUBLIC	??_C@_0BB@CAEOPHDE@RefreshEquipment?$AA@	; `string'
PUBLIC	??_C@_0BB@HFALJDHO@RefreshCharacter?$AA@	; `string'
PUBLIC	??_C@_0BA@JECEPFD@RefreshExchange?$AA@		; `string'
PUBLIC	??_C@_0BB@JLCHKFKI@RefreshInventory?$AA@	; `string'
PUBLIC	??_C@_0P@PHDJJCCP@RefreshSafebox?$AA@		; `string'
PUBLIC	??_C@_0N@EFFAOLPI@RefreshSkill?$AA@		; `string'
PUBLIC	??_C@_0O@PDJLBMPA@RefreshStatus?$AA@		; `string'
PUBLIC	??_C@_0M@HNBFKLDC@RefreshMall?$AA@		; `string'
PUBLIC	??_C@_0BF@NLJDKFFK@RefreshGuildInfoPage?$AA@	; `string'
PUBLIC	??_C@_0BB@CDMJAHKO@RefreshMessenger?$AA@	; `string'
PUBLIC	??_C@_0BH@BOJHBBF@RefreshGuildMemberPage?$AA@	; `string'
PUBLIC	??_C@_0BG@FFPNPADB@RefreshGuildBoardPage?$AA@	; `string'
PUBLIC	??_C@_0BG@MICKDFKA@RefreshGuildSkillPage?$AA@	; `string'
PUBLIC	??_C@_0CE@PAAOLBDB@RefreshGuildMemberPageGradeCombo@ ; `string'
PUBLIC	??_C@_05FONOJENF@?$CIsii?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BG@CBAJOEAC@RefreshGuildGradePage?$AA@	; `string'
PUBLIC	??_C@_0BL@HPKACCGC@?$CD?$CD?5Network?5?9?5Game?5Phase?5?$CD?$CD?$AA@ ; `string'
PUBLIC	??_C@_0M@DJFBBLID@ShowMapName?$AA@		; `string'
PUBLIC	??_C@_0BB@FNPCBFHE@CloseTargetBoard?$AA@	; `string'
PUBLIC	??_C@_0EC@IHJJGCFB@CPythonNetworkStream?3?3RecvDuelSt@ ; `string'
PUBLIC	??_C@_0IB@FFAGJAOL@CPythonNetworkStream?3?3SendCharac@ ; `string'
PUBLIC	??_C@_0CE@DHDBME@?5SendMessengerAddByNamePacket?5?3?5@ ; `string'
PUBLIC	??_C@_0DL@GMAAOOOI@Can?8t?5register?5emoticon?5string?4?4@ ; `string'
PUBLIC	??_C@_0DN@EFFJHKOL@CPythonNetworkStream?3?3SendUseSki@ ; `string'
PUBLIC	??_C@_0BF@EKLOHGBI@BINARY_SetTipMessage?$AA@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_07IAFACCAD@?$CFs?5?3?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BF@MEFMFHCI@BINARY_SetBigMessage?$AA@	; `string'
PUBLIC	??_C@_0O@MLMPGGOH@OnRecvWhisper?$AA@		; `string'
PUBLIC	??_C@_05FKJLIKKL@?$CIiss?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BD@HFHHLLOG@OnRecvWhisperError?$AA@	; `string'
PUBLIC	??_C@_0BL@MJBHNNKO@OnRecvWhisperSystemMessage?$AA@ ; `string'
PUBLIC	??_C@_0M@JJMCBALF@OnPickMoney?$AA@		; `string'
PUBLIC	??_C@_0BP@DGLKKAJF@Recv?5Point?5Change?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0CL@KJGPDLAC@CPythonNetworkStream?3?3RecvDeadPa@ ; `string'
PUBLIC	??_C@_0CL@MKMKFBIM@CPythonNetworkStream?3?3RecvStunPa@ ; `string'
PUBLIC	??_C@_0L@MNOOMILJ@OnGameOver?$AA@		; `string'
PUBLIC	??_C@_0M@BDKDPHGA@?A?V?$MA?N?$LA?x?5?$LL?g?$LI?A?$AA@ ; `string'
PUBLIC	??_C@_0BL@HCNNPICH@Send?5On_Click?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0CF@OKKJKDKD@Send?5Character?5Position?5Packet?5E@ ; `string'
PUBLIC	??_C@_09PJIJIJPH@StartShop?$AA@			; `string'
PUBLIC	??_C@_0BD@ICLELGCO@SendOnClickPacket?6?$AA@	; `string'
PUBLIC	??_C@_0M@DLPMCOFP@RefreshShop?$AA@		; `string'
PUBLIC	??_C@_07FONJAJPH@EndShop?$AA@			; `string'
PUBLIC	??_C@_0BB@GHBGEHD@NOT_ENOUGH_MONEY?$AA@		; `string'
PUBLIC	??_C@_0BE@MHMAEIEM@SetShopSellingPrice?$AA@	; `string'
PUBLIC	??_C@_0BE@OHHJLOIF@NOT_ENOUGH_MONEY_EX?$AA@	; `string'
PUBLIC	??_C@_0M@NHHHAHOK@OnShopError?$AA@		; `string'
PUBLIC	??_C@_0P@HIHIAGBD@INVENTORY_FULL?$AA@		; `string'
PUBLIC	??_C@_07FBAJNJNN@SOLDOUT?$AA@			; `string'
PUBLIC	??_C@_0DJ@IGANFIGP@CPythonNetworkStream?3?3RecvShopPa@ ; `string'
PUBLIC	??_C@_0M@HAELFLPD@INVALID_POS?$AA@		; `string'
PUBLIC	??_C@_0M@GJLEGLOM@EndExchange?$AA@		; `string'
PUBLIC	??_C@_0O@HKIIBLHD@StartExchange?$AA@		; `string'
PUBLIC	??_C@_0P@DNLFDBJJ@trade_less_elk?$AA@		; `string'
PUBLIC	??_C@_0O@LLCGBEIB@trade_already?$AA@		; `string'
PUBLIC	??_C@_0CA@LAFLPPD@Recv?5Quest?5Info?5Packet?5Error?5?$CD2?$AA@ ; `string'
PUBLIC	??_C@_0CA@CACIOMDA@Recv?5Quest?5Info?5Packet?5Error?5?$CD1?$AA@ ; `string'
PUBLIC	??_C@_0BN@JBCFOMDG@RecvQuestConfirmPacket?5Error?$AA@ ; `string'
PUBLIC	??_C@_0N@IPPKALM@RefreshQuest?$AA@		; `string'
PUBLIC	??_C@_0CC@ELOCPLFN@RecvRequestMakeGuild?5Packet?5Erro@ ; `string'
PUBLIC	??_C@_0BG@KIBJJMEI@BINARY_OnQuestConfirm?$AA@	; `string'
PUBLIC	??_C@_0BA@BHDOCKEA@ToggleDebugInfo?$AA@		; `string'
PUBLIC	??_C@_0N@FKOIEIPK@AskGuildName?$AA@		; `string'
PUBLIC	??_C@_0CD@FOAEKPNP@send_trade_start_packet?5?5?5vid?5?$CFd@ ; `string'
PUBLIC	??_C@_0BP@CGFAIMHK@send_trade_start_packet?5Error?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@JFABNFDE@send_trade_item_add_packet?5Error@ ; `string'
PUBLIC	??_C@_0CB@EABMKDBI@send_trade_elk_add_packet?5Error?6@ ; `string'
PUBLIC	??_C@_0CA@EEPLBN@send_trade_accept_packet?5Error?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@IFEOOANP@send_trade_item_del_packet?5Error@ ; `string'
PUBLIC	??_C@_0BA@ILEGHCPF@StartPointReset?$AA@		; `string'
PUBLIC	??_C@_0BO@FJKDIHPJ@send_trade_exit_packet?5Error?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@FELFLKOI@RecvScriptPacket_SizeError?$AA@ ; `string'
PUBLIC	??_C@_0BL@GIIBIOJB@RecvScriptPacket_RecvError?$AA@ ; `string'
PUBLIC	??_C@_0CA@DKGOFDHL@Send?5Script?5Button?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0CA@GLOCGDPA@Send?5Script?5Answer?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0CB@KDIADHIP@SendQuestInputStringPacket?5Error@ ; `string'
PUBLIC	??_C@_0CB@FGDJCCCM@SendAnswerMakeGuild?5Packet?5Error@ ; `string'
PUBLIC	??_C@_0CB@HKJKPPKG@?5SendQuestConfirmPacket?5?3?5?$CFd?0?5?$CFd@ ; `string'
PUBLIC	??_C@_0BN@IAHFIDIL@SendQuestConfirmPacket?5Error?$AA@ ; `string'
PUBLIC	??_C@_0DB@OELACDEA@CPythonNetworkStream?3?3RecvSkillL@ ; `string'
PUBLIC	??_C@_0DH@MPAMADMO@CPythonNetworkStream?3?3RecvSkillC@ ; `string'
PUBLIC	??_C@_0DE@EBNCHOOM@CPythonNetworkStream?3?3RecvSkillL@ ; `string'
PUBLIC	??_C@_0BE@OJMAIMGE@?5?$DO?$DO?5RecvSkillLevel?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@PIHJNOHE@Damage?5is?5equal?5or?5below?50?4?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HIJGCIDI@Recv?5Target?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BB@PDPGJKAD@SetHPTargetBoard?$AA@	; `string'
PUBLIC	??_C@_0BM@KLEOIHKF@CloseTargetBoardIfDifferent?$AA@ ; `string'
PUBLIC	??_C@_0BI@OCDKMKMI@Recv?5Speed?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BI@LEDBDCKL@Recv?5Mount?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BN@KNAMGOGH@VID?5?$FL?$CFd?$FN?$LA?$KB?5?E?$LI?$LA?Y?$MA?$LL?5?C?$NP?$LA?$KB?5?$LM?$LD?A?$KE?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@IBBLODAF@Send?5Battle?5Attack?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BG@GKKFNNN@SendShootPacket?5Error?$AA@	; `string'
PUBLIC	??_C@_0EM@NIJLGOIC@CPythonNetworkStream?3?3RecvFlyTar@ ; `string'
PUBLIC	??_C@_0BJ@MBCMDDJG@Send?5Target?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BP@MONNHODC@Send?5FlyTargeting?5Packet?5Error?$AA@ ; `string'
PUBLIC	??_C@_0EG@HLBPKODM@CPythonNetworkStream?3?3SendPartyI@ ; `string'
PUBLIC	??_C@_0DM@NAODJGJE@CPythonNetworkStream?3?3SendSyncPo@ ; `string'
PUBLIC	??_C@_0FA@IIILKEFH@CPythonNetworkStream?3?3SendPartyI@ ; `string'
PUBLIC	??_C@_0CA@GNHHEHBK@?5?$DM?$DM?5SendPartyInvitePacket?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0EG@BBBGKACF@CPythonNetworkStream?3?3SendPartyR@ ; `string'
PUBLIC	??_C@_0CK@GHKGLGPO@?5?$DM?$DM?5SendPartyInviteAnswerPacket?5@ ; `string'
PUBLIC	??_C@_0EM@FFPCCHJM@CPythonNetworkStream?3?3SendPartyS@ ; `string'
PUBLIC	??_C@_0CA@HANJMBEA@?5?$DM?$DM?5SendPartyRemovePacket?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0EM@BMAFGIHC@CPythonNetworkStream?3?3SendPartyU@ ; `string'
PUBLIC	??_C@_0CK@PHAHCCJC@?5?$DM?$DM?5SendPartySetStatePacket?5?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0EH@IOBBPNMN@CPythonNetworkStream?3?3SendPartyP@ ; `string'
PUBLIC	??_C@_0CG@GLODGHKD@?5?$DM?$DM?5SendPartyUseSkillPacket?5?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0EO@GALKDEGO@?5CPythonNetworkStream?3?3RecvParty@ ; `string'
PUBLIC	??_C@_0CD@LLPEDDBL@?5?$DM?$DM?5SendPartyParameterPacket?5?3?5?$CF@ ; `string'
PUBLIC	??_C@_0BO@EBDJDNJB@?5?$DO?$DO?5RecvPartyInvite?5?3?5?$CFd?0?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@FPJOLEHH@RecvPartyInviteQuestion?$AA@	; `string'
PUBLIC	??_C@_0BL@GPMBAKEI@?5?$DO?$DO?5RecvPartyAdd?5?3?5?$CFd?0?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0P@JPKHKGNP@AddPartyMember?$AA@		; `string'
PUBLIC	??_C@_0BC@DGCJFOHN@RemovePartyMember?$AA@	; `string'
PUBLIC	??_C@_0BG@JOKFDABD@UpdatePartyMemberInfo?$AA@	; `string'
PUBLIC	??_C@_0BA@JPJIDGOI@LinkPartyMember?$AA@		; `string'
PUBLIC	??_C@_0BK@FHNAOGNK@?5?$DO?$DO?5RecvPartyRemove?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@KBCGJNOO@UnlinkAllPartyMember?$AA@	; `string'
PUBLIC	??_C@_0BM@FEBFPLO@?5?$DO?$DO?5RecvPartyLink?5?3?5?$CFd?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@JOBNIIPD@?5?$DO?$DO?5RecvPartyUnlink?5?3?5?$CFd?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@EBBCCLIK@UnlinkPartyMember?$AA@	; `string'
PUBLIC	??_C@_0BN@HDHIECAG@?5?$DO?$DO?5RecvPartyParameter?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@FFLEPOCB@ChangePartyParameter?$AA@	; `string'
PUBLIC	??_C@_0CB@OCJDCDKN@?5SendGuildRemoveMemberPacket?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BL@GHDBPEKM@?5SendGuildAddMemberPacket?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@ENAPGANL@?5SendGuildChangeGradeAuthorityPa@ ; `string'
PUBLIC	??_C@_0CI@HCDCDOMK@?5SendGuildChangeGradeNamePacket?5@ ; `string'
PUBLIC	??_C@_0CE@ILONPNIK@?5SendGuildPostCommentPacket?5?$CFd?0?5@ ; `string'
PUBLIC	??_C@_0BK@JBHNFCGO@?5SendGuildOfferPacket?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@DFFJJDFM@?5SendGuildRefreshCommentPacket?5?$CF@ ; `string'
PUBLIC	??_C@_0CC@HHBLBNGP@?5SendGuildDeleteCommentPacket?5?$CFd@ ; `string'
PUBLIC	??_C@_0CB@HHLIHMFO@?5SendGuildUseSkillPacket?5?$CFd?0?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CK@NJDDFMMG@?5SendGuildChangeMemberGradePacke@ ; `string'
PUBLIC	??_C@_0CF@HPNCOLAE@?5SendGuildInviteAnswerPacket?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0DA@BBFAPAKJ@?5SendGuildChangeMemberGeneralFla@ ; `string'
PUBLIC	??_C@_0CB@OEPAEO@?5SendGuildDepositMoneyPacket?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BO@DLDFHEKF@?5SendGuildChargeGSPPacket?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0M@JPGKCCFN@DeleteGuild?$AA@		; `string'
PUBLIC	??_C@_0CC@HBGAJKKF@?5SendGuildWithdrawMoneyPacket?5?$CFd@ ; `string'
PUBLIC	??_C@_0BC@MJKOOFCD@RefreshGuildGrade?$AA@	; `string'
PUBLIC	??_C@_0O@EGDOPDJO@?5?$DMRemove?$DO?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@KDHBOMAA@?5?$DMChange?5Grade?5Authority?$DO?5?$CFd?0?5?$CFd@ ; `string'
PUBLIC	??_C@_0BN@JFJPHNLH@?5?$DMChange?5Grade?5Name?$DO?5?$CFd?0?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@HEKKNAEA@?5?$DMChangeMemberGrade?$DO?5?$CFd?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GJIHEANJ@?5?$DMChangeEXP?$DO?5?$CFd?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@MPFPDEHG@?5?$DMChangeMemberGeneralFlag?$DO?5?$CFd?0?5?$CF@ ; `string'
PUBLIC	??_C@_0BK@FEHNPJOD@?5?$DMSkillInfo?$DO?5?$CFd?5?1?5?$CFd?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@EECNELJB@?5?$DMGuild?5Invite?$DO?5?$CFd?0?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@GJGOAKHL@RecvGuildInviteQuestion?$AA@	; `string'
PUBLIC	??_C@_0BO@HMPGICIO@BINARY_GuildWar_OnSendDeclare?$AA@ ; `string'
PUBLIC	??_C@_0DF@PELONEKB@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@ ; `string'
PUBLIC	??_C@_0BO@JAJLCPKG@BINARY_GuildWar_OnRecvDeclare?$AA@ ; `string'
PUBLIC	??_C@_0DF@BIEEJDD@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@ ; `string'
PUBLIC	??_C@_0BI@JKFNHMFD@BINARY_GuildWar_OnStart?$AA@	; `string'
PUBLIC	??_C@_0DI@LOGKJDI@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@ ; `string'
PUBLIC	??_C@_0BG@NACAFPAN@BINARY_GuildWar_OnEnd?$AA@	; `string'
PUBLIC	??_C@_0CM@HGKOKFIL@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@ ; `string'
PUBLIC	??_C@_0CA@FNEJFGNL@?5?$DO?$DO?5GulidWarEndList?5?$FL?$CFd?5vs?5?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@PIMGMDLK@?5?$DO?$DO?5GulidWarList?5?$FL?$CFd?5vs?5?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IAMOHDFF@?5?$DO?$DO?5Guild?5Money?5Change?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@LBOEDDLE@BINARY_GuildWar_OnRecvPoint?$AA@ ; `string'
PUBLIC	??_C@_0BH@DPEJLPAP@OnFishingNotifyUnknown?$AA@	; `string'
PUBLIC	??_C@_0BB@CJFMLNJB@OnFishingFailure?$AA@	; `string'
PUBLIC	??_C@_0BB@OABOAGML@OnFishingSuccess?$AA@	; `string'
PUBLIC	??_C@_0BA@ODHDNEFK@OnFishingNotify?$AA@		; `string'
PUBLIC	??_C@_0BK@CKEFNKBC@BINARY_PrivateShop_Appear?$AA@ ; `string'
PUBLIC	??_C@_0BN@BEOHMMCM@BINARY_PrivateShop_Disappear?$AA@ ; `string'
PUBLIC	??_C@_0BB@CHHJLMHC@OpenRefineDialog?$AA@	; `string'
PUBLIC	??_C@_06GAHGMLBJ@?$CIiiii?$CJ?$AA@		; `string'
PUBLIC	??_C@_07FANHMMCA@?$CIiiiii?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BN@KLPAAKFJ@AppendMaterialToRefineDialog?$AA@ ; `string'
PUBLIC	??_C@_0BN@PKCCDLMA@SendClientReportPacket?5Error?$AA@ ; `string'
PUBLIC	??_C@_0L@DJAIFHCH@1215955205?$AA@		; `string'
PUBLIC	??_C@_0BF@DEMCFMHM@BINARY_NEW_AddAffect?$AA@	; `string'
PUBLIC	??_C@_0BJ@FBHNPCOP@Fri?5Sep?527?521?356?350?52013?$AA@ ; `string'
PUBLIC	??_C@_0BE@OLAMAMAK@OpenEquipmentDialog?$AA@	; `string'
PUBLIC	??_C@_0BI@NIFEGIKP@BINARY_NEW_RemoveAffect?$AA@	; `string'
PUBLIC	??_C@_0BJ@DBOCKHJF@SetEquipmentDialogSocket?$AA@ ; `string'
PUBLIC	??_C@_0BH@DIEBEMHE@SetEquipmentDialogItem?$AA@	; `string'
PUBLIC	??_C@_0BH@NJGJICND@BINARY_OpenAtlasWindow?$AA@	; `string'
PUBLIC	??_C@_0BH@NIIPMAGM@SetEquipmentDialogAttr?$AA@	; `string'
PUBLIC	??_C@_0BH@KEGDJEJM@BINARY_UpdateLovePoint?$AA@	; `string'
PUBLIC	??_C@_0BB@EGDBDJKJ@BINARY_LoverInfo?$AA@	; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonQuest@@@@0PAVCPythonQuest@@A ; CSingleton<CPythonQuest>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
EXTRN	?CreateIndexedFly@CFlyingManager@@QAEXKPAVCActorInstance@@0@Z:PROC ; CFlyingManager::CreateIndexedFly
EXTRN	?Send@CNetworkStream@@QAE_NHPBD@Z:PROC		; CNetworkStream::Send
EXTRN	_strncmp:PROC
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonQuest@@@@0PAVCPythonQuest@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonQuest@@@@0PAVCPythonQuest@@A DD 01H DUP (?) ; CSingleton<CPythonQuest>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A DD 01H DUP (?) ; CSingleton<CPythonShop>::ms_singleton
_BSS	ENDS
;	COMDAT ??_C@_0BB@EGDBDJKJ@BINARY_LoverInfo?$AA@
CONST	SEGMENT
??_C@_0BB@EGDBDJKJ@BINARY_LoverInfo?$AA@ DB 'BINARY_LoverInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KEGDJEJM@BINARY_UpdateLovePoint?$AA@
CONST	SEGMENT
??_C@_0BH@KEGDJEJM@BINARY_UpdateLovePoint?$AA@ DB 'BINARY_UpdateLovePoint'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NIIPMAGM@SetEquipmentDialogAttr?$AA@
CONST	SEGMENT
??_C@_0BH@NIIPMAGM@SetEquipmentDialogAttr?$AA@ DB 'SetEquipmentDialogAttr'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NJGJICND@BINARY_OpenAtlasWindow?$AA@
CONST	SEGMENT
??_C@_0BH@NJGJICND@BINARY_OpenAtlasWindow?$AA@ DB 'BINARY_OpenAtlasWindow'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DIEBEMHE@SetEquipmentDialogItem?$AA@
CONST	SEGMENT
??_C@_0BH@DIEBEMHE@SetEquipmentDialogItem?$AA@ DB 'SetEquipmentDialogItem'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBOCKHJF@SetEquipmentDialogSocket?$AA@
CONST	SEGMENT
??_C@_0BJ@DBOCKHJF@SetEquipmentDialogSocket?$AA@ DB 'SetEquipmentDialogSo'
	DB	'cket', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NIFEGIKP@BINARY_NEW_RemoveAffect?$AA@
CONST	SEGMENT
??_C@_0BI@NIFEGIKP@BINARY_NEW_RemoveAffect?$AA@ DB 'BINARY_NEW_RemoveAffe'
	DB	'ct', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OLAMAMAK@OpenEquipmentDialog?$AA@
CONST	SEGMENT
??_C@_0BE@OLAMAMAK@OpenEquipmentDialog?$AA@ DB 'OpenEquipmentDialog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FBHNPCOP@Fri?5Sep?527?521?356?350?52013?$AA@
CONST	SEGMENT
??_C@_0BJ@FBHNPCOP@Fri?5Sep?527?521?356?350?52013?$AA@ DB 'Fri Sep 27 21:'
	DB	'56:50 2013', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DEMCFMHM@BINARY_NEW_AddAffect?$AA@
CONST	SEGMENT
??_C@_0BF@DEMCFMHM@BINARY_NEW_AddAffect?$AA@ DB 'BINARY_NEW_AddAffect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DJAIFHCH@1215955205?$AA@
CONST	SEGMENT
??_C@_0L@DJAIFHCH@1215955205?$AA@ DB '1215955205', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PKCCDLMA@SendClientReportPacket?5Error?$AA@
CONST	SEGMENT
??_C@_0BN@PKCCDLMA@SendClientReportPacket?5Error?$AA@ DB 'SendClientRepor'
	DB	'tPacket Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KLPAAKFJ@AppendMaterialToRefineDialog?$AA@
CONST	SEGMENT
??_C@_0BN@KLPAAKFJ@AppendMaterialToRefineDialog?$AA@ DB 'AppendMaterialTo'
	DB	'RefineDialog', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FANHMMCA@?$CIiiiii?$CJ?$AA@
CONST	SEGMENT
??_C@_07FANHMMCA@?$CIiiiii?$CJ?$AA@ DB '(iiiii)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GAHGMLBJ@?$CIiiii?$CJ?$AA@
CONST	SEGMENT
??_C@_06GAHGMLBJ@?$CIiiii?$CJ?$AA@ DB '(iiii)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHHJLMHC@OpenRefineDialog?$AA@
CONST	SEGMENT
??_C@_0BB@CHHJLMHC@OpenRefineDialog?$AA@ DB 'OpenRefineDialog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BEOHMMCM@BINARY_PrivateShop_Disappear?$AA@
CONST	SEGMENT
??_C@_0BN@BEOHMMCM@BINARY_PrivateShop_Disappear?$AA@ DB 'BINARY_PrivateSh'
	DB	'op_Disappear', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CKEFNKBC@BINARY_PrivateShop_Appear?$AA@
CONST	SEGMENT
??_C@_0BK@CKEFNKBC@BINARY_PrivateShop_Appear?$AA@ DB 'BINARY_PrivateShop_'
	DB	'Appear', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ODHDNEFK@OnFishingNotify?$AA@
CONST	SEGMENT
??_C@_0BA@ODHDNEFK@OnFishingNotify?$AA@ DB 'OnFishingNotify', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OABOAGML@OnFishingSuccess?$AA@
CONST	SEGMENT
??_C@_0BB@OABOAGML@OnFishingSuccess?$AA@ DB 'OnFishingSuccess', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CJFMLNJB@OnFishingFailure?$AA@
CONST	SEGMENT
??_C@_0BB@CJFMLNJB@OnFishingFailure?$AA@ DB 'OnFishingFailure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DPEJLPAP@OnFishingNotifyUnknown?$AA@
CONST	SEGMENT
??_C@_0BH@DPEJLPAP@OnFishingNotifyUnknown?$AA@ DB 'OnFishingNotifyUnknown'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LBOEDDLE@BINARY_GuildWar_OnRecvPoint?$AA@
CONST	SEGMENT
??_C@_0BM@LBOEDDLE@BINARY_GuildWar_OnRecvPoint?$AA@ DB 'BINARY_GuildWar_O'
	DB	'nRecvPoint', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IAMOHDFF@?5?$DO?$DO?5Guild?5Money?5Change?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@IAMOHDFF@?5?$DO?$DO?5Guild?5Money?5Change?5?3?5?$CFd?6?$AA@ DB ' '
	DB	'>> Guild Money Change : %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PIMGMDLK@?5?$DO?$DO?5GulidWarList?5?$FL?$CFd?5vs?5?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BN@PIMGMDLK@?5?$DO?$DO?5GulidWarList?5?$FL?$CFd?5vs?5?$CFd?$FN?6?$AA@ DB ' '
	DB	'>> GulidWarList [%d vs %d]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FNEJFGNL@?5?$DO?$DO?5GulidWarEndList?5?$FL?$CFd?5vs?5?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0CA@FNEJFGNL@?5?$DO?$DO?5GulidWarEndList?5?$FL?$CFd?5vs?5?$CFd?$FN?6?$AA@ DB ' '
	DB	'>> GulidWarEndList [%d vs %d]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HGKOKFIL@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@
CONST	SEGMENT
??_C@_0CM@HGKOKFIL@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@ DB ' >> G'
	DB	'UILD_SUBHEADER_GC_WAR : GUILD_WAR_END', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NACAFPAN@BINARY_GuildWar_OnEnd?$AA@
CONST	SEGMENT
??_C@_0BG@NACAFPAN@BINARY_GuildWar_OnEnd?$AA@ DB 'BINARY_GuildWar_OnEnd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LOGKJDI@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@
CONST	SEGMENT
??_C@_0DI@LOGKJDI@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@ DB ' >> GU'
	DB	'ILD_SUBHEADER_GC_WAR : GUILD_WAR_ON_WAR : %d, %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JKFNHMFD@BINARY_GuildWar_OnStart?$AA@
CONST	SEGMENT
??_C@_0BI@JKFNHMFD@BINARY_GuildWar_OnStart?$AA@ DB 'BINARY_GuildWar_OnSta'
	DB	'rt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BIEEJDD@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@
CONST	SEGMENT
??_C@_0DF@BIEEJDD@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@ DB ' >> GU'
	DB	'ILD_SUBHEADER_GC_WAR : GUILD_WAR_RECV_DECLARE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JAJLCPKG@BINARY_GuildWar_OnRecvDeclare?$AA@
CONST	SEGMENT
??_C@_0BO@JAJLCPKG@BINARY_GuildWar_OnRecvDeclare?$AA@ DB 'BINARY_GuildWar'
	DB	'_OnRecvDeclare', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PELONEKB@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@
CONST	SEGMENT
??_C@_0DF@PELONEKB@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@ DB ' >> G'
	DB	'UILD_SUBHEADER_GC_WAR : GUILD_WAR_SEND_DECLARE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HMPGICIO@BINARY_GuildWar_OnSendDeclare?$AA@
CONST	SEGMENT
??_C@_0BO@HMPGICIO@BINARY_GuildWar_OnSendDeclare?$AA@ DB 'BINARY_GuildWar'
	DB	'_OnSendDeclare', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GJGOAKHL@RecvGuildInviteQuestion?$AA@
CONST	SEGMENT
??_C@_0BI@GJGOAKHL@RecvGuildInviteQuestion?$AA@ DB 'RecvGuildInviteQuesti'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EECNELJB@?5?$DMGuild?5Invite?$DO?5?$CFd?0?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BI@EECNELJB@?5?$DMGuild?5Invite?$DO?5?$CFd?0?5?$CFs?6?$AA@ DB ' <G'
	DB	'uild Invite> %d, %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FEHNPJOD@?5?$DMSkillInfo?$DO?5?$CFd?5?1?5?$CFd?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@FEHNPJOD@?5?$DMSkillInfo?$DO?5?$CFd?5?1?5?$CFd?0?5?$CFd?6?$AA@ DB ' '
	DB	'<SkillInfo> %d / %d, %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MPFPDEHG@?5?$DMChangeMemberGeneralFlag?$DO?5?$CFd?0?5?$CF@
CONST	SEGMENT
??_C@_0CD@MPFPDEHG@?5?$DMChangeMemberGeneralFlag?$DO?5?$CFd?0?5?$CF@ DB ' '
	DB	'<ChangeMemberGeneralFlag> %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GJIHEANJ@?5?$DMChangeEXP?$DO?5?$CFd?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BF@GJIHEANJ@?5?$DMChangeEXP?$DO?5?$CFd?0?5?$CFd?6?$AA@ DB ' <Chang'
	DB	'eEXP> %d, %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HEKKNAEA@?5?$DMChangeMemberGrade?$DO?5?$CFd?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@HEKKNAEA@?5?$DMChangeMemberGrade?$DO?5?$CFd?0?5?$CFd?6?$AA@ DB ' '
	DB	'<ChangeMemberGrade> %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JFJPHNLH@?5?$DMChange?5Grade?5Name?$DO?5?$CFd?0?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BN@JFJPHNLH@?5?$DMChange?5Grade?5Name?$DO?5?$CFd?0?5?$CFs?6?$AA@ DB ' '
	DB	'<Change Grade Name> %d, %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KDHBOMAA@?5?$DMChange?5Grade?5Authority?$DO?5?$CFd?0?5?$CFd@
CONST	SEGMENT
??_C@_0CC@KDHBOMAA@?5?$DMChange?5Grade?5Authority?$DO?5?$CFd?0?5?$CFd@ DB ' '
	DB	'<Change Grade Authority> %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EGDOPDJO@?5?$DMRemove?$DO?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@EGDOPDJO@?5?$DMRemove?$DO?5?$CFd?6?$AA@ DB ' <Remove> %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MJKOOFCD@RefreshGuildGrade?$AA@
CONST	SEGMENT
??_C@_0BC@MJKOOFCD@RefreshGuildGrade?$AA@ DB 'RefreshGuildGrade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HBGAJKKF@?5SendGuildWithdrawMoneyPacket?5?$CFd@
CONST	SEGMENT
??_C@_0CC@HBGAJKKF@?5SendGuildWithdrawMoneyPacket?5?$CFd@ DB ' SendGuildW'
	DB	'ithdrawMoneyPacket %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPGKCCFN@DeleteGuild?$AA@
CONST	SEGMENT
??_C@_0M@JPGKCCFN@DeleteGuild?$AA@ DB 'DeleteGuild', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DLDFHEKF@?5SendGuildChargeGSPPacket?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BO@DLDFHEKF@?5SendGuildChargeGSPPacket?5?$CFd?6?$AA@ DB ' SendGuil'
	DB	'dChargeGSPPacket %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OEPAEO@?5SendGuildDepositMoneyPacket?5?$CFd?6@
CONST	SEGMENT
??_C@_0CB@OEPAEO@?5SendGuildDepositMoneyPacket?5?$CFd?6@ DB ' SendGuildDe'
	DB	'positMoneyPacket %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BBFAPAKJ@?5SendGuildChangeMemberGeneralFla@
CONST	SEGMENT
??_C@_0DA@BBFAPAKJ@?5SendGuildChangeMemberGeneralFla@ DB ' SendGuildChang'
	DB	'eMemberGeneralFlagPacket %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HPNCOLAE@?5SendGuildInviteAnswerPacket?5?$CFd?0@
CONST	SEGMENT
??_C@_0CF@HPNCOLAE@?5SendGuildInviteAnswerPacket?5?$CFd?0@ DB ' SendGuild'
	DB	'InviteAnswerPacket %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NJDDFMMG@?5SendGuildChangeMemberGradePacke@
CONST	SEGMENT
??_C@_0CK@NJDDFMMG@?5SendGuildChangeMemberGradePacke@ DB ' SendGuildChang'
	DB	'eMemberGradePacket %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HHLIHMFO@?5SendGuildUseSkillPacket?5?$CFd?0?5?$CFd?6@
CONST	SEGMENT
??_C@_0CB@HHLIHMFO@?5SendGuildUseSkillPacket?5?$CFd?0?5?$CFd?6@ DB ' Send'
	DB	'GuildUseSkillPacket %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HHBLBNGP@?5SendGuildDeleteCommentPacket?5?$CFd@
CONST	SEGMENT
??_C@_0CC@HHBLBNGP@?5SendGuildDeleteCommentPacket?5?$CFd@ DB ' SendGuildD'
	DB	'eleteCommentPacket %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DFFJJDFM@?5SendGuildRefreshCommentPacket?5?$CF@
CONST	SEGMENT
??_C@_0CD@DFFJJDFM@?5SendGuildRefreshCommentPacket?5?$CF@ DB ' SendGuildR'
	DB	'efreshCommentPacket %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JBHNFCGO@?5SendGuildOfferPacket?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@JBHNFCGO@?5SendGuildOfferPacket?5?$CFd?6?$AA@ DB ' SendGuildOff'
	DB	'erPacket %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ILONPNIK@?5SendGuildPostCommentPacket?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0CE@ILONPNIK@?5SendGuildPostCommentPacket?5?$CFd?0?5@ DB ' SendGuil'
	DB	'dPostCommentPacket %d, %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HCDCDOMK@?5SendGuildChangeGradeNamePacket?5@
CONST	SEGMENT
??_C@_0CI@HCDCDOMK@?5SendGuildChangeGradeNamePacket?5@ DB ' SendGuildChan'
	DB	'geGradeNamePacket %d, %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@ENAPGANL@?5SendGuildChangeGradeAuthorityPa@
CONST	SEGMENT
??_C@_0CN@ENAPGANL@?5SendGuildChangeGradeAuthorityPa@ DB ' SendGuildChang'
	DB	'eGradeAuthorityPacket %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GHDBPEKM@?5SendGuildAddMemberPacket?6?$AA@
CONST	SEGMENT
??_C@_0BL@GHDBPEKM@?5SendGuildAddMemberPacket?6?$AA@ DB ' SendGuildAddMem'
	DB	'berPacket', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OCJDCDKN@?5SendGuildRemoveMemberPacket?5?$CFd?6@
CONST	SEGMENT
??_C@_0CB@OCJDCDKN@?5SendGuildRemoveMemberPacket?5?$CFd?6@ DB ' SendGuild'
	DB	'RemoveMemberPacket %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FFLEPOCB@ChangePartyParameter?$AA@
CONST	SEGMENT
??_C@_0BF@FFLEPOCB@ChangePartyParameter?$AA@ DB 'ChangePartyParameter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HDHIECAG@?5?$DO?$DO?5RecvPartyParameter?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@HDHIECAG@?5?$DO?$DO?5RecvPartyParameter?5?3?5?$CFd?6?$AA@ DB ' '
	DB	'>> RecvPartyParameter : %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBBCCLIK@UnlinkPartyMember?$AA@
CONST	SEGMENT
??_C@_0BC@EBBCCLIK@UnlinkPartyMember?$AA@ DB 'UnlinkPartyMember', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JOBNIIPD@?5?$DO?$DO?5RecvPartyUnlink?5?3?5?$CFd?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BO@JOBNIIPD@?5?$DO?$DO?5RecvPartyUnlink?5?3?5?$CFd?0?5?$CFd?6?$AA@ DB ' '
	DB	'>> RecvPartyUnlink : %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FEBFPLO@?5?$DO?$DO?5RecvPartyLink?5?3?5?$CFd?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@FEBFPLO@?5?$DO?$DO?5RecvPartyLink?5?3?5?$CFd?0?5?$CFd?6?$AA@ DB ' '
	DB	'>> RecvPartyLink : %d, %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KBCGJNOO@UnlinkAllPartyMember?$AA@
CONST	SEGMENT
??_C@_0BF@KBCGJNOO@UnlinkAllPartyMember?$AA@ DB 'UnlinkAllPartyMember', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FHNAOGNK@?5?$DO?$DO?5RecvPartyRemove?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@FHNAOGNK@?5?$DO?$DO?5RecvPartyRemove?5?3?5?$CFd?6?$AA@ DB ' >> '
	DB	'RecvPartyRemove : %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JPJIDGOI@LinkPartyMember?$AA@
CONST	SEGMENT
??_C@_0BA@JPJIDGOI@LinkPartyMember?$AA@ DB 'LinkPartyMember', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JOKFDABD@UpdatePartyMemberInfo?$AA@
CONST	SEGMENT
??_C@_0BG@JOKFDABD@UpdatePartyMemberInfo?$AA@ DB 'UpdatePartyMemberInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DGCJFOHN@RemovePartyMember?$AA@
CONST	SEGMENT
??_C@_0BC@DGCJFOHN@RemovePartyMember?$AA@ DB 'RemovePartyMember', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JPKHKGNP@AddPartyMember?$AA@
CONST	SEGMENT
??_C@_0P@JPKHKGNP@AddPartyMember?$AA@ DB 'AddPartyMember', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GPMBAKEI@?5?$DO?$DO?5RecvPartyAdd?5?3?5?$CFd?0?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@GPMBAKEI@?5?$DO?$DO?5RecvPartyAdd?5?3?5?$CFd?0?5?$CFs?6?$AA@ DB ' '
	DB	'>> RecvPartyAdd : %d, %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FPJOLEHH@RecvPartyInviteQuestion?$AA@
CONST	SEGMENT
??_C@_0BI@FPJOLEHH@RecvPartyInviteQuestion?$AA@ DB 'RecvPartyInviteQuesti'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EBDJDNJB@?5?$DO?$DO?5RecvPartyInvite?5?3?5?$CFd?0?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BO@EBDJDNJB@?5?$DO?$DO?5RecvPartyInvite?5?3?5?$CFd?0?5?$CFs?6?$AA@ DB ' '
	DB	'>> RecvPartyInvite : %d, %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LLPEDDBL@?5?$DM?$DM?5SendPartyParameterPacket?5?3?5?$CF@
CONST	SEGMENT
??_C@_0CD@LLPEDDBL@?5?$DM?$DM?5SendPartyParameterPacket?5?3?5?$CF@ DB ' <'
	DB	'< SendPartyParameterPacket : %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@GALKDEGO@?5CPythonNetworkStream?3?3RecvParty@
CONST	SEGMENT
??_C@_0EO@GALKDEGO@?5CPythonNetworkStream?3?3RecvParty@ DB ' CPythonNetwo'
	DB	'rkStream::RecvPartyInvite - Failed to find leader instance [%'
	DB	'd]', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GLODGHKD@?5?$DM?$DM?5SendPartyUseSkillPacket?5?3?5?$CFd@
CONST	SEGMENT
??_C@_0CG@GLODGHKD@?5?$DM?$DM?5SendPartyUseSkillPacket?5?3?5?$CFd@ DB ' <'
	DB	'< SendPartyUseSkillPacket : %d, %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@IOBBPNMN@CPythonNetworkStream?3?3SendPartyP@
CONST	SEGMENT
??_C@_0EH@IOBBPNMN@CPythonNetworkStream?3?3SendPartyP@ DB 'CPythonNetwork'
	DB	'Stream::SendPartyParameterPacket(%d) - PACKET SEND ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PHAHCCJC@?5?$DM?$DM?5SendPartySetStatePacket?5?3?5?$CFd@
CONST	SEGMENT
??_C@_0CK@PHAHCCJC@?5?$DM?$DM?5SendPartySetStatePacket?5?3?5?$CFd@ DB ' <'
	DB	'< SendPartySetStatePacket : %d, %d, %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@BMAFGIHC@CPythonNetworkStream?3?3SendPartyU@
CONST	SEGMENT
??_C@_0EM@BMAFGIHC@CPythonNetworkStream?3?3SendPartyU@ DB 'CPythonNetwork'
	DB	'Stream::SendPartyUseSkillPacket(%ud, %ud) - PACKET SEND ERROR'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HANJMBEA@?5?$DM?$DM?5SendPartyRemovePacket?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@HANJMBEA@?5?$DM?$DM?5SendPartyRemovePacket?5?3?5?$CFd?6?$AA@ DB ' '
	DB	'<< SendPartyRemovePacket : %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@FFPCCHJM@CPythonNetworkStream?3?3SendPartyS@
CONST	SEGMENT
??_C@_0EM@FFPCCHJM@CPythonNetworkStream?3?3SendPartyS@ DB 'CPythonNetwork'
	DB	'Stream::SendPartySetStatePacket(%ud, %ud) - PACKET SEND ERROR'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GHKGLGPO@?5?$DM?$DM?5SendPartyInviteAnswerPacket?5@
CONST	SEGMENT
??_C@_0CK@GHKGLGPO@?5?$DM?$DM?5SendPartyInviteAnswerPacket?5@ DB ' << Sen'
	DB	'dPartyInviteAnswerPacket : %d, %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BBBGKACF@CPythonNetworkStream?3?3SendPartyR@
CONST	SEGMENT
??_C@_0EG@BBBGKACF@CPythonNetworkStream?3?3SendPartyR@ DB 'CPythonNetwork'
	DB	'Stream::SendPartyRemovePacket [%ud] - PACKET SEND ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GNHHEHBK@?5?$DM?$DM?5SendPartyInvitePacket?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@GNHHEHBK@?5?$DM?$DM?5SendPartyInvitePacket?5?3?5?$CFd?6?$AA@ DB ' '
	DB	'<< SendPartyInvitePacket : %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@IIILKEFH@CPythonNetworkStream?3?3SendPartyI@
CONST	SEGMENT
??_C@_0FA@IIILKEFH@CPythonNetworkStream?3?3SendPartyI@ DB 'CPythonNetwork'
	DB	'Stream::SendPartyInviteAnswerPacket [%ud %ud] - PACKET SEND E'
	DB	'RROR', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@NAODJGJE@CPythonNetworkStream?3?3SendSyncPo@
CONST	SEGMENT
??_C@_0DM@NAODJGJE@CPythonNetworkStream?3?3SendSyncPo@ DB 'CPythonNetwork'
	DB	'Stream::SendSyncPositionElementPacket - ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@HLBPKODM@CPythonNetworkStream?3?3SendPartyI@
CONST	SEGMENT
??_C@_0EG@HLBPKODM@CPythonNetworkStream?3?3SendPartyI@ DB 'CPythonNetwork'
	DB	'Stream::SendPartyInvitePacket [%ud] - PACKET SEND ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MONNHODC@Send?5FlyTargeting?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0BP@MONNHODC@Send?5FlyTargeting?5Packet?5Error?$AA@ DB 'Send FlyTar'
	DB	'geting Packet Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MBCMDDJG@Send?5Target?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0BJ@MBCMDDJG@Send?5Target?5Packet?5Error?$AA@ DB 'Send Target Packe'
	DB	't Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@NIJLGOIC@CPythonNetworkStream?3?3RecvFlyTar@
CONST	SEGMENT
??_C@_0EM@NIJLGOIC@CPythonNetworkStream?3?3RecvFlyTar@ DB 'CPythonNetwork'
	DB	'Stream::RecvFlyTargetingPacket() - dwShooterVID[%d] NOT EXIST'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GKKFNNN@SendShootPacket?5Error?$AA@
CONST	SEGMENT
??_C@_0BG@GKKFNNN@SendShootPacket?5Error?$AA@ DB 'SendShootPacket Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IBBLODAF@Send?5Battle?5Attack?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0CA@IBBLODAF@Send?5Battle?5Attack?5Packet?5Error?$AA@ DB 'Send Batt'
	DB	'le Attack Packet Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KNAMGOGH@VID?5?$FL?$CFd?$FN?$LA?$KB?5?E?$LI?$LA?Y?$MA?$LL?5?C?$NP?$LA?$KB?5?$LM?$LD?A?$KE?6?$AA@
CONST	SEGMENT
??_C@_0BN@KNAMGOGH@VID?5?$FL?$CFd?$FN?$LA?$KB?5?E?$LI?$LA?Y?$MA?$LL?5?C?$NP?$LA?$KB?5?$LM?$LD?A?$KE?6?$AA@ DB 'V'
	DB	'ID [%d]', 0b0H, 0a1H, ' ', 0c5H, 0b8H, 0b0H, 0d9H, 0c0H, 0bbH
	DB	' ', 0c3H, 0dfH, 0b0H, 0a1H, ' ', 0bcH, 0b3H, 0c1H, 0a4H, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEDBDCKL@Recv?5Mount?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0BI@LEDBDCKL@Recv?5Mount?5Packet?5Error?$AA@ DB 'Recv Mount Packet '
	DB	'Error', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OCDKMKMI@Recv?5Speed?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0BI@OCDKMKMI@Recv?5Speed?5Packet?5Error?$AA@ DB 'Recv Speed Packet '
	DB	'Error', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KLEOIHKF@CloseTargetBoardIfDifferent?$AA@
CONST	SEGMENT
??_C@_0BM@KLEOIHKF@CloseTargetBoardIfDifferent?$AA@ DB 'CloseTargetBoardI'
	DB	'fDifferent', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PDPGJKAD@SetHPTargetBoard?$AA@
CONST	SEGMENT
??_C@_0BB@PDPGJKAD@SetHPTargetBoard?$AA@ DB 'SetHPTargetBoard', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HIJGCIDI@Recv?5Target?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0BJ@HIJGCIDI@Recv?5Target?5Packet?5Error?$AA@ DB 'Recv Target Packe'
	DB	't Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PIHJNOHE@Damage?5is?5equal?5or?5below?50?4?$AA@
CONST	SEGMENT
??_C@_0BM@PIHJNOHE@Damage?5is?5equal?5or?5below?50?4?$AA@ DB 'Damage is e'
	DB	'qual or below 0.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OJMAIMGE@?5?$DO?$DO?5RecvSkillLevel?6?$AA@
CONST	SEGMENT
??_C@_0BE@OJMAIMGE@?5?$DO?$DO?5RecvSkillLevel?6?$AA@ DB ' >> RecvSkillLev'
	DB	'el', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EBNCHOOM@CPythonNetworkStream?3?3RecvSkillL@
CONST	SEGMENT
??_C@_0DE@EBNCHOOM@CPythonNetworkStream?3?3RecvSkillL@ DB 'CPythonNetwork'
	DB	'Stream::RecvSkillLevelNew - RecvError', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MPAMADMO@CPythonNetworkStream?3?3RecvSkillC@
CONST	SEGMENT
??_C@_0DH@MPAMADMO@CPythonNetworkStream?3?3RecvSkillC@ DB 'CPythonNetwork'
	DB	'Stream::RecvSkillCoolTimeEnd - RecvError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OELACDEA@CPythonNetworkStream?3?3RecvSkillL@
CONST	SEGMENT
??_C@_0DB@OELACDEA@CPythonNetworkStream?3?3RecvSkillL@ DB 'CPythonNetwork'
	DB	'Stream::RecvSkillLevel - RecvError', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IAHFIDIL@SendQuestConfirmPacket?5Error?$AA@
CONST	SEGMENT
??_C@_0BN@IAHFIDIL@SendQuestConfirmPacket?5Error?$AA@ DB 'SendQuestConfir'
	DB	'mPacket Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HKJKPPKG@?5SendQuestConfirmPacket?5?3?5?$CFd?0?5?$CFd@
CONST	SEGMENT
??_C@_0CB@HKJKPPKG@?5SendQuestConfirmPacket?5?3?5?$CFd?0?5?$CFd@ DB ' Sen'
	DB	'dQuestConfirmPacket : %d, %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FGDJCCCM@SendAnswerMakeGuild?5Packet?5Error@
CONST	SEGMENT
??_C@_0CB@FGDJCCCM@SendAnswerMakeGuild?5Packet?5Error@ DB 'SendAnswerMake'
	DB	'Guild Packet Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KDIADHIP@SendQuestInputStringPacket?5Error@
CONST	SEGMENT
??_C@_0CB@KDIADHIP@SendQuestInputStringPacket?5Error@ DB 'SendQuestInputS'
	DB	'tringPacket Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GLOCGDPA@Send?5Script?5Answer?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0CA@GLOCGDPA@Send?5Script?5Answer?5Packet?5Error?$AA@ DB 'Send Scri'
	DB	'pt Answer Packet Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DKGOFDHL@Send?5Script?5Button?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0CA@DKGOFDHL@Send?5Script?5Button?5Packet?5Error?$AA@ DB 'Send Scri'
	DB	'pt Button Packet Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GIIBIOJB@RecvScriptPacket_RecvError?$AA@
CONST	SEGMENT
??_C@_0BL@GIIBIOJB@RecvScriptPacket_RecvError?$AA@ DB 'RecvScriptPacket_R'
	DB	'ecvError', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FELFLKOI@RecvScriptPacket_SizeError?$AA@
CONST	SEGMENT
??_C@_0BL@FELFLKOI@RecvScriptPacket_SizeError?$AA@ DB 'RecvScriptPacket_S'
	DB	'izeError', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FJKDIHPJ@send_trade_exit_packet?5Error?6?$AA@
CONST	SEGMENT
??_C@_0BO@FJKDIHPJ@send_trade_exit_packet?5Error?6?$AA@ DB 'send_trade_ex'
	DB	'it_packet Error', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILEGHCPF@StartPointReset?$AA@
CONST	SEGMENT
??_C@_0BA@ILEGHCPF@StartPointReset?$AA@ DB 'StartPointReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IFEOOANP@send_trade_item_del_packet?5Error@
CONST	SEGMENT
??_C@_0CC@IFEOOANP@send_trade_item_del_packet?5Error@ DB 'send_trade_item'
	DB	'_del_packet Error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EEPLBN@send_trade_accept_packet?5Error?6?$AA@
CONST	SEGMENT
??_C@_0CA@EEPLBN@send_trade_accept_packet?5Error?6?$AA@ DB 'send_trade_ac'
	DB	'cept_packet Error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EABMKDBI@send_trade_elk_add_packet?5Error?6@
CONST	SEGMENT
??_C@_0CB@EABMKDBI@send_trade_elk_add_packet?5Error?6@ DB 'send_trade_elk'
	DB	'_add_packet Error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JFABNFDE@send_trade_item_add_packet?5Error@
CONST	SEGMENT
??_C@_0CC@JFABNFDE@send_trade_item_add_packet?5Error@ DB 'send_trade_item'
	DB	'_add_packet Error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CGFAIMHK@send_trade_start_packet?5Error?6?$AA@
CONST	SEGMENT
??_C@_0BP@CGFAIMHK@send_trade_start_packet?5Error?6?$AA@ DB 'send_trade_s'
	DB	'tart_packet Error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FOAEKPNP@send_trade_start_packet?5?5?5vid?5?$CFd@
CONST	SEGMENT
??_C@_0CD@FOAEKPNP@send_trade_start_packet?5?5?5vid?5?$CFd@ DB 'send_trad'
	DB	'e_start_packet   vid %d ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FKOIEIPK@AskGuildName?$AA@
CONST	SEGMENT
??_C@_0N@FKOIEIPK@AskGuildName?$AA@ DB 'AskGuildName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BHDOCKEA@ToggleDebugInfo?$AA@
CONST	SEGMENT
??_C@_0BA@BHDOCKEA@ToggleDebugInfo?$AA@ DB 'ToggleDebugInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KIBJJMEI@BINARY_OnQuestConfirm?$AA@
CONST	SEGMENT
??_C@_0BG@KIBJJMEI@BINARY_OnQuestConfirm?$AA@ DB 'BINARY_OnQuestConfirm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ELOCPLFN@RecvRequestMakeGuild?5Packet?5Erro@
CONST	SEGMENT
??_C@_0CC@ELOCPLFN@RecvRequestMakeGuild?5Packet?5Erro@ DB 'RecvRequestMak'
	DB	'eGuild Packet Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IPPKALM@RefreshQuest?$AA@
CONST	SEGMENT
??_C@_0N@IPPKALM@RefreshQuest?$AA@ DB 'RefreshQuest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JBCFOMDG@RecvQuestConfirmPacket?5Error?$AA@
CONST	SEGMENT
??_C@_0BN@JBCFOMDG@RecvQuestConfirmPacket?5Error?$AA@ DB 'RecvQuestConfir'
	DB	'mPacket Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CACIOMDA@Recv?5Quest?5Info?5Packet?5Error?5?$CD1?$AA@
CONST	SEGMENT
??_C@_0CA@CACIOMDA@Recv?5Quest?5Info?5Packet?5Error?5?$CD1?$AA@ DB 'Recv '
	DB	'Quest Info Packet Error #1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LAFLPPD@Recv?5Quest?5Info?5Packet?5Error?5?$CD2?$AA@
CONST	SEGMENT
??_C@_0CA@LAFLPPD@Recv?5Quest?5Info?5Packet?5Error?5?$CD2?$AA@ DB 'Recv Q'
	DB	'uest Info Packet Error #2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LLCGBEIB@trade_already?$AA@
CONST	SEGMENT
??_C@_0O@LLCGBEIB@trade_already?$AA@ DB 'trade_already', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DNLFDBJJ@trade_less_elk?$AA@
CONST	SEGMENT
??_C@_0P@DNLFDBJJ@trade_less_elk?$AA@ DB 'trade_less_elk', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HKIIBLHD@StartExchange?$AA@
CONST	SEGMENT
??_C@_0O@HKIIBLHD@StartExchange?$AA@ DB 'StartExchange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GJLEGLOM@EndExchange?$AA@
CONST	SEGMENT
??_C@_0M@GJLEGLOM@EndExchange?$AA@ DB 'EndExchange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HAELFLPD@INVALID_POS?$AA@
CONST	SEGMENT
??_C@_0M@HAELFLPD@INVALID_POS?$AA@ DB 'INVALID_POS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@IGANFIGP@CPythonNetworkStream?3?3RecvShopPa@
CONST	SEGMENT
??_C@_0DJ@IGANFIGP@CPythonNetworkStream?3?3RecvShopPa@ DB 'CPythonNetwork'
	DB	'Stream::RecvShopPacket: Unknown subheader', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBAJNJNN@SOLDOUT?$AA@
CONST	SEGMENT
??_C@_07FBAJNJNN@SOLDOUT?$AA@ DB 'SOLDOUT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HIHIAGBD@INVENTORY_FULL?$AA@
CONST	SEGMENT
??_C@_0P@HIHIAGBD@INVENTORY_FULL?$AA@ DB 'INVENTORY_FULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHHHAHOK@OnShopError?$AA@
CONST	SEGMENT
??_C@_0M@NHHHAHOK@OnShopError?$AA@ DB 'OnShopError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OHHJLOIF@NOT_ENOUGH_MONEY_EX?$AA@
CONST	SEGMENT
??_C@_0BE@OHHJLOIF@NOT_ENOUGH_MONEY_EX?$AA@ DB 'NOT_ENOUGH_MONEY_EX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MHMAEIEM@SetShopSellingPrice?$AA@
CONST	SEGMENT
??_C@_0BE@MHMAEIEM@SetShopSellingPrice?$AA@ DB 'SetShopSellingPrice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHBGEHD@NOT_ENOUGH_MONEY?$AA@
CONST	SEGMENT
??_C@_0BB@GHBGEHD@NOT_ENOUGH_MONEY?$AA@ DB 'NOT_ENOUGH_MONEY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FONJAJPH@EndShop?$AA@
CONST	SEGMENT
??_C@_07FONJAJPH@EndShop?$AA@ DB 'EndShop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DLPMCOFP@RefreshShop?$AA@
CONST	SEGMENT
??_C@_0M@DLPMCOFP@RefreshShop?$AA@ DB 'RefreshShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ICLELGCO@SendOnClickPacket?6?$AA@
CONST	SEGMENT
??_C@_0BD@ICLELGCO@SendOnClickPacket?6?$AA@ DB 'SendOnClickPacket', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJIJIJPH@StartShop?$AA@
CONST	SEGMENT
??_C@_09PJIJIJPH@StartShop?$AA@ DB 'StartShop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OKKJKDKD@Send?5Character?5Position?5Packet?5E@
CONST	SEGMENT
??_C@_0CF@OKKJKDKD@Send?5Character?5Position?5Packet?5E@ DB 'Send Charact'
	DB	'er Position Packet Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HCNNPICH@Send?5On_Click?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0BL@HCNNPICH@Send?5On_Click?5Packet?5Error?$AA@ DB 'Send On_Click P'
	DB	'acket Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BDKDPHGA@?A?V?$MA?N?$LA?x?5?$LL?g?$LI?A?$AA@
CONST	SEGMENT
??_C@_0M@BDKDPHGA@?A?V?$MA?N?$LA?x?5?$LL?g?$LI?A?$AA@ DB 0c1H, 0d6H, 0c0H
	DB	0ceH, 0b0H, 0f8H, ' ', 0bbH, 0e7H, 0b8H, 0c1H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MNOOMILJ@OnGameOver?$AA@
CONST	SEGMENT
??_C@_0L@MNOOMILJ@OnGameOver?$AA@ DB 'OnGameOver', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MKMKFBIM@CPythonNetworkStream?3?3RecvStunPa@
CONST	SEGMENT
??_C@_0CL@MKMKFBIM@CPythonNetworkStream?3?3RecvStunPa@ DB 'CPythonNetwork'
	DB	'Stream::RecvStunPacket Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KJGPDLAC@CPythonNetworkStream?3?3RecvDeadPa@
CONST	SEGMENT
??_C@_0CL@KJGPDLAC@CPythonNetworkStream?3?3RecvDeadPa@ DB 'CPythonNetwork'
	DB	'Stream::RecvDeadPacket Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DGLKKAJF@Recv?5Point?5Change?5Packet?5Error?$AA@
CONST	SEGMENT
??_C@_0BP@DGLKKAJF@Recv?5Point?5Change?5Packet?5Error?$AA@ DB 'Recv Point'
	DB	' Change Packet Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JJMCBALF@OnPickMoney?$AA@
CONST	SEGMENT
??_C@_0M@JJMCBALF@OnPickMoney?$AA@ DB 'OnPickMoney', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MJBHNNKO@OnRecvWhisperSystemMessage?$AA@
CONST	SEGMENT
??_C@_0BL@MJBHNNKO@OnRecvWhisperSystemMessage?$AA@ DB 'OnRecvWhisperSyste'
	DB	'mMessage', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HFHHLLOG@OnRecvWhisperError?$AA@
CONST	SEGMENT
??_C@_0BD@HFHHLLOG@OnRecvWhisperError?$AA@ DB 'OnRecvWhisperError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKJLIKKL@?$CIiss?$CJ?$AA@
CONST	SEGMENT
??_C@_05FKJLIKKL@?$CIiss?$CJ?$AA@ DB '(iss)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLMPGGOH@OnRecvWhisper?$AA@
CONST	SEGMENT
??_C@_0O@MLMPGGOH@OnRecvWhisper?$AA@ DB 'OnRecvWhisper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEFMFHCI@BINARY_SetBigMessage?$AA@
CONST	SEGMENT
??_C@_0BF@MEFMFHCI@BINARY_SetBigMessage?$AA@ DB 'BINARY_SetBigMessage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IAFACCAD@?$CFs?5?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_07IAFACCAD@?$CFs?5?3?5?$CFs?$AA@ DB '%s : %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EKLOHGBI@BINARY_SetTipMessage?$AA@
CONST	SEGMENT
??_C@_0BF@EKLOHGBI@BINARY_SetTipMessage?$AA@ DB 'BINARY_SetTipMessage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EFFJHKOL@CPythonNetworkStream?3?3SendUseSki@
CONST	SEGMENT
??_C@_0DN@EFFJHKOL@CPythonNetworkStream?3?3SendUseSki@ DB 'CPythonNetwork'
	DB	'Stream::SendUseSkillPacket - SEND PACKET ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GMAAOOOI@Can?8t?5register?5emoticon?5string?4?4@
CONST	SEGMENT
??_C@_0DL@GMAAOOOI@Can?8t?5register?5emoticon?5string?4?4@ DB 'Can''t reg'
	DB	'ister emoticon string... vector is full (size:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DHDBME@?5SendMessengerAddByNamePacket?5?3?5@
CONST	SEGMENT
??_C@_0CE@DHDBME@?5SendMessengerAddByNamePacket?5?3?5@ DB ' SendMessenger'
	DB	'AddByNamePacket : %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@FFAGJAOL@CPythonNetworkStream?3?3SendCharac@
CONST	SEGMENT
??_C@_0IB@FFAGJAOL@CPythonNetworkStream?3?3SendCharac@ DB 'CPythonNetwork'
	DB	'Stream::SendCharacterStatePacket(dwCmdTime=%u, fDstPos=(%f, %'
	DB	'f), fDstRot=%f, eFunc=%d uArg=%d) - PACKET SEND ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@IHJJGCFB@CPythonNetworkStream?3?3RecvDuelSt@
CONST	SEGMENT
??_C@_0EC@IHJJGCFB@CPythonNetworkStream?3?3RecvDuelSt@ DB 'CPythonNetwork'
	DB	'Stream::RecvDuelStartPacket - MainCharacter is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FNPCBFHE@CloseTargetBoard?$AA@
CONST	SEGMENT
??_C@_0BB@FNPCBFHE@CloseTargetBoard?$AA@ DB 'CloseTargetBoard', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DJFBBLID@ShowMapName?$AA@
CONST	SEGMENT
??_C@_0M@DJFBBLID@ShowMapName?$AA@ DB 'ShowMapName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HPKACCGC@?$CD?$CD?5Network?5?9?5Game?5Phase?5?$CD?$CD?$AA@
CONST	SEGMENT
??_C@_0BL@HPKACCGC@?$CD?$CD?5Network?5?9?5Game?5Phase?5?$CD?$CD?$AA@ DB '#'
	DB	'# Network - Game Phase ##', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CBAJOEAC@RefreshGuildGradePage?$AA@
CONST	SEGMENT
??_C@_0BG@CBAJOEAC@RefreshGuildGradePage?$AA@ DB 'RefreshGuildGradePage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FONOJENF@?$CIsii?$CJ?$AA@
CONST	SEGMENT
??_C@_05FONOJENF@?$CIsii?$CJ?$AA@ DB '(sii)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PAAOLBDB@RefreshGuildMemberPageGradeCombo@
CONST	SEGMENT
??_C@_0CE@PAAOLBDB@RefreshGuildMemberPageGradeCombo@ DB 'RefreshGuildMemb'
	DB	'erPageGradeComboBox', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MICKDFKA@RefreshGuildSkillPage?$AA@
CONST	SEGMENT
??_C@_0BG@MICKDFKA@RefreshGuildSkillPage?$AA@ DB 'RefreshGuildSkillPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FFPNPADB@RefreshGuildBoardPage?$AA@
CONST	SEGMENT
??_C@_0BG@FFPNPADB@RefreshGuildBoardPage?$AA@ DB 'RefreshGuildBoardPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BOJHBBF@RefreshGuildMemberPage?$AA@
CONST	SEGMENT
??_C@_0BH@BOJHBBF@RefreshGuildMemberPage?$AA@ DB 'RefreshGuildMemberPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CDMJAHKO@RefreshMessenger?$AA@
CONST	SEGMENT
??_C@_0BB@CDMJAHKO@RefreshMessenger?$AA@ DB 'RefreshMessenger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NLJDKFFK@RefreshGuildInfoPage?$AA@
CONST	SEGMENT
??_C@_0BF@NLJDKFFK@RefreshGuildInfoPage?$AA@ DB 'RefreshGuildInfoPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HNBFKLDC@RefreshMall?$AA@
CONST	SEGMENT
??_C@_0M@HNBFKLDC@RefreshMall?$AA@ DB 'RefreshMall', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PDJLBMPA@RefreshStatus?$AA@
CONST	SEGMENT
??_C@_0O@PDJLBMPA@RefreshStatus?$AA@ DB 'RefreshStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EFFAOLPI@RefreshSkill?$AA@
CONST	SEGMENT
??_C@_0N@EFFAOLPI@RefreshSkill?$AA@ DB 'RefreshSkill', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PHDJJCCP@RefreshSafebox?$AA@
CONST	SEGMENT
??_C@_0P@PHDJJCCP@RefreshSafebox?$AA@ DB 'RefreshSafebox', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JLCHKFKI@RefreshInventory?$AA@
CONST	SEGMENT
??_C@_0BB@JLCHKFKI@RefreshInventory?$AA@ DB 'RefreshInventory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JECEPFD@RefreshExchange?$AA@
CONST	SEGMENT
??_C@_0BA@JECEPFD@RefreshExchange?$AA@ DB 'RefreshExchange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HFALJDHO@RefreshCharacter?$AA@
CONST	SEGMENT
??_C@_0BB@HFALJDHO@RefreshCharacter?$AA@ DB 'RefreshCharacter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CAEOPHDE@RefreshEquipment?$AA@
CONST	SEGMENT
??_C@_0BB@CAEOPHDE@RefreshEquipment?$AA@ DB 'RefreshEquipment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FLFBFOOJ@RefreshTargetBoard?$AA@
CONST	SEGMENT
??_C@_0BD@FLFBFOOJ@RefreshTargetBoard?$AA@ DB 'RefreshTargetBoard', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBBNLEM@Game?$AA@
CONST	SEGMENT
??_C@_04IBBNLEM@Game?$AA@ DB 'Game', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IJENFIMO@RefreshTargetBoardByVID?$AA@
CONST	SEGMENT
??_C@_0BI@IJENFIMO@RefreshTargetBoardByVID?$AA@ DB 'RefreshTargetBoardByV'
	DB	'ID', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GGFFBLPA@RefreshTargetBoardByName?$AA@
CONST	SEGMENT
??_C@_0BJ@GGFFBLPA@RefreshTargetBoardByName?$AA@ DB 'RefreshTargetBoardBy'
	DB	'Name', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DGNNMOLK@RefreshAlignment?$AA@
CONST	SEGMENT
??_C@_0BB@DGNNMOLK@RefreshAlignment?$AA@ DB 'RefreshAlignment', 00H ; `string'
?gs_bEmpireLanuageEnable@@3HA DD 01H			; gs_bEmpireLanuageEnable
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Pdif
PUBLIC	??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
PUBLIC	??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?NoPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::NoPath
PUBLIC	?ChangeDosPath@CFileNameHelper@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CFileNameHelper::ChangeDosPath
PUBLIC	?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::at
PUBLIC	?_Fill_n@std@@YAPADPADID@Z			; std::_Fill_n
PUBLIC	??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<char,char,char>
PUBLIC	??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z	; std::_Rechecked<char *,char *>
PUBLIC	??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninit_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Unchecked@PAD@std@@YAPADPAD@Z		; std::_Unchecked<char *>
PUBLIC	??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z ; std::_Fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
PUBLIC	??$_Rechecked@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@@std@@YAAAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAPAV10@PAPAV10@@Z ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
PUBLIC	??$_Uninit_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$_Unchecked@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
PUBLIC	??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<char,unsigned int,char>
PUBLIC	??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z ; std::_Ptr_cat<char,char>
PUBLIC	??$_Val_type@PAD@std@@YAPADPAD@Z		; std::_Val_type<char *>
PUBLIC	??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Umove<char *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ; std::_Uninitialized_default_fill_n<char *,unsigned int,std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Setcont
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
PUBLIC	?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocate
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
PUBLIC	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ ; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@DV?$allocator@D@std@@@std@@IBEII@Z ; std::vector<char,std::allocator<char> >::_Grow_to
PUBLIC	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
PUBLIC	?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::_Unused_capacity
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::allocate
PUBLIC	?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Compat
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >
PUBLIC	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy
PUBLIC	?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reserve
PUBLIC	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
PUBLIC	?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::_Pop_back_n
PUBLIC	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
PUBLIC	?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Growmap
PUBLIC	?begin@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator<
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator++
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEABUSShopItemTable@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator*
PUBLIC	?size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::size
PUBLIC	?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end
PUBLIC	?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin
PUBLIC	?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ; std::vector<char,std::allocator<char> >::clear
PUBLIC	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
PUBLIC	?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::resize
PUBLIC	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	?Instance@?$CSingleton@VCPythonQuest@@@@SAAAVCPythonQuest@@XZ ; CSingleton<CPythonQuest>::Instance
PUBLIC	?instance@?$CSingleton@VCPythonShop@@@@SAAAVCPythonShop@@XZ ; CSingleton<CPythonShop>::instance
PUBLIC	?Instance@?$CSingleton@VCPythonShop@@@@SAAAVCPythonShop@@XZ ; CSingleton<CPythonShop>::Instance
PUBLIC	?instance@?$CSingleton@VCPythonPlayer@@@@SAAAVCPythonPlayer@@XZ ; CSingleton<CPythonPlayer>::instance
PUBLIC	?pop_front@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_front
PUBLIC	?front@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::front
PUBLIC	?SendDragonSoulRefinePacket@CPythonNetworkStream@@QAE_NEPAUSItemPos@@@Z ; CPythonNetworkStream::SendDragonSoulRefinePacket
PUBLIC	?RecvDigMotionPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvDigMotionPacket
PUBLIC	?RecvLovePointUpdatePacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvLovePointUpdatePacket
PUBLIC	?RecvLoverInfoPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvLoverInfoPacket
PUBLIC	?RecvTargetDeletePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvTargetDeletePacket
PUBLIC	?RecvTargetUpdatePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvTargetUpdatePacket
PUBLIC	?RecvTargetCreatePacketNew@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvTargetCreatePacketNew
PUBLIC	?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvLandPacket
PUBLIC	?RecvViewEquipPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvViewEquipPacket
PUBLIC	?RecvChannelPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvChannelPacket
PUBLIC	?RecvAffectRemovePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvAffectRemovePacket
PUBLIC	?RecvAffectAddPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvAffectAddPacket
PUBLIC	?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::SendClientVersionPacket
PUBLIC	?RecvNPCList@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvNPCList
PUBLIC	?RecvRefineInformationPacketNew@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvRefineInformationPacketNew
PUBLIC	?RecvRefineInformationPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvRefineInformationPacket
PUBLIC	?RecvChangeSkillGroupPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvChangeSkillGroupPacket
PUBLIC	?RecvWalkModePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvWalkModePacket
PUBLIC	?RecvTimePacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvTimePacket
PUBLIC	?RecvShopSignPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvShopSignPacket
PUBLIC	?SendBuildPrivateShopPacket@CPythonNetworkStream@@QAE_NPBDABV?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@@Z ; CPythonNetworkStream::SendBuildPrivateShopPacket
PUBLIC	?RecvDungeon@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvDungeon
PUBLIC	?RecvFishing@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvFishing
PUBLIC	??0command_give_item@@QAE@XZ			; command_give_item::command_give_item
PUBLIC	?SendFishingPacket@CPythonNetworkStream@@QAE_NH@Z ; CPythonNetworkStream::SendFishingPacket
PUBLIC	??0SGuildMemberData@CPythonGuild@@QAE@XZ	; CPythonGuild::SGuildMemberData::SGuildMemberData
PUBLIC	?RecvGuild@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvGuild
PUBLIC	?RecvPartyParameter@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPartyParameter
PUBLIC	?RecvPartyUnlink@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPartyUnlink
PUBLIC	?RecvPartyLink@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPartyLink
PUBLIC	?RecvPartyRemove@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPartyRemove
PUBLIC	?RecvPartyUpdate@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPartyUpdate
PUBLIC	?RecvPartyAdd@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPartyAdd
PUBLIC	?RecvPartyInvite@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPartyInvite
PUBLIC	?RecvMessenger@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvMessenger
PUBLIC	?SendSyncPositionElementPacket@CPythonNetworkStream@@QAE_NKKK@Z ; CPythonNetworkStream::SendSyncPositionElementPacket
PUBLIC	?SendTargetPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendTargetPacket
PUBLIC	?RecvCreateFlyPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCreateFlyPacket
PUBLIC	?SendFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z ; CPythonNetworkStream::SendFlyTargetingPacket
PUBLIC	?SendAddFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z ; CPythonNetworkStream::SendAddFlyTargetingPacket
PUBLIC	?SendShootPacket@CPythonNetworkStream@@QAE_NI@Z	; CPythonNetworkStream::SendShootPacket
PUBLIC	?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvFlyTargetingPacket
PUBLIC	?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvAddFlyTargetingPacket
PUBLIC	?SendSpecial@CPythonNetworkStream@@QAE_NHPAX@Z	; CPythonNetworkStream::SendSpecial
PUBLIC	?SendAttackPacket@CPythonNetworkStream@@QAE_NIK@Z ; CPythonNetworkStream::SendAttackPacket
PUBLIC	?RecvChangeSpeedPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvChangeSpeedPacket
PUBLIC	?RecvMountPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvMountPacket
PUBLIC	?RecvTargetPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvTargetPacket
PUBLIC	?RecvDamageInfoPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvDamageInfoPacket
PUBLIC	?RecvSkillLevelNew@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSkillLevelNew
PUBLIC	?RecvSkillLevel@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvSkillLevel
PUBLIC	?RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvScriptPacket
PUBLIC	?__IsPlayerAttacking@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__IsPlayerAttacking
PUBLIC	??0command_exchange@@QAE@XZ			; command_exchange::command_exchange
PUBLIC	?RecvRequestMakeGuild@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvRequestMakeGuild
PUBLIC	?RecvQuestConfirmPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvQuestConfirmPacket
PUBLIC	??1SQuestInstance@CPythonQuest@@QAE@XZ		; CPythonQuest::SQuestInstance::~SQuestInstance
PUBLIC	?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvQuestInfoPacket
PUBLIC	??0packet_exchange@@QAE@XZ			; packet_exchange::packet_exchange
PUBLIC	?RecvExchangePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvExchangePacket
PUBLIC	?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvShopPacket
PUBLIC	?RecvMotionPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvMotionPacket
PUBLIC	?RecvCharacterPositionPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterPositionPacket
PUBLIC	?RecvDeadPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvDeadPacket
PUBLIC	?RecvStunPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvStunPacket
PUBLIC	?RecvPointChange@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPointChange
PUBLIC	?RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvWhisperPacket
PUBLIC	?RecvChatPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvChatPacket
PUBLIC	?__ConvertEmpireText@CPythonNetworkStream@@IAEXKPAD@Z ; CPythonNetworkStream::__ConvertEmpireText
PUBLIC	?ParseEmoticon@CPythonNetworkStream@@IAE_NPBDPAK@Z ; CPythonNetworkStream::ParseEmoticon
PUBLIC	?SendUseSkillPacket@CPythonNetworkStream@@QAE_NKK@Z ; CPythonNetworkStream::SendUseSkillPacket
PUBLIC	?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ; CPythonNetworkStream::SendCharacterStatePacket
PUBLIC	?__SendHack@CPythonNetworkStream@@IAE_NPBD@Z	; CPythonNetworkStream::__SendHack
PUBLIC	?RecvPVPPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPVPPacket
PUBLIC	?RecvDuelStartPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvDuelStartPacket
PUBLIC	?RecvWarpPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvWarpPacket
PUBLIC	?RecvObserverMovePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvObserverMovePacket
PUBLIC	?RecvObserverRemovePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvObserverRemovePacket
PUBLIC	?RecvObserverAddPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvObserverAddPacket
PUBLIC	?__LeaveGamePhase@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::__LeaveGamePhase
PUBLIC	?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z	; CPythonNetworkStream::__ShowMapName
PUBLIC	?GamePhase@CPythonNetworkStream@@IAEXXZ		; CPythonNetworkStream::GamePhase
PUBLIC	?__SetGuildID@CPythonNetworkStream@@IAEXK@Z	; CPythonNetworkStream::__SetGuildID
PUBLIC	?__RefreshEquipmentWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshEquipmentWindow
PUBLIC	?__RefreshInventoryWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshInventoryWindow
PUBLIC	?__RefreshCharacterWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshCharacterWindow
PUBLIC	?__RefreshStatus@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::__RefreshStatus
PUBLIC	?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshExchangeWindow
PUBLIC	?__RefreshSkillWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshSkillWindow
PUBLIC	?__RefreshMallWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshMallWindow
PUBLIC	?__RefreshSafeboxWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshSafeboxWindow
PUBLIC	?__RefreshMessengerWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshMessengerWindow
PUBLIC	?__RefreshGuildWindowInfoPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowInfoPage
PUBLIC	?__RefreshGuildWindowBoardPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowBoardPage
PUBLIC	?__RefreshGuildWindowMemberPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowMemberPage
PUBLIC	?__RefreshGuildWindowMemberPageGradeComboBox@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowMemberPageGradeComboBox
PUBLIC	?__RefreshGuildWindowSkillPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowSkillPage
PUBLIC	?__RefreshGuildWindowGradePage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowGradePage
PUBLIC	?__RefreshTargetBoard@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshTargetBoard
PUBLIC	?__RefreshTargetBoardByName@CPythonNetworkStream@@IAEXPBD@Z ; CPythonNetworkStream::__RefreshTargetBoardByName
PUBLIC	?__RefreshTargetBoardByVID@CPythonNetworkStream@@IAEXK@Z ; CPythonNetworkStream::__RefreshTargetBoardByVID
PUBLIC	?__RefreshAlignmentWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshAlignmentWindow
PUBLIC	??0SQuestInstance@CPythonQuest@@QAE@XZ		; CPythonQuest::SQuestInstance::SQuestInstance
PUBLIC	?SetTabCount@CPythonShop@@QAEXE@Z		; CPythonShop::SetTabCount
PUBLIC	??0SGuildGradeData@CPythonGuild@@QAE@EPBD@Z	; CPythonGuild::SGuildGradeData::SGuildGradeData
PUBLIC	??0SPacketCGDragonSoulRefine@@QAE@XZ		; SPacketCGDragonSoulRefine::SPacketCGDragonSoulRefine
PUBLIC	?Warp@CPythonNetworkStream@@QAEXJJ@Z		; CPythonNetworkStream::Warp
PUBLIC	?SendWhisperPacket@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendWhisperPacket
PUBLIC	?SendMobileMessagePacket@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendMobileMessagePacket
PUBLIC	?SendCharacterPositionPacket@CPythonNetworkStream@@QAE_NE@Z ; CPythonNetworkStream::SendCharacterPositionPacket
PUBLIC	?SendOnClickPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendOnClickPacket
PUBLIC	?SendGiveItemPacket@CPythonNetworkStream@@QAE_NKUSItemPos@@H@Z ; CPythonNetworkStream::SendGiveItemPacket
PUBLIC	?SendExchangeStartPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendExchangeStartPacket
PUBLIC	?SendExchangeElkAddPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendExchangeElkAddPacket
PUBLIC	?SendExchangeItemAddPacket@CPythonNetworkStream@@QAE_NUSItemPos@@E@Z ; CPythonNetworkStream::SendExchangeItemAddPacket
PUBLIC	?SendExchangeItemDelPacket@CPythonNetworkStream@@QAE_NE@Z ; CPythonNetworkStream::SendExchangeItemDelPacket
PUBLIC	?SendExchangeAcceptPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::SendExchangeAcceptPacket
PUBLIC	?SendExchangeExitPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::SendExchangeExitPacket
PUBLIC	?ToggleGameDebugInfo@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::ToggleGameDebugInfo
PUBLIC	?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z ; CPythonNetworkStream::RegisterEmoticonString
PUBLIC	?SendMessengerAddByVIDPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendMessengerAddByVIDPacket
PUBLIC	?SendMessengerAddByNamePacket@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::SendMessengerAddByNamePacket
PUBLIC	?SendMessengerRemovePacket@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendMessengerRemovePacket
PUBLIC	?SendPartyInvitePacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendPartyInvitePacket
PUBLIC	?SendPartyInviteAnswerPacket@CPythonNetworkStream@@QAE_NKE@Z ; CPythonNetworkStream::SendPartyInviteAnswerPacket
PUBLIC	?SendPartyRemovePacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendPartyRemovePacket
PUBLIC	?SendPartySetStatePacket@CPythonNetworkStream@@QAE_NKEE@Z ; CPythonNetworkStream::SendPartySetStatePacket
PUBLIC	?SendPartyUseSkillPacket@CPythonNetworkStream@@QAE_NEK@Z ; CPythonNetworkStream::SendPartyUseSkillPacket
PUBLIC	?SendPartyParameterPacket@CPythonNetworkStream@@QAE_NE@Z ; CPythonNetworkStream::SendPartyParameterPacket
PUBLIC	?SendAnswerMakeGuildPacket@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::SendAnswerMakeGuildPacket
PUBLIC	?SendQuestInputStringPacket@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::SendQuestInputStringPacket
PUBLIC	?SendQuestConfirmPacket@CPythonNetworkStream@@QAE_NEK@Z ; CPythonNetworkStream::SendQuestConfirmPacket
PUBLIC	?SendGuildAddMemberPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendGuildAddMemberPacket
PUBLIC	?SendGuildRemoveMemberPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendGuildRemoveMemberPacket
PUBLIC	?SendGuildChangeGradeNamePacket@CPythonNetworkStream@@QAE_NEPBD@Z ; CPythonNetworkStream::SendGuildChangeGradeNamePacket
PUBLIC	?SendGuildChangeGradeAuthorityPacket@CPythonNetworkStream@@QAE_NEE@Z ; CPythonNetworkStream::SendGuildChangeGradeAuthorityPacket
PUBLIC	?SendGuildOfferPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendGuildOfferPacket
PUBLIC	?SendGuildPostCommentPacket@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::SendGuildPostCommentPacket
PUBLIC	?SendGuildDeleteCommentPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendGuildDeleteCommentPacket
PUBLIC	?SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendGuildRefreshCommentsPacket
PUBLIC	?SendGuildChangeMemberGradePacket@CPythonNetworkStream@@QAE_NKE@Z ; CPythonNetworkStream::SendGuildChangeMemberGradePacket
PUBLIC	?SendGuildUseSkillPacket@CPythonNetworkStream@@QAE_NKK@Z ; CPythonNetworkStream::SendGuildUseSkillPacket
PUBLIC	?SendGuildChangeMemberGeneralPacket@CPythonNetworkStream@@QAE_NKE@Z ; CPythonNetworkStream::SendGuildChangeMemberGeneralPacket
PUBLIC	?SendGuildInviteAnswerPacket@CPythonNetworkStream@@QAE_NKE@Z ; CPythonNetworkStream::SendGuildInviteAnswerPacket
PUBLIC	?SendGuildChargeGSPPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendGuildChargeGSPPacket
PUBLIC	?SendGuildDepositMoneyPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendGuildDepositMoneyPacket
PUBLIC	?SendGuildWithdrawMoneyPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendGuildWithdrawMoneyPacket
PUBLIC	?SendRefinePacket@CPythonNetworkStream@@QAE_NEE@Z ; CPythonNetworkStream::SendRefinePacket
PUBLIC	?SendSelectItemPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendSelectItemPacket
PUBLIC	?__TEST_SetSkillGroupFake@CPythonNetworkStream@@QAEXH@Z ; CPythonNetworkStream::__TEST_SetSkillGroupFake
PUBLIC	?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z ; CPythonNetworkStream::SendChatPacket
PUBLIC	?SetGamePhase@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::SetGamePhase
PUBLIC	?__InitializeGamePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__InitializeGamePhase
PUBLIC	?SendScriptButtonPacket@CPythonNetworkStream@@QAE_NI@Z ; CPythonNetworkStream::SendScriptButtonPacket
PUBLIC	?SendScriptAnswerPacket@CPythonNetworkStream@@QAE_NH@Z ; CPythonNetworkStream::SendScriptAnswerPacket
_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?$S1@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4IA
_BSS	SEGMENT
?$S1@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4IA DD 01H DUP (?) ; S1<`template-parameter-15',CPythonNetworkStream::mePhase,unsigned int, ?? >
_BSS	ENDS
;	COMDAT ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA
_BSS	SEGMENT
?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA DD 01H DUP (?) ; `CPythonNetworkStream::GamePhase'::`15'::s_nextRefreshTime
_BSS	ENDS
;	COMDAT ?line@?5??RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ@4PADA
_BSS	SEGMENT
?line@?5??RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ@4PADA DB 0100H DUP (?) ; `CPythonNetworkStream::RecvWhisperPacket'::`6'::line
_BSS	ENDS
;	COMDAT ?$S3@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4IA
_BSS	SEGMENT
?$S3@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4IA DD 01H DUP (?) ; S3<`template-parameter-8',CPythonNetworkStream::vScriptPacket,unsigned int, ?? >
_BSS	ENDS
;	COMDAT ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
_BSS	SEGMENT
?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 018H DUP (?) ; `CPythonNetworkStream::RecvScriptPacket'::`8'::str
_BSS	ENDS
;	COMDAT ?$S4@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4IA
_BSS	SEGMENT
?$S4@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4IA DD 01H DUP (?) ; S4<`template-parameter-2',CPythonNetworkStream::dGuildRefreshCommentsPacket,unsigned char * const,bool,unsigned long>
_BSS	ENDS
;	COMDAT ?s_LastTime@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4KA
_BSS	SEGMENT
?s_LastTime@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4KA DD 01H DUP (?) ; `CPythonNetworkStream::SendGuildRefreshCommentsPacket'::`2'::s_LastTime
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__SetGuildID@CPythonNetworkStream@@IAEXK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__SetGuildID@CPythonNetworkStream@@IAEXK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__SetGuildID@CPythonNetworkStream@@IAEXK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__SetGuildID@CPythonNetworkStream@@IAEXK@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GamePhase@CPythonNetworkStream@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GamePhase@CPythonNetworkStream@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GamePhase@CPythonNetworkStream@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GamePhase@CPythonNetworkStream@@IAEXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecvGuild@CPythonNetworkStream@@IAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?RecvGuild@CPythonNetworkStream@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecvGuild@CPythonNetworkStream@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvGuild@CPythonNetworkStream@@IAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvGuild@CPythonNetworkStream@@IAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvGuild@CPythonNetworkStream@@IAE_NXZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ$0
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendScriptAnswerPacket@CPythonNetworkStream@@QAE_NH@Z
_TEXT	SEGMENT
_ScriptAnswer$ = -4					; size = 2
_iAnswer$ = 8						; size = 4
?SendScriptAnswerPacket@CPythonNetworkStream@@QAE_NH@Z PROC ; CPythonNetworkStream::SendScriptAnswerPacket, COMDAT
; _this$ = ecx

; 2236 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2237 : 	TPacketCGScriptAnswer ScriptAnswer;
; 2238 : 
; 2239 : 	ScriptAnswer.header = HEADER_CG_SCRIPT_ANSWER;
; 2240 : 	ScriptAnswer.answer = (BYTE) iAnswer;

  00004	8b 45 08	 mov	 eax, DWORD PTR _iAnswer$[ebp]
  00007	56		 push	 esi
  00008	88 45 fd	 mov	 BYTE PTR _ScriptAnswer$[ebp+1], al
  0000b	8b f1		 mov	 esi, ecx

; 2241 : 	if (!Send(sizeof(TPacketCGScriptAnswer), &ScriptAnswer))

  0000d	8d 45 fc	 lea	 eax, DWORD PTR _ScriptAnswer$[ebp]
  00010	c6 45 fc 1d	 mov	 BYTE PTR _ScriptAnswer$[ebp], 29 ; 0000001dH
  00014	50		 push	 eax
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001c	84 c0		 test	 al, al
  0001e	75 16		 jne	 SHORT $LN1@SendScript

; 2242 : 	{
; 2243 : 		Tracen("Send Script Answer Packet Error");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@GLOCGDPA@Send?5Script?5Answer?5Packet?5Error?$AA@
  00025	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002a	83 c4 04	 add	 esp, 4

; 2244 : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	5e		 pop	 esi

; 2248 : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN1@SendScript:

; 2245 : 	}
; 2246 : 
; 2247 : 	return SendSequence();

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0003d	5e		 pop	 esi

; 2248 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?SendScriptAnswerPacket@CPythonNetworkStream@@QAE_NH@Z ENDP ; CPythonNetworkStream::SendScriptAnswerPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendScriptButtonPacket@CPythonNetworkStream@@QAE_NI@Z
_TEXT	SEGMENT
_ScriptButton$ = -8					; size = 5
_iIndex$ = 8						; size = 4
?SendScriptButtonPacket@CPythonNetworkStream@@QAE_NI@Z PROC ; CPythonNetworkStream::SendScriptButtonPacket, COMDAT
; _this$ = ecx

; 2251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2252 : 	TPacketCGScriptButton ScriptButton;
; 2253 : 
; 2254 : 	ScriptButton.header = HEADER_CG_SCRIPT_BUTTON;
; 2255 : 	ScriptButton.idx = iIndex;

  00006	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00009	56		 push	 esi
  0000a	89 45 f9	 mov	 DWORD PTR _ScriptButton$[ebp+1], eax
  0000d	8b f1		 mov	 esi, ecx

; 2256 : 	if (!Send(sizeof(TPacketCGScriptButton), &ScriptButton))

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _ScriptButton$[ebp]
  00012	c6 45 f8 42	 mov	 BYTE PTR _ScriptButton$[ebp], 66 ; 00000042H
  00016	50		 push	 eax
  00017	6a 05		 push	 5
  00019	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001e	84 c0		 test	 al, al
  00020	75 16		 jne	 SHORT $LN1@SendScript

; 2257 : 	{
; 2258 : 		Tracen("Send Script Button Packet Error");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DKGOFDHL@Send?5Script?5Button?5Packet?5Error?$AA@
  00027	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002c	83 c4 04	 add	 esp, 4

; 2259 : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 2263 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN1@SendScript:

; 2260 : 	}
; 2261 : 
; 2262 : 	return SendSequence();

  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0003f	5e		 pop	 esi

; 2263 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?SendScriptButtonPacket@CPythonNetworkStream@@QAE_NI@Z ENDP ; CPythonNetworkStream::SendScriptButtonPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__InitializeGamePhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
__Cat$1 = -5						; size = 1
__Alval$2 = -1						; size = 1
?__InitializeGamePhase@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__InitializeGamePhase, COMDAT
; _this$ = ecx

; 790  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 791  : 	__ServerTimeSync_Initialize();

  00009	e8 00 00 00 00	 call	 ?__ServerTimeSync_Initialize@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__ServerTimeSync_Initialize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000e	ff 75 fb	 push	 DWORD PTR __Cat$1[ebp]
  00011	8d 45 ff	 lea	 eax, DWORD PTR __Alval$2[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 793  : 	m_isRefreshStatus=false;

  00014	c7 86 10 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+784], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0001e	50		 push	 eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 797  : 	m_isRefreshExchangeWnd=false;

  0001f	c7 86 14 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+788], 0

; 798  : 	m_isRefreshSkillWnd=false;
; 799  : 	m_isRefreshSafeboxWnd=false;
; 800  : 	m_isRefreshMallWnd=false;
; 801  : 	m_isRefreshMessengerWnd=false;

  00029	c7 86 18 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+792], 0

; 802  : 	m_isRefreshGuildWndInfoPage=false;
; 803  : 	m_isRefreshGuildWndBoardPage=false;
; 804  : 	m_isRefreshGuildWndMemberPage=false;
; 805  : 	m_isRefreshGuildWndMemberPageGradeComboBox=false;

  00033	66 c7 86 1c 03
	00 00 00 00	 mov	 WORD PTR [esi+796], 0

; 806  : 	m_isRefreshGuildWndSkillPage=false;
; 807  : 	m_isRefreshGuildWndGradePage=false;

  0003c	c6 86 1e 03 00
	00 00		 mov	 BYTE PTR [esi+798], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00043	ff b6 24 03 00
	00		 push	 DWORD PTR [esi+804]
  00049	ff b6 20 03 00
	00		 push	 DWORD PTR [esi+800]
  0004f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00054	8b 86 20 03 00
	00		 mov	 eax, DWORD PTR [esi+800]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0005a	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0005d	89 86 24 03 00
	00		 mov	 DWORD PTR [esi+804], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 811  : 	m_pInstTarget = NULL;

  00063	c7 86 48 79 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+31048], 0
  0006d	5e		 pop	 esi

; 812  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?__InitializeGamePhase@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__InitializeGamePhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SetGamePhase@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?SetGamePhase@CPythonNetworkStream@@QAEXXZ PROC		; CPythonNetworkStream::SetGamePhase, COMDAT
; _this$ = ecx

; 859  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  00004	6a 04		 push	 4
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_04IBBNLEM@Game?$AA@
  0000b	ff b7 1c 01 00
	00		 push	 DWORD PTR [edi+284]
  00011	8d 8f 0c 01 00
	00		 lea	 ecx, DWORD PTR [edi+268]
  00017	6a 00		 push	 0
  00019	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);

  0001e	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 860  : 	if ("Game"!=m_strPhase)

  00020	74 1e		 je	 SHORT $LN14@SetGamePha
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 41   : 			if (m_pSelfObject)

  00022	8b 97 68 01 00
	00		 mov	 edx, DWORD PTR [edi+360]
  00028	85 d2		 test	 edx, edx
  0002a	74 14		 je	 SHORT $LN14@SetGamePha

; 42   : 				if (m_pFuncObject)

  0002c	8b 87 70 01 00
	00		 mov	 eax, DWORD PTR [edi+368]
  00032	85 c0		 test	 eax, eax
  00034	74 0a		 je	 SHORT $LN14@SetGamePha

; 43   : 					(m_pSelfObject->*m_pFuncObject)();

  00036	8b 8f 74 01 00
	00		 mov	 ecx, DWORD PTR [edi+372]
  0003c	03 ca		 add	 ecx, edx
  0003e	ff d0		 call	 eax
$LN14@SetGamePha:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 863  : 	Tracen("");

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00045	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen

; 864  : 	Tracen("## Network - Game Phase ##");

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HPKACCGC@?$CD?$CD?5Network?5?9?5Game?5Phase?5?$CD?$CD?$AA@
  0004f	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen

; 865  : 	Tracen("");

  00054	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00059	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00061	8d 8f 0c 01 00
	00		 lea	 ecx, DWORD PTR [edi+268]
  00067	6a 04		 push	 4
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_04IBBNLEM@Game?$AA@
  0006e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 869  : 	m_dwChangingPhaseTime = ELTimer_GetMSec();

  00073	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 870  : 	m_phaseProcessFunc.Set(this, &CPythonNetworkStream::GamePhase);
; 871  : 	m_phaseLeaveFunc.Set(this, &CPythonNetworkStream::__LeaveGamePhase);
; 872  : 
; 873  : 	// Main Character O
; 874  : 
; 875  : 	IAbstractPlayer & rkPlayer = IAbstractPlayer::GetSingleton();

  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton

; 876  : 	rkPlayer.SetMainCharacterIndex(GetMainActorVID());

  0007e	8b cf		 mov	 ecx, edi
  00080	89 87 90 00 00
	00		 mov	 DWORD PTR [edi+144], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 24   : 			m_pSelfObject = pSelfObject;

  00086	89 bf 50 01 00
	00		 mov	 DWORD PTR [edi+336], edi

; 25   : 			m_pFuncObject = pFuncObject;

  0008c	c7 87 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+344], OFFSET ?GamePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::GamePhase
  00096	c7 87 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+348], 0

; 24   : 			m_pSelfObject = pSelfObject;

  000a0	89 bf 68 01 00
	00		 mov	 DWORD PTR [edi+360], edi

; 25   : 			m_pFuncObject = pFuncObject;

  000a6	c7 87 70 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+368], OFFSET ?__LeaveGamePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__LeaveGamePhase
  000b0	c7 87 74 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+372], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 876  : 	rkPlayer.SetMainCharacterIndex(GetMainActorVID());

  000ba	8b 32		 mov	 esi, DWORD PTR [edx]
  000bc	e8 00 00 00 00	 call	 ?GetMainActorVID@CPythonNetworkStream@@QAEKXZ ; CPythonNetworkStream::GetMainActorVID
  000c1	50		 push	 eax
  000c2	8b ca		 mov	 ecx, edx
  000c4	ff 56 08	 call	 DWORD PTR [esi+8]

; 877  : 
; 878  : 	__RefreshStatus();

  000c7	8b cf		 mov	 ecx, edi

; 879  : }

  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi

; 877  : 
; 878  : 	__RefreshStatus();

  000cb	e9 00 00 00 00	 jmp	 ?__RefreshStatus@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshStatus
?SetGamePhase@CPythonNetworkStream@@QAEXXZ ENDP		; CPythonNetworkStream::SetGamePhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z
_TEXT	SEGMENT
tv66 = 8						; size = 4
_ChatPacket$ = 8					; size = 4
_c_szChat$ = 8						; size = 4
_byType$ = 12						; size = 1
?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z PROC	; CPythonNetworkStream::SendChatPacket, COMDAT
; _this$ = ecx

; 1168 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1169 : 	if (strlen(c_szChat) == 0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _c_szChat$[ebp]
  00007	8b d6		 mov	 edx, esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0000f	90		 npad	 1
$LL22@SendChatPa:
  00010	8a 02		 mov	 al, BYTE PTR [edx]
  00012	42		 inc	 edx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL22@SendChatPa
  00017	2b d1		 sub	 edx, ecx
  00019	75 08		 jne	 SHORT $LN9@SendChatPa
$LN28@SendChatPa:
  0001b	5f		 pop	 edi

; 1170 : 		return true;

  0001c	b0 01		 mov	 al, 1
  0001e	5e		 pop	 esi

; 1204 : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
$LN9@SendChatPa:

; 1171 : 
; 1172 : 	if (strlen(c_szChat) >= 512)

  00023	8b ce		 mov	 ecx, esi
  00025	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL23@SendChatPa:
  00028	8a 01		 mov	 al, BYTE PTR [ecx]
  0002a	41		 inc	 ecx
  0002b	84 c0		 test	 al, al
  0002d	75 f9		 jne	 SHORT $LL23@SendChatPa
  0002f	2b ca		 sub	 ecx, edx
  00031	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  00037	73 e2		 jae	 SHORT $LN28@SendChatPa

; 1173 : 		return true;
; 1174 : 
; 1175 : 	if (c_szChat[0] == '/')

  00039	80 3e 2f	 cmp	 BYTE PTR [esi], 47	; 0000002fH
  0003c	75 3b		 jne	 SHORT $LN4@SendChatPa

; 1176 : 	{
; 1177 : 		if (1 == strlen(c_szChat))

  0003e	8b ce		 mov	 ecx, esi
  00040	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL24@SendChatPa:
  00043	8a 01		 mov	 al, BYTE PTR [ecx]
  00045	41		 inc	 ecx
  00046	84 c0		 test	 al, al
  00048	75 f9		 jne	 SHORT $LL24@SendChatPa
  0004a	2b ca		 sub	 ecx, edx
  0004c	83 f9 01	 cmp	 ecx, 1
  0004f	75 1c		 jne	 SHORT $LN6@SendChatPa
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

  00051	83 bf 04 01 00
	00 00		 cmp	 DWORD PTR [edi+260], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1179 : 			if (!m_strLastCommand.empty())

  00058	74 1f		 je	 SHORT $LN4@SendChatPa
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0005a	83 bf 08 01 00
	00 10		 cmp	 DWORD PTR [edi+264], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1180 : 				c_szChat = m_strLastCommand.c_str();

  00061	8d b7 f4 00 00
	00		 lea	 esi, DWORD PTR [edi+244]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00067	72 10		 jb	 SHORT $LN4@SendChatPa
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00069	8b 36		 mov	 esi, DWORD PTR [esi]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1182 : 		else

  0006b	eb 0c		 jmp	 SHORT $LN4@SendChatPa
$LN6@SendChatPa:

; 1183 : 		{
; 1184 : 			m_strLastCommand = c_szChat;

  0006d	56		 push	 esi
  0006e	8d 8f f4 00 00
	00		 lea	 ecx, DWORD PTR [edi+244]
  00074	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN4@SendChatPa:

; 1185 : 		}
; 1186 : 	}
; 1187 : 
; 1188 : 	if (ClientCommand(c_szChat))

  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ?ClientCommand@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::ClientCommand
  0007f	84 c0		 test	 al, al
  00081	75 98		 jne	 SHORT $LN28@SendChatPa

; 1189 : 		return true;
; 1190 : 
; 1191 : 	int iTextLen = strlen(c_szChat) + 1;

  00083	8b ce		 mov	 ecx, esi
  00085	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL25@SendChatPa:
  00088	8a 01		 mov	 al, BYTE PTR [ecx]
  0008a	41		 inc	 ecx
  0008b	84 c0		 test	 al, al
  0008d	75 f9		 jne	 SHORT $LL25@SendChatPa
  0008f	2b ca		 sub	 ecx, edx

; 1192 : 	TPacketCGChat ChatPacket;
; 1193 : 	ChatPacket.header = HEADER_CG_CHAT;

  00091	c6 45 08 03	 mov	 BYTE PTR _ChatPacket$[ebp], 3
  00095	53		 push	 ebx
  00096	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]

; 1194 : 	ChatPacket.length = sizeof(ChatPacket) + iTextLen;
; 1195 : 	ChatPacket.type = byType;
; 1196 : 
; 1197 : 	if (!Send(sizeof(ChatPacket), &ChatPacket))

  00099	8b cf		 mov	 ecx, edi
  0009b	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009e	66 89 45 09	 mov	 WORD PTR _ChatPacket$[ebp+1], ax
  000a2	8b 45 0c	 mov	 eax, DWORD PTR _byType$[ebp]
  000a5	88 45 0b	 mov	 BYTE PTR _ChatPacket$[ebp+3], al
  000a8	8d 45 08	 lea	 eax, DWORD PTR _ChatPacket$[ebp]
  000ab	50		 push	 eax
  000ac	6a 04		 push	 4
  000ae	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  000b3	84 c0		 test	 al, al
  000b5	74 0d		 je	 SHORT $LN27@SendChatPa

; 1198 : 		return false;
; 1199 : 
; 1200 : 	if (!Send(iTextLen, c_szChat))

  000b7	56		 push	 esi
  000b8	53		 push	 ebx
  000b9	8b cf		 mov	 ecx, edi
  000bb	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBD@Z ; CNetworkStream::Send
  000c0	84 c0		 test	 al, al
  000c2	75 09		 jne	 SHORT $LN1@SendChatPa
$LN27@SendChatPa:
  000c4	5b		 pop	 ebx
  000c5	5f		 pop	 edi

; 1201 : 		return false;

  000c6	32 c0		 xor	 al, al
  000c8	5e		 pop	 esi

; 1204 : }

  000c9	5d		 pop	 ebp
  000ca	c2 08 00	 ret	 8
$LN1@SendChatPa:

; 1202 : 
; 1203 : 	return SendSequence();

  000cd	8b cf		 mov	 ecx, edi
  000cf	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  000d4	5b		 pop	 ebx
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi

; 1204 : }

  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z ENDP	; CPythonNetworkStream::SendChatPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__TEST_SetSkillGroupFake@CPythonNetworkStream@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?__TEST_SetSkillGroupFake@CPythonNetworkStream@@QAEXH@Z PROC ; CPythonNetworkStream::__TEST_SetSkillGroupFake, COMDAT
; _this$ = ecx

; 3994 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3995 : 	m_dwMainActorSkillGroup = DWORD(iIndex);

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 3996 : 
; 3997 : 	CPythonPlayer::Instance().NEW_ClearSkillData();

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0000f	6a 00		 push	 0
  00011	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  00017	e8 00 00 00 00	 call	 ?NEW_ClearSkillData@CPythonPlayer@@QAEX_N@Z ; CPythonPlayer::NEW_ClearSkillData

; 3998 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshCharacter", Py_BuildValue("()"));

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00027	50		 push	 eax
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HFALJDHO@RefreshCharacter?$AA@
  0002d	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00033	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	5e		 pop	 esi

; 3999 : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?__TEST_SetSkillGroupFake@CPythonNetworkStream@@QAEXH@Z ENDP ; CPythonNetworkStream::__TEST_SetSkillGroupFake
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendSelectItemPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_kScriptSelectItem$ = -8				; size = 5
_dwItemPos$ = 8						; size = 4
?SendSelectItemPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendSelectItemPacket, COMDAT
; _this$ = ecx

; 4015 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4016 : 	TPacketCGScriptSelectItem kScriptSelectItem;
; 4017 : 	kScriptSelectItem.header = HEADER_CG_SCRIPT_SELECT_ITEM;
; 4018 : 	kScriptSelectItem.selection = dwItemPos;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dwItemPos$[ebp]
  00009	56		 push	 esi
  0000a	89 45 f9	 mov	 DWORD PTR _kScriptSelectItem$[ebp+1], eax
  0000d	8b f1		 mov	 esi, ecx

; 4019 : 
; 4020 : 	if (!Send(sizeof(kScriptSelectItem), &kScriptSelectItem))

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _kScriptSelectItem$[ebp]
  00012	c6 45 f8 72	 mov	 BYTE PTR _kScriptSelectItem$[ebp], 114 ; 00000072H
  00016	50		 push	 eax
  00017	6a 05		 push	 5
  00019	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001e	84 c0		 test	 al, al
  00020	75 07		 jne	 SHORT $LN1@SendSelect
  00022	5e		 pop	 esi

; 4024 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN1@SendSelect:

; 4021 : 		return false;
; 4022 : 
; 4023 : 	return SendSequence();

  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00030	5e		 pop	 esi

; 4024 : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?SendSelectItemPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendSelectItemPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendRefinePacket@CPythonNetworkStream@@QAE_NEE@Z
_TEXT	SEGMENT
_kRefinePacket$ = -4					; size = 3
_byPos$ = 8						; size = 1
_byType$ = 12						; size = 1
?SendRefinePacket@CPythonNetworkStream@@QAE_NEE@Z PROC	; CPythonNetworkStream::SendRefinePacket, COMDAT
; _this$ = ecx

; 4002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4003 : 	TPacketCGRefine kRefinePacket;
; 4004 : 	kRefinePacket.header = HEADER_CG_REFINE;
; 4005 : 	kRefinePacket.pos = byPos;

  00004	8b 45 08	 mov	 eax, DWORD PTR _byPos$[ebp]
  00007	88 45 fd	 mov	 BYTE PTR _kRefinePacket$[ebp+1], al

; 4006 : 	kRefinePacket.type = byType;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _byType$[ebp]
  0000d	56		 push	 esi
  0000e	88 45 fe	 mov	 BYTE PTR _kRefinePacket$[ebp+2], al
  00011	8b f1		 mov	 esi, ecx

; 4007 : 
; 4008 : 	if (!Send(sizeof(kRefinePacket), &kRefinePacket))

  00013	8d 45 fc	 lea	 eax, DWORD PTR _kRefinePacket$[ebp]
  00016	c6 45 fc 60	 mov	 BYTE PTR _kRefinePacket$[ebp], 96 ; 00000060H
  0001a	50		 push	 eax
  0001b	6a 03		 push	 3
  0001d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00022	84 c0		 test	 al, al
  00024	75 07		 jne	 SHORT $LN1@SendRefine
  00026	5e		 pop	 esi

; 4012 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN1@SendRefine:

; 4009 : 		return false;
; 4010 : 
; 4011 : 	return SendSequence();

  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00034	5e		 pop	 esi

; 4012 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?SendRefinePacket@CPythonNetworkStream@@QAE_NEE@Z ENDP	; CPythonNetworkStream::SendRefinePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildWithdrawMoneyPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwMoney$ = 8						; size = 4
?SendGuildWithdrawMoneyPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendGuildWithdrawMoneyPacket, COMDAT
; _this$ = ecx

; 3280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3281 : 	TPacketCGGuild GuildPacket;
; 3282 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3283 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_WITHDRAW_MONEY;
; 3284 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	0e		 mov	 WORD PTR _GuildPacket$[ebp], 3664 ; 00000e50H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN2@SendGuildW
$LN5@SendGuildW:

; 3285 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3291 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@SendGuildW:

; 3286 : 	if (!Send(sizeof(dwMoney), &dwMoney))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwMoney$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN5@SendGuildW

; 3287 : 		return false;
; 3288 : 
; 3289 : 	Tracef(" SendGuildWithdrawMoneyPacket %d\n", dwMoney);

  00036	ff 75 08	 push	 DWORD PTR _dwMoney$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HBGAJKKF@?5SendGuildWithdrawMoneyPacket?5?$CFd@
  0003e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00043	83 c4 08	 add	 esp, 8

; 3290 : 	return SendSequence();

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004d	5e		 pop	 esi

; 3291 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?SendGuildWithdrawMoneyPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendGuildWithdrawMoneyPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildDepositMoneyPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwMoney$ = 8						; size = 4
?SendGuildDepositMoneyPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendGuildDepositMoneyPacket, COMDAT
; _this$ = ecx

; 3266 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3267 : 	TPacketCGGuild GuildPacket;
; 3268 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3269 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_DEPOSIT_MONEY;
; 3270 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	0d		 mov	 WORD PTR _GuildPacket$[ebp], 3408 ; 00000d50H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN2@SendGuildD
$LN5@SendGuildD:

; 3271 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3277 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@SendGuildD:

; 3272 : 	if (!Send(sizeof(dwMoney), &dwMoney))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwMoney$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN5@SendGuildD

; 3273 : 		return false;
; 3274 : 
; 3275 : 	Tracef(" SendGuildDepositMoneyPacket %d\n", dwMoney);

  00036	ff 75 08	 push	 DWORD PTR _dwMoney$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OEPAEO@?5SendGuildDepositMoneyPacket?5?$CFd?6@
  0003e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00043	83 c4 08	 add	 esp, 8

; 3276 : 	return SendSequence();

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004d	5e		 pop	 esi

; 3277 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?SendGuildDepositMoneyPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendGuildDepositMoneyPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildChargeGSPPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwMoney$ = 8						; size = 4
?SendGuildChargeGSPPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendGuildChargeGSPPacket, COMDAT
; _this$ = ecx

; 3251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3252 : 	TPacketCGGuild GuildPacket;
; 3253 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3254 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHARGE_GSP;
; 3255 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	0c		 mov	 WORD PTR _GuildPacket$[ebp], 3152 ; 00000c50H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN2@SendGuildC
$LN5@SendGuildC:

; 3256 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3263 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@SendGuildC:

; 3257 : 
; 3258 : 	if (!Send(sizeof(dwMoney), &dwMoney))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwMoney$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN5@SendGuildC

; 3259 : 		return false;
; 3260 : 
; 3261 : 	Tracef(" SendGuildChargeGSPPacket %d\n", dwMoney);

  00036	ff 75 08	 push	 DWORD PTR _dwMoney$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DLDFHEKF@?5SendGuildChargeGSPPacket?5?$CFd?6?$AA@
  0003e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00043	83 c4 08	 add	 esp, 8

; 3262 : 	return SendSequence();

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004d	5e		 pop	 esi

; 3263 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?SendGuildChargeGSPPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendGuildChargeGSPPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildInviteAnswerPacket@CPythonNetworkStream@@QAE_NKE@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwGuildID$ = 8						; size = 4
_byAnswer$ = 12						; size = 1
?SendGuildInviteAnswerPacket@CPythonNetworkStream@@QAE_NKE@Z PROC ; CPythonNetworkStream::SendGuildInviteAnswerPacket, COMDAT
; _this$ = ecx

; 3234 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3235 : 	TPacketCGGuild GuildPacket;
; 3236 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3237 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_GUILD_INVITE_ANSWER;
; 3238 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	0b		 mov	 WORD PTR _GuildPacket$[ebp], 2896 ; 00000b50H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN3@SendGuildI
$LN6@SendGuildI:

; 3239 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3248 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN3@SendGuildI:

; 3240 : 
; 3241 : 	if (!Send(sizeof(dwGuildID), &dwGuildID))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwGuildID$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN6@SendGuildI

; 3242 : 		return false;
; 3243 : 	if (!Send(sizeof(byAnswer), &byAnswer))

  00036	8d 45 0c	 lea	 eax, DWORD PTR _byAnswer$[ebp]
  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	6a 01		 push	 1
  0003e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00043	84 c0		 test	 al, al
  00045	74 d5		 je	 SHORT $LN6@SendGuildI

; 3244 : 		return false;
; 3245 : 
; 3246 : 	Tracef(" SendGuildInviteAnswerPacket %d, %d\n", dwGuildID, byAnswer);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _byAnswer$[ebp]
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	50		 push	 eax
  0004e	ff 75 08	 push	 DWORD PTR _dwGuildID$[ebp]
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HPNCOLAE@?5SendGuildInviteAnswerPacket?5?$CFd?0@
  00056	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3247 : 	return SendSequence();

  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00065	5e		 pop	 esi

; 3248 : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?SendGuildInviteAnswerPacket@CPythonNetworkStream@@QAE_NKE@Z ENDP ; CPythonNetworkStream::SendGuildInviteAnswerPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildChangeMemberGeneralPacket@CPythonNetworkStream@@QAE_NKE@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwPID$ = 8						; size = 4
_byFlag$ = 12						; size = 1
?SendGuildChangeMemberGeneralPacket@CPythonNetworkStream@@QAE_NKE@Z PROC ; CPythonNetworkStream::SendGuildChangeMemberGeneralPacket, COMDAT
; _this$ = ecx

; 3217 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3218 : 	TPacketCGGuild GuildPacket;
; 3219 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3220 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_MEMBER_GENERAL;
; 3221 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	0a		 mov	 WORD PTR _GuildPacket$[ebp], 2640 ; 00000a50H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN3@SendGuildC
$LN6@SendGuildC:

; 3222 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3231 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN3@SendGuildC:

; 3223 : 
; 3224 : 	if (!Send(sizeof(dwPID), &dwPID))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwPID$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN6@SendGuildC

; 3225 : 		return false;
; 3226 : 	if (!Send(sizeof(byFlag), &byFlag))

  00036	8d 45 0c	 lea	 eax, DWORD PTR _byFlag$[ebp]
  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	6a 01		 push	 1
  0003e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00043	84 c0		 test	 al, al
  00045	74 d5		 je	 SHORT $LN6@SendGuildC

; 3227 : 		return false;
; 3228 : 
; 3229 : 	Tracef(" SendGuildChangeMemberGeneralFlagPacket %d, %d\n", dwPID, byFlag);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _byFlag$[ebp]
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	50		 push	 eax
  0004e	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@BBFAPAKJ@?5SendGuildChangeMemberGeneralFla@
  00056	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3230 : 	return SendSequence();

  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00065	5e		 pop	 esi

; 3231 : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?SendGuildChangeMemberGeneralPacket@CPythonNetworkStream@@QAE_NKE@Z ENDP ; CPythonNetworkStream::SendGuildChangeMemberGeneralPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildUseSkillPacket@CPythonNetworkStream@@QAE_NKK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwSkillID$ = 8						; size = 4
_dwTargetVID$ = 12					; size = 4
?SendGuildUseSkillPacket@CPythonNetworkStream@@QAE_NKK@Z PROC ; CPythonNetworkStream::SendGuildUseSkillPacket, COMDAT
; _this$ = ecx

; 3200 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3201 : 	TPacketCGGuild GuildPacket;
; 3202 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3203 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_USE_SKILL;
; 3204 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	09		 mov	 WORD PTR _GuildPacket$[ebp], 2384 ; 00000950H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN3@SendGuildU
$LN6@SendGuildU:

; 3205 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3214 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN3@SendGuildU:

; 3206 : 
; 3207 : 	if (!Send(sizeof(dwSkillID), &dwSkillID))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwSkillID$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN6@SendGuildU

; 3208 : 		return false;
; 3209 : 	if (!Send(sizeof(dwTargetVID), &dwTargetVID))

  00036	8d 45 0c	 lea	 eax, DWORD PTR _dwTargetVID$[ebp]
  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	6a 04		 push	 4
  0003e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00043	84 c0		 test	 al, al
  00045	74 d5		 je	 SHORT $LN6@SendGuildU

; 3210 : 		return false;
; 3211 : 
; 3212 : 	Tracef(" SendGuildUseSkillPacket %d, %d\n", dwSkillID, dwTargetVID);

  00047	ff 75 0c	 push	 DWORD PTR _dwTargetVID$[ebp]
  0004a	ff 75 08	 push	 DWORD PTR _dwSkillID$[ebp]
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HHLIHMFO@?5SendGuildUseSkillPacket?5?$CFd?0?5?$CFd?6@
  00052	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3213 : 	return SendSequence();

  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00061	5e		 pop	 esi

; 3214 : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 08 00	 ret	 8
?SendGuildUseSkillPacket@CPythonNetworkStream@@QAE_NKK@Z ENDP ; CPythonNetworkStream::SendGuildUseSkillPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildChangeMemberGradePacket@CPythonNetworkStream@@QAE_NKE@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwPID$ = 8						; size = 4
_byGrade$ = 12						; size = 1
?SendGuildChangeMemberGradePacket@CPythonNetworkStream@@QAE_NKE@Z PROC ; CPythonNetworkStream::SendGuildChangeMemberGradePacket, COMDAT
; _this$ = ecx

; 3183 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3184 : 	TPacketCGGuild GuildPacket;
; 3185 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3186 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_MEMBER_GRADE;
; 3187 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	08		 mov	 WORD PTR _GuildPacket$[ebp], 2128 ; 00000850H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN3@SendGuildC
$LN6@SendGuildC:

; 3188 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3197 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN3@SendGuildC:

; 3189 : 
; 3190 : 	if (!Send(sizeof(dwPID), &dwPID))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwPID$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN6@SendGuildC

; 3191 : 		return false;
; 3192 : 	if (!Send(sizeof(byGrade), &byGrade))

  00036	8d 45 0c	 lea	 eax, DWORD PTR _byGrade$[ebp]
  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	6a 01		 push	 1
  0003e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00043	84 c0		 test	 al, al
  00045	74 d5		 je	 SHORT $LN6@SendGuildC

; 3193 : 		return false;
; 3194 : 
; 3195 : 	Tracef(" SendGuildChangeMemberGradePacket %d, %d\n", dwPID, byGrade);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _byGrade$[ebp]
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	50		 push	 eax
  0004e	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NJDDFMMG@?5SendGuildChangeMemberGradePacke@
  00056	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3196 : 	return SendSequence();

  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00065	5e		 pop	 esi

; 3197 : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?SendGuildChangeMemberGradePacket@CPythonNetworkStream@@QAE_NKE@Z ENDP ; CPythonNetworkStream::SendGuildChangeMemberGradePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwHighestIndex$ = 8					; size = 4
?SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendGuildRefreshCommentsPacket, COMDAT
; _this$ = ecx

; 3165 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3166 : 	static DWORD s_LastTime = timeGetTime() - 1001;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S4@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4IA
  00009	56		 push	 esi
  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__timeGetTime@0
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	a8 01		 test	 al, 1
  00015	75 14		 jne	 SHORT $LN3@SendGuildR
  00017	83 c8 01	 or	 eax, 1
  0001a	a3 00 00 00 00	 mov	 DWORD PTR ?$S4@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4IA, eax
  0001f	ff d6		 call	 esi
  00021	2d e9 03 00 00	 sub	 eax, 1001		; 000003e9H
  00026	a3 00 00 00 00	 mov	 DWORD PTR ?s_LastTime@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4KA, eax
$LN3@SendGuildR:

; 3167 : 
; 3168 : 	if (timeGetTime() - s_LastTime < 1000)

  0002b	ff d6		 call	 esi
  0002d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?s_LastTime@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4KA
  00033	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00038	73 0a		 jae	 SHORT $LN2@SendGuildR

; 3169 : 		return true;

  0003a	5f		 pop	 edi
  0003b	b0 01		 mov	 al, 1
  0003d	5e		 pop	 esi

; 3180 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN2@SendGuildR:

; 3170 : 	s_LastTime = timeGetTime();

  00044	ff d6		 call	 esi
  00046	a3 00 00 00 00	 mov	 DWORD PTR ?s_LastTime@?1??SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z@4KA, eax

; 3171 : 
; 3172 : 	TPacketCGGuild GuildPacket;
; 3173 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3174 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_REFRESH_COMMENT;
; 3175 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  0004b	8b cf		 mov	 ecx, edi
  0004d	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00050	66 c7 45 fc 50
	07		 mov	 WORD PTR _GuildPacket$[ebp], 1872 ; 00000750H
  00056	50		 push	 eax
  00057	6a 02		 push	 2
  00059	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0005e	84 c0		 test	 al, al
  00060	75 08		 jne	 SHORT $LN1@SendGuildR
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 3180 : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
$LN1@SendGuildR:

; 3176 : 		return false;
; 3177 : 
; 3178 : 	Tracef(" SendGuildRefreshCommentPacket %d\n", dwHighestIndex);

  0006a	ff 75 08	 push	 DWORD PTR _dwHighestIndex$[ebp]
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DFFJJDFM@?5SendGuildRefreshCommentPacket?5?$CF@
  00072	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00077	83 c4 08	 add	 esp, 8

; 3179 : 	return SendSequence();

  0007a	8b cf		 mov	 ecx, edi
  0007c	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi

; 3180 : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?SendGuildRefreshCommentsPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendGuildRefreshCommentsPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildDeleteCommentPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwIndex$ = 8						; size = 4
?SendGuildDeleteCommentPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendGuildDeleteCommentPacket, COMDAT
; _this$ = ecx

; 3150 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3151 : 	TPacketCGGuild GuildPacket;
; 3152 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3153 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_DELETE_COMMENT;
; 3154 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	06		 mov	 WORD PTR _GuildPacket$[ebp], 1616 ; 00000650H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN2@SendGuildD
$LN5@SendGuildD:

; 3155 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3162 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@SendGuildD:

; 3156 : 
; 3157 : 	if (!Send(sizeof(dwIndex), &dwIndex))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwIndex$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN5@SendGuildD

; 3158 : 		return false;
; 3159 : 
; 3160 : 	Tracef(" SendGuildDeleteCommentPacket %d\n", dwIndex);

  00036	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HHBLBNGP@?5SendGuildDeleteCommentPacket?5?$CFd@
  0003e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00043	83 c4 08	 add	 esp, 8

; 3161 : 	return SendSequence();

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004d	5e		 pop	 esi

; 3162 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?SendGuildDeleteCommentPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendGuildDeleteCommentPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildPostCommentPacket@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_GuildPacket$ = -8					; size = 2
_bySize$ = -1						; size = 1
_c_szMessage$ = 8					; size = 4
?SendGuildPostCommentPacket@CPythonNetworkStream@@QAE_NPBD@Z PROC ; CPythonNetworkStream::SendGuildPostCommentPacket, COMDAT
; _this$ = ecx

; 3132 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 3133 : 	TPacketCGGuild GuildPacket;
; 3134 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3135 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_POST_COMMENT;
; 3136 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00007	8d 45 f8	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  0000a	66 c7 45 f8 50
	05		 mov	 WORD PTR _GuildPacket$[ebp], 1360 ; 00000550H
  00010	50		 push	 eax
  00011	6a 02		 push	 2
  00013	8b f1		 mov	 esi, ecx
  00015	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001a	84 c0		 test	 al, al
  0001c	75 07		 jne	 SHORT $LN3@SendGuildP
  0001e	5e		 pop	 esi

; 3147 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN3@SendGuildP:
  00025	57		 push	 edi

; 3137 : 		return false;
; 3138 : 
; 3139 : 	BYTE bySize = BYTE(strlen(c_szMessage)) + 1;

  00026	8b 7d 08	 mov	 edi, DWORD PTR _c_szMessage$[ebp]
  00029	8b cf		 mov	 ecx, edi
  0002b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0002e	8b ff		 npad	 2
$LL6@SendGuildP:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	41		 inc	 ecx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL6@SendGuildP
  00037	2b ca		 sub	 ecx, edx

; 3140 : 	if (!Send(sizeof(bySize), &bySize))

  00039	8d 45 ff	 lea	 eax, DWORD PTR _bySize$[ebp]
  0003c	fe c1		 inc	 cl
  0003e	50		 push	 eax
  0003f	88 4d ff	 mov	 BYTE PTR _bySize$[ebp], cl
  00042	8b ce		 mov	 ecx, esi
  00044	6a 01		 push	 1
  00046	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0004b	84 c0		 test	 al, al
  0004d	74 11		 je	 SHORT $LN8@SendGuildP

; 3141 : 		return false;
; 3142 : 	if (!Send(bySize, c_szMessage))

  0004f	0f b6 45 ff	 movzx	 eax, BYTE PTR _bySize$[ebp]
  00053	8b ce		 mov	 ecx, esi
  00055	57		 push	 edi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBD@Z ; CNetworkStream::Send
  0005c	84 c0		 test	 al, al
  0005e	75 0a		 jne	 SHORT $LN1@SendGuildP
$LN8@SendGuildP:
  00060	5f		 pop	 edi

; 3143 : 		return false;

  00061	32 c0		 xor	 al, al
  00063	5e		 pop	 esi

; 3147 : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
$LN1@SendGuildP:

; 3144 : 
; 3145 : 	Tracef(" SendGuildPostCommentPacket %d, %s\n", bySize, c_szMessage);

  0006a	0f b6 45 ff	 movzx	 eax, BYTE PTR _bySize$[ebp]
  0006e	57		 push	 edi
  0006f	50		 push	 eax
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@ILONPNIK@?5SendGuildPostCommentPacket?5?$CFd?0?5@
  00075	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3146 : 	return SendSequence();

  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 3147 : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?SendGuildPostCommentPacket@CPythonNetworkStream@@QAE_NPBD@Z ENDP ; CPythonNetworkStream::SendGuildPostCommentPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildOfferPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwExperience$ = 8					; size = 4
?SendGuildOfferPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendGuildOfferPacket, COMDAT
; _this$ = ecx

; 3118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3119 : 	TPacketCGGuild GuildPacket;
; 3120 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3121 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_OFFER;
; 3122 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	04		 mov	 WORD PTR _GuildPacket$[ebp], 1104 ; 00000450H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN2@SendGuildO
$LN5@SendGuildO:

; 3123 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3129 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@SendGuildO:

; 3124 : 	if (!Send(sizeof(dwExperience), &dwExperience))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwExperience$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN5@SendGuildO

; 3125 : 		return false;
; 3126 : 
; 3127 : 	Tracef(" SendGuildOfferPacket %d\n", dwExperience);

  00036	ff 75 08	 push	 DWORD PTR _dwExperience$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JBHNFCGO@?5SendGuildOfferPacket?5?$CFd?6?$AA@
  0003e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00043	83 c4 08	 add	 esp, 8

; 3128 : 	return SendSequence();

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004d	5e		 pop	 esi

; 3129 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?SendGuildOfferPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendGuildOfferPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildChangeGradeAuthorityPacket@CPythonNetworkStream@@QAE_NEE@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_byGradeNumber$ = 8					; size = 1
_byAuthority$ = 12					; size = 1
?SendGuildChangeGradeAuthorityPacket@CPythonNetworkStream@@QAE_NEE@Z PROC ; CPythonNetworkStream::SendGuildChangeGradeAuthorityPacket, COMDAT
; _this$ = ecx

; 3102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3103 : 	TPacketCGGuild GuildPacket;
; 3104 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3105 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_GRADE_AUTHORITY;
; 3106 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	03		 mov	 WORD PTR _GuildPacket$[ebp], 848 ; 00000350H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN3@SendGuildC
$LN6@SendGuildC:

; 3107 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3115 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN3@SendGuildC:

; 3108 : 	if (!Send(sizeof(byGradeNumber), &byGradeNumber))

  00025	8d 45 08	 lea	 eax, DWORD PTR _byGradeNumber$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN6@SendGuildC

; 3109 : 		return false;
; 3110 : 	if (!Send(sizeof(byAuthority), &byAuthority))

  00036	8d 45 0c	 lea	 eax, DWORD PTR _byAuthority$[ebp]
  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	6a 01		 push	 1
  0003e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00043	84 c0		 test	 al, al
  00045	74 d5		 je	 SHORT $LN6@SendGuildC

; 3111 : 		return false;
; 3112 : 
; 3113 : 	Tracef(" SendGuildChangeGradeAuthorityPacket %d, %d\n", byGradeNumber, byAuthority);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _byAuthority$[ebp]
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	50		 push	 eax
  0004e	8b 45 08	 mov	 eax, DWORD PTR _byGradeNumber$[ebp]
  00051	0f b6 c0	 movzx	 eax, al
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@ENAPGANL@?5SendGuildChangeGradeAuthorityPa@
  0005a	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3114 : 	return SendSequence();

  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00069	5e		 pop	 esi

; 3115 : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?SendGuildChangeGradeAuthorityPacket@CPythonNetworkStream@@QAE_NEE@Z ENDP ; CPythonNetworkStream::SendGuildChangeGradeAuthorityPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildChangeGradeNamePacket@CPythonNetworkStream@@QAE_NEPBD@Z
_TEXT	SEGMENT
_GuildPacket$ = -20					; size = 2
_szName$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_byGradeNumber$ = 8					; size = 1
_c_szName$ = 12						; size = 4
?SendGuildChangeGradeNamePacket@CPythonNetworkStream@@QAE_NEPBD@Z PROC ; CPythonNetworkStream::SendGuildChangeGradeNamePacket, COMDAT
; _this$ = ecx

; 3081 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 0c	 mov	 edi, DWORD PTR _c_szName$[ebp]

; 3082 : 	TPacketCGGuild GuildPacket;
; 3083 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3084 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_CHANGE_GRADE_NAME;
; 3085 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00015	8d 45 ec	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00018	50		 push	 eax
  00019	6a 02		 push	 2
  0001b	8b f1		 mov	 esi, ecx
  0001d	66 c7 45 ec 50
	02		 mov	 WORD PTR _GuildPacket$[ebp], 592 ; 00000250H
  00023	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00028	84 c0		 test	 al, al
  0002a	75 14		 jne	 SHORT $LN3@SendGuildC
$LN8@SendGuildC:
  0002c	5f		 pop	 edi

; 3086 : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	5e		 pop	 esi

; 3099 : }

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00033	33 cd		 xor	 ecx, ebp
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN3@SendGuildC:

; 3087 : 	if (!Send(sizeof(byGradeNumber), &byGradeNumber))

  00040	8d 45 08	 lea	 eax, DWORD PTR _byGradeNumber$[ebp]
  00043	8b ce		 mov	 ecx, esi
  00045	50		 push	 eax
  00046	6a 01		 push	 1
  00048	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0004d	84 c0		 test	 al, al
  0004f	74 db		 je	 SHORT $LN8@SendGuildC

; 3088 : 		return false;
; 3089 : 
; 3090 : 	char szName[GUILD_GRADE_NAME_MAX_LEN+1];
; 3091 : 	strncpy(szName, c_szName, GUILD_GRADE_NAME_MAX_LEN);

  00051	6a 08		 push	 8
  00053	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00056	57		 push	 edi
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _strncpy
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3092 : 	szName[GUILD_GRADE_NAME_MAX_LEN] = '\0';

  00060	c6 45 f8 00	 mov	 BYTE PTR _szName$[ebp+8], 0

; 3093 : 
; 3094 : 	if (!Send(sizeof(szName), &szName))

  00064	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00067	8b ce		 mov	 ecx, esi
  00069	50		 push	 eax
  0006a	6a 09		 push	 9
  0006c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00071	84 c0		 test	 al, al
  00073	74 b7		 je	 SHORT $LN8@SendGuildC

; 3095 : 		return false;
; 3096 : 
; 3097 : 	Tracef(" SendGuildChangeGradeNamePacket %d, %s\n", byGradeNumber, c_szName);

  00075	8b 45 08	 mov	 eax, DWORD PTR _byGradeNumber$[ebp]
  00078	57		 push	 edi
  00079	0f b6 c0	 movzx	 eax, al
  0007c	50		 push	 eax
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HCDCDOMK@?5SendGuildChangeGradeNamePacket?5@
  00082	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3098 : 	return SendSequence();

  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 3099 : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	5f		 pop	 edi
  00095	33 cd		 xor	 ecx, ebp
  00097	5e		 pop	 esi
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
?SendGuildChangeGradeNamePacket@CPythonNetworkStream@@QAE_NEPBD@Z ENDP ; CPythonNetworkStream::SendGuildChangeGradeNamePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildRemoveMemberPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwPID$ = 8						; size = 4
?SendGuildRemoveMemberPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendGuildRemoveMemberPacket, COMDAT
; _this$ = ecx

; 3067 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3068 : 	TPacketCGGuild GuildPacket;
; 3069 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3070 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_REMOVE_MEMBER;
; 3071 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	01		 mov	 WORD PTR _GuildPacket$[ebp], 336 ; 00000150H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN2@SendGuildR
$LN5@SendGuildR:

; 3072 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3078 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@SendGuildR:

; 3073 : 	if (!Send(sizeof(dwPID), &dwPID))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwPID$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN5@SendGuildR

; 3074 : 		return false;
; 3075 : 
; 3076 : 	Tracef(" SendGuildRemoveMemberPacket %d\n", dwPID);

  00036	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OCJDCDKN@?5SendGuildRemoveMemberPacket?5?$CFd?6@
  0003e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00043	83 c4 08	 add	 esp, 8

; 3077 : 	return SendSequence();

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004d	5e		 pop	 esi

; 3078 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?SendGuildRemoveMemberPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendGuildRemoveMemberPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGuildAddMemberPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_GuildPacket$ = -4					; size = 2
_dwVID$ = 8						; size = 4
?SendGuildAddMemberPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendGuildAddMemberPacket, COMDAT
; _this$ = ecx

; 3053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3054 : 	TPacketCGGuild GuildPacket;
; 3055 : 	GuildPacket.byHeader = HEADER_CG_GUILD;
; 3056 : 	GuildPacket.bySubHeader = GUILD_SUBHEADER_CG_ADD_MEMBER;
; 3057 : 	if (!Send(sizeof(GuildPacket), &GuildPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00008	66 c7 45 fc 50
	00		 mov	 WORD PTR _GuildPacket$[ebp], 80 ; 00000050H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN2@SendGuildA
$LN5@SendGuildA:

; 3058 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 3064 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@SendGuildA:

; 3059 : 	if (!Send(sizeof(dwVID), &dwVID))

  00025	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN5@SendGuildA

; 3060 : 		return false;
; 3061 : 
; 3062 : 	Tracef(" SendGuildAddMemberPacket\n", dwVID);

  00036	ff 75 08	 push	 DWORD PTR _dwVID$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GHDBPEKM@?5SendGuildAddMemberPacket?6?$AA@
  0003e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00043	83 c4 08	 add	 esp, 8

; 3063 : 	return SendSequence();

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004d	5e		 pop	 esi

; 3064 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?SendGuildAddMemberPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendGuildAddMemberPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendQuestConfirmPacket@CPythonNetworkStream@@QAE_NEK@Z
_TEXT	SEGMENT
_kPacket$ = -8						; size = 6
_byAnswer$ = 8						; size = 1
_dwPID$ = 12						; size = 4
?SendQuestConfirmPacket@CPythonNetworkStream@@QAE_NEK@Z PROC ; CPythonNetworkStream::SendQuestConfirmPacket, COMDAT
; _this$ = ecx

; 2299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2300 : 	TPacketCGQuestConfirm kPacket;
; 2301 : 	kPacket.header = HEADER_CG_QUEST_CONFIRM;
; 2302 : 	kPacket.answer = byAnswer;

  00007	8a 5d 08	 mov	 bl, BYTE PTR _byAnswer$[ebp]

; 2303 : 	kPacket.requestPID = dwPID;
; 2304 : 
; 2305 : 	if (!Send(sizeof(kPacket), &kPacket))

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _kPacket$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR _dwPID$[ebp]
  00012	8b f1		 mov	 esi, ecx
  00014	50		 push	 eax
  00015	6a 06		 push	 6
  00017	c6 45 f8 1f	 mov	 BYTE PTR _kPacket$[ebp], 31 ; 0000001fH
  0001b	88 5d f9	 mov	 BYTE PTR _kPacket$[ebp+1], bl
  0001e	89 7d fa	 mov	 DWORD PTR _kPacket$[ebp+2], edi
  00021	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00026	84 c0		 test	 al, al
  00028	75 18		 jne	 SHORT $LN1@SendQuestC

; 2306 : 	{
; 2307 : 		Tracen("SendQuestConfirmPacket Error");

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IAHFIDIL@SendQuestConfirmPacket?5Error?$AA@
  0002f	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00034	83 c4 04	 add	 esp, 4

; 2308 : 		return false;

  00037	32 c0		 xor	 al, al
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 2313 : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN1@SendQuestC:

; 2309 : 	}
; 2310 : 
; 2311 : 	Tracenf(" SendQuestConfirmPacket : %d, %d", byAnswer, dwPID);

  00042	57		 push	 edi
  00043	0f b6 c3	 movzx	 eax, bl
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HKJKPPKG@?5SendQuestConfirmPacket?5?3?5?$CFd?0?5?$CFd@
  0004c	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2312 : 	return SendSequence();

  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 2313 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?SendQuestConfirmPacket@CPythonNetworkStream@@QAE_NEK@Z ENDP ; CPythonNetworkStream::SendQuestConfirmPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendQuestInputStringPacket@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_Packet$ = -72						; size = 66
__$ArrayPad$ = -4					; size = 4
_c_szString$ = 8					; size = 4
?SendQuestInputStringPacket@CPythonNetworkStream@@QAE_NPBD@Z PROC ; CPythonNetworkStream::SendQuestInputStringPacket, COMDAT
; _this$ = ecx

; 2284 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _c_szString$[ebp]
  00013	56		 push	 esi

; 2285 : 	TPacketCGQuestInputString Packet;
; 2286 : 	Packet.bHeader = HEADER_CG_QUEST_INPUT_STRING;
; 2287 : 	strncpy(Packet.szString, c_szString, QUEST_INPUT_STRING_MAX_NUM);

  00014	6a 40		 push	 64			; 00000040H
  00016	50		 push	 eax
  00017	8d 45 b9	 lea	 eax, DWORD PTR _Packet$[ebp+1]
  0001a	c6 45 b8 1e	 mov	 BYTE PTR _Packet$[ebp], 30 ; 0000001eH
  0001e	50		 push	 eax
  0001f	8b f1		 mov	 esi, ecx
  00021	e8 00 00 00 00	 call	 _strncpy
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2288 : 
; 2289 : 	if (!Send(sizeof(Packet), &Packet))

  00029	8d 45 b8	 lea	 eax, DWORD PTR _Packet$[ebp]
  0002c	8b ce		 mov	 ecx, esi
  0002e	50		 push	 eax
  0002f	6a 42		 push	 66			; 00000042H
  00031	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00036	84 c0		 test	 al, al
  00038	75 20		 jne	 SHORT $LN1@SendQuestI

; 2290 : 	{
; 2291 : 		Tracen("SendQuestInputStringPacket Error");

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KDIADHIP@SendQuestInputStringPacket?5Error@
  0003f	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00044	83 c4 04	 add	 esp, 4

; 2292 : 		return false;

  00047	32 c0		 xor	 al, al
  00049	5e		 pop	 esi

; 2296 : }

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004d	33 cd		 xor	 ecx, ebp
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
$LN1@SendQuestI:

; 2293 : 	}
; 2294 : 
; 2295 : 	return SendSequence();

  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 2296 : }

  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	33 cd		 xor	 ecx, ebp
  00066	5e		 pop	 esi
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
?SendQuestInputStringPacket@CPythonNetworkStream@@QAE_NPBD@Z ENDP ; CPythonNetworkStream::SendQuestInputStringPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendAnswerMakeGuildPacket@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_Packet$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_c_szName$ = 8						; size = 4
?SendAnswerMakeGuildPacket@CPythonNetworkStream@@QAE_NPBD@Z PROC ; CPythonNetworkStream::SendAnswerMakeGuildPacket, COMDAT
; _this$ = ecx

; 2266 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _c_szName$[ebp]
  00013	56		 push	 esi

; 2267 : 	TPacketCGAnswerMakeGuild Packet;
; 2268 : 
; 2269 : 	Packet.header = HEADER_CG_ANSWER_MAKE_GUILD;
; 2270 : 	strncpy(Packet.guild_name, c_szName, GUILD_NAME_MAX_LEN);

  00014	6a 0c		 push	 12			; 0000000cH
  00016	50		 push	 eax
  00017	8d 45 ed	 lea	 eax, DWORD PTR _Packet$[ebp+1]
  0001a	c6 45 ec 51	 mov	 BYTE PTR _Packet$[ebp], 81 ; 00000051H
  0001e	50		 push	 eax
  0001f	8b f1		 mov	 esi, ecx
  00021	e8 00 00 00 00	 call	 _strncpy
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2271 : 	Packet.guild_name[GUILD_NAME_MAX_LEN] = '\0';

  00029	c6 45 f9 00	 mov	 BYTE PTR _Packet$[ebp+13], 0

; 2272 : 
; 2273 : 	if (!Send(sizeof(Packet), &Packet))

  0002d	8d 45 ec	 lea	 eax, DWORD PTR _Packet$[ebp]
  00030	8b ce		 mov	 ecx, esi
  00032	50		 push	 eax
  00033	6a 0e		 push	 14			; 0000000eH
  00035	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0003a	84 c0		 test	 al, al
  0003c	75 20		 jne	 SHORT $LN1@SendAnswer

; 2274 : 	{
; 2275 : 		Tracen("SendAnswerMakeGuild Packet Error");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FGDJCCCM@SendAnswerMakeGuild?5Packet?5Error@
  00043	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00048	83 c4 04	 add	 esp, 4

; 2276 : 		return false;

  0004b	32 c0		 xor	 al, al
  0004d	5e		 pop	 esi

; 2281 : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN1@SendAnswer:

; 2277 : 	}
; 2278 : 
; 2279 : // 	Tracef(" SendAnswerMakeGuildPacket : %s", c_szName);
; 2280 : 	return SendSequence();

  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 2281 : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	5e		 pop	 esi
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?SendAnswerMakeGuildPacket@CPythonNetworkStream@@QAE_NPBD@Z ENDP ; CPythonNetworkStream::SendAnswerMakeGuildPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendPartyParameterPacket@CPythonNetworkStream@@QAE_NE@Z
_TEXT	SEGMENT
_kPartyParameter$ = -4					; size = 2
_byDistributeMode$ = 8					; size = 1
?SendPartyParameterPacket@CPythonNetworkStream@@QAE_NE@Z PROC ; CPythonNetworkStream::SendPartyParameterPacket, COMDAT
; _this$ = ecx

; 2906 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2907 : 	TPacketCGPartyParameter kPartyParameter;
; 2908 : 	kPartyParameter.bHeader = HEADER_CG_PARTY_PARAMETER;
; 2909 : 	kPartyParameter.bDistributeMode = byDistributeMode;

  00005	8a 5d 08	 mov	 bl, BYTE PTR _byDistributeMode$[ebp]

; 2910 : 
; 2911 : 	if (!Send(sizeof(kPartyParameter), &kPartyParameter))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _kPartyParameter$[ebp]
  0000b	56		 push	 esi
  0000c	50		 push	 eax
  0000d	6a 02		 push	 2
  0000f	8b f1		 mov	 esi, ecx
  00011	c6 45 fc 4e	 mov	 BYTE PTR _kPartyParameter$[ebp], 78 ; 0000004eH
  00015	88 5d fd	 mov	 BYTE PTR _kPartyParameter$[ebp+1], bl
  00018	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001d	84 c0		 test	 al, al

; 2912 : 	{
; 2913 : 		Tracenf("CPythonNetworkStream::SendPartyParameterPacket(%d) - PACKET SEND ERROR", byDistributeMode);

  0001f	0f b6 c3	 movzx	 eax, bl
  00022	50		 push	 eax
  00023	75 17		 jne	 SHORT $LN1@SendPartyP
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@IOBBPNMN@CPythonNetworkStream?3?3SendPartyP@
  0002a	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0002f	83 c4 08	 add	 esp, 8

; 2914 : 		return false;

  00032	32 c0		 xor	 al, al
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 2919 : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN1@SendPartyP:

; 2915 : 	}
; 2916 : 
; 2917 : 	Tracef(" << SendPartyParameterPacket : %d\n", byDistributeMode);

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LLPEDDBL@?5?$DM?$DM?5SendPartyParameterPacket?5?3?5?$CF@
  00041	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00046	83 c4 08	 add	 esp, 8

; 2918 : 	return SendSequence();

  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 2919 : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?SendPartyParameterPacket@CPythonNetworkStream@@QAE_NE@Z ENDP ; CPythonNetworkStream::SendPartyParameterPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendPartyUseSkillPacket@CPythonNetworkStream@@QAE_NEK@Z
_TEXT	SEGMENT
_kPartyUseSkill$ = -8					; size = 6
_bySkillIndex$ = 8					; size = 1
_dwVID$ = 12						; size = 4
?SendPartyUseSkillPacket@CPythonNetworkStream@@QAE_NEK@Z PROC ; CPythonNetworkStream::SendPartyUseSkillPacket, COMDAT
; _this$ = ecx

; 2889 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2890 : 	TPacketCGPartyUseSkill kPartyUseSkill;
; 2891 : 	kPartyUseSkill.byHeader = HEADER_CG_PARTY_USE_SKILL;
; 2892 : 	kPartyUseSkill.bySkillIndex = bySkillIndex;

  00007	8a 5d 08	 mov	 bl, BYTE PTR _bySkillIndex$[ebp]

; 2893 : 	kPartyUseSkill.dwTargetVID = dwVID;
; 2894 : 
; 2895 : 	if (!Send(sizeof(kPartyUseSkill), &kPartyUseSkill))

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _kPartyUseSkill$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR _dwVID$[ebp]
  00011	57		 push	 edi
  00012	50		 push	 eax
  00013	6a 06		 push	 6
  00015	8b f9		 mov	 edi, ecx
  00017	c6 45 f8 4c	 mov	 BYTE PTR _kPartyUseSkill$[ebp], 76 ; 0000004cH
  0001b	88 5d f9	 mov	 BYTE PTR _kPartyUseSkill$[ebp+1], bl
  0001e	89 75 fa	 mov	 DWORD PTR _kPartyUseSkill$[ebp+2], esi
  00021	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00026	84 c0		 test	 al, al

; 2896 : 	{
; 2897 : 		Tracenf("CPythonNetworkStream::SendPartyUseSkillPacket(%ud, %ud) - PACKET SEND ERROR", bySkillIndex, dwVID);

  00028	0f b6 c3	 movzx	 eax, bl
  0002b	56		 push	 esi
  0002c	50		 push	 eax
  0002d	75 18		 jne	 SHORT $LN1@SendPartyU
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@BMAFGIHC@CPythonNetworkStream?3?3SendPartyU@
  00034	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2898 : 		return false;

  0003c	32 c0		 xor	 al, al
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 2903 : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN1@SendPartyU:

; 2899 : 	}
; 2900 : 
; 2901 : 	Tracef(" << SendPartyUseSkillPacket : %d, %d\n", bySkillIndex, dwVID);

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GLODGHKD@?5?$DM?$DM?5SendPartyUseSkillPacket?5?3?5?$CFd@
  0004c	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2902 : 	return SendSequence();

  00054	8b cf		 mov	 ecx, edi
  00056	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 2903 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?SendPartyUseSkillPacket@CPythonNetworkStream@@QAE_NEK@Z ENDP ; CPythonNetworkStream::SendPartyUseSkillPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendPartySetStatePacket@CPythonNetworkStream@@QAE_NKEE@Z
_TEXT	SEGMENT
_kPartySetState$ = -8					; size = 7
_dwVID$ = 8						; size = 4
_byState$ = 12						; size = 1
_byFlag$ = 16						; size = 1
?SendPartySetStatePacket@CPythonNetworkStream@@QAE_NKEE@Z PROC ; CPythonNetworkStream::SendPartySetStatePacket, COMDAT
; _this$ = ecx

; 2871 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2872 : 	TPacketCGPartySetState kPartySetState;
; 2873 : 	kPartySetState.byHeader = HEADER_CG_PARTY_SET_STATE;
; 2874 : 	kPartySetState.dwVID = dwVID;
; 2875 : 	kPartySetState.byState = byState;

  00007	8a 5d 0c	 mov	 bl, BYTE PTR _byState$[ebp]

; 2876 : 	kPartySetState.byFlag = byFlag;
; 2877 : 
; 2878 : 	if (!Send(sizeof(kPartySetState), &kPartySetState))

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _kPartySetState$[ebp]
  0000d	8a 7d 10	 mov	 bh, BYTE PTR _byFlag$[ebp]
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _dwVID$[ebp]
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	6a 07		 push	 7
  00018	8b f9		 mov	 edi, ecx
  0001a	c6 45 f8 4b	 mov	 BYTE PTR _kPartySetState$[ebp], 75 ; 0000004bH
  0001e	89 75 f9	 mov	 DWORD PTR _kPartySetState$[ebp+1], esi
  00021	88 5d fd	 mov	 BYTE PTR _kPartySetState$[ebp+5], bl
  00024	88 7d fe	 mov	 BYTE PTR _kPartySetState$[ebp+6], bh
  00027	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0002c	84 c0		 test	 al, al
  0002e	75 1d		 jne	 SHORT $LN1@SendPartyS

; 2879 : 	{
; 2880 : 		Tracenf("CPythonNetworkStream::SendPartySetStatePacket(%ud, %ud) - PACKET SEND ERROR", dwVID, byState);

  00030	0f b6 c3	 movzx	 eax, bl
  00033	50		 push	 eax
  00034	56		 push	 esi
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@FFPCCHJM@CPythonNetworkStream?3?3SendPartyS@
  0003a	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2881 : 		return false;

  00042	32 c0		 xor	 al, al
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx

; 2886 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SendPartyS:

; 2882 : 	}
; 2883 : 
; 2884 : 	Tracef(" << SendPartySetStatePacket : %d, %d, %d\n", dwVID, byState, byFlag);

  0004d	0f b6 c7	 movzx	 eax, bh
  00050	50		 push	 eax
  00051	0f b6 c3	 movzx	 eax, bl
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PHAHCCJC@?5?$DM?$DM?5SendPartySetStatePacket?5?3?5?$CFd@
  0005b	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00060	83 c4 10	 add	 esp, 16			; 00000010H

; 2885 : 	return SendSequence();

  00063	8b cf		 mov	 ecx, edi
  00065	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx

; 2886 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 0c 00	 ret	 12			; 0000000cH
?SendPartySetStatePacket@CPythonNetworkStream@@QAE_NKEE@Z ENDP ; CPythonNetworkStream::SendPartySetStatePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendPartyRemovePacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_kPartyInviteRemove$ = -8				; size = 5
_dwPID$ = 8						; size = 4
?SendPartyRemovePacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendPartyRemovePacket, COMDAT
; _this$ = ecx

; 2855 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 2856 : 	TPacketCGPartyRemove kPartyInviteRemove;
; 2857 : 	kPartyInviteRemove.header = HEADER_CG_PARTY_REMOVE;
; 2858 : 	kPartyInviteRemove.pid = dwPID;

  00007	8b 75 08	 mov	 esi, DWORD PTR _dwPID$[ebp]

; 2859 : 
; 2860 : 	if (!Send(sizeof(kPartyInviteRemove), &kPartyInviteRemove))

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _kPartyInviteRemove$[ebp]
  0000d	57		 push	 edi
  0000e	50		 push	 eax
  0000f	6a 05		 push	 5
  00011	8b f9		 mov	 edi, ecx
  00013	c6 45 f8 4a	 mov	 BYTE PTR _kPartyInviteRemove$[ebp], 74 ; 0000004aH
  00017	89 75 f9	 mov	 DWORD PTR _kPartyInviteRemove$[ebp+1], esi
  0001a	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send

; 2861 : 	{
; 2862 : 		Tracenf("CPythonNetworkStream::SendPartyRemovePacket [%ud] - PACKET SEND ERROR", dwPID);

  0001f	56		 push	 esi
  00020	84 c0		 test	 al, al
  00022	75 17		 jne	 SHORT $LN1@SendPartyR
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@BBBGKACF@CPythonNetworkStream?3?3SendPartyR@
  00029	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0002e	83 c4 08	 add	 esp, 8

; 2863 : 		return false;

  00031	32 c0		 xor	 al, al
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 2868 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN1@SendPartyR:

; 2864 : 	}
; 2865 : 
; 2866 : 	Tracef(" << SendPartyRemovePacket : %d\n", dwPID);

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HANJMBEA@?5?$DM?$DM?5SendPartyRemovePacket?5?3?5?$CFd?6?$AA@
  00040	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00045	83 c4 08	 add	 esp, 8

; 2867 : 	return SendSequence();

  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 2868 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?SendPartyRemovePacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendPartyRemovePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendPartyInviteAnswerPacket@CPythonNetworkStream@@QAE_NKE@Z
_TEXT	SEGMENT
_kPartyInviteAnswerPacket$ = -8				; size = 6
_dwLeaderVID$ = 8					; size = 4
_byAnswer$ = 12						; size = 1
?SendPartyInviteAnswerPacket@CPythonNetworkStream@@QAE_NKE@Z PROC ; CPythonNetworkStream::SendPartyInviteAnswerPacket, COMDAT
; _this$ = ecx

; 2838 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2839 : 	TPacketCGPartyInviteAnswer kPartyInviteAnswerPacket;
; 2840 : 	kPartyInviteAnswerPacket.header = HEADER_CG_PARTY_INVITE_ANSWER;
; 2841 : 	kPartyInviteAnswerPacket.leader_pid = dwLeaderVID;
; 2842 : 	kPartyInviteAnswerPacket.accept = byAnswer;

  00007	8a 5d 0c	 mov	 bl, BYTE PTR _byAnswer$[ebp]

; 2843 : 
; 2844 : 	if (!Send(sizeof(kPartyInviteAnswerPacket), &kPartyInviteAnswerPacket))

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _kPartyInviteAnswerPacket$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _dwLeaderVID$[ebp]
  00011	57		 push	 edi
  00012	50		 push	 eax
  00013	6a 06		 push	 6
  00015	8b f9		 mov	 edi, ecx
  00017	c6 45 f8 49	 mov	 BYTE PTR _kPartyInviteAnswerPacket$[ebp], 73 ; 00000049H
  0001b	89 75 f9	 mov	 DWORD PTR _kPartyInviteAnswerPacket$[ebp+1], esi
  0001e	88 5d fd	 mov	 BYTE PTR _kPartyInviteAnswerPacket$[ebp+5], bl
  00021	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00026	84 c0		 test	 al, al

; 2845 : 	{
; 2846 : 		Tracenf("CPythonNetworkStream::SendPartyInviteAnswerPacket [%ud %ud] - PACKET SEND ERROR", dwLeaderVID, byAnswer);

  00028	0f b6 c3	 movzx	 eax, bl
  0002b	50		 push	 eax
  0002c	56		 push	 esi
  0002d	75 18		 jne	 SHORT $LN1@SendPartyI
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@IIILKEFH@CPythonNetworkStream?3?3SendPartyI@
  00034	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2847 : 		return false;

  0003c	32 c0		 xor	 al, al
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 2852 : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN1@SendPartyI:

; 2848 : 	}
; 2849 : 
; 2850 : 	Tracef(" << SendPartyInviteAnswerPacket : %d, %d\n", dwLeaderVID, byAnswer);

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GHKGLGPO@?5?$DM?$DM?5SendPartyInviteAnswerPacket?5@
  0004c	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2851 : 	return SendSequence();

  00054	8b cf		 mov	 ecx, edi
  00056	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 2852 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?SendPartyInviteAnswerPacket@CPythonNetworkStream@@QAE_NKE@Z ENDP ; CPythonNetworkStream::SendPartyInviteAnswerPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendPartyInvitePacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_kPartyInvitePacket$ = -8				; size = 5
_dwVID$ = 8						; size = 4
?SendPartyInvitePacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendPartyInvitePacket, COMDAT
; _this$ = ecx

; 2822 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 2823 : 	TPacketCGPartyInvite kPartyInvitePacket;
; 2824 : 	kPartyInvitePacket.header = HEADER_CG_PARTY_INVITE;
; 2825 : 	kPartyInvitePacket.vid = dwVID;

  00007	8b 75 08	 mov	 esi, DWORD PTR _dwVID$[ebp]

; 2826 : 
; 2827 : 	if (!Send(sizeof(kPartyInvitePacket), &kPartyInvitePacket))

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _kPartyInvitePacket$[ebp]
  0000d	57		 push	 edi
  0000e	50		 push	 eax
  0000f	6a 05		 push	 5
  00011	8b f9		 mov	 edi, ecx
  00013	c6 45 f8 48	 mov	 BYTE PTR _kPartyInvitePacket$[ebp], 72 ; 00000048H
  00017	89 75 f9	 mov	 DWORD PTR _kPartyInvitePacket$[ebp+1], esi
  0001a	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send

; 2828 : 	{
; 2829 : 		Tracenf("CPythonNetworkStream::SendPartyInvitePacket [%ud] - PACKET SEND ERROR", dwVID);

  0001f	56		 push	 esi
  00020	84 c0		 test	 al, al
  00022	75 17		 jne	 SHORT $LN1@SendPartyI
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@HLBPKODM@CPythonNetworkStream?3?3SendPartyI@
  00029	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0002e	83 c4 08	 add	 esp, 8

; 2830 : 		return false;

  00031	32 c0		 xor	 al, al
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 2835 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN1@SendPartyI:

; 2831 : 	}
; 2832 : 
; 2833 : 	Tracef(" << SendPartyInvitePacket : %d\n", dwVID);

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@GNHHEHBK@?5?$DM?$DM?5SendPartyInvitePacket?5?3?5?$CFd?6?$AA@
  00040	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00045	83 c4 08	 add	 esp, 8

; 2834 : 	return SendSequence();

  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 2835 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?SendPartyInvitePacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendPartyInvitePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendMessengerRemovePacket@CPythonNetworkStream@@QAE_NPBD0@Z
_TEXT	SEGMENT
_packet$ = -32						; size = 2
_szKey$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_c_szKey$ = 8						; size = 4
_c_szName$ = 12						; size = 4
?SendMessengerRemovePacket@CPythonNetworkStream@@QAE_NPBD0@Z PROC ; CPythonNetworkStream::SendMessengerRemovePacket, COMDAT
; _this$ = ecx

; 1097 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _c_szKey$[ebp]

; 1098 : 	TPacketCGMessenger packet;
; 1099 : 	packet.header = HEADER_CG_MESSENGER;
; 1100 : 	packet.subheader = MESSENGER_SUBHEADER_CG_REMOVE;
; 1101 : 	if (!Send(sizeof(packet), &packet))

  00014	8d 45 e0	 lea	 eax, DWORD PTR _packet$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _c_szName$[ebp]
  0001c	8b f1		 mov	 esi, ecx
  0001e	50		 push	 eax
  0001f	6a 02		 push	 2
  00021	66 c7 45 e0 43
	02		 mov	 WORD PTR _packet$[ebp], 579 ; 00000243H
  00027	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0002c	84 c0		 test	 al, al
  0002e	75 15		 jne	 SHORT $LN2@SendMessen
$LN5@SendMessen:
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 1102 : 		return false;

  00032	32 c0		 xor	 al, al
  00034	5b		 pop	 ebx

; 1109 : }

  00035	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00038	33 cd		 xor	 ecx, ebp
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
$LN2@SendMessen:

; 1103 : 	char szKey[CHARACTER_NAME_MAX_LEN];
; 1104 : 	strncpy(szKey, c_szKey, CHARACTER_NAME_MAX_LEN-1);

  00045	6a 17		 push	 23			; 00000017H
  00047	8d 45 e4	 lea	 eax, DWORD PTR _szKey$[ebp]
  0004a	53		 push	 ebx
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _strncpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1105 : 	if (!Send(sizeof(szKey), &szKey))

  00054	8d 45 e4	 lea	 eax, DWORD PTR _szKey$[ebp]
  00057	8b ce		 mov	 ecx, esi
  00059	50		 push	 eax
  0005a	6a 18		 push	 24			; 00000018H
  0005c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00061	84 c0		 test	 al, al
  00063	74 cb		 je	 SHORT $LN5@SendMessen

; 1106 : 		return false;
; 1107 : 	__RefreshTargetBoardByName(c_szName);

  00065	57		 push	 edi
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?__RefreshTargetBoardByName@CPythonNetworkStream@@IAEXPBD@Z ; CPythonNetworkStream::__RefreshTargetBoardByName

; 1108 : 	return SendSequence();

  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 1109 : }

  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	33 cd		 xor	 ecx, ebp
  0007b	5b		 pop	 ebx
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
?SendMessengerRemovePacket@CPythonNetworkStream@@QAE_NPBD0@Z ENDP ; CPythonNetworkStream::SendMessengerRemovePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendMessengerAddByNamePacket@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_packet$ = -32						; size = 2
_szName$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_c_szName$ = 8						; size = 4
?SendMessengerAddByNamePacket@CPythonNetworkStream@@QAE_NPBD@Z PROC ; CPythonNetworkStream::SendMessengerAddByNamePacket, COMDAT
; _this$ = ecx

; 1080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _c_szName$[ebp]

; 1081 : 	TPacketCGMessenger packet;
; 1082 : 	packet.header = HEADER_CG_MESSENGER;
; 1083 : 	packet.subheader = MESSENGER_SUBHEADER_CG_ADD_BY_NAME;
; 1084 : 	if (!Send(sizeof(packet), &packet))

  00015	8d 45 e0	 lea	 eax, DWORD PTR _packet$[ebp]
  00018	50		 push	 eax
  00019	6a 02		 push	 2
  0001b	8b f1		 mov	 esi, ecx
  0001d	66 c7 45 e0 43
	01		 mov	 WORD PTR _packet$[ebp], 323 ; 00000143H
  00023	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00028	84 c0		 test	 al, al
  0002a	75 14		 jne	 SHORT $LN2@SendMessen
$LN7@SendMessen:
  0002c	5f		 pop	 edi

; 1085 : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	5e		 pop	 esi

; 1094 : }

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00033	33 cd		 xor	 ecx, ebp
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN2@SendMessen:

; 1086 : 	char szName[CHARACTER_NAME_MAX_LEN];
; 1087 : 	strncpy(szName, c_szName, CHARACTER_NAME_MAX_LEN-1);

  00040	6a 17		 push	 23			; 00000017H
  00042	8d 45 e4	 lea	 eax, DWORD PTR _szName$[ebp]
  00045	57		 push	 edi
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _strncpy
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1088 : 	szName[CHARACTER_NAME_MAX_LEN-1] = '\0'; // #720:       

  0004f	c6 45 fb 00	 mov	 BYTE PTR _szName$[ebp+23], 0

; 1089 : 
; 1090 : 	if (!Send(sizeof(szName), &szName))

  00053	8d 45 e4	 lea	 eax, DWORD PTR _szName$[ebp]
  00056	8b ce		 mov	 ecx, esi
  00058	50		 push	 eax
  00059	6a 18		 push	 24			; 00000018H
  0005b	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00060	84 c0		 test	 al, al
  00062	74 c8		 je	 SHORT $LN7@SendMessen

; 1091 : 		return false;
; 1092 : 	Tracef(" SendMessengerAddByNamePacket : %s\n", c_szName);

  00064	57		 push	 edi
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@DHDBME@?5SendMessengerAddByNamePacket?5?3?5@
  0006a	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0006f	83 c4 08	 add	 esp, 8

; 1093 : 	return SendSequence();

  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 1094 : }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	5f		 pop	 edi
  0007d	33 cd		 xor	 ecx, ebp
  0007f	5e		 pop	 esi
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?SendMessengerAddByNamePacket@CPythonNetworkStream@@QAE_NPBD@Z ENDP ; CPythonNetworkStream::SendMessengerAddByNamePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendMessengerAddByVIDPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_packet$ = -4						; size = 2
_vid$ = 8						; size = 4
?SendMessengerAddByVIDPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendMessengerAddByVIDPacket, COMDAT
; _this$ = ecx

; 1068 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1069 : 	TPacketCGMessenger packet;
; 1070 : 	packet.header = HEADER_CG_MESSENGER;
; 1071 : 	packet.subheader = MESSENGER_SUBHEADER_CG_ADD_BY_VID;
; 1072 : 	if (!Send(sizeof(packet), &packet))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _packet$[ebp]
  00008	66 c7 45 fc 43
	00		 mov	 WORD PTR _packet$[ebp], 67 ; 00000043H
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN2@SendMessen
$LN5@SendMessen:

; 1073 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	5e		 pop	 esi

; 1077 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@SendMessen:

; 1074 : 	if (!Send(sizeof(vid), &vid))

  00025	8d 45 08	 lea	 eax, DWORD PTR _vid$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	6a 04		 push	 4
  0002d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00032	84 c0		 test	 al, al
  00034	74 e6		 je	 SHORT $LN5@SendMessen

; 1075 : 		return false;
; 1076 : 	return SendSequence();

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0003d	5e		 pop	 esi

; 1077 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?SendMessengerAddByVIDPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendMessengerAddByVIDPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z
_TEXT	SEGMENT
$T2 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_pcEmoticonString$ = 8					; size = 4
?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z PROC ; CPythonNetworkStream::RegisterEmoticonString, COMDAT
; _this$ = ecx

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 24	 sub	 esp, 36			; 00000024H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 1c	 mov	 DWORD PTR __$ArrayPad$[esp+48], eax
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00029	33 c4		 xor	 eax, esp
  0002b	50		 push	 eax
  0002c	8d 44 24 30	 lea	 eax, DWORD PTR __$EHRec$[esp+60]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	8b 75 08	 mov	 esi, DWORD PTR _pcEmoticonString$[ebp]

; 1210 : 	if (m_EmoticonStringVector.size() >= CInstanceBase::EMOTICON_NUM)

  00039	8d b9 20 03 00
	00		 lea	 edi, DWORD PTR [ecx+800]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0003f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00042	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00047	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00049	f7 e9		 imul	 ecx
  0004b	c1 fa 02	 sar	 edx, 2
  0004e	8b ca		 mov	 ecx, edx
  00050	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00053	03 ca		 add	 ecx, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1210 : 	if (m_EmoticonStringVector.size() >= CInstanceBase::EMOTICON_NUM)

  00055	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0005b	72 26		 jb	 SHORT $LN1@RegisterEm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0005d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00060	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00065	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00067	f7 e9		 imul	 ecx
  00069	c1 fa 02	 sar	 edx, 2
  0006c	8b c2		 mov	 eax, edx
  0006e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00071	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1212 : 		TraceError("Can't register emoticon string... vector is full (size:%d)", m_EmoticonStringVector.size() );

  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GMAAOOOI@Can?8t?5register?5emoticon?5string?4?4@
  00079	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0007e	83 c4 08	 add	 esp, 8

; 1213 : 		return;

  00081	eb 5e		 jmp	 SHORT $LN73@RegisterEm
$LN1@RegisterEm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00083	80 3e 00	 cmp	 BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00086	c7 44 24 24 0f
	00 00 00	 mov	 DWORD PTR $T2[esp+80], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0008e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T2[esp+76], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00096	c6 44 24 10 00	 mov	 BYTE PTR $T2[esp+60], 0

; 523  : 			: _CSTD strlen(_First));

  0009b	75 04		 jne	 SHORT $LN51@RegisterEm
  0009d	33 c0		 xor	 eax, eax
  0009f	eb 0e		 jmp	 SHORT $LN52@RegisterEm
$LN51@RegisterEm:
  000a1	8b c6		 mov	 eax, esi
  000a3	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL85@RegisterEm:
  000a6	8a 08		 mov	 cl, BYTE PTR [eax]
  000a8	40		 inc	 eax
  000a9	84 c9		 test	 cl, cl
  000ab	75 f9		 jne	 SHORT $LL85@RegisterEm
  000ad	2b c2		 sub	 eax, edx
$LN52@RegisterEm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  000af	50		 push	 eax
  000b0	56		 push	 esi
  000b1	8d 4c 24 18	 lea	 ecx, DWORD PTR $T2[esp+68]
  000b5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1215 : 	m_EmoticonStringVector.push_back(pcEmoticonString);

  000ba	8d 44 24 10	 lea	 eax, DWORD PTR $T2[esp+60]
  000be	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+68], 0
  000c6	50		 push	 eax
  000c7	8b cf		 mov	 ecx, edi
  000c9	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000ce	83 7c 24 24 10	 cmp	 DWORD PTR $T2[esp+80], 16 ; 00000010H
  000d3	72 0c		 jb	 SHORT $LN73@RegisterEm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000d5	ff 74 24 10	 push	 DWORD PTR $T2[esp+60]
  000d9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000de	83 c4 04	 add	 esp, 4
$LN73@RegisterEm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1216 : }

  000e1	8b 4c 24 30	 mov	 ecx, DWORD PTR __$EHRec$[esp+60]
  000e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ec	59		 pop	 ecx
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+48]
  000f3	33 cc		 xor	 ecx, esp
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 d4	 lea	 eax, DWORD PTR [edx-44]
  0000f	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 08	 add	 eax, 8
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterEmoticonString@CPythonNetworkStream@@QAEXPBD@Z ENDP ; CPythonNetworkStream::RegisterEmoticonString
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?ToggleGameDebugInfo@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?ToggleGameDebugInfo@CPythonNetworkStream@@QAEXXZ PROC	; CPythonNetworkStream::ToggleGameDebugInfo, COMDAT
; _this$ = ecx

; 2050 : {

  00000	56		 push	 esi

; 2051 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ToggleDebugInfo", Py_BuildValue("()"));

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BHDOCKEA@ToggleDebugInfo?$AA@
  00014	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0001a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	5e		 pop	 esi

; 2052 : }

  00023	c3		 ret	 0
?ToggleGameDebugInfo@CPythonNetworkStream@@QAEXXZ ENDP	; CPythonNetworkStream::ToggleGameDebugInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendExchangeExitPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_packet$ = -12						; size = 10
?SendExchangeExitPacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::SendExchangeExitPacket, COMDAT
; _this$ = ecx

; 2159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2160 : 	if (!__CanActMainInstance())

  00009	e8 00 00 00 00	 call	 ?__CanActMainInstance@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__CanActMainInstance
  0000e	84 c0		 test	 al, al
  00010	75 07		 jne	 SHORT $LN2@SendExchan

; 2161 : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi

; 2175 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN2@SendExchan:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  00019	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001e	c6 45 fb 01	 mov	 BYTE PTR _packet$[ebp+7], 1
  00022	66 89 45 fc	 mov	 WORD PTR _packet$[ebp+8], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2168 : 	if (!Send(sizeof(packet), &packet))

  00026	8b ce		 mov	 ecx, esi
  00028	8d 45 f4	 lea	 eax, DWORD PTR _packet$[ebp]
  0002b	66 c7 45 f4 1b
	05		 mov	 WORD PTR _packet$[ebp], 1307 ; 0000051bH
  00031	50		 push	 eax
  00032	6a 0a		 push	 10			; 0000000aH
  00034	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00039	84 c0		 test	 al, al
  0003b	75 14		 jne	 SHORT $LN1@SendExchan

; 2169 : 	{
; 2170 : 		Tracef("send_trade_exit_packet Error\n");

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FJKDIHPJ@send_trade_exit_packet?5Error?6?$AA@
  00042	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00047	83 c4 04	 add	 esp, 4

; 2171 : 		return false;

  0004a	32 c0		 xor	 al, al
  0004c	5e		 pop	 esi

; 2175 : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN1@SendExchan:

; 2172 : 	}
; 2173 : 
; 2174 : 	return SendSequence();

  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00058	5e		 pop	 esi

; 2175 : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?SendExchangeExitPacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::SendExchangeExitPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendExchangeAcceptPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_packet$ = -12						; size = 10
?SendExchangeAcceptPacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::SendExchangeAcceptPacket, COMDAT
; _this$ = ecx

; 2140 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2141 : 	if (!__CanActMainInstance())

  00009	e8 00 00 00 00	 call	 ?__CanActMainInstance@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__CanActMainInstance
  0000e	84 c0		 test	 al, al
  00010	75 07		 jne	 SHORT $LN2@SendExchan

; 2142 : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi

; 2156 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN2@SendExchan:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  00019	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001e	c6 45 fb 01	 mov	 BYTE PTR _packet$[ebp+7], 1
  00022	66 89 45 fc	 mov	 WORD PTR _packet$[ebp+8], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2149 : 	if (!Send(sizeof(packet), &packet))

  00026	8b ce		 mov	 ecx, esi
  00028	8d 45 f4	 lea	 eax, DWORD PTR _packet$[ebp]
  0002b	66 c7 45 f4 1b
	04		 mov	 WORD PTR _packet$[ebp], 1051 ; 0000041bH
  00031	50		 push	 eax
  00032	6a 0a		 push	 10			; 0000000aH
  00034	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00039	84 c0		 test	 al, al
  0003b	75 14		 jne	 SHORT $LN1@SendExchan

; 2150 : 	{
; 2151 : 		Tracef("send_trade_accept_packet Error\n");

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@EEPLBN@send_trade_accept_packet?5Error?6?$AA@
  00042	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00047	83 c4 04	 add	 esp, 4

; 2152 : 		return false;

  0004a	32 c0		 xor	 al, al
  0004c	5e		 pop	 esi

; 2156 : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN1@SendExchan:

; 2153 : 	}
; 2154 : 
; 2155 : 	return SendSequence();

  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00058	5e		 pop	 esi

; 2156 : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?SendExchangeAcceptPacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::SendExchangeAcceptPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendExchangeItemDelPacket@CPythonNetworkStream@@QAE_NE@Z
_TEXT	SEGMENT
_pos$dead$ = 8						; size = 1
?SendExchangeItemDelPacket@CPythonNetworkStream@@QAE_NE@Z PROC ; CPythonNetworkStream::SendExchangeItemDelPacket, COMDAT
; _this$dead$ = ecx

; 2118 : 	assert(!"Can't be called function - CPythonNetworkStream::SendExchangeItemDelPacket");
; 2119 : 	return true;

  00000	b0 01		 mov	 al, 1

; 2120 : 
; 2121 : 	if (!__CanActMainInstance())
; 2122 : 		return true;
; 2123 : 
; 2124 : 	TPacketCGExchange	packet;
; 2125 : 
; 2126 : 	packet.header		= HEADER_CG_EXCHANGE;
; 2127 : 	packet.subheader	= EXCHANGE_SUBHEADER_CG_ITEM_DEL;
; 2128 : 	packet.arg1			= pos;
; 2129 : 
; 2130 : 	if (!Send(sizeof(packet), &packet))
; 2131 : 	{
; 2132 : 		Tracef("send_trade_item_del_packet Error\n");
; 2133 : 		return false;
; 2134 : 	}
; 2135 : 
; 2136 : 	return SendSequence();
; 2137 : }

  00002	c2 04 00	 ret	 4
?SendExchangeItemDelPacket@CPythonNetworkStream@@QAE_NE@Z ENDP ; CPythonNetworkStream::SendExchangeItemDelPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendExchangeItemAddPacket@CPythonNetworkStream@@QAE_NUSItemPos@@E@Z
_TEXT	SEGMENT
_packet$ = -12						; size = 10
_ItemPos$ = 8						; size = 3
_byDisplayPos$ = 12					; size = 1
?SendExchangeItemAddPacket@CPythonNetworkStream@@QAE_NUSItemPos@@E@Z PROC ; CPythonNetworkStream::SendExchangeItemAddPacket, COMDAT
; _this$ = ecx

; 2096 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2097 : 	if (!__CanActMainInstance())

  00009	e8 00 00 00 00	 call	 ?__CanActMainInstance@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__CanActMainInstance
  0000e	84 c0		 test	 al, al
  00010	75 09		 jne	 SHORT $LN2@SendExchan

; 2098 : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi

; 2114 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
$LN2@SendExchan:

; 2099 : 
; 2100 : 	TPacketCGExchange	packet;
; 2101 : 
; 2102 : 	packet.header		= HEADER_CG_EXCHANGE;
; 2103 : 	packet.subheader	= EXCHANGE_SUBHEADER_CG_ITEM_ADD;
; 2104 : 	packet.Pos			= ItemPos;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _ItemPos$[ebp]

; 2105 : 	packet.arg2			= byDisplayPos;
; 2106 : 
; 2107 : 	if (!Send(sizeof(packet), &packet))

  0001e	8b ce		 mov	 ecx, esi
  00020	66 89 45 fb	 mov	 WORD PTR _packet$[ebp+7], ax
  00024	8b 45 0a	 mov	 eax, DWORD PTR _ItemPos$[ebp+2]
  00027	88 45 fd	 mov	 BYTE PTR _packet$[ebp+9], al
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _byDisplayPos$[ebp]
  0002d	88 45 fa	 mov	 BYTE PTR _packet$[ebp+6], al
  00030	8d 45 f4	 lea	 eax, DWORD PTR _packet$[ebp]
  00033	50		 push	 eax
  00034	6a 0a		 push	 10			; 0000000aH
  00036	66 c7 45 f4 1b
	01		 mov	 WORD PTR _packet$[ebp], 283 ; 0000011bH
  0003c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00041	84 c0		 test	 al, al
  00043	75 16		 jne	 SHORT $LN1@SendExchan

; 2108 : 	{
; 2109 : 		Tracef("send_trade_item_add_packet Error\n");

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@JFABNFDE@send_trade_item_add_packet?5Error@
  0004a	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0004f	83 c4 04	 add	 esp, 4

; 2110 : 		return false;

  00052	32 c0		 xor	 al, al
  00054	5e		 pop	 esi

; 2114 : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
$LN1@SendExchan:

; 2111 : 	}
; 2112 : 
; 2113 : 	return SendSequence();

  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00062	5e		 pop	 esi

; 2114 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
?SendExchangeItemAddPacket@CPythonNetworkStream@@QAE_NUSItemPos@@E@Z ENDP ; CPythonNetworkStream::SendExchangeItemAddPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendExchangeElkAddPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_packet$ = -12						; size = 10
_elk$ = 8						; size = 4
?SendExchangeElkAddPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendExchangeElkAddPacket, COMDAT
; _this$ = ecx

; 2076 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2077 : 	if (!__CanActMainInstance())

  00009	e8 00 00 00 00	 call	 ?__CanActMainInstance@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__CanActMainInstance
  0000e	84 c0		 test	 al, al
  00010	75 09		 jne	 SHORT $LN2@SendExchan

; 2078 : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi

; 2093 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN2@SendExchan:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0001b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00020	c6 45 fb 01	 mov	 BYTE PTR _packet$[ebp+7], 1
  00024	66 89 45 fc	 mov	 WORD PTR _packet$[ebp+8], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2086 : 	if (!Send(sizeof(packet), &packet))

  00028	8b ce		 mov	 ecx, esi
  0002a	8b 45 08	 mov	 eax, DWORD PTR _elk$[ebp]
  0002d	89 45 f6	 mov	 DWORD PTR _packet$[ebp+2], eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR _packet$[ebp]
  00033	50		 push	 eax
  00034	6a 0a		 push	 10			; 0000000aH
  00036	66 c7 45 f4 1b
	03		 mov	 WORD PTR _packet$[ebp], 795 ; 0000031bH
  0003c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00041	84 c0		 test	 al, al
  00043	75 16		 jne	 SHORT $LN1@SendExchan

; 2087 : 	{
; 2088 : 		Tracef("send_trade_elk_add_packet Error\n");

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EABMKDBI@send_trade_elk_add_packet?5Error?6@
  0004a	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0004f	83 c4 04	 add	 esp, 4

; 2089 : 		return false;

  00052	32 c0		 xor	 al, al
  00054	5e		 pop	 esi

; 2093 : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN1@SendExchan:

; 2090 : 	}
; 2091 : 
; 2092 : 	return SendSequence();

  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00062	5e		 pop	 esi

; 2093 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
?SendExchangeElkAddPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendExchangeElkAddPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendExchangeStartPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_packet$ = -12						; size = 10
_vid$ = 8						; size = 4
?SendExchangeStartPacket@CPythonNetworkStream@@QAE_NK@Z PROC ; CPythonNetworkStream::SendExchangeStartPacket, COMDAT
; _this$ = ecx

; 2055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2056 : 	if (!__CanActMainInstance())

  00009	e8 00 00 00 00	 call	 ?__CanActMainInstance@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__CanActMainInstance
  0000e	84 c0		 test	 al, al
  00010	75 09		 jne	 SHORT $LN2@SendExchan

; 2057 : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi

; 2073 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN2@SendExchan:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0001b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00020	c6 45 fb 01	 mov	 BYTE PTR _packet$[ebp+7], 1
  00024	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2063 : 	packet.arg1			= vid;

  00025	8b 7d 08	 mov	 edi, DWORD PTR _vid$[ebp]

; 2065 : 	if (!Send(sizeof(packet), &packet))

  00028	8b ce		 mov	 ecx, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0002a	66 89 45 fc	 mov	 WORD PTR _packet$[ebp+8], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2065 : 	if (!Send(sizeof(packet), &packet))

  0002e	8d 45 f4	 lea	 eax, DWORD PTR _packet$[ebp]
  00031	50		 push	 eax
  00032	6a 0a		 push	 10			; 0000000aH
  00034	66 c7 45 f4 1b
	00		 mov	 WORD PTR _packet$[ebp], 27 ; 0000001bH
  0003a	89 7d f6	 mov	 DWORD PTR _packet$[ebp+2], edi
  0003d	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00042	84 c0		 test	 al, al
  00044	75 17		 jne	 SHORT $LN1@SendExchan

; 2066 : 	{
; 2067 : 		Tracef("send_trade_start_packet Error\n");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CGFAIMHK@send_trade_start_packet?5Error?6?$AA@
  0004b	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00050	83 c4 04	 add	 esp, 4

; 2068 : 		return false;

  00053	32 c0		 xor	 al, al
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 2073 : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN1@SendExchan:

; 2069 : 	}
; 2070 : 
; 2071 : 	Tracef("send_trade_start_packet   vid %d \n", vid);

  0005d	57		 push	 edi
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FOAEKPNP@send_trade_start_packet?5?5?5vid?5?$CFd@
  00063	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00068	83 c4 08	 add	 esp, 8

; 2072 : 	return SendSequence();

  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 2073 : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
?SendExchangeStartPacket@CPythonNetworkStream@@QAE_NK@Z ENDP ; CPythonNetworkStream::SendExchangeStartPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendGiveItemPacket@CPythonNetworkStream@@QAE_NKUSItemPos@@H@Z
_TEXT	SEGMENT
_GiveItemPacket$ = -12					; size = 9
_dwTargetVID$ = 8					; size = 4
_ItemPos$ = 12						; size = 3
_iItemCount$ = 16					; size = 4
?SendGiveItemPacket@CPythonNetworkStream@@QAE_NKUSItemPos@@H@Z PROC ; CPythonNetworkStream::SendGiveItemPacket, COMDAT
; _this$ = ecx

; 3772 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3773 : 	TPacketCGGiveItem GiveItemPacket;
; 3774 : 	GiveItemPacket.byHeader = HEADER_CG_GIVE_ITEM;
; 3775 : 	GiveItemPacket.dwTargetVID = dwTargetVID;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dwTargetVID$[ebp]
  00009	89 45 f5	 mov	 DWORD PTR _GiveItemPacket$[ebp+1], eax

; 3776 : 	GiveItemPacket.ItemPos = ItemPos;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _ItemPos$[ebp]
  0000f	66 89 45 f9	 mov	 WORD PTR _GiveItemPacket$[ebp+5], ax
  00013	8b 45 0e	 mov	 eax, DWORD PTR _ItemPos$[ebp+2]
  00016	88 45 fb	 mov	 BYTE PTR _GiveItemPacket$[ebp+7], al

; 3777 : 	GiveItemPacket.byItemCount = iItemCount;

  00019	8b 45 10	 mov	 eax, DWORD PTR _iItemCount$[ebp]
  0001c	56		 push	 esi
  0001d	88 45 fc	 mov	 BYTE PTR _GiveItemPacket$[ebp+8], al
  00020	8b f1		 mov	 esi, ecx

; 3778 : 
; 3779 : 	if (!Send(sizeof(GiveItemPacket), &GiveItemPacket))

  00022	8d 45 f4	 lea	 eax, DWORD PTR _GiveItemPacket$[ebp]
  00025	c6 45 f4 53	 mov	 BYTE PTR _GiveItemPacket$[ebp], 83 ; 00000053H
  00029	50		 push	 eax
  0002a	6a 09		 push	 9
  0002c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00031	84 c0		 test	 al, al
  00033	75 07		 jne	 SHORT $LN1@SendGiveIt
  00035	5e		 pop	 esi

; 3783 : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SendGiveIt:

; 3780 : 		return false;
; 3781 : 
; 3782 : 	return SendSequence();

  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00043	5e		 pop	 esi

; 3783 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 0c 00	 ret	 12			; 0000000cH
?SendGiveItemPacket@CPythonNetworkStream@@QAE_NKUSItemPos@@H@Z ENDP ; CPythonNetworkStream::SendGiveItemPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendOnClickPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_OnClickPacket$ = -8					; size = 5
_vid$ = 8						; size = 4
?SendOnClickPacket@CPythonNetworkStream@@QAE_NK@Z PROC	; CPythonNetworkStream::SendOnClickPacket, COMDAT
; _this$ = ecx

; 1617 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1618 : 	TPacketCGOnClick OnClickPacket;
; 1619 : 	OnClickPacket.header	= HEADER_CG_ON_CLICK;
; 1620 : 	OnClickPacket.vid		= vid;

  00006	8b 45 08	 mov	 eax, DWORD PTR _vid$[ebp]
  00009	56		 push	 esi
  0000a	89 45 f9	 mov	 DWORD PTR _OnClickPacket$[ebp+1], eax
  0000d	8b f1		 mov	 esi, ecx

; 1621 : 
; 1622 : 	if (!Send(sizeof(OnClickPacket), &OnClickPacket))

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _OnClickPacket$[ebp]
  00012	c6 45 f8 1a	 mov	 BYTE PTR _OnClickPacket$[ebp], 26 ; 0000001aH
  00016	50		 push	 eax
  00017	6a 05		 push	 5
  00019	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001e	84 c0		 test	 al, al
  00020	75 16		 jne	 SHORT $LN1@SendOnClic

; 1623 : 	{
; 1624 : 		Tracen("Send On_Click Packet Error");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HCNNPICH@Send?5On_Click?5Packet?5Error?$AA@
  00027	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002c	83 c4 04	 add	 esp, 4

; 1625 : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1630 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN1@SendOnClic:

; 1626 : 	}
; 1627 : 
; 1628 : 	Tracef("SendOnClickPacket\n");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ICLELGCO@SendOnClickPacket?6?$AA@
  0003d	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00042	83 c4 04	 add	 esp, 4

; 1629 : 	return SendSequence();

  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004c	5e		 pop	 esi

; 1630 : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?SendOnClickPacket@CPythonNetworkStream@@QAE_NK@Z ENDP	; CPythonNetworkStream::SendOnClickPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendCharacterPositionPacket@CPythonNetworkStream@@QAE_NE@Z
_TEXT	SEGMENT
_PositionPacket$ = -4					; size = 2
_iPosition$ = 8						; size = 1
?SendCharacterPositionPacket@CPythonNetworkStream@@QAE_NE@Z PROC ; CPythonNetworkStream::SendCharacterPositionPacket, COMDAT
; _this$ = ecx

; 1601 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1602 : 	TPacketCGPosition PositionPacket;
; 1603 : 
; 1604 : 	PositionPacket.header = HEADER_CG_CHARACTER_POSITION;
; 1605 : 	PositionPacket.position = iPosition;

  00004	8b 45 08	 mov	 eax, DWORD PTR _iPosition$[ebp]
  00007	56		 push	 esi
  00008	88 45 fd	 mov	 BYTE PTR _PositionPacket$[ebp+1], al
  0000b	8b f1		 mov	 esi, ecx

; 1606 : 
; 1607 : 	if (!Send(sizeof(TPacketCGPosition), &PositionPacket))

  0000d	8d 45 fc	 lea	 eax, DWORD PTR _PositionPacket$[ebp]
  00010	c6 45 fc 1c	 mov	 BYTE PTR _PositionPacket$[ebp], 28 ; 0000001cH
  00014	50		 push	 eax
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001c	84 c0		 test	 al, al
  0001e	75 16		 jne	 SHORT $LN1@SendCharac

; 1608 : 	{
; 1609 : 		Tracen("Send Character Position Packet Error");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OKKJKDKD@Send?5Character?5Position?5Packet?5E@
  00025	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002a	83 c4 04	 add	 esp, 4

; 1610 : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	5e		 pop	 esi

; 1614 : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN1@SendCharac:

; 1611 : 	}
; 1612 : 
; 1613 : 	return SendSequence();

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0003d	5e		 pop	 esi

; 1614 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?SendCharacterPositionPacket@CPythonNetworkStream@@QAE_NE@Z ENDP ; CPythonNetworkStream::SendCharacterPositionPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendMobileMessagePacket@CPythonNetworkStream@@QAE_NPBD0@Z
_TEXT	SEGMENT
_SMSPacket$ = -32					; size = 28
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_c_szChat$ = 12						; size = 4
?SendMobileMessagePacket@CPythonNetworkStream@@QAE_NPBD0@Z PROC ; CPythonNetworkStream::SendMobileMessagePacket, COMDAT
; _this$ = ecx

; 1463 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 0c	 mov	 edi, DWORD PTR _c_szChat$[ebp]
  00019	8b f1		 mov	 esi, ecx

; 1464 : 	int iTextLen = strlen(c_szChat) + 1;

  0001b	8b c7		 mov	 eax, edi
  0001d	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$LL5@SendMobile:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL5@SendMobile
  00027	2b c3		 sub	 eax, ebx

; 1465 : 	TPacketCGSMS SMSPacket;
; 1466 : 	SMSPacket.bHeader = HEADER_CG_SMS;

  00029	c6 45 e0 6b	 mov	 BYTE PTR _SMSPacket$[ebp], 107 ; 0000006bH

; 1467 : 	SMSPacket.wSize = sizeof(SMSPacket) + iTextLen;
; 1468 : 
; 1469 : 	strncpy(SMSPacket.szNameTo, name, sizeof(SMSPacket.szNameTo) - 1);

  0002d	6a 18		 push	 24			; 00000018H
  0002f	52		 push	 edx
  00030	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  00033	8d 43 1c	 lea	 eax, DWORD PTR [ebx+28]
  00036	66 89 45 e1	 mov	 WORD PTR _SMSPacket$[ebp+1], ax
  0003a	8d 45 e3	 lea	 eax, DWORD PTR _SMSPacket$[ebp+3]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _strncpy
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1470 : 
; 1471 : 	if (!Send(sizeof(SMSPacket), &SMSPacket))

  00046	8d 45 e0	 lea	 eax, DWORD PTR _SMSPacket$[ebp]
  00049	8b ce		 mov	 ecx, esi
  0004b	50		 push	 eax
  0004c	6a 1c		 push	 28			; 0000001cH
  0004e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00053	84 c0		 test	 al, al
  00055	75 15		 jne	 SHORT $LN2@SendMobile
$LN6@SendMobile:
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 1472 : 		return false;

  00059	32 c0		 xor	 al, al
  0005b	5b		 pop	 ebx

; 1478 : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
$LN2@SendMobile:

; 1473 : 
; 1474 : 	if (!Send(iTextLen, c_szChat))

  0006c	57		 push	 edi
  0006d	53		 push	 ebx
  0006e	8b ce		 mov	 ecx, esi
  00070	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBD@Z ; CNetworkStream::Send
  00075	84 c0		 test	 al, al
  00077	74 de		 je	 SHORT $LN6@SendMobile

; 1475 : 		return false;
; 1476 : 
; 1477 : 	return SendSequence();

  00079	8b ce		 mov	 ecx, esi
  0007b	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 1478 : }

  00080	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	33 cd		 xor	 ecx, ebp
  00087	5b		 pop	 ebx
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
?SendMobileMessagePacket@CPythonNetworkStream@@QAE_NPBD0@Z ENDP ; CPythonNetworkStream::SendMobileMessagePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendWhisperPacket@CPythonNetworkStream@@QAE_NPBD0@Z
_TEXT	SEGMENT
_name$GSCopy$1$ = -36					; size = 4
_WhisperPacket$ = -32					; size = 28
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_c_szChat$ = 12						; size = 4
?SendWhisperPacket@CPythonNetworkStream@@QAE_NPBD0@Z PROC ; CPythonNetworkStream::SendWhisperPacket, COMDAT
; _this$ = ecx

; 1442 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _c_szChat$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx
  0001a	89 45 dc	 mov	 DWORD PTR _name$GSCopy$1$[ebp], eax

; 1443 : 	if (strlen(c_szChat) >= 255)

  0001d	8b ce		 mov	 ecx, esi
  0001f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL6@SendWhispe:
  00022	8a 01		 mov	 al, BYTE PTR [ecx]
  00024	41		 inc	 ecx
  00025	84 c0		 test	 al, al
  00027	75 f9		 jne	 SHORT $LL6@SendWhispe
  00029	2b ca		 sub	 ecx, edx
  0002b	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00031	72 14		 jb	 SHORT $LN3@SendWhispe

; 1444 : 		return true;

  00033	5f		 pop	 edi
  00034	b0 01		 mov	 al, 1
  00036	5e		 pop	 esi

; 1460 : }

  00037	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003a	33 cd		 xor	 ecx, ebp
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN3@SendWhispe:

; 1445 : 
; 1446 : 	int iTextLen = strlen(c_szChat) + 1;

  00047	8b ce		 mov	 ecx, esi
  00049	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0004c	8d 64 24 00	 npad	 4
$LL7@SendWhispe:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL7@SendWhispe
  00057	2b ca		 sub	 ecx, edx

; 1447 : 	TPacketCGWhisper WhisperPacket;
; 1448 : 	WhisperPacket.bHeader = HEADER_CG_WHISPER;

  00059	c6 45 e0 13	 mov	 BYTE PTR _WhisperPacket$[ebp], 19 ; 00000013H
  0005d	53		 push	 ebx

; 1449 : 	WhisperPacket.wSize = sizeof(WhisperPacket) + iTextLen;
; 1450 : 
; 1451 : 	strncpy(WhisperPacket.szNameTo, name, sizeof(WhisperPacket.szNameTo) - 1);

  0005e	6a 18		 push	 24			; 00000018H
  00060	ff 75 dc	 push	 DWORD PTR _name$GSCopy$1$[ebp]
  00063	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
  00066	8d 43 1c	 lea	 eax, DWORD PTR [ebx+28]
  00069	66 89 45 e1	 mov	 WORD PTR _WhisperPacket$[ebp+1], ax
  0006d	8d 45 e3	 lea	 eax, DWORD PTR _WhisperPacket$[ebp+3]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _strncpy
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1452 : 
; 1453 : 	if (!Send(sizeof(WhisperPacket), &WhisperPacket))

  00079	8d 45 e0	 lea	 eax, DWORD PTR _WhisperPacket$[ebp]
  0007c	8b cf		 mov	 ecx, edi
  0007e	50		 push	 eax
  0007f	6a 1c		 push	 28			; 0000001cH
  00081	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00086	84 c0		 test	 al, al
  00088	74 0d		 je	 SHORT $LN9@SendWhispe

; 1454 : 		return false;
; 1455 : 
; 1456 : 	if (!Send(iTextLen, c_szChat))

  0008a	56		 push	 esi
  0008b	53		 push	 ebx
  0008c	8b cf		 mov	 ecx, edi
  0008e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBD@Z ; CNetworkStream::Send
  00093	84 c0		 test	 al, al
  00095	75 15		 jne	 SHORT $LN1@SendWhispe
$LN9@SendWhispe:
  00097	5b		 pop	 ebx
  00098	5f		 pop	 edi

; 1457 : 		return false;

  00099	32 c0		 xor	 al, al
  0009b	5e		 pop	 esi

; 1460 : }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
$LN1@SendWhispe:

; 1458 : 
; 1459 : 	return SendSequence();

  000ac	8b cf		 mov	 ecx, edi
  000ae	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 1460 : }

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	5b		 pop	 ebx
  000b7	5f		 pop	 edi
  000b8	33 cd		 xor	 ecx, ebp
  000ba	5e		 pop	 esi
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
?SendWhisperPacket@CPythonNetworkStream@@QAE_NPBD0@Z ENDP ; CPythonNetworkStream::SendWhisperPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?Warp@CPythonNetworkStream@@QAEXJJ@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_fHeight$ = -4						; size = 4
_lLocalX$ = 8						; size = 4
_lGlobalX$ = 8						; size = 4
_lLocalY$ = 12						; size = 4
_lGlobalY$ = 12						; size = 4
?Warp@CPythonNetworkStream@@QAEXJJ@Z PROC		; CPythonNetworkStream::Warp, COMDAT
; _this$ = ecx

; 815  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 816  : 	CPythonBackground& rkBgMgr=CPythonBackground::Instance();

  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0000d	56		 push	 esi
  0000e	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx

; 817  : 	rkBgMgr.Destroy();

  00011	8b cb		 mov	 ecx, ebx
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 ?Destroy@CPythonBackground@@QAEXXZ ; CPythonBackground::Destroy

; 818  : 	rkBgMgr.Create();

  00019	8b cb		 mov	 ecx, ebx
  0001b	e8 00 00 00 00	 call	 ?Create@CPythonBackground@@QAEXXZ ; CPythonBackground::Create

; 819  : 	rkBgMgr.Warp(lGlobalX, lGlobalY);

  00020	8b 7d 0c	 mov	 edi, DWORD PTR _lGlobalY$[ebp]
  00023	8b cb		 mov	 ecx, ebx
  00025	8b 75 08	 mov	 esi, DWORD PTR _lGlobalX$[ebp]
  00028	57		 push	 edi
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?Warp@CPythonBackground@@QAEXKK@Z ; CPythonBackground::Warp

; 820  : 	//rkBgMgr.SetShadowLevel(CPythonBackground::SHADOW_ALL);
; 821  : 	rkBgMgr.RefreshShadowLevel();

  0002f	8b cb		 mov	 ecx, ebx
  00031	e8 00 00 00 00	 call	 ?RefreshShadowLevel@CPythonBackground@@QAEXXZ ; CPythonBackground::RefreshShadowLevel

; 822  : 
; 823  : 	// NOTE : Warp  CenterPosition Height 0     
; 824  : 	//         Height      Position  
; 825  : 	//         - [levites]
; 826  : 	LONG lLocalX = lGlobalX;
; 827  : 	LONG lLocalY = lGlobalY;
; 828  : 	__GlobalPositionToLocalPosition(lLocalX, lLocalY);

  00036	8d 45 0c	 lea	 eax, DWORD PTR _lLocalY$[ebp]
  00039	89 75 08	 mov	 DWORD PTR _lLocalX$[ebp], esi
  0003c	50		 push	 eax
  0003d	8d 45 08	 lea	 eax, DWORD PTR _lLocalX$[ebp]
  00040	89 7d 0c	 mov	 DWORD PTR _lLocalY$[ebp], edi
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?__GlobalPositionToLocalPosition@CPythonNetworkStream@@IAEXAAJ0@Z ; CPythonNetworkStream::__GlobalPositionToLocalPosition
  00049	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _lLocalY$[ebp]

; 829  : 	float fHeight = CPythonBackground::Instance().GetHeight(float(lLocalX), float(lLocalY));

  0004e	83 ec 08	 sub	 esp, 8
  00051	66 0f 6e 4d 08	 movd	 xmm1, DWORD PTR _lLocalX$[ebp]
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0005c	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0005f	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00062	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00068	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0006d	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight

; 830  : 
; 831  : 	IAbstractApplication& rkApp=IAbstractApplication::GetSingleton();

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A ; TAbstractSingleton<IAbstractApplication>::ms_singleton

; 832  : 	rkApp.SetCenterPosition(float(lLocalX), float(lLocalY), fHeight);

  00078	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0007b	d9 5d fc	 fstp	 DWORD PTR _fHeight$[ebp]
  0007e	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  00083	8b 01		 mov	 eax, DWORD PTR [ecx]
  00085	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0008b	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _lLocalY$[ebp]
  00090	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00093	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00099	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _lLocalX$[ebp]
  0009e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	ff 50 18	 call	 DWORD PTR [eax+24]

; 833  : 
; 834  : 	__ShowMapName(lLocalX, lLocalY);

  000a9	ff 75 0c	 push	 DWORD PTR _lLocalY$[ebp]
  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000af	ff 75 08	 push	 DWORD PTR _lLocalX$[ebp]
  000b2	e8 00 00 00 00	 call	 ?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z ; CPythonNetworkStream::__ShowMapName
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 835  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 08 00	 ret	 8
?Warp@CPythonNetworkStream@@QAEXJJ@Z ENDP		; CPythonNetworkStream::Warp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h
;	COMDAT ??0SPacketCGDragonSoulRefine@@QAE@XZ
_TEXT	SEGMENT
??0SPacketCGDragonSoulRefine@@QAE@XZ PROC		; SPacketCGDragonSoulRefine::SPacketCGDragonSoulRefine, COMDAT
; _this$ = ecx

; 2792 : 	{}

  00000	56		 push	 esi
  00001	c6 01 cd	 mov	 BYTE PTR [ecx], 205	; 000000cdH
  00004	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00007	ba 0e 00 00 00	 mov	 edx, 14			; 0000000eH
  0000c	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
$LL4@SPacketCGD:
  00011	4a		 dec	 edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00012	c6 00 01	 mov	 BYTE PTR [eax], 1

; 187  : 		cell = WORD_MAX;

  00015	66 89 70 01	 mov	 WORD PTR [eax+1], si
  00019	8d 40 03	 lea	 eax, DWORD PTR [eax+3]
  0001c	79 f3		 jns	 SHORT $LL4@SPacketCGD
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h

; 2792 : 	{}

  0001e	8b c1		 mov	 eax, ecx
  00020	5e		 pop	 esi
  00021	c3		 ret	 0
??0SPacketCGDragonSoulRefine@@QAE@XZ ENDP		; SPacketCGDragonSoulRefine::SPacketCGDragonSoulRefine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonguild.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonguild.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonguild.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonguild.h
;	COMDAT ??0SGuildGradeData@CPythonGuild@@QAE@EPBD@Z
_TEXT	SEGMENT
_byAuthorityFlag_$ = 8					; size = 1
_c_szName_$ = 12					; size = 4
??0SGuildGradeData@CPythonGuild@@QAE@EPBD@Z PROC	; CPythonGuild::SGuildGradeData::SGuildGradeData, COMDAT
; _this$ = ecx

; 30   : 			SGuildGradeData(BYTE byAuthorityFlag_, const char * c_szName_) : byAuthorityFlag(byAuthorityFlag_), strName(c_szName_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 45 08	 mov	 al, BYTE PTR _byAuthorityFlag_$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _c_szName_$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonguild.h

; 30   : 			SGuildGradeData(BYTE byAuthorityFlag_, const char * c_szName_) : byAuthorityFlag(byAuthorityFlag_), strName(c_szName_) {}

  0000d	88 06		 mov	 BYTE PTR [esi], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0000f	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00016	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0001d	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0

; 523  : 			: _CSTD strlen(_First));

  00021	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00024	75 14		 jne	 SHORT $LN46@SGuildGrad
  00026	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00028	51		 push	 ecx
  00029	57		 push	 edi
  0002a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonguild.h

; 30   : 			SGuildGradeData(BYTE byAuthorityFlag_, const char * c_szName_) : byAuthorityFlag(byAuthorityFlag_), strName(c_szName_) {}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN46@SGuildGrad:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0003a	8b cf		 mov	 ecx, edi
  0003c	53		 push	 ebx
  0003d	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
$LL48@SGuildGrad:
  00040	8a 01		 mov	 al, BYTE PTR [ecx]
  00042	41		 inc	 ecx
  00043	84 c0		 test	 al, al
  00045	75 f9		 jne	 SHORT $LL48@SGuildGrad
  00047	2b cb		 sub	 ecx, ebx
  00049	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0004a	51		 push	 ecx
  0004b	57		 push	 edi
  0004c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00054	5f		 pop	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonguild.h

; 30   : 			SGuildGradeData(BYTE byAuthorityFlag_, const char * c_szName_) : byAuthorityFlag(byAuthorityFlag_), strName(c_szName_) {}

  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
??0SGuildGradeData@CPythonGuild@@QAE@EPBD@Z ENDP	; CPythonGuild::SGuildGradeData::SGuildGradeData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonshop.h
;	COMDAT ?SetTabCount@CPythonShop@@QAEXE@Z
_TEXT	SEGMENT
_bTabCount$ = 8						; size = 1
?SetTabCount@CPythonShop@@QAEXE@Z PROC			; CPythonShop::SetTabCount, COMDAT
; _this$ = ecx

; 34   : 		void SetTabCount(BYTE bTabCount) { m_bTabCount = bTabCount; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 45 08	 mov	 al, BYTE PTR _bTabCount$[ebp]
  00006	88 41 10	 mov	 BYTE PTR [ecx+16], al
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetTabCount@CPythonShop@@QAEXE@Z ENDP			; CPythonShop::SetTabCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonquest.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonquest.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonquest.h
;	COMDAT ??0SQuestInstance@CPythonQuest@@QAE@XZ
_TEXT	SEGMENT
??0SQuestInstance@CPythonQuest@@QAE@XZ PROC		; CPythonQuest::SQuestInstance::SQuestInstance, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00000	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonquest.h

; 14   : 			}

  00007	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00014	c7 41 30 0f 00
	00 00		 mov	 DWORD PTR [ecx+48], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001b	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00022	c6 41 1c 00	 mov	 BYTE PTR [ecx+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00026	c7 41 48 0f 00
	00 00		 mov	 DWORD PTR [ecx+72], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0002d	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00034	c6 41 34 00	 mov	 BYTE PTR [ecx+52], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00038	c7 41 60 0f 00
	00 00		 mov	 DWORD PTR [ecx+96], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0003f	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [ecx+92], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00046	c6 41 4c 00	 mov	 BYTE PTR [ecx+76], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonquest.h

; 10   : 				dwIndex = 0;

  0004a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 11   : 				iClockValue = 0;

  00050	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 12   : 				iCounterValue = 0;

  00057	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 13   : 				iStartTime = 0;

  0005e	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 14   : 			}

  00065	c3		 ret	 0
??0SQuestInstance@CPythonQuest@@QAE@XZ ENDP		; CPythonQuest::SQuestInstance::SQuestInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshAlignmentWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshAlignmentWindow@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshAlignmentWindow, COMDAT
; _this$ = ecx

; 32   : {

  00000	56		 push	 esi

; 33   : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshAlignment", Py_BuildValue("()"));

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DGNNMOLK@RefreshAlignment?$AA@
  00014	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0001a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	5e		 pop	 esi

; 34   : }

  00023	c3		 ret	 0
?__RefreshAlignmentWindow@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshAlignmentWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshTargetBoardByVID@CPythonNetworkStream@@IAEXK@Z
_TEXT	SEGMENT
_dwVID$ = 8						; size = 4
?__RefreshTargetBoardByVID@CPythonNetworkStream@@IAEXK@Z PROC ; CPythonNetworkStream::__RefreshTargetBoardByVID, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 38   : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoardByVID", Py_BuildValue("(i)", dwVID));

  00004	ff 75 08	 push	 DWORD PTR _dwVID$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00014	50		 push	 eax
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@IJENFIMO@RefreshTargetBoardByVID?$AA@
  0001a	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00020	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00025	83 c4 14	 add	 esp, 20			; 00000014H
  00028	5e		 pop	 esi

; 39   : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?__RefreshTargetBoardByVID@CPythonNetworkStream@@IAEXK@Z ENDP ; CPythonNetworkStream::__RefreshTargetBoardByVID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshTargetBoardByName@CPythonNetworkStream@@IAEXPBD@Z
_TEXT	SEGMENT
_c_szName$ = 8						; size = 4
?__RefreshTargetBoardByName@CPythonNetworkStream@@IAEXPBD@Z PROC ; CPythonNetworkStream::__RefreshTargetBoardByName, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 43   : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoardByName", Py_BuildValue("(s)", c_szName));

  00004	ff 75 08	 push	 DWORD PTR _c_szName$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00014	50		 push	 eax
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GGFFBLPA@RefreshTargetBoardByName?$AA@
  0001a	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00020	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00025	83 c4 14	 add	 esp, 20			; 00000014H
  00028	5e		 pop	 esi

; 44   : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?__RefreshTargetBoardByName@CPythonNetworkStream@@IAEXPBD@Z ENDP ; CPythonNetworkStream::__RefreshTargetBoardByName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshTargetBoard@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshTargetBoard@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__RefreshTargetBoard, COMDAT
; _this$ = ecx

; 47   : {

  00000	56		 push	 esi

; 48   : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshTargetBoard", Py_BuildValue("()"));

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FLFBFOOJ@RefreshTargetBoard?$AA@
  00014	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0001a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	5e		 pop	 esi

; 49   : }

  00023	c3		 ret	 0
?__RefreshTargetBoard@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__RefreshTargetBoard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshGuildWindowGradePage@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshGuildWindowGradePage@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshGuildWindowGradePage, COMDAT
; _this$ = ecx

; 53   : 	m_isRefreshGuildWndGradePage=true;

  00000	c6 81 1e 03 00
	00 01		 mov	 BYTE PTR [ecx+798], 1

; 54   : }

  00007	c3		 ret	 0
?__RefreshGuildWindowGradePage@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshGuildWindowGradePage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshGuildWindowSkillPage@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshGuildWindowSkillPage@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshGuildWindowSkillPage, COMDAT
; _this$ = ecx

; 58   : 	m_isRefreshGuildWndSkillPage=true;

  00000	c6 81 1d 03 00
	00 01		 mov	 BYTE PTR [ecx+797], 1

; 59   : }

  00007	c3		 ret	 0
?__RefreshGuildWindowSkillPage@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshGuildWindowSkillPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshGuildWindowMemberPageGradeComboBox@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshGuildWindowMemberPageGradeComboBox@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshGuildWindowMemberPageGradeComboBox, COMDAT
; _this$ = ecx

; 63   : 	m_isRefreshGuildWndMemberPageGradeComboBox=true;

  00000	c6 81 1c 03 00
	00 01		 mov	 BYTE PTR [ecx+796], 1

; 64   : }

  00007	c3		 ret	 0
?__RefreshGuildWindowMemberPageGradeComboBox@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshGuildWindowMemberPageGradeComboBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshGuildWindowMemberPage@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshGuildWindowMemberPage@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshGuildWindowMemberPage, COMDAT
; _this$ = ecx

; 68   : 	m_isRefreshGuildWndMemberPage=true;

  00000	c6 81 1b 03 00
	00 01		 mov	 BYTE PTR [ecx+795], 1

; 69   : }

  00007	c3		 ret	 0
?__RefreshGuildWindowMemberPage@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshGuildWindowMemberPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshGuildWindowBoardPage@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshGuildWindowBoardPage@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshGuildWindowBoardPage, COMDAT
; _this$ = ecx

; 73   : 	m_isRefreshGuildWndBoardPage=true;

  00000	c6 81 1a 03 00
	00 01		 mov	 BYTE PTR [ecx+794], 1

; 74   : }

  00007	c3		 ret	 0
?__RefreshGuildWindowBoardPage@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshGuildWindowBoardPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshGuildWindowInfoPage@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshGuildWindowInfoPage@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshGuildWindowInfoPage, COMDAT
; _this$ = ecx

; 78   : 	m_isRefreshGuildWndInfoPage=true;

  00000	c6 81 19 03 00
	00 01		 mov	 BYTE PTR [ecx+793], 1

; 79   : }

  00007	c3		 ret	 0
?__RefreshGuildWindowInfoPage@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshGuildWindowInfoPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshMessengerWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshMessengerWindow@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshMessengerWindow, COMDAT
; _this$ = ecx

; 83   : 	m_isRefreshMessengerWnd=true;

  00000	c6 81 18 03 00
	00 01		 mov	 BYTE PTR [ecx+792], 1

; 84   : }

  00007	c3		 ret	 0
?__RefreshMessengerWindow@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshMessengerWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshSafeboxWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshSafeboxWindow@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshSafeboxWindow, COMDAT
; _this$ = ecx

; 88   : 	m_isRefreshSafeboxWnd=true;

  00000	c6 81 16 03 00
	00 01		 mov	 BYTE PTR [ecx+790], 1

; 89   : }

  00007	c3		 ret	 0
?__RefreshSafeboxWindow@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshSafeboxWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshMallWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshMallWindow@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__RefreshMallWindow, COMDAT
; _this$ = ecx

; 93   : 	m_isRefreshMallWnd=true;

  00000	c6 81 17 03 00
	00 01		 mov	 BYTE PTR [ecx+791], 1

; 94   : }

  00007	c3		 ret	 0
?__RefreshMallWindow@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__RefreshMallWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshSkillWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshSkillWindow@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__RefreshSkillWindow, COMDAT
; _this$ = ecx

; 98   : 	m_isRefreshSkillWnd=true;

  00000	c6 81 15 03 00
	00 01		 mov	 BYTE PTR [ecx+789], 1

; 99   : }

  00007	c3		 ret	 0
?__RefreshSkillWindow@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__RefreshSkillWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshExchangeWindow, COMDAT
; _this$ = ecx

; 103  : 	m_isRefreshExchangeWnd=true;

  00000	c6 81 14 03 00
	00 01		 mov	 BYTE PTR [ecx+788], 1

; 104  : }

  00007	c3		 ret	 0
?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshExchangeWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshStatus@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshStatus@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__RefreshStatus, COMDAT
; _this$ = ecx

; 108  : 	m_isRefreshStatus=true;

  00000	c6 81 10 03 00
	00 01		 mov	 BYTE PTR [ecx+784], 1

; 109  : }

  00007	c3		 ret	 0
?__RefreshStatus@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__RefreshStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshCharacterWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshCharacterWindow@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshCharacterWindow, COMDAT
; _this$ = ecx

; 113  : 	m_isRefreshCharacterWnd=true;

  00000	c6 81 11 03 00
	00 01		 mov	 BYTE PTR [ecx+785], 1

; 114  : }

  00007	c3		 ret	 0
?__RefreshCharacterWindow@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshCharacterWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshInventoryWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshInventoryWindow@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshInventoryWindow, COMDAT
; _this$ = ecx

; 118  : 	m_isRefreshInventoryWnd=true;

  00000	c6 81 13 03 00
	00 01		 mov	 BYTE PTR [ecx+787], 1

; 119  : }

  00007	c3		 ret	 0
?__RefreshInventoryWindow@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshInventoryWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__RefreshEquipmentWindow@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__RefreshEquipmentWindow@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__RefreshEquipmentWindow, COMDAT
; _this$ = ecx

; 123  : 	m_isRefreshEquipmentWnd=true;

  00000	c6 81 12 03 00
	00 01		 mov	 BYTE PTR [ecx+786], 1

; 124  : }

  00007	c3		 ret	 0
?__RefreshEquipmentWindow@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__RefreshEquipmentWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__SetGuildID@CPythonNetworkStream@@IAEXK@Z
_TEXT	SEGMENT
_rkPlayer$1$ = -52					; size = 4
tv633 = -48						; size = 4
_guildName$2 = -44					; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_id$ = 8						; size = 4
?__SetGuildID@CPythonNetworkStream@@IAEXK@Z PROC	; CPythonNetworkStream::__SetGuildID, COMDAT
; _this$ = ecx

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__SetGuildID@CPythonNetworkStream@@IAEXK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 128  : 	if (m_dwGuildID != id)

  0002b	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0002e	39 81 b0 00 00
	00		 cmp	 DWORD PTR [ecx+176], eax
  00034	0f 84 c1 00 00
	00		 je	 $LN4@SetGuildID

; 129  : 	{
; 130  : 		m_dwGuildID = id;
; 131  : 		IAbstractPlayer& rkPlayer = IAbstractPlayer::GetSingleton();

  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  00040	8d b1 a8 02 00
	00		 lea	 esi, DWORD PTR [ecx+680]
  00046	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax
  0004c	8d b9 98 02 00
	00		 lea	 edi, DWORD PTR [ecx+664]
  00052	89 55 cc	 mov	 DWORD PTR _rkPlayer$1$[ebp], edx
  00055	8d 99 a0 01 00
	00		 lea	 ebx, DWORD PTR [ecx+416]
  0005b	c7 45 d0 04 00
	00 00		 mov	 DWORD PTR tv633[ebp], 4
$LL6@SetGuildID:

; 134  : 			if (!strncmp(m_akSimplePlayerInfo[i].szName, rkPlayer.GetName(), CHARACTER_NAME_MAX_LEN))

  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	8b ca		 mov	 ecx, edx
  00066	6a 18		 push	 24			; 00000018H
  00068	ff 50 14	 call	 DWORD PTR [eax+20]
  0006b	50		 push	 eax
  0006c	53		 push	 ebx
  0006d	e8 00 00 00 00	 call	 _strncmp
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	85 c0		 test	 eax, eax
  00077	75 6d		 jne	 SHORT $LN5@SetGuildID

; 135  : 			{
; 136  : 				m_adwGuildID[i] = id;

  00079	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0007c	89 07		 mov	 DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0007e	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _guildName$2[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00085	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _guildName$2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0008c	c6 45 d4 00	 mov	 BYTE PTR _guildName$2[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 139  : 				if (CPythonGuild::Instance().GetGuildName(id, &guildName))

  00090	8d 4d d4	 lea	 ecx, DWORD PTR _guildName$2[ebp]
  00093	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0009a	51		 push	 ecx
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?GetGuildName@CPythonGuild@@QAE_NKPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonGuild::GetGuildName
  000a7	84 c0		 test	 al, al
  000a9	74 15		 je	 SHORT $LN151@SetGuildID
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 998  : 		if (this != &_Right)

  000ab	8d 45 d4	 lea	 eax, DWORD PTR _guildName$2[ebp]
  000ae	3b f0		 cmp	 esi, eax
  000b0	74 1c		 je	 SHORT $LN107@SetGuildID

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));

  000b2	6a ff		 push	 -1
  000b4	6a 00		 push	 0
  000b6	50		 push	 eax
  000b7	8b ce		 mov	 ecx, esi
  000b9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 143  : 				else

  000be	eb 0e		 jmp	 SHORT $LN107@SetGuildID
$LN151@SetGuildID:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  000c0	6a 00		 push	 0
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000c7	8b ce		 mov	 ecx, esi
  000c9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN107@SetGuildID:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 147  : 			}

  000ce	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000d5	83 7d e8 10	 cmp	 DWORD PTR _guildName$2[ebp+20], 16 ; 00000010H
  000d9	72 0b		 jb	 SHORT $LN5@SetGuildID
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000db	ff 75 d4	 push	 DWORD PTR _guildName$2[ebp]
  000de	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e3	83 c4 04	 add	 esp, 4
$LN5@SetGuildID:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 133  : 		for (int i = 0; i < PLAYER_PER_ACCOUNT4; ++i)

  000e6	8b 55 cc	 mov	 edx, DWORD PTR _rkPlayer$1$[ebp]
  000e9	83 c7 04	 add	 edi, 4
  000ec	83 c3 3f	 add	 ebx, 63			; 0000003fH
  000ef	83 c6 18	 add	 esi, 24			; 00000018H
  000f2	ff 4d d0	 dec	 DWORD PTR tv633[ebp]
  000f5	0f 85 67 ff ff
	ff		 jne	 $LL6@SetGuildID
$LN4@SetGuildID:

; 148  : 	}
; 149  : }

  000fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00105	59		 pop	 ecx
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010c	33 cd		 xor	 ecx, ebp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__SetGuildID@CPythonNetworkStream@@IAEXK@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _guildName$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?__SetGuildID@CPythonNetworkStream@@IAEXK@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__SetGuildID@CPythonNetworkStream@@IAEXK@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__SetGuildID@CPythonNetworkStream@@IAEXK@Z ENDP	; CPythonNetworkStream::__SetGuildID
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?GamePhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
_header$ = -33						; size = 1
_dwRecvCount$1$ = -32					; size = 4
$T2 = -28						; size = 12
__$EHRec$ = -12						; size = 12
?GamePhase@CPythonNetworkStream@@IAEXXZ PROC		; CPythonNetworkStream::GamePhase, COMDAT
; _this$ = ecx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GamePhase@CPythonNetworkStream@@IAEXXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 18	 sub	 esp, 24			; 00000018H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	50		 push	 eax
  00022	8d 44 24 28	 lea	 eax, DWORD PTR __$EHRec$[esp+52]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1362 : 		return (this->_Mysize == 0);

  0002e	83 be 34 79 00
	00 00		 cmp	 DWORD PTR [esi+31028], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 192  : 	if (!m_kQue_stHack.empty())

  00035	74 78		 je	 SHORT $LN150@GamePhase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1406 : 		return (*begin());

  00037	8d 44 24 18	 lea	 eax, DWORD PTR $T2[esp+52]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 194  : 		__SendHack(m_kQue_stHack.front().c_str());

  0003b	8d be 24 79 00
	00		 lea	 edi, DWORD PTR [esi+31012]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1406 : 		return (*begin());

  00041	50		 push	 eax
  00042	8b cf		 mov	 ecx, edi
  00044	e8 00 00 00 00	 call	 ?begin@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
  00049	8b d0		 mov	 edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0004b	8b 02		 mov	 eax, DWORD PTR [edx]
  0004d	85 c0		 test	 eax, eax
  0004f	74 02		 je	 SHORT $LN139@GamePhase
$LN138@GamePhase:
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
$LN139@GamePhase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00053	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1406 : 		return (*begin());

  00056	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00059	49		 dec	 ecx
  0005a	23 4a 08	 and	 ecx, DWORD PTR [edx+8]

; 1406 : 		return (*begin());

  0005d	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00060	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00064	72 02		 jb	 SHORT $LN147@GamePhase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00066	8b 00		 mov	 eax, DWORD PTR [eax]
$LN147@GamePhase:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 194  : 		__SendHack(m_kQue_stHack.front().c_str());

  00068	50		 push	 eax
  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?__SendHack@CPythonNetworkStream@@IAE_NPBD@Z ; CPythonNetworkStream::__SendHack
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00070	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  00073	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00076	49		 dec	 ecx
  00077	23 4f 0c	 and	 ecx, DWORD PTR [edi+12]

; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  0007a	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0007d	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00081	72 0a		 jb	 SHORT $LN187@GamePhase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00083	ff 33		 push	 DWORD PTR [ebx]
  00085	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008a	83 c4 04	 add	 esp, 4
$LN187@GamePhase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0008d	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH

; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00094	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0009b	c6 03 00	 mov	 BYTE PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1454 : 		if (--this->_Mysize == 0)

  0009e	ff 4f 10	 dec	 DWORD PTR [edi+16]
  000a1	75 09		 jne	 SHORT $LN151@GamePhase

; 1455 : 			this->_Myoff = 0;

  000a3	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 1456 : 		else

  000aa	eb 03		 jmp	 SHORT $LN150@GamePhase
$LN151@GamePhase:

; 1457 : 			++this->_Myoff;

  000ac	ff 47 0c	 inc	 DWORD PTR [edi+12]
$LN150@GamePhase:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 198  : 	TPacketHeader header = 0;

  000af	32 ff		 xor	 bh, bh

; 199  : 	bool ret = true;

  000b1	b3 01		 mov	 bl, 1
  000b3	88 7c 24 13	 mov	 BYTE PTR _header$[esp+52], bh

; 200  : 
; 201  : #ifdef __PERFORMANCE_CHECK__
; 202  : 	DWORD timeBeginDispatch=timeGetTime();
; 203  : 
; 204  : 	static std::map<DWORD, PERF_PacketInfo> kMap_kPacketInfo;
; 205  : 	kMap_kPacketInfo.clear();
; 206  : #endif
; 207  : 
; 208  : 	const DWORD MAX_RECV_COUNT = 4;
; 209  : 	const DWORD SAFE_RECV_BUFSIZE = 8192;
; 210  : 	DWORD dwRecvCount = 0;

  000b7	33 c9		 xor	 ecx, ecx
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$LL123@GamePhase:

; 215  : 			&& m_strPhase == "Game") //phase_game      .

  000c0	8b c1		 mov	 eax, ecx
  000c2	41		 inc	 ecx
  000c3	89 4c 24 14	 mov	 DWORD PTR _dwRecvCount$1$[esp+52], ecx
  000c7	83 f8 03	 cmp	 eax, 3
  000ca	72 5e		 jb	 SHORT $LN121@GamePhase
  000cc	8b ce		 mov	 ecx, esi
  000ce	e8 00 00 00 00	 call	 ?GetRecvBufferSize@CNetworkStream@@QAEHXZ ; CNetworkStream::GetRecvBufferSize
  000d3	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  000d8	73 50		 jae	 SHORT $LN121@GamePhase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000da	83 be 20 01 00
	00 10		 cmp	 DWORD PTR [esi+288], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 215  : 			&& m_strPhase == "Game") //phase_game      .

  000e1	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  000e7	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]

; 520  : 			: this->_Bx._Buf);

  000ea	72 02		 jb	 SHORT $LN221@GamePhase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000ec	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN221@GamePhase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2182 : 			_N0 < _Count ? _N0 : _Count);

  000ee	b8 04 00 00 00	 mov	 eax, 4
  000f3	3b f8		 cmp	 edi, eax
  000f5	0f 42 c7	 cmovb	 eax, edi
  000f8	50		 push	 eax
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_04IBBNLEM@Game?$AA@
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

  00107	85 c0		 test	 eax, eax
  00109	75 14		 jne	 SHORT $LN238@GamePhase
  0010b	83 ff 04	 cmp	 edi, 4
  0010e	73 05		 jae	 SHORT $LN211@GamePhase
  00110	83 c8 ff	 or	 eax, -1
  00113	eb 08		 jmp	 SHORT $LN212@GamePhase
$LN211@GamePhase:
  00115	33 c0		 xor	 eax, eax
  00117	83 ff 04	 cmp	 edi, 4
  0011a	0f 95 c0	 setne	 al
$LN212@GamePhase:

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);

  0011d	85 c0		 test	 eax, eax
$LN238@GamePhase:
  0011f	0f 94 c0	 sete	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 215  : 			&& m_strPhase == "Game") //phase_game      .

  00122	84 c0		 test	 al, al
  00124	0f 85 22 05 00
	00		 jne	 $LN122@GamePhase
$LN121@GamePhase:

; 216  : 			break;
; 217  : 
; 218  : 		if (!CheckPacket(&header))

  0012a	8d 44 24 13	 lea	 eax, DWORD PTR _header$[esp+52]
  0012e	8b ce		 mov	 ecx, esi
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z ; CPythonNetworkStream::CheckPacket

; 219  : 			break;
; 220  : 
; 221  : #ifdef __PERFORMANCE_CHECK__
; 222  : 		DWORD timeBeginPacket=timeGetTime();
; 223  : #endif
; 224  : 
; 225  : 		switch (header)

  00136	8a 7c 24 13	 mov	 bh, BYTE PTR _header$[esp+52]
  0013a	84 c0		 test	 al, al
  0013c	0f 84 0a 05 00
	00		 je	 $LN122@GamePhase
  00142	0f b6 cf	 movzx	 ecx, bh
  00145	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00148	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0014d	0f 87 28 04 00
	00		 ja	 $LN19@GamePhase
  00153	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN235@GamePhase[eax]
  0015a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN240@GamePhase[eax*4]
$LN117@GamePhase:

; 226  : 		{
; 227  : 			case HEADER_GC_OBSERVER_ADD:
; 228  : 				ret = RecvObserverAddPacket();

  00161	8b ce		 mov	 ecx, esi
  00163	e8 00 00 00 00	 call	 ?RecvObserverAddPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvObserverAddPacket

; 229  : 				break;

  00168	e9 16 04 00 00	 jmp	 $LN239@GamePhase
$LN116@GamePhase:

; 230  : 			case HEADER_GC_OBSERVER_REMOVE:
; 231  : 				ret = RecvObserverRemovePacket();

  0016d	8b ce		 mov	 ecx, esi
  0016f	e8 00 00 00 00	 call	 ?RecvObserverRemovePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvObserverRemovePacket

; 232  : 				break;

  00174	e9 0a 04 00 00	 jmp	 $LN239@GamePhase
$LN115@GamePhase:

; 233  : 			case HEADER_GC_OBSERVER_MOVE:
; 234  : 				ret = RecvObserverMovePacket();

  00179	8b ce		 mov	 ecx, esi
  0017b	e8 00 00 00 00	 call	 ?RecvObserverMovePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvObserverMovePacket

; 235  : 				break;

  00180	e9 fe 03 00 00	 jmp	 $LN239@GamePhase
$LN114@GamePhase:

; 236  : 			case HEADER_GC_WARP:
; 237  : 				ret = RecvWarpPacket();

  00185	8b ce		 mov	 ecx, esi
  00187	e8 00 00 00 00	 call	 ?RecvWarpPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvWarpPacket

; 238  : 				break;

  0018c	e9 f2 03 00 00	 jmp	 $LN239@GamePhase
$LN112@GamePhase:

; 242  : 				return; //  Phase     GamePhase  - [levites]
; 243  : 				break;
; 244  : 
; 245  : 			case HEADER_GC_PVP:
; 246  : 				ret = RecvPVPPacket();

  00191	8b ce		 mov	 ecx, esi
  00193	e8 00 00 00 00	 call	 ?RecvPVPPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPVPPacket

; 247  : 				break;

  00198	e9 e6 03 00 00	 jmp	 $LN239@GamePhase
$LN111@GamePhase:

; 248  : 
; 249  : 			case HEADER_GC_DUEL_START:
; 250  : 				ret = RecvDuelStartPacket();

  0019d	8b ce		 mov	 ecx, esi
  0019f	e8 00 00 00 00	 call	 ?RecvDuelStartPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvDuelStartPacket

; 251  : 				break;

  001a4	e9 da 03 00 00	 jmp	 $LN239@GamePhase
$LN110@GamePhase:

; 252  : 
; 253  : 			case HEADER_GC_CHARACTER_ADD:
; 254  :  				ret = RecvCharacterAppendPacket();

  001a9	8b ce		 mov	 ecx, esi
  001ab	e8 00 00 00 00	 call	 ?RecvCharacterAppendPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterAppendPacket

; 255  : 				break;

  001b0	e9 ce 03 00 00	 jmp	 $LN239@GamePhase
$LN109@GamePhase:

; 256  : 
; 257  : 			case HEADER_GC_CHAR_ADDITIONAL_INFO:
; 258  : 				ret = RecvCharacterAdditionalInfo();

  001b5	8b ce		 mov	 ecx, esi
  001b7	e8 00 00 00 00	 call	 ?RecvCharacterAdditionalInfo@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterAdditionalInfo

; 259  : 				break;

  001bc	e9 c2 03 00 00	 jmp	 $LN239@GamePhase
$LN108@GamePhase:

; 260  : 
; 261  : 			case HEADER_GC_CHARACTER_ADD2:
; 262  : 				ret = RecvCharacterAppendPacketNew();

  001c1	8b ce		 mov	 ecx, esi
  001c3	e8 00 00 00 00	 call	 ?RecvCharacterAppendPacketNew@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterAppendPacketNew

; 263  : 				break;

  001c8	e9 b6 03 00 00	 jmp	 $LN239@GamePhase
$LN107@GamePhase:

; 264  : 
; 265  : 			case HEADER_GC_CHARACTER_UPDATE:
; 266  : 				ret = RecvCharacterUpdatePacket();

  001cd	8b ce		 mov	 ecx, esi
  001cf	e8 00 00 00 00	 call	 ?RecvCharacterUpdatePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterUpdatePacket

; 267  : 				break;

  001d4	e9 aa 03 00 00	 jmp	 $LN239@GamePhase
$LN106@GamePhase:

; 268  : 
; 269  : 			case HEADER_GC_CHARACTER_UPDATE2:
; 270  : 				ret = RecvCharacterUpdatePacketNew();

  001d9	8b ce		 mov	 ecx, esi
  001db	e8 00 00 00 00	 call	 ?RecvCharacterUpdatePacketNew@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterUpdatePacketNew

; 271  : 				break;

  001e0	e9 9e 03 00 00	 jmp	 $LN239@GamePhase
$LN105@GamePhase:

; 272  : 
; 273  : 			case HEADER_GC_CHARACTER_DEL:
; 274  : 				ret = RecvCharacterDeletePacket();

  001e5	8b ce		 mov	 ecx, esi
  001e7	e8 00 00 00 00	 call	 ?RecvCharacterDeletePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterDeletePacket

; 275  : 				break;

  001ec	e9 92 03 00 00	 jmp	 $LN239@GamePhase
$LN104@GamePhase:

; 276  : 
; 277  : 			case HEADER_GC_CHAT:
; 278  : 				ret = RecvChatPacket();

  001f1	8b ce		 mov	 ecx, esi
  001f3	e8 00 00 00 00	 call	 ?RecvChatPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvChatPacket

; 279  : 				break;

  001f8	e9 86 03 00 00	 jmp	 $LN239@GamePhase
$LN103@GamePhase:

; 280  : 
; 281  : 			case HEADER_GC_SYNC_POSITION:
; 282  : 				ret = RecvSyncPositionPacket();

  001fd	8b ce		 mov	 ecx, esi
  001ff	e8 00 00 00 00	 call	 ?RecvSyncPositionPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSyncPositionPacket

; 283  : 				break;

  00204	e9 7a 03 00 00	 jmp	 $LN239@GamePhase
$LN102@GamePhase:

; 284  : 
; 285  : 			case HEADER_GC_OWNERSHIP:
; 286  : 				ret = RecvOwnerShipPacket();

  00209	8b ce		 mov	 ecx, esi
  0020b	e8 00 00 00 00	 call	 ?RecvOwnerShipPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvOwnerShipPacket

; 287  : 				break;

  00210	e9 6e 03 00 00	 jmp	 $LN239@GamePhase
$LN101@GamePhase:

; 288  : 
; 289  : 			case HEADER_GC_WHISPER:
; 290  : 				ret = RecvWhisperPacket();

  00215	8b ce		 mov	 ecx, esi
  00217	e8 00 00 00 00	 call	 ?RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvWhisperPacket

; 291  : 				break;

  0021c	e9 62 03 00 00	 jmp	 $LN239@GamePhase
$LN100@GamePhase:

; 292  : 
; 293  : 			case HEADER_GC_CHARACTER_MOVE:
; 294  : 				ret = RecvCharacterMovePacket();

  00221	8b ce		 mov	 ecx, esi
  00223	e8 00 00 00 00	 call	 ?RecvCharacterMovePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterMovePacket

; 295  : 				break;

  00228	e9 56 03 00 00	 jmp	 $LN239@GamePhase
$LN99@GamePhase:

; 296  : 
; 297  : 			// Position
; 298  : 			case HEADER_GC_CHARACTER_POSITION:
; 299  : 				ret = RecvCharacterPositionPacket();

  0022d	8b ce		 mov	 ecx, esi
  0022f	e8 00 00 00 00	 call	 ?RecvCharacterPositionPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterPositionPacket

; 300  : 				break;

  00234	e9 4a 03 00 00	 jmp	 $LN239@GamePhase
$LN98@GamePhase:

; 301  : 
; 302  : 			// Battle Packet
; 303  : 			case HEADER_GC_STUN:
; 304  : 				ret = RecvStunPacket();

  00239	8b ce		 mov	 ecx, esi
  0023b	e8 00 00 00 00	 call	 ?RecvStunPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvStunPacket

; 305  : 				break;

  00240	e9 3e 03 00 00	 jmp	 $LN239@GamePhase
$LN97@GamePhase:

; 306  : 
; 307  : 			case HEADER_GC_DEAD:
; 308  : 				ret = RecvDeadPacket();

  00245	8b ce		 mov	 ecx, esi
  00247	e8 00 00 00 00	 call	 ?RecvDeadPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvDeadPacket

; 309  : 				break;

  0024c	e9 32 03 00 00	 jmp	 $LN239@GamePhase
$LN96@GamePhase:

; 310  : 
; 311  : 			case HEADER_GC_PLAYER_POINT_CHANGE:
; 312  : 				ret = RecvPointChange();

  00251	8b ce		 mov	 ecx, esi
  00253	e8 00 00 00 00	 call	 ?RecvPointChange@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPointChange

; 313  : 				break;

  00258	e9 26 03 00 00	 jmp	 $LN239@GamePhase
$LN95@GamePhase:

; 314  : 
; 315  : 			// item packet.
; 316  : 			case HEADER_GC_ITEM_SET:
; 317  : 				ret = RecvItemSetPacket();

  0025d	8b ce		 mov	 ecx, esi
  0025f	e8 00 00 00 00	 call	 ?RecvItemSetPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvItemSetPacket

; 318  : 				break;

  00264	e9 1a 03 00 00	 jmp	 $LN239@GamePhase
$LN94@GamePhase:

; 319  : 
; 320  : 			case HEADER_GC_ITEM_SET2:
; 321  : 				ret = RecvItemSetPacket2();

  00269	8b ce		 mov	 ecx, esi
  0026b	e8 00 00 00 00	 call	 ?RecvItemSetPacket2@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvItemSetPacket2

; 322  : 				break;

  00270	e9 0e 03 00 00	 jmp	 $LN239@GamePhase
$LN93@GamePhase:

; 323  : 
; 324  : 			case HEADER_GC_ITEM_USE:
; 325  : 				ret = RecvItemUsePacket();

  00275	8b ce		 mov	 ecx, esi
  00277	e8 00 00 00 00	 call	 ?RecvItemUsePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvItemUsePacket

; 326  : 				break;

  0027c	e9 02 03 00 00	 jmp	 $LN239@GamePhase
$LN92@GamePhase:

; 327  : 
; 328  : 			case HEADER_GC_ITEM_UPDATE:
; 329  : 				ret = RecvItemUpdatePacket();

  00281	8b ce		 mov	 ecx, esi
  00283	e8 00 00 00 00	 call	 ?RecvItemUpdatePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvItemUpdatePacket

; 330  : 				break;

  00288	e9 f6 02 00 00	 jmp	 $LN239@GamePhase
$LN91@GamePhase:

; 331  : 
; 332  : 			case HEADER_GC_ITEM_GROUND_ADD:
; 333  : 				ret = RecvItemGroundAddPacket();

  0028d	8b ce		 mov	 ecx, esi
  0028f	e8 00 00 00 00	 call	 ?RecvItemGroundAddPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvItemGroundAddPacket

; 334  : 				break;

  00294	e9 ea 02 00 00	 jmp	 $LN239@GamePhase
$LN90@GamePhase:

; 335  : 
; 336  : 			case HEADER_GC_ITEM_GROUND_DEL:
; 337  : 				ret = RecvItemGroundDelPacket();

  00299	8b ce		 mov	 ecx, esi
  0029b	e8 00 00 00 00	 call	 ?RecvItemGroundDelPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvItemGroundDelPacket

; 338  : 				break;

  002a0	e9 de 02 00 00	 jmp	 $LN239@GamePhase
$LN89@GamePhase:

; 339  : 
; 340  : 			case HEADER_GC_ITEM_OWNERSHIP:
; 341  : 				ret = RecvItemOwnership();

  002a5	8b ce		 mov	 ecx, esi
  002a7	e8 00 00 00 00	 call	 ?RecvItemOwnership@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvItemOwnership

; 342  : 				break;

  002ac	e9 d2 02 00 00	 jmp	 $LN239@GamePhase
$LN88@GamePhase:

; 343  : 
; 344  : 			case HEADER_GC_QUICKSLOT_ADD:
; 345  : 				ret = RecvQuickSlotAddPacket();

  002b1	8b ce		 mov	 ecx, esi
  002b3	e8 00 00 00 00	 call	 ?RecvQuickSlotAddPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvQuickSlotAddPacket

; 346  : 				break;

  002b8	e9 c6 02 00 00	 jmp	 $LN239@GamePhase
$LN87@GamePhase:

; 347  : 
; 348  : 			case HEADER_GC_QUICKSLOT_DEL:
; 349  : 				ret = RecvQuickSlotDelPacket();

  002bd	8b ce		 mov	 ecx, esi
  002bf	e8 00 00 00 00	 call	 ?RecvQuickSlotDelPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvQuickSlotDelPacket

; 350  : 				break;

  002c4	e9 ba 02 00 00	 jmp	 $LN239@GamePhase
$LN86@GamePhase:

; 351  : 
; 352  : 			case HEADER_GC_QUICKSLOT_SWAP:
; 353  : 				ret = RecvQuickSlotMovePacket();

  002c9	8b ce		 mov	 ecx, esi
  002cb	e8 00 00 00 00	 call	 ?RecvQuickSlotMovePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvQuickSlotMovePacket

; 354  : 				break;

  002d0	e9 ae 02 00 00	 jmp	 $LN239@GamePhase
$LN85@GamePhase:

; 355  : 
; 356  : 			case HEADER_GC_MOTION:
; 357  : 				ret = RecvMotionPacket();

  002d5	8b ce		 mov	 ecx, esi
  002d7	e8 00 00 00 00	 call	 ?RecvMotionPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMotionPacket

; 358  : 				break;

  002dc	e9 a2 02 00 00	 jmp	 $LN239@GamePhase
$LN84@GamePhase:

; 359  : 
; 360  : 			case HEADER_GC_SHOP:
; 361  : 				ret = RecvShopPacket();

  002e1	8b ce		 mov	 ecx, esi
  002e3	e8 00 00 00 00	 call	 ?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvShopPacket

; 362  : 				break;

  002e8	e9 96 02 00 00	 jmp	 $LN239@GamePhase
$LN83@GamePhase:

; 363  : 				
; 364  : 			case HEADER_GC_SHOP_SIGN:
; 365  : 				ret = RecvShopSignPacket();

  002ed	8b ce		 mov	 ecx, esi
  002ef	e8 00 00 00 00	 call	 ?RecvShopSignPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvShopSignPacket

; 366  : 				break;

  002f4	e9 8a 02 00 00	 jmp	 $LN239@GamePhase
$LN82@GamePhase:

; 367  : 
; 368  : 			case HEADER_GC_EXCHANGE:
; 369  : 				ret = RecvExchangePacket();

  002f9	8b ce		 mov	 ecx, esi
  002fb	e8 00 00 00 00	 call	 ?RecvExchangePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvExchangePacket

; 370  : 				break;

  00300	e9 7e 02 00 00	 jmp	 $LN239@GamePhase
$LN81@GamePhase:

; 371  : 
; 372  : 			case HEADER_GC_QUEST_INFO:
; 373  : 				ret = RecvQuestInfoPacket();

  00305	8b ce		 mov	 ecx, esi
  00307	e8 00 00 00 00	 call	 ?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvQuestInfoPacket

; 374  : 				break;

  0030c	e9 72 02 00 00	 jmp	 $LN239@GamePhase
$LN80@GamePhase:

; 375  : 
; 376  : 			case HEADER_GC_REQUEST_MAKE_GUILD:
; 377  : 				ret = RecvRequestMakeGuild();

  00311	8b ce		 mov	 ecx, esi
  00313	e8 00 00 00 00	 call	 ?RecvRequestMakeGuild@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvRequestMakeGuild

; 378  : 				break;

  00318	e9 66 02 00 00	 jmp	 $LN239@GamePhase
$LN79@GamePhase:

; 379  : 
; 380  : 			case HEADER_GC_PING:
; 381  : 				ret = RecvPingPacket();

  0031d	8b ce		 mov	 ecx, esi
  0031f	e8 00 00 00 00	 call	 ?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPingPacket

; 382  : 				break;

  00324	e9 5a 02 00 00	 jmp	 $LN239@GamePhase
$LN78@GamePhase:

; 383  : 
; 384  : 			case HEADER_GC_SCRIPT:
; 385  : 				ret = RecvScriptPacket();

  00329	8b ce		 mov	 ecx, esi
  0032b	e8 00 00 00 00	 call	 ?RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvScriptPacket

; 386  : 				break;

  00330	e9 4e 02 00 00	 jmp	 $LN239@GamePhase
$LN77@GamePhase:

; 387  : 
; 388  : 			case HEADER_GC_QUEST_CONFIRM:
; 389  : 				ret = RecvQuestConfirmPacket();

  00335	8b ce		 mov	 ecx, esi
  00337	e8 00 00 00 00	 call	 ?RecvQuestConfirmPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvQuestConfirmPacket

; 390  : 				break;

  0033c	e9 42 02 00 00	 jmp	 $LN239@GamePhase
$LN76@GamePhase:

; 391  : 
; 392  : 			case HEADER_GC_TARGET:
; 393  : 				ret = RecvTargetPacket();

  00341	8b ce		 mov	 ecx, esi
  00343	e8 00 00 00 00	 call	 ?RecvTargetPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvTargetPacket

; 394  : 				break;

  00348	e9 36 02 00 00	 jmp	 $LN239@GamePhase
$LN75@GamePhase:

; 395  : 
; 396  : 			case HEADER_GC_DAMAGE_INFO:
; 397  : 				ret = RecvDamageInfoPacket();

  0034d	8b ce		 mov	 ecx, esi
  0034f	e8 00 00 00 00	 call	 ?RecvDamageInfoPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvDamageInfoPacket

; 398  : 				break;

  00354	e9 2a 02 00 00	 jmp	 $LN239@GamePhase
$LN74@GamePhase:

; 399  : 
; 400  : 			case HEADER_GC_MOUNT:
; 401  : 				ret = RecvMountPacket();

  00359	8b ce		 mov	 ecx, esi
  0035b	e8 00 00 00 00	 call	 ?RecvMountPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMountPacket

; 402  : 				break;

  00360	e9 1e 02 00 00	 jmp	 $LN239@GamePhase
$LN73@GamePhase:

; 403  : 
; 404  : 			case HEADER_GC_CHANGE_SPEED:
; 405  : 				ret = RecvChangeSpeedPacket();

  00365	8b ce		 mov	 ecx, esi
  00367	e8 00 00 00 00	 call	 ?RecvChangeSpeedPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvChangeSpeedPacket

; 406  : 				break;

  0036c	e9 12 02 00 00	 jmp	 $LN239@GamePhase
$LN72@GamePhase:

; 407  : 
; 408  : 			case HEADER_GC_PLAYER_POINTS:
; 409  : 				ret = __RecvPlayerPoints();

  00371	8b ce		 mov	 ecx, esi
  00373	e8 00 00 00 00	 call	 ?__RecvPlayerPoints@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvPlayerPoints

; 410  : 				break;

  00378	e9 06 02 00 00	 jmp	 $LN239@GamePhase
$LN71@GamePhase:

; 411  : 
; 412  : 			case HEADER_GC_CREATE_FLY:
; 413  : 				ret = RecvCreateFlyPacket();

  0037d	8b ce		 mov	 ecx, esi
  0037f	e8 00 00 00 00	 call	 ?RecvCreateFlyPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCreateFlyPacket

; 414  : 				break;

  00384	e9 fa 01 00 00	 jmp	 $LN239@GamePhase
$LN70@GamePhase:

; 415  : 
; 416  : 			case HEADER_GC_FLY_TARGETING:
; 417  : 				ret = RecvFlyTargetingPacket();

  00389	8b ce		 mov	 ecx, esi
  0038b	e8 00 00 00 00	 call	 ?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvFlyTargetingPacket

; 418  : 				break;

  00390	e9 ee 01 00 00	 jmp	 $LN239@GamePhase
$LN69@GamePhase:

; 419  : 
; 420  : 			case HEADER_GC_ADD_FLY_TARGETING:
; 421  : 				ret = RecvAddFlyTargetingPacket();

  00395	8b ce		 mov	 ecx, esi
  00397	e8 00 00 00 00	 call	 ?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvAddFlyTargetingPacket

; 422  : 				break;

  0039c	e9 e2 01 00 00	 jmp	 $LN239@GamePhase
$LN68@GamePhase:

; 423  : 
; 424  : 			case HEADER_GC_SKILL_LEVEL:
; 425  : 				ret = RecvSkillLevel();

  003a1	8b ce		 mov	 ecx, esi
  003a3	e8 00 00 00 00	 call	 ?RecvSkillLevel@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSkillLevel

; 426  : 				break;

  003a8	e9 d6 01 00 00	 jmp	 $LN239@GamePhase
$LN67@GamePhase:

; 427  : 
; 428  : 			case HEADER_GC_SKILL_LEVEL_NEW:
; 429  : 				ret = RecvSkillLevelNew();

  003ad	8b ce		 mov	 ecx, esi
  003af	e8 00 00 00 00	 call	 ?RecvSkillLevelNew@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSkillLevelNew

; 430  : 				break;

  003b4	e9 ca 01 00 00	 jmp	 $LN239@GamePhase
$LN66@GamePhase:

; 431  : 
; 432  : 			case HEADER_GC_MESSENGER:
; 433  : 				ret = RecvMessenger();

  003b9	8b ce		 mov	 ecx, esi
  003bb	e8 00 00 00 00	 call	 ?RecvMessenger@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMessenger

; 434  : 				break;

  003c0	e9 be 01 00 00	 jmp	 $LN239@GamePhase
$LN65@GamePhase:

; 435  : 
; 436  : 			case HEADER_GC_GUILD:
; 437  : 				ret = RecvGuild();

  003c5	8b ce		 mov	 ecx, esi
  003c7	e8 00 00 00 00	 call	 ?RecvGuild@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvGuild

; 438  : 				break;

  003cc	e9 b2 01 00 00	 jmp	 $LN239@GamePhase
$LN64@GamePhase:

; 439  : 
; 440  : 			case HEADER_GC_PARTY_INVITE:
; 441  : 				ret = RecvPartyInvite();

  003d1	8b ce		 mov	 ecx, esi
  003d3	e8 00 00 00 00	 call	 ?RecvPartyInvite@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPartyInvite

; 442  : 				break;

  003d8	e9 a6 01 00 00	 jmp	 $LN239@GamePhase
$LN63@GamePhase:

; 443  : 
; 444  : 			case HEADER_GC_PARTY_ADD:
; 445  : 				ret = RecvPartyAdd();

  003dd	8b ce		 mov	 ecx, esi
  003df	e8 00 00 00 00	 call	 ?RecvPartyAdd@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPartyAdd

; 446  : 				break;

  003e4	e9 9a 01 00 00	 jmp	 $LN239@GamePhase
$LN62@GamePhase:

; 447  : 
; 448  : 			case HEADER_GC_PARTY_UPDATE:
; 449  : 				ret = RecvPartyUpdate();

  003e9	8b ce		 mov	 ecx, esi
  003eb	e8 00 00 00 00	 call	 ?RecvPartyUpdate@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPartyUpdate

; 450  : 				break;

  003f0	e9 8e 01 00 00	 jmp	 $LN239@GamePhase
$LN61@GamePhase:

; 451  : 
; 452  : 			case HEADER_GC_PARTY_REMOVE:
; 453  : 				ret = RecvPartyRemove();

  003f5	8b ce		 mov	 ecx, esi
  003f7	e8 00 00 00 00	 call	 ?RecvPartyRemove@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPartyRemove

; 454  : 				break;

  003fc	e9 82 01 00 00	 jmp	 $LN239@GamePhase
$LN60@GamePhase:

; 455  : 
; 456  : 			case HEADER_GC_PARTY_LINK:
; 457  : 				ret = RecvPartyLink();

  00401	8b ce		 mov	 ecx, esi
  00403	e8 00 00 00 00	 call	 ?RecvPartyLink@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPartyLink

; 458  : 				break;

  00408	e9 76 01 00 00	 jmp	 $LN239@GamePhase
$LN59@GamePhase:

; 459  : 
; 460  : 			case HEADER_GC_PARTY_UNLINK:
; 461  : 				ret = RecvPartyUnlink();

  0040d	8b ce		 mov	 ecx, esi
  0040f	e8 00 00 00 00	 call	 ?RecvPartyUnlink@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPartyUnlink

; 462  : 				break;

  00414	e9 6a 01 00 00	 jmp	 $LN239@GamePhase
$LN58@GamePhase:

; 463  : 
; 464  : 			case HEADER_GC_PARTY_PARAMETER:
; 465  : 				ret = RecvPartyParameter();

  00419	8b ce		 mov	 ecx, esi
  0041b	e8 00 00 00 00	 call	 ?RecvPartyParameter@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPartyParameter

; 466  : 				break;

  00420	e9 5e 01 00 00	 jmp	 $LN239@GamePhase
$LN57@GamePhase:

; 467  : 
; 468  : 			case HEADER_GC_SAFEBOX_SET:
; 469  : 				ret = RecvSafeBoxSetPacket();

  00425	8b ce		 mov	 ecx, esi
  00427	e8 00 00 00 00	 call	 ?RecvSafeBoxSetPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSafeBoxSetPacket

; 470  : 				break;

  0042c	e9 52 01 00 00	 jmp	 $LN239@GamePhase
$LN56@GamePhase:

; 471  : 
; 472  : 			case HEADER_GC_SAFEBOX_DEL:
; 473  : 				ret = RecvSafeBoxDelPacket();

  00431	8b ce		 mov	 ecx, esi
  00433	e8 00 00 00 00	 call	 ?RecvSafeBoxDelPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSafeBoxDelPacket

; 474  : 				break;

  00438	e9 46 01 00 00	 jmp	 $LN239@GamePhase
$LN55@GamePhase:

; 475  : 
; 476  : 			case HEADER_GC_SAFEBOX_WRONG_PASSWORD:
; 477  : 				ret = RecvSafeBoxWrongPasswordPacket();

  0043d	8b ce		 mov	 ecx, esi
  0043f	e8 00 00 00 00	 call	 ?RecvSafeBoxWrongPasswordPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSafeBoxWrongPasswordPacket

; 478  : 				break;

  00444	e9 3a 01 00 00	 jmp	 $LN239@GamePhase
$LN54@GamePhase:

; 479  : 
; 480  : 			case HEADER_GC_SAFEBOX_SIZE:
; 481  : 				ret = RecvSafeBoxSizePacket();

  00449	8b ce		 mov	 ecx, esi
  0044b	e8 00 00 00 00	 call	 ?RecvSafeBoxSizePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSafeBoxSizePacket

; 482  : 				break;

  00450	e9 2e 01 00 00	 jmp	 $LN239@GamePhase
$LN53@GamePhase:

; 483  : 
; 484  : 			case HEADER_GC_SAFEBOX_MONEY_CHANGE:
; 485  : 				ret = RecvSafeBoxMoneyChangePacket();

  00455	8b ce		 mov	 ecx, esi
  00457	e8 00 00 00 00	 call	 ?RecvSafeBoxMoneyChangePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSafeBoxMoneyChangePacket

; 486  : 				break;

  0045c	e9 22 01 00 00	 jmp	 $LN239@GamePhase
$LN52@GamePhase:

; 487  : 
; 488  : 			case HEADER_GC_FISHING:
; 489  : 				ret = RecvFishing();

  00461	8b ce		 mov	 ecx, esi
  00463	e8 00 00 00 00	 call	 ?RecvFishing@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvFishing

; 490  : 				break;

  00468	e9 16 01 00 00	 jmp	 $LN239@GamePhase
$LN51@GamePhase:

; 491  : 
; 492  : 			case HEADER_GC_DUNGEON:
; 493  : 				ret = RecvDungeon();

  0046d	8b ce		 mov	 ecx, esi
  0046f	e8 00 00 00 00	 call	 ?RecvDungeon@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvDungeon

; 494  : 				break;

  00474	e9 0a 01 00 00	 jmp	 $LN239@GamePhase
$LN50@GamePhase:

; 495  : 
; 496  : 			case HEADER_GC_TIME:
; 497  : 				ret = RecvTimePacket();

  00479	8b ce		 mov	 ecx, esi
  0047b	e8 00 00 00 00	 call	 ?RecvTimePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvTimePacket

; 498  : 				break;

  00480	e9 fe 00 00 00	 jmp	 $LN239@GamePhase
$LN49@GamePhase:

; 499  : 
; 500  : 			case HEADER_GC_WALK_MODE:
; 501  : 				ret = RecvWalkModePacket();

  00485	8b ce		 mov	 ecx, esi
  00487	e8 00 00 00 00	 call	 ?RecvWalkModePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvWalkModePacket

; 502  : 				break;

  0048c	e9 f2 00 00 00	 jmp	 $LN239@GamePhase
$LN48@GamePhase:

; 503  : 
; 504  : 			case HEADER_GC_CHANGE_SKILL_GROUP:
; 505  : 				ret = RecvChangeSkillGroupPacket();

  00491	8b ce		 mov	 ecx, esi
  00493	e8 00 00 00 00	 call	 ?RecvChangeSkillGroupPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvChangeSkillGroupPacket

; 506  : 				break;

  00498	e9 e6 00 00 00	 jmp	 $LN239@GamePhase
$LN47@GamePhase:

; 507  : 
; 508  : 			case HEADER_GC_REFINE_INFORMATION:
; 509  : 				ret = RecvRefineInformationPacket();

  0049d	8b ce		 mov	 ecx, esi
  0049f	e8 00 00 00 00	 call	 ?RecvRefineInformationPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvRefineInformationPacket

; 510  : 				break;

  004a4	e9 da 00 00 00	 jmp	 $LN239@GamePhase
$LN46@GamePhase:

; 511  : 
; 512  : 			case HEADER_GC_REFINE_INFORMATION_NEW:
; 513  : 				ret = RecvRefineInformationPacketNew();

  004a9	8b ce		 mov	 ecx, esi
  004ab	e8 00 00 00 00	 call	 ?RecvRefineInformationPacketNew@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvRefineInformationPacketNew

; 514  : 				break;

  004b0	e9 ce 00 00 00	 jmp	 $LN239@GamePhase
$LN45@GamePhase:

; 515  : 
; 516  : 			case HEADER_GC_SEPCIAL_EFFECT:
; 517  : 				ret = RecvSpecialEffect();

  004b5	8b ce		 mov	 ecx, esi
  004b7	e8 00 00 00 00	 call	 ?RecvSpecialEffect@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSpecialEffect

; 518  : 				break;

  004bc	e9 c2 00 00 00	 jmp	 $LN239@GamePhase
$LN44@GamePhase:

; 519  : 
; 520  : 			case HEADER_GC_NPC_POSITION:
; 521  : 				ret = RecvNPCList();

  004c1	8b ce		 mov	 ecx, esi
  004c3	e8 00 00 00 00	 call	 ?RecvNPCList@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvNPCList

; 522  : 				break;

  004c8	e9 b6 00 00 00	 jmp	 $LN239@GamePhase
$LN43@GamePhase:

; 523  : 
; 524  : 			case HEADER_GC_CHANNEL:
; 525  : 				ret = RecvChannelPacket();

  004cd	8b ce		 mov	 ecx, esi
  004cf	e8 00 00 00 00	 call	 ?RecvChannelPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvChannelPacket

; 526  : 				break;

  004d4	e9 aa 00 00 00	 jmp	 $LN239@GamePhase
$LN42@GamePhase:

; 527  : 
; 528  : 			case HEADER_GC_VIEW_EQUIP:
; 529  : 				ret = RecvViewEquipPacket();

  004d9	8b ce		 mov	 ecx, esi
  004db	e8 00 00 00 00	 call	 ?RecvViewEquipPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvViewEquipPacket

; 530  : 				break;

  004e0	e9 9e 00 00 00	 jmp	 $LN239@GamePhase
$LN41@GamePhase:

; 531  : 
; 532  : 			case HEADER_GC_LAND_LIST:
; 533  : 				ret = RecvLandPacket();

  004e5	8b ce		 mov	 ecx, esi
  004e7	e8 00 00 00 00	 call	 ?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvLandPacket

; 534  : 				break;

  004ec	e9 92 00 00 00	 jmp	 $LN239@GamePhase
$LN40@GamePhase:

; 535  : 
; 536  : 			//case HEADER_GC_TARGET_CREATE:
; 537  : 			//	ret = RecvTargetCreatePacket();
; 538  : 			//	break;
; 539  : 
; 540  : 			case HEADER_GC_TARGET_CREATE_NEW:
; 541  : 				ret = RecvTargetCreatePacketNew();

  004f1	8b ce		 mov	 ecx, esi
  004f3	e8 00 00 00 00	 call	 ?RecvTargetCreatePacketNew@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvTargetCreatePacketNew

; 542  : 				break;

  004f8	e9 86 00 00 00	 jmp	 $LN239@GamePhase
$LN39@GamePhase:

; 543  : 
; 544  : 			case HEADER_GC_TARGET_UPDATE:
; 545  : 				ret = RecvTargetUpdatePacket();

  004fd	8b ce		 mov	 ecx, esi
  004ff	e8 00 00 00 00	 call	 ?RecvTargetUpdatePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvTargetUpdatePacket

; 546  : 				break;

  00504	eb 7d		 jmp	 SHORT $LN239@GamePhase
$LN38@GamePhase:

; 547  : 
; 548  : 			case HEADER_GC_TARGET_DELETE:
; 549  : 				ret = RecvTargetDeletePacket();

  00506	8b ce		 mov	 ecx, esi
  00508	e8 00 00 00 00	 call	 ?RecvTargetDeletePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvTargetDeletePacket

; 550  : 				break;

  0050d	eb 74		 jmp	 SHORT $LN239@GamePhase
$LN37@GamePhase:

; 551  : 
; 552  : 			case HEADER_GC_AFFECT_ADD:
; 553  : 				ret = RecvAffectAddPacket();

  0050f	8b ce		 mov	 ecx, esi
  00511	e8 00 00 00 00	 call	 ?RecvAffectAddPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvAffectAddPacket

; 554  : 				break;

  00516	eb 6b		 jmp	 SHORT $LN239@GamePhase
$LN36@GamePhase:

; 555  : 
; 556  : 			case HEADER_GC_AFFECT_REMOVE:
; 557  : 				ret = RecvAffectRemovePacket();

  00518	8b ce		 mov	 ecx, esi
  0051a	e8 00 00 00 00	 call	 ?RecvAffectRemovePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvAffectRemovePacket

; 558  : 				break;

  0051f	eb 62		 jmp	 SHORT $LN239@GamePhase
$LN35@GamePhase:

; 559  : 
; 560  : 			case HEADER_GC_MALL_OPEN:
; 561  : 				ret = RecvMallOpenPacket();

  00521	8b ce		 mov	 ecx, esi
  00523	e8 00 00 00 00	 call	 ?RecvMallOpenPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvMallOpenPacket

; 562  : 				break;

  00528	eb 59		 jmp	 SHORT $LN239@GamePhase
$LN34@GamePhase:

; 563  : 
; 564  : 			case HEADER_GC_MALL_SET:
; 565  : 				ret = RecvMallItemSetPacket();

  0052a	8b ce		 mov	 ecx, esi
  0052c	e8 00 00 00 00	 call	 ?RecvMallItemSetPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvMallItemSetPacket

; 566  : 				break;

  00531	eb 50		 jmp	 SHORT $LN239@GamePhase
$LN33@GamePhase:

; 567  : 
; 568  : 			case HEADER_GC_MALL_DEL:
; 569  : 				ret = RecvMallItemDelPacket();

  00533	8b ce		 mov	 ecx, esi
  00535	e8 00 00 00 00	 call	 ?RecvMallItemDelPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvMallItemDelPacket

; 570  : 				break;

  0053a	eb 47		 jmp	 SHORT $LN239@GamePhase
$LN32@GamePhase:

; 571  : 
; 572  : 			case HEADER_GC_LOVER_INFO:
; 573  : 				ret = RecvLoverInfoPacket();

  0053c	8b ce		 mov	 ecx, esi
  0053e	e8 00 00 00 00	 call	 ?RecvLoverInfoPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvLoverInfoPacket

; 574  : 				break;

  00543	eb 3e		 jmp	 SHORT $LN239@GamePhase
$LN31@GamePhase:

; 575  : 
; 576  : 			case HEADER_GC_LOVE_POINT_UPDATE:
; 577  : 				ret = RecvLovePointUpdatePacket();

  00545	8b ce		 mov	 ecx, esi
  00547	e8 00 00 00 00	 call	 ?RecvLovePointUpdatePacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvLovePointUpdatePacket

; 578  : 				break;

  0054c	eb 35		 jmp	 SHORT $LN239@GamePhase
$LN30@GamePhase:

; 579  : 
; 580  : 			case HEADER_GC_DIG_MOTION:
; 581  : 				ret = RecvDigMotionPacket();

  0054e	8b ce		 mov	 ecx, esi
  00550	e8 00 00 00 00	 call	 ?RecvDigMotionPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvDigMotionPacket

; 582  : 				break;

  00555	eb 2c		 jmp	 SHORT $LN239@GamePhase
$LN23@GamePhase:

; 613  : 				return;
; 614  : 				break;
; 615  : #endif
; 616  : 
; 617  : 			case HEADER_GC_HS_REQUEST:
; 618  : 				ret = RecvHSCheckRequest();

  00557	8b ce		 mov	 ecx, esi
  00559	e8 00 00 00 00	 call	 ?RecvHSCheckRequest@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvHSCheckRequest

; 619  : 				break;

  0055e	eb 23		 jmp	 SHORT $LN239@GamePhase
$LN22@GamePhase:

; 620  : 
; 621  : 			case HEADER_GC_XTRAP_CS1_REQUEST:
; 622  : 				ret = RecvXTrapVerifyRequest();

  00560	8b ce		 mov	 ecx, esi
  00562	e8 00 00 00 00	 call	 ?RecvXTrapVerifyRequest@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvXTrapVerifyRequest

; 623  : 				break;

  00567	eb 1a		 jmp	 SHORT $LN239@GamePhase
$LN21@GamePhase:

; 624  : 
; 625  : 			case HEADER_GC_SPECIFIC_EFFECT:
; 626  : 				ret = RecvSpecificEffect();

  00569	8b ce		 mov	 ecx, esi
  0056b	e8 00 00 00 00	 call	 ?RecvSpecificEffect@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvSpecificEffect

; 627  : 				break;

  00570	eb 11		 jmp	 SHORT $LN239@GamePhase
$LN20@GamePhase:

; 628  : 
; 629  : 			case HEADER_GC_DRAGON_SOUL_REFINE:
; 630  : 				ret = RecvDragonSoulRefine();

  00572	8b ce		 mov	 ecx, esi
  00574	e8 00 00 00 00	 call	 ?RecvDragonSoulRefine@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvDragonSoulRefine

; 631  : 				break;

  00579	eb 08		 jmp	 SHORT $LN239@GamePhase
$LN19@GamePhase:

; 632  : 
; 633  : 			default:
; 634  : 				ret = RecvDefaultPacket(header);

  0057b	51		 push	 ecx
  0057c	8b ce		 mov	 ecx, esi
  0057e	e8 00 00 00 00	 call	 ?RecvDefaultPacket@CPythonNetworkStream@@IAE_NH@Z ; CPythonNetworkStream::RecvDefaultPacket
$LN239@GamePhase:
  00583	8a d8		 mov	 bl, al
  00585	84 db		 test	 bl, bl
  00587	0f 84 c3 00 00
	00		 je	 $LN233@GamePhase

; 211  : 
; 212  :     while (ret)

  0058d	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwRecvCount$1$[esp+52]
  00591	e9 2a fb ff ff	 jmp	 $LL123@GamePhase
$LN113@GamePhase:

; 239  : 
; 240  : 			case HEADER_GC_PHASE:
; 241  : 				ret = RecvPhasePacket();

  00596	8b ce		 mov	 ecx, esi
  00598	e8 00 00 00 00	 call	 ?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPhasePacket

; 786  : 	}	
; 787  : }

  0059d	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  005a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005a8	59		 pop	 ecx
  005a9	5f		 pop	 edi
  005aa	5e		 pop	 esi
  005ab	5b		 pop	 ebx
  005ac	8b e5		 mov	 esp, ebp
  005ae	5d		 pop	 ebp
  005af	c3		 ret	 0
$LN29@GamePhase:

; 583  : 
; 584  : 			case HEADER_GC_HANDSHAKE:
; 585  : 				RecvHandshakePacket();

  005b0	8b ce		 mov	 ecx, esi
  005b2	e8 00 00 00 00	 call	 ?RecvHandshakePacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHandshakePacket

; 786  : 	}	
; 787  : }

  005b7	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  005bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005c2	59		 pop	 ecx
  005c3	5f		 pop	 edi
  005c4	5e		 pop	 esi
  005c5	5b		 pop	 ebx
  005c6	8b e5		 mov	 esp, ebp
  005c8	5d		 pop	 ebp
  005c9	c3		 ret	 0
$LN28@GamePhase:

; 586  : 				return;
; 587  : 				break;
; 588  : 
; 589  : 			case HEADER_GC_HANDSHAKE_OK:
; 590  : 				RecvHandshakeOKPacket();

  005ca	8b ce		 mov	 ecx, esi
  005cc	e8 00 00 00 00	 call	 ?RecvHandshakeOKPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHandshakeOKPacket

; 786  : 	}	
; 787  : }

  005d1	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  005d5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005dc	59		 pop	 ecx
  005dd	5f		 pop	 edi
  005de	5e		 pop	 esi
  005df	5b		 pop	 ebx
  005e0	8b e5		 mov	 esp, ebp
  005e2	5d		 pop	 ebp
  005e3	c3		 ret	 0
$LN27@GamePhase:

; 591  : 				return;
; 592  : 				break;
; 593  : 			
; 594  : 			case HEADER_GC_HYBRIDCRYPT_KEYS:
; 595  : 				RecvHybridCryptKeyPacket();

  005e4	8b ce		 mov	 ecx, esi
  005e6	e8 00 00 00 00	 call	 ?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptKeyPacket

; 786  : 	}	
; 787  : }

  005eb	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  005ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005f6	59		 pop	 ecx
  005f7	5f		 pop	 edi
  005f8	5e		 pop	 esi
  005f9	5b		 pop	 ebx
  005fa	8b e5		 mov	 esp, ebp
  005fc	5d		 pop	 ebp
  005fd	c3		 ret	 0
$LN26@GamePhase:

; 596  : 				return;
; 597  : 				break;
; 598  : 
; 599  : 			case HEADER_GC_HYBRIDCRYPT_SDB:
; 600  : 				RecvHybridCryptSDBPacket();

  005fe	8b ce		 mov	 ecx, esi
  00600	e8 00 00 00 00	 call	 ?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptSDBPacket

; 786  : 	}	
; 787  : }

  00605	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  00609	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00610	59		 pop	 ecx
  00611	5f		 pop	 edi
  00612	5e		 pop	 esi
  00613	5b		 pop	 ebx
  00614	8b e5		 mov	 esp, ebp
  00616	5d		 pop	 ebp
  00617	c3		 ret	 0
$LN25@GamePhase:

; 601  : 				return;
; 602  : 				break;
; 603  : 
; 604  : 
; 605  : #ifdef _IMPROVED_PACKET_ENCRYPTION_
; 606  : 			case HEADER_GC_KEY_AGREEMENT:
; 607  : 				RecvKeyAgreementPacket();

  00618	8b ce		 mov	 ecx, esi
  0061a	e8 00 00 00 00	 call	 ?RecvKeyAgreementPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvKeyAgreementPacket

; 786  : 	}	
; 787  : }

  0061f	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  00623	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0062a	59		 pop	 ecx
  0062b	5f		 pop	 edi
  0062c	5e		 pop	 esi
  0062d	5b		 pop	 ebx
  0062e	8b e5		 mov	 esp, ebp
  00630	5d		 pop	 ebp
  00631	c3		 ret	 0
$LN24@GamePhase:

; 608  : 				return;
; 609  : 				break;
; 610  : 
; 611  : 			case HEADER_GC_KEY_AGREEMENT_COMPLETED:
; 612  : 				RecvKeyAgreementCompletedPacket();

  00632	8b ce		 mov	 ecx, esi
  00634	e8 00 00 00 00	 call	 ?RecvKeyAgreementCompletedPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvKeyAgreementCompletedPacket

; 786  : 	}	
; 787  : }

  00639	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  0063d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00644	59		 pop	 ecx
  00645	5f		 pop	 edi
  00646	5e		 pop	 esi
  00647	5b		 pop	 ebx
  00648	8b e5		 mov	 esp, ebp
  0064a	5d		 pop	 ebp
  0064b	c3		 ret	 0
$LN122@GamePhase:

; 635  : 				break;
; 636  : 		}
; 637  : #ifdef __PERFORMANCE_CHECK__
; 638  : 		DWORD timeEndPacket=timeGetTime();
; 639  : 
; 640  : 		{
; 641  : 			PERF_PacketInfo& rkPacketInfo=kMap_kPacketInfo[header];
; 642  : 			rkPacketInfo.dwCount++;
; 643  : 			rkPacketInfo.dwTime+=timeEndPacket-timeBeginPacket;			
; 644  : 		}
; 645  : 
; 646  : 		{
; 647  : 			PERF_PacketInfo& rkPacketInfo=gs_kPacketTimeAnalyzer.m_kMap_kPacketInfo[header];
; 648  : 			rkPacketInfo.dwCount++;
; 649  : 			rkPacketInfo.dwTime+=timeEndPacket-timeBeginPacket;			
; 650  : 		}
; 651  : #endif
; 652  : 	}
; 653  : 
; 654  : #ifdef __PERFORMANCE_CHECK__
; 655  : 	DWORD timeEndDispatch=timeGetTime();
; 656  : 	
; 657  : 	if (timeEndDispatch-timeBeginDispatch>2)
; 658  : 	{
; 659  : 		static FILE* fp=fopen("perf_dispatch_packet.txt", "w");		
; 660  : 
; 661  : 		fprintf(fp, "delay %d\n", timeEndDispatch-timeBeginDispatch);
; 662  : 		for (std::map<DWORD, PERF_PacketInfo>::iterator i=kMap_kPacketInfo.begin(); i!=kMap_kPacketInfo.end(); ++i)
; 663  : 		{
; 664  : 			if (i->second.dwTime>0)
; 665  : 				fprintf(fp, "header %d: count %d, time %d\n", i->first, i->second.dwCount, i->second.dwTime);
; 666  : 		}
; 667  : 		fputs("=====================================================\n", fp);
; 668  : 		fflush(fp);
; 669  : 	}
; 670  : #endif
; 671  : 
; 672  : 	if (!ret)

  0064c	84 db		 test	 bl, bl
  0064e	75 0b		 jne	 SHORT $LN18@GamePhase
$LN233@GamePhase:

; 673  : 		RecvErrorPacket(header);

  00650	0f b6 c7	 movzx	 eax, bh
  00653	8b ce		 mov	 ecx, esi
  00655	50		 push	 eax
  00656	e8 00 00 00 00	 call	 ?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z ; CPythonNetworkStream::RecvErrorPacket
$LN18@GamePhase:

; 674  : 
; 675  : 	static DWORD s_nextRefreshTime = ELTimer_GetMSec();

  0065b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4IA
  00660	a8 01		 test	 al, 1
  00662	75 22		 jne	 SHORT $LN17@GamePhase
  00664	83 c8 01	 or	 eax, 1
  00667	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4IA, eax
  0066c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 0
  00674	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00679	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
  0067e	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+60], -1
$LN17@GamePhase:

; 676  : 
; 677  : 	DWORD curTime = ELTimer_GetMSec();

  00686	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0068b	8b f8		 mov	 edi, eax

; 678  : 	if (s_nextRefreshTime > curTime)

  0068d	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, edi
  00693	0f 87 5d 03 00
	00		 ja	 $LN1@GamePhase

; 679  : 		return;	
; 680  : 	
; 681  : 	
; 682  : 
; 683  : 	if (m_isRefreshCharacterWnd)

  00699	80 be 11 03 00
	00 00		 cmp	 BYTE PTR [esi+785], 0
  006a0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__Py_BuildValue
  006a6	74 30		 je	 SHORT $LN15@GamePhase

; 684  : 	{
; 685  : 		m_isRefreshCharacterWnd=false;
; 686  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshCharacter", Py_BuildValue("()"));

  006a8	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  006ad	c6 86 11 03 00
	00 00		 mov	 BYTE PTR [esi+785], 0
  006b4	ff d3		 call	 ebx
  006b6	83 c4 04	 add	 esp, 4
  006b9	50		 push	 eax
  006ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HFALJDHO@RefreshCharacter?$AA@
  006bf	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  006c5	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 687  : 		s_nextRefreshTime = curTime + 300;

  006ca	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  006d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  006d3	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN15@GamePhase:

; 688  : 	}
; 689  : 
; 690  : 	if (m_isRefreshEquipmentWnd)

  006d8	80 be 12 03 00
	00 00		 cmp	 BYTE PTR [esi+786], 0
  006df	74 30		 je	 SHORT $LN14@GamePhase

; 691  : 	{
; 692  : 		m_isRefreshEquipmentWnd=false;
; 693  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshEquipment", Py_BuildValue("()"));

  006e1	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  006e6	c6 86 12 03 00
	00 00		 mov	 BYTE PTR [esi+786], 0
  006ed	ff d3		 call	 ebx
  006ef	83 c4 04	 add	 esp, 4
  006f2	50		 push	 eax
  006f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CAEOPHDE@RefreshEquipment?$AA@
  006f8	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  006fe	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 694  : 		s_nextRefreshTime = curTime + 300;

  00703	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  00709	83 c4 0c	 add	 esp, 12			; 0000000cH
  0070c	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN14@GamePhase:

; 695  : 	}
; 696  : 
; 697  : 	if (m_isRefreshInventoryWnd)

  00711	80 be 13 03 00
	00 00		 cmp	 BYTE PTR [esi+787], 0
  00718	74 30		 je	 SHORT $LN13@GamePhase

; 698  : 	{
; 699  : 		m_isRefreshInventoryWnd=false;
; 700  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshInventory", Py_BuildValue("()"));

  0071a	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0071f	c6 86 13 03 00
	00 00		 mov	 BYTE PTR [esi+787], 0
  00726	ff d3		 call	 ebx
  00728	83 c4 04	 add	 esp, 4
  0072b	50		 push	 eax
  0072c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JLCHKFKI@RefreshInventory?$AA@
  00731	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00737	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 701  : 		s_nextRefreshTime = curTime + 300;

  0073c	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  00742	83 c4 0c	 add	 esp, 12			; 0000000cH
  00745	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN13@GamePhase:

; 702  : 	}
; 703  : 
; 704  : 	if (m_isRefreshExchangeWnd)

  0074a	80 be 14 03 00
	00 00		 cmp	 BYTE PTR [esi+788], 0
  00751	74 30		 je	 SHORT $LN12@GamePhase

; 705  : 	{
; 706  : 		m_isRefreshExchangeWnd=false;
; 707  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshExchange", Py_BuildValue("()"));

  00753	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00758	c6 86 14 03 00
	00 00		 mov	 BYTE PTR [esi+788], 0
  0075f	ff d3		 call	 ebx
  00761	83 c4 04	 add	 esp, 4
  00764	50		 push	 eax
  00765	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JECEPFD@RefreshExchange?$AA@
  0076a	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00770	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 708  : 		s_nextRefreshTime = curTime + 300;

  00775	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  0077b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0077e	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN12@GamePhase:

; 709  : 	}
; 710  : 
; 711  : 	if (m_isRefreshSkillWnd)

  00783	80 be 15 03 00
	00 00		 cmp	 BYTE PTR [esi+789], 0
  0078a	74 30		 je	 SHORT $LN11@GamePhase

; 712  : 	{
; 713  : 		m_isRefreshSkillWnd=false;
; 714  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshSkill", Py_BuildValue("()"));

  0078c	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00791	c6 86 15 03 00
	00 00		 mov	 BYTE PTR [esi+789], 0
  00798	ff d3		 call	 ebx
  0079a	83 c4 04	 add	 esp, 4
  0079d	50		 push	 eax
  0079e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EFFAOLPI@RefreshSkill?$AA@
  007a3	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  007a9	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 715  : 		s_nextRefreshTime = curTime + 300;

  007ae	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  007b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  007b7	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN11@GamePhase:

; 716  : 	}
; 717  : 
; 718  : 	if (m_isRefreshSafeboxWnd)

  007bc	80 be 16 03 00
	00 00		 cmp	 BYTE PTR [esi+790], 0
  007c3	74 30		 je	 SHORT $LN10@GamePhase

; 719  : 	{
; 720  : 		m_isRefreshSafeboxWnd=false;
; 721  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshSafebox", Py_BuildValue("()"));

  007c5	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  007ca	c6 86 16 03 00
	00 00		 mov	 BYTE PTR [esi+790], 0
  007d1	ff d3		 call	 ebx
  007d3	83 c4 04	 add	 esp, 4
  007d6	50		 push	 eax
  007d7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PHDJJCCP@RefreshSafebox?$AA@
  007dc	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  007e2	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 722  : 		s_nextRefreshTime = curTime + 300;

  007e7	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  007ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  007f0	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN10@GamePhase:

; 723  : 	}
; 724  : 
; 725  : 	if (m_isRefreshMallWnd)

  007f5	80 be 17 03 00
	00 00		 cmp	 BYTE PTR [esi+791], 0
  007fc	74 30		 je	 SHORT $LN9@GamePhase

; 726  : 	{
; 727  : 		m_isRefreshMallWnd=false;
; 728  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshMall", Py_BuildValue("()"));

  007fe	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00803	c6 86 17 03 00
	00 00		 mov	 BYTE PTR [esi+791], 0
  0080a	ff d3		 call	 ebx
  0080c	83 c4 04	 add	 esp, 4
  0080f	50		 push	 eax
  00810	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HNBFKLDC@RefreshMall?$AA@
  00815	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0081b	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 729  : 		s_nextRefreshTime = curTime + 300;

  00820	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  00826	83 c4 0c	 add	 esp, 12			; 0000000cH
  00829	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN9@GamePhase:

; 730  : 	}
; 731  : 
; 732  : 	if (m_isRefreshStatus)

  0082e	80 be 10 03 00
	00 00		 cmp	 BYTE PTR [esi+784], 0
  00835	74 30		 je	 SHORT $LN8@GamePhase

; 733  : 	{
; 734  : 		m_isRefreshStatus=false;
; 735  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshStatus", Py_BuildValue("()"));

  00837	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0083c	c6 86 10 03 00
	00 00		 mov	 BYTE PTR [esi+784], 0
  00843	ff d3		 call	 ebx
  00845	83 c4 04	 add	 esp, 4
  00848	50		 push	 eax
  00849	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PDJLBMPA@RefreshStatus?$AA@
  0084e	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00854	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 736  : 		s_nextRefreshTime = curTime + 300;

  00859	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  0085f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00862	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN8@GamePhase:

; 737  : 	}
; 738  : 
; 739  : 	if (m_isRefreshMessengerWnd)

  00867	80 be 18 03 00
	00 00		 cmp	 BYTE PTR [esi+792], 0
  0086e	74 30		 je	 SHORT $LN7@GamePhase

; 740  : 	{
; 741  : 		m_isRefreshMessengerWnd=false;
; 742  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshMessenger", Py_BuildValue("()"));

  00870	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00875	c6 86 18 03 00
	00 00		 mov	 BYTE PTR [esi+792], 0
  0087c	ff d3		 call	 ebx
  0087e	83 c4 04	 add	 esp, 4
  00881	50		 push	 eax
  00882	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CDMJAHKO@RefreshMessenger?$AA@
  00887	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0088d	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 743  : 		s_nextRefreshTime = curTime + 300;

  00892	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  00898	83 c4 0c	 add	 esp, 12			; 0000000cH
  0089b	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN7@GamePhase:

; 744  : 	}
; 745  : 
; 746  : 	if (m_isRefreshGuildWndInfoPage)

  008a0	80 be 19 03 00
	00 00		 cmp	 BYTE PTR [esi+793], 0
  008a7	74 30		 je	 SHORT $LN6@GamePhase

; 747  : 	{
; 748  : 		m_isRefreshGuildWndInfoPage=false;
; 749  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildInfoPage", Py_BuildValue("()"));

  008a9	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  008ae	c6 86 19 03 00
	00 00		 mov	 BYTE PTR [esi+793], 0
  008b5	ff d3		 call	 ebx
  008b7	83 c4 04	 add	 esp, 4
  008ba	50		 push	 eax
  008bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NLJDKFFK@RefreshGuildInfoPage?$AA@
  008c0	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  008c6	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 750  : 		s_nextRefreshTime = curTime + 300;

  008cb	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  008d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  008d4	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN6@GamePhase:

; 751  : 	}
; 752  : 
; 753  : 	if (m_isRefreshGuildWndBoardPage)

  008d9	80 be 1a 03 00
	00 00		 cmp	 BYTE PTR [esi+794], 0
  008e0	74 30		 je	 SHORT $LN5@GamePhase

; 754  : 	{
; 755  : 		m_isRefreshGuildWndBoardPage=false;
; 756  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildBoardPage", Py_BuildValue("()"));

  008e2	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  008e7	c6 86 1a 03 00
	00 00		 mov	 BYTE PTR [esi+794], 0
  008ee	ff d3		 call	 ebx
  008f0	83 c4 04	 add	 esp, 4
  008f3	50		 push	 eax
  008f4	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FFPNPADB@RefreshGuildBoardPage?$AA@
  008f9	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  008ff	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 757  : 		s_nextRefreshTime = curTime + 300;

  00904	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  0090a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0090d	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN5@GamePhase:

; 758  : 	}
; 759  : 
; 760  : 	if (m_isRefreshGuildWndMemberPage)

  00912	80 be 1b 03 00
	00 00		 cmp	 BYTE PTR [esi+795], 0
  00919	74 30		 je	 SHORT $LN4@GamePhase

; 761  : 	{
; 762  : 		m_isRefreshGuildWndMemberPage=false;
; 763  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildMemberPage", Py_BuildValue("()"));

  0091b	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00920	c6 86 1b 03 00
	00 00		 mov	 BYTE PTR [esi+795], 0
  00927	ff d3		 call	 ebx
  00929	83 c4 04	 add	 esp, 4
  0092c	50		 push	 eax
  0092d	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BOJHBBF@RefreshGuildMemberPage?$AA@
  00932	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00938	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 764  : 		s_nextRefreshTime = curTime + 300;

  0093d	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  00943	83 c4 0c	 add	 esp, 12			; 0000000cH
  00946	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN4@GamePhase:

; 765  : 	}
; 766  : 
; 767  : 	if (m_isRefreshGuildWndMemberPageGradeComboBox)

  0094b	80 be 1c 03 00
	00 00		 cmp	 BYTE PTR [esi+796], 0
  00952	74 30		 je	 SHORT $LN3@GamePhase

; 768  : 	{
; 769  : 		m_isRefreshGuildWndMemberPageGradeComboBox=false;
; 770  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildMemberPageGradeComboBox", Py_BuildValue("()"));

  00954	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00959	c6 86 1c 03 00
	00 00		 mov	 BYTE PTR [esi+796], 0
  00960	ff d3		 call	 ebx
  00962	83 c4 04	 add	 esp, 4
  00965	50		 push	 eax
  00966	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@PAAOLBDB@RefreshGuildMemberPageGradeCombo@
  0096b	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00971	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 771  : 		s_nextRefreshTime = curTime + 300;

  00976	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  0097c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0097f	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN3@GamePhase:

; 772  : 	}
; 773  : 
; 774  : 	if (m_isRefreshGuildWndSkillPage)

  00984	80 be 1d 03 00
	00 00		 cmp	 BYTE PTR [esi+797], 0
  0098b	74 30		 je	 SHORT $LN2@GamePhase

; 775  : 	{
; 776  : 		m_isRefreshGuildWndSkillPage=false;
; 777  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildSkillPage", Py_BuildValue("()"));

  0098d	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00992	c6 86 1d 03 00
	00 00		 mov	 BYTE PTR [esi+797], 0
  00999	ff d3		 call	 ebx
  0099b	83 c4 04	 add	 esp, 4
  0099e	50		 push	 eax
  0099f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MICKDFKA@RefreshGuildSkillPage?$AA@
  009a4	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  009aa	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 778  : 		s_nextRefreshTime = curTime + 300;

  009af	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  009b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  009b8	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN2@GamePhase:

; 779  : 	}
; 780  : 
; 781  : 	if (m_isRefreshGuildWndGradePage)

  009bd	80 be 1e 03 00
	00 00		 cmp	 BYTE PTR [esi+798], 0
  009c4	74 30		 je	 SHORT $LN1@GamePhase

; 782  : 	{
; 783  : 		m_isRefreshGuildWndGradePage=false;
; 784  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGradePage", Py_BuildValue("()"));

  009c6	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  009cb	c6 86 1e 03 00
	00 00		 mov	 BYTE PTR [esi+798], 0
  009d2	ff d3		 call	 ebx
  009d4	83 c4 04	 add	 esp, 4
  009d7	50		 push	 eax
  009d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CBAJOEAC@RefreshGuildGradePage?$AA@
  009dd	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  009e3	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 785  : 		s_nextRefreshTime = curTime + 300;

  009e8	8d 87 2c 01 00
	00		 lea	 eax, DWORD PTR [edi+300]
  009ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  009f1	a3 00 00 00 00	 mov	 DWORD PTR ?s_nextRefreshTime@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4KA, eax
$LN1@GamePhase:

; 786  : 	}	
; 787  : }

  009f6	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  009fa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00a01	59		 pop	 ecx
  00a02	5f		 pop	 edi
  00a03	5e		 pop	 esi
  00a04	5b		 pop	 ebx
  00a05	8b e5		 mov	 esp, ebp
  00a07	5d		 pop	 ebp
  00a08	c3		 ret	 0
  00a09	8d 49 00	 npad	 3
$LN240@GamePhase:
  00a0c	00 00 00 00	 DD	 $LN110@GamePhase
  00a10	00 00 00 00	 DD	 $LN105@GamePhase
  00a14	00 00 00 00	 DD	 $LN100@GamePhase
  00a18	00 00 00 00	 DD	 $LN104@GamePhase
  00a1c	00 00 00 00	 DD	 $LN103@GamePhase
  00a20	00 00 00 00	 DD	 $LN98@GamePhase
  00a24	00 00 00 00	 DD	 $LN97@GamePhase
  00a28	00 00 00 00	 DD	 $LN72@GamePhase
  00a2c	00 00 00 00	 DD	 $LN96@GamePhase
  00a30	00 00 00 00	 DD	 $LN73@GamePhase
  00a34	00 00 00 00	 DD	 $LN107@GamePhase
  00a38	00 00 00 00	 DD	 $LN95@GamePhase
  00a3c	00 00 00 00	 DD	 $LN94@GamePhase
  00a40	00 00 00 00	 DD	 $LN93@GamePhase
  00a44	00 00 00 00	 DD	 $LN92@GamePhase
  00a48	00 00 00 00	 DD	 $LN91@GamePhase
  00a4c	00 00 00 00	 DD	 $LN90@GamePhase
  00a50	00 00 00 00	 DD	 $LN88@GamePhase
  00a54	00 00 00 00	 DD	 $LN87@GamePhase
  00a58	00 00 00 00	 DD	 $LN86@GamePhase
  00a5c	00 00 00 00	 DD	 $LN89@GamePhase
  00a60	00 00 00 00	 DD	 $LN101@GamePhase
  00a64	00 00 00 00	 DD	 $LN85@GamePhase
  00a68	00 00 00 00	 DD	 $LN84@GamePhase
  00a6c	00 00 00 00	 DD	 $LN83@GamePhase
  00a70	00 00 00 00	 DD	 $LN111@GamePhase
  00a74	00 00 00 00	 DD	 $LN112@GamePhase
  00a78	00 00 00 00	 DD	 $LN82@GamePhase
  00a7c	00 00 00 00	 DD	 $LN99@GamePhase
  00a80	00 00 00 00	 DD	 $LN79@GamePhase
  00a84	00 00 00 00	 DD	 $LN78@GamePhase
  00a88	00 00 00 00	 DD	 $LN77@GamePhase
  00a8c	00 00 00 00	 DD	 $LN74@GamePhase
  00a90	00 00 00 00	 DD	 $LN102@GamePhase
  00a94	00 00 00 00	 DD	 $LN76@GamePhase
  00a98	00 00 00 00	 DD	 $LN114@GamePhase
  00a9c	00 00 00 00	 DD	 $LN69@GamePhase
  00aa0	00 00 00 00	 DD	 $LN71@GamePhase
  00aa4	00 00 00 00	 DD	 $LN70@GamePhase
  00aa8	00 00 00 00	 DD	 $LN68@GamePhase
  00aac	00 00 00 00	 DD	 $LN66@GamePhase
  00ab0	00 00 00 00	 DD	 $LN65@GamePhase
  00ab4	00 00 00 00	 DD	 $LN67@GamePhase
  00ab8	00 00 00 00	 DD	 $LN64@GamePhase
  00abc	00 00 00 00	 DD	 $LN63@GamePhase
  00ac0	00 00 00 00	 DD	 $LN62@GamePhase
  00ac4	00 00 00 00	 DD	 $LN61@GamePhase
  00ac8	00 00 00 00	 DD	 $LN81@GamePhase
  00acc	00 00 00 00	 DD	 $LN80@GamePhase
  00ad0	00 00 00 00	 DD	 $LN58@GamePhase
  00ad4	00 00 00 00	 DD	 $LN53@GamePhase
  00ad8	00 00 00 00	 DD	 $LN57@GamePhase
  00adc	00 00 00 00	 DD	 $LN56@GamePhase
  00ae0	00 00 00 00	 DD	 $LN55@GamePhase
  00ae4	00 00 00 00	 DD	 $LN54@GamePhase
  00ae8	00 00 00 00	 DD	 $LN52@GamePhase
  00aec	00 00 00 00	 DD	 $LN60@GamePhase
  00af0	00 00 00 00	 DD	 $LN59@GamePhase
  00af4	00 00 00 00	 DD	 $LN47@GamePhase
  00af8	00 00 00 00	 DD	 $LN117@GamePhase
  00afc	00 00 00 00	 DD	 $LN116@GamePhase
  00b00	00 00 00 00	 DD	 $LN115@GamePhase
  00b04	00 00 00 00	 DD	 $LN42@GamePhase
  00b08	00 00 00 00	 DD	 $LN50@GamePhase
  00b0c	00 00 00 00	 DD	 $LN51@GamePhase
  00b10	00 00 00 00	 DD	 $LN49@GamePhase
  00b14	00 00 00 00	 DD	 $LN48@GamePhase
  00b18	00 00 00 00	 DD	 $LN45@GamePhase
  00b1c	00 00 00 00	 DD	 $LN44@GamePhase
  00b20	00 00 00 00	 DD	 $LN106@GamePhase
  00b24	00 00 00 00	 DD	 $LN46@GamePhase
  00b28	00 00 00 00	 DD	 $LN108@GamePhase
  00b2c	00 00 00 00	 DD	 $LN43@GamePhase
  00b30	00 00 00 00	 DD	 $LN35@GamePhase
  00b34	00 00 00 00	 DD	 $LN39@GamePhase
  00b38	00 00 00 00	 DD	 $LN38@GamePhase
  00b3c	00 00 00 00	 DD	 $LN40@GamePhase
  00b40	00 00 00 00	 DD	 $LN37@GamePhase
  00b44	00 00 00 00	 DD	 $LN36@GamePhase
  00b48	00 00 00 00	 DD	 $LN34@GamePhase
  00b4c	00 00 00 00	 DD	 $LN33@GamePhase
  00b50	00 00 00 00	 DD	 $LN41@GamePhase
  00b54	00 00 00 00	 DD	 $LN32@GamePhase
  00b58	00 00 00 00	 DD	 $LN31@GamePhase
  00b5c	00 00 00 00	 DD	 $LN30@GamePhase
  00b60	00 00 00 00	 DD	 $LN75@GamePhase
  00b64	00 00 00 00	 DD	 $LN109@GamePhase
  00b68	00 00 00 00	 DD	 $LN27@GamePhase
  00b6c	00 00 00 00	 DD	 $LN26@GamePhase
  00b70	00 00 00 00	 DD	 $LN23@GamePhase
  00b74	00 00 00 00	 DD	 $LN22@GamePhase
  00b78	00 00 00 00	 DD	 $LN21@GamePhase
  00b7c	00 00 00 00	 DD	 $LN20@GamePhase
  00b80	00 00 00 00	 DD	 $LN24@GamePhase
  00b84	00 00 00 00	 DD	 $LN25@GamePhase
  00b88	00 00 00 00	 DD	 $LN28@GamePhase
  00b8c	00 00 00 00	 DD	 $LN113@GamePhase
  00b90	00 00 00 00	 DD	 $LN29@GamePhase
  00b94	00 00 00 00	 DD	 $LN19@GamePhase
$LN235@GamePhase:
  00b98	00		 DB	 0
  00b99	01		 DB	 1
  00b9a	02		 DB	 2
  00b9b	03		 DB	 3
  00b9c	04		 DB	 4
  00b9d	62		 DB	 98			; 00000062H
  00b9e	62		 DB	 98			; 00000062H
  00b9f	62		 DB	 98			; 00000062H
  00ba0	62		 DB	 98			; 00000062H
  00ba1	62		 DB	 98			; 00000062H
  00ba2	62		 DB	 98			; 00000062H
  00ba3	62		 DB	 98			; 00000062H
  00ba4	05		 DB	 5
  00ba5	06		 DB	 6
  00ba6	62		 DB	 98			; 00000062H
  00ba7	07		 DB	 7
  00ba8	08		 DB	 8
  00ba9	09		 DB	 9
  00baa	0a		 DB	 10			; 0000000aH
  00bab	0b		 DB	 11			; 0000000bH
  00bac	0c		 DB	 12			; 0000000cH
  00bad	0d		 DB	 13			; 0000000dH
  00bae	62		 DB	 98			; 00000062H
  00baf	62		 DB	 98			; 00000062H
  00bb0	0e		 DB	 14			; 0000000eH
  00bb1	0f		 DB	 15			; 0000000fH
  00bb2	10		 DB	 16			; 00000010H
  00bb3	11		 DB	 17			; 00000011H
  00bb4	12		 DB	 18			; 00000012H
  00bb5	13		 DB	 19			; 00000013H
  00bb6	14		 DB	 20			; 00000014H
  00bb7	62		 DB	 98			; 00000062H
  00bb8	62		 DB	 98			; 00000062H
  00bb9	15		 DB	 21			; 00000015H
  00bba	62		 DB	 98			; 00000062H
  00bbb	16		 DB	 22			; 00000016H
  00bbc	62		 DB	 98			; 00000062H
  00bbd	17		 DB	 23			; 00000017H
  00bbe	18		 DB	 24			; 00000018H
  00bbf	19		 DB	 25			; 00000019H
  00bc0	1a		 DB	 26			; 0000001aH
  00bc1	1b		 DB	 27			; 0000001bH
  00bc2	1c		 DB	 28			; 0000001cH
  00bc3	1d		 DB	 29			; 0000001dH
  00bc4	1e		 DB	 30			; 0000001eH
  00bc5	1f		 DB	 31			; 0000001fH
  00bc6	62		 DB	 98			; 00000062H
  00bc7	62		 DB	 98			; 00000062H
  00bc8	62		 DB	 98			; 00000062H
  00bc9	62		 DB	 98			; 00000062H
  00bca	62		 DB	 98			; 00000062H
  00bcb	62		 DB	 98			; 00000062H
  00bcc	62		 DB	 98			; 00000062H
  00bcd	62		 DB	 98			; 00000062H
  00bce	62		 DB	 98			; 00000062H
  00bcf	62		 DB	 98			; 00000062H
  00bd0	62		 DB	 98			; 00000062H
  00bd1	62		 DB	 98			; 00000062H
  00bd2	62		 DB	 98			; 00000062H
  00bd3	62		 DB	 98			; 00000062H
  00bd4	20		 DB	 32			; 00000020H
  00bd5	21		 DB	 33			; 00000021H
  00bd6	22		 DB	 34			; 00000022H
  00bd7	62		 DB	 98			; 00000062H
  00bd8	23		 DB	 35			; 00000023H
  00bd9	62		 DB	 98			; 00000062H
  00bda	62		 DB	 98			; 00000062H
  00bdb	62		 DB	 98			; 00000062H
  00bdc	24		 DB	 36			; 00000024H
  00bdd	25		 DB	 37			; 00000025H
  00bde	26		 DB	 38			; 00000026H
  00bdf	27		 DB	 39			; 00000027H
  00be0	62		 DB	 98			; 00000062H
  00be1	28		 DB	 40			; 00000028H
  00be2	29		 DB	 41			; 00000029H
  00be3	2a		 DB	 42			; 0000002aH
  00be4	2b		 DB	 43			; 0000002bH
  00be5	2c		 DB	 44			; 0000002cH
  00be6	2d		 DB	 45			; 0000002dH
  00be7	2e		 DB	 46			; 0000002eH
  00be8	2f		 DB	 47			; 0000002fH
  00be9	30		 DB	 48			; 00000030H
  00bea	31		 DB	 49			; 00000031H
  00beb	32		 DB	 50			; 00000032H
  00bec	33		 DB	 51			; 00000033H
  00bed	34		 DB	 52			; 00000034H
  00bee	35		 DB	 53			; 00000035H
  00bef	36		 DB	 54			; 00000036H
  00bf0	37		 DB	 55			; 00000037H
  00bf1	62		 DB	 98			; 00000062H
  00bf2	38		 DB	 56			; 00000038H
  00bf3	39		 DB	 57			; 00000039H
  00bf4	62		 DB	 98			; 00000062H
  00bf5	62		 DB	 98			; 00000062H
  00bf6	3a		 DB	 58			; 0000003aH
  00bf7	3b		 DB	 59			; 0000003bH
  00bf8	3c		 DB	 60			; 0000003cH
  00bf9	3d		 DB	 61			; 0000003dH
  00bfa	3e		 DB	 62			; 0000003eH
  00bfb	62		 DB	 98			; 00000062H
  00bfc	62		 DB	 98			; 00000062H
  00bfd	62		 DB	 98			; 00000062H
  00bfe	62		 DB	 98			; 00000062H
  00bff	62		 DB	 98			; 00000062H
  00c00	62		 DB	 98			; 00000062H
  00c01	3f		 DB	 63			; 0000003fH
  00c02	62		 DB	 98			; 00000062H
  00c03	62		 DB	 98			; 00000062H
  00c04	62		 DB	 98			; 00000062H
  00c05	40		 DB	 64			; 00000040H
  00c06	41		 DB	 65			; 00000041H
  00c07	42		 DB	 66			; 00000042H
  00c08	62		 DB	 98			; 00000062H
  00c09	43		 DB	 67			; 00000043H
  00c0a	44		 DB	 68			; 00000044H
  00c0b	62		 DB	 98			; 00000062H
  00c0c	45		 DB	 69			; 00000045H
  00c0d	62		 DB	 98			; 00000062H
  00c0e	46		 DB	 70			; 00000046H
  00c0f	47		 DB	 71			; 00000047H
  00c10	48		 DB	 72			; 00000048H
  00c11	49		 DB	 73			; 00000049H
  00c12	4a		 DB	 74			; 0000004aH
  00c13	4b		 DB	 75			; 0000004bH
  00c14	4c		 DB	 76			; 0000004cH
  00c15	4d		 DB	 77			; 0000004dH
  00c16	4e		 DB	 78			; 0000004eH
  00c17	4f		 DB	 79			; 0000004fH
  00c18	50		 DB	 80			; 00000050H
  00c19	51		 DB	 81			; 00000051H
  00c1a	52		 DB	 82			; 00000052H
  00c1b	53		 DB	 83			; 00000053H
  00c1c	62		 DB	 98			; 00000062H
  00c1d	54		 DB	 84			; 00000054H
  00c1e	55		 DB	 85			; 00000055H
  00c1f	56		 DB	 86			; 00000056H
  00c20	62		 DB	 98			; 00000062H
  00c21	62		 DB	 98			; 00000062H
  00c22	62		 DB	 98			; 00000062H
  00c23	62		 DB	 98			; 00000062H
  00c24	62		 DB	 98			; 00000062H
  00c25	62		 DB	 98			; 00000062H
  00c26	62		 DB	 98			; 00000062H
  00c27	62		 DB	 98			; 00000062H
  00c28	62		 DB	 98			; 00000062H
  00c29	62		 DB	 98			; 00000062H
  00c2a	62		 DB	 98			; 00000062H
  00c2b	62		 DB	 98			; 00000062H
  00c2c	62		 DB	 98			; 00000062H
  00c2d	62		 DB	 98			; 00000062H
  00c2e	62		 DB	 98			; 00000062H
  00c2f	57		 DB	 87			; 00000057H
  00c30	58		 DB	 88			; 00000058H
  00c31	62		 DB	 98			; 00000062H
  00c32	62		 DB	 98			; 00000062H
  00c33	62		 DB	 98			; 00000062H
  00c34	62		 DB	 98			; 00000062H
  00c35	62		 DB	 98			; 00000062H
  00c36	62		 DB	 98			; 00000062H
  00c37	62		 DB	 98			; 00000062H
  00c38	62		 DB	 98			; 00000062H
  00c39	62		 DB	 98			; 00000062H
  00c3a	62		 DB	 98			; 00000062H
  00c3b	62		 DB	 98			; 00000062H
  00c3c	62		 DB	 98			; 00000062H
  00c3d	62		 DB	 98			; 00000062H
  00c3e	62		 DB	 98			; 00000062H
  00c3f	62		 DB	 98			; 00000062H
  00c40	62		 DB	 98			; 00000062H
  00c41	62		 DB	 98			; 00000062H
  00c42	62		 DB	 98			; 00000062H
  00c43	62		 DB	 98			; 00000062H
  00c44	62		 DB	 98			; 00000062H
  00c45	62		 DB	 98			; 00000062H
  00c46	62		 DB	 98			; 00000062H
  00c47	62		 DB	 98			; 00000062H
  00c48	62		 DB	 98			; 00000062H
  00c49	62		 DB	 98			; 00000062H
  00c4a	62		 DB	 98			; 00000062H
  00c4b	62		 DB	 98			; 00000062H
  00c4c	62		 DB	 98			; 00000062H
  00c4d	62		 DB	 98			; 00000062H
  00c4e	62		 DB	 98			; 00000062H
  00c4f	62		 DB	 98			; 00000062H
  00c50	62		 DB	 98			; 00000062H
  00c51	62		 DB	 98			; 00000062H
  00c52	62		 DB	 98			; 00000062H
  00c53	62		 DB	 98			; 00000062H
  00c54	62		 DB	 98			; 00000062H
  00c55	62		 DB	 98			; 00000062H
  00c56	62		 DB	 98			; 00000062H
  00c57	62		 DB	 98			; 00000062H
  00c58	62		 DB	 98			; 00000062H
  00c59	62		 DB	 98			; 00000062H
  00c5a	62		 DB	 98			; 00000062H
  00c5b	62		 DB	 98			; 00000062H
  00c5c	62		 DB	 98			; 00000062H
  00c5d	62		 DB	 98			; 00000062H
  00c5e	62		 DB	 98			; 00000062H
  00c5f	62		 DB	 98			; 00000062H
  00c60	62		 DB	 98			; 00000062H
  00c61	62		 DB	 98			; 00000062H
  00c62	62		 DB	 98			; 00000062H
  00c63	59		 DB	 89			; 00000059H
  00c64	5a		 DB	 90			; 0000005aH
  00c65	62		 DB	 98			; 00000062H
  00c66	62		 DB	 98			; 00000062H
  00c67	5b		 DB	 91			; 0000005bH
  00c68	5c		 DB	 92			; 0000005cH
  00c69	62		 DB	 98			; 00000062H
  00c6a	62		 DB	 98			; 00000062H
  00c6b	62		 DB	 98			; 00000062H
  00c6c	62		 DB	 98			; 00000062H
  00c6d	62		 DB	 98			; 00000062H
  00c6e	62		 DB	 98			; 00000062H
  00c6f	62		 DB	 98			; 00000062H
  00c70	62		 DB	 98			; 00000062H
  00c71	62		 DB	 98			; 00000062H
  00c72	62		 DB	 98			; 00000062H
  00c73	62		 DB	 98			; 00000062H
  00c74	62		 DB	 98			; 00000062H
  00c75	62		 DB	 98			; 00000062H
  00c76	62		 DB	 98			; 00000062H
  00c77	62		 DB	 98			; 00000062H
  00c78	62		 DB	 98			; 00000062H
  00c79	62		 DB	 98			; 00000062H
  00c7a	62		 DB	 98			; 00000062H
  00c7b	62		 DB	 98			; 00000062H
  00c7c	62		 DB	 98			; 00000062H
  00c7d	62		 DB	 98			; 00000062H
  00c7e	62		 DB	 98			; 00000062H
  00c7f	62		 DB	 98			; 00000062H
  00c80	62		 DB	 98			; 00000062H
  00c81	62		 DB	 98			; 00000062H
  00c82	62		 DB	 98			; 00000062H
  00c83	62		 DB	 98			; 00000062H
  00c84	62		 DB	 98			; 00000062H
  00c85	62		 DB	 98			; 00000062H
  00c86	62		 DB	 98			; 00000062H
  00c87	62		 DB	 98			; 00000062H
  00c88	62		 DB	 98			; 00000062H
  00c89	62		 DB	 98			; 00000062H
  00c8a	62		 DB	 98			; 00000062H
  00c8b	62		 DB	 98			; 00000062H
  00c8c	62		 DB	 98			; 00000062H
  00c8d	62		 DB	 98			; 00000062H
  00c8e	62		 DB	 98			; 00000062H
  00c8f	62		 DB	 98			; 00000062H
  00c90	62		 DB	 98			; 00000062H
  00c91	5d		 DB	 93			; 0000005dH
  00c92	5e		 DB	 94			; 0000005eH
  00c93	5f		 DB	 95			; 0000005fH
  00c94	60		 DB	 96			; 00000060H
  00c95	62		 DB	 98			; 00000062H
  00c96	61		 DB	 97			; 00000061H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GamePhase@CPythonNetworkStream@@IAEXXZ$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?P@??GamePhase@CPythonNetworkStream@@IAEXXZ@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?GamePhase@CPythonNetworkStream@@IAEXXZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 dc	 lea	 eax, DWORD PTR [edx-36]
  00015	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GamePhase@CPythonNetworkStream@@IAEXXZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GamePhase@CPythonNetworkStream@@IAEXXZ ENDP		; CPythonNetworkStream::GamePhase
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z
_TEXT	SEGMENT
_lLocalY$GSCopy$1$ = -48				; size = 4
_$S2$ = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_lLocalX$ = 8						; size = 4
_lLocalY$ = 12						; size = 4
?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z PROC	; CPythonNetworkStream::__ShowMapName, COMDAT
; _this$ = ecx

; 838  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 28	 sub	 esp, 40			; 00000028H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+52], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 44 24 38	 lea	 eax, DWORD PTR __$EHRec$[esp+68]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	8b f9		 mov	 edi, ecx
  00039	8b 45 0c	 mov	 eax, DWORD PTR _lLocalY$[ebp]
  0003c	8b 5d 08	 mov	 ebx, DWORD PTR _lLocalX$[ebp]

; 839  : 	const std::string & c_rstrMapFileName = CPythonBackground::Instance().GetWarpMapName();

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00045	89 44 24 14	 mov	 DWORD PTR _lLocalY$GSCopy$1$[esp+68], eax
  00049	e8 00 00 00 00	 call	 ?GetWarpMapName@CPythonBackground@@QAEPBDXZ ; CPythonBackground::GetWarpMapName
  0004e	8b d0		 mov	 edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00050	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR _$S2$[esp+88], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00058	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _$S2$[esp+84], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00060	c6 44 24 18 00	 mov	 BYTE PTR _$S2$[esp+68], 0

; 523  : 			: _CSTD strlen(_First));

  00065	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00068	75 04		 jne	 SHORT $LN48@ShowMapNam
  0006a	33 c9		 xor	 ecx, ecx
  0006c	eb 0e		 jmp	 SHORT $LN49@ShowMapNam
$LN48@ShowMapNam:
  0006e	8b ca		 mov	 ecx, edx
  00070	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL90@ShowMapNam:
  00073	8a 01		 mov	 al, BYTE PTR [ecx]
  00075	41		 inc	 ecx
  00076	84 c0		 test	 al, al
  00078	75 f9		 jne	 SHORT $LL90@ShowMapNam
  0007a	2b ce		 sub	 ecx, esi
$LN49@ShowMapNam:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0007c	51		 push	 ecx
  0007d	52		 push	 edx
  0007e	8d 4c 24 20	 lea	 ecx, DWORD PTR _$S2$[esp+76]
  00082	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 840  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ShowMapName", Py_BuildValue("(sii)", c_rstrMapFileName.c_str(), lLocalX, lLocalY));

  00087	ff 74 24 14	 push	 DWORD PTR _lLocalY$GSCopy$1$[esp+68]
  0008b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+80], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00093	8d 44 24 1c	 lea	 eax, DWORD PTR _$S2$[esp+72]
  00097	83 7c 24 30 10	 cmp	 DWORD PTR _$S2$[esp+92], 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 840  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ShowMapName", Py_BuildValue("(sii)", c_rstrMapFileName.c_str(), lLocalX, lLocalY));

  0009c	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0009d	0f 43 44 24 20	 cmovae	 eax, DWORD PTR _$S2$[esp+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 840  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ShowMapName", Py_BuildValue("(sii)", c_rstrMapFileName.c_str(), lLocalX, lLocalY));

  000a2	50		 push	 eax
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_05FONOJENF@?$CIsii?$CJ?$AA@
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000ae	50		 push	 eax
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DJFBBLID@ShowMapName?$AA@
  000b4	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  000ba	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000bf	83 c4 1c	 add	 esp, 28			; 0000001cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000c2	83 7c 24 2c 10	 cmp	 DWORD PTR _$S2$[esp+88], 16 ; 00000010H
  000c7	72 0c		 jb	 SHORT $LN78@ShowMapNam
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000c9	ff 74 24 18	 push	 DWORD PTR _$S2$[esp+68]
  000cd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d2	83 c4 04	 add	 esp, 4
$LN78@ShowMapNam:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 841  : }

  000d5	8b 4c 24 38	 mov	 ecx, DWORD PTR __$EHRec$[esp+68]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+52]
  000e8	33 cc		 xor	 ecx, esp
  000ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _$S2$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 cc	 lea	 eax, DWORD PTR [edx-52]
  0000f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__ShowMapName@CPythonNetworkStream@@IAEXJJ@Z ENDP	; CPythonNetworkStream::__ShowMapName
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__LeaveGamePhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__LeaveGamePhase@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__LeaveGamePhase, COMDAT
; _this$ = ecx

; 844  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 845  : 	CInstanceBase::ClearPVPKeySystem();

  00003	e8 00 00 00 00	 call	 ?ClearPVPKeySystem@CInstanceBase@@SAXXZ ; CInstanceBase::ClearPVPKeySystem

; 846  : 
; 847  : 	__ClearNetworkActorManager();

  00008	8b ce		 mov	 ecx, esi
  0000a	e8 00 00 00 00	 call	 ?__ClearNetworkActorManager@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__ClearNetworkActorManager

; 848  : 
; 849  : 	m_bComboSkillFlag = FALSE;
; 850  : 
; 851  : 	IAbstractCharacterManager& rkChrMgr=IAbstractCharacterManager::GetSingleton();

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00015	c6 86 21 79 00
	00 00		 mov	 BYTE PTR [esi+31009], 0

; 852  : 	rkChrMgr.Destroy();

  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	ff 50 04	 call	 DWORD PTR [eax+4]

; 853  : 
; 854  : 	CPythonItem& rkItemMgr=CPythonItem::Instance();
; 855  : 	rkItemMgr.Destroy();

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonItem@@@@0PAVCPythonItem@@A ; CSingleton<CPythonItem>::ms_singleton
  00027	5e		 pop	 esi
  00028	e9 00 00 00 00	 jmp	 ?Destroy@CPythonItem@@QAEXXZ ; CPythonItem::Destroy
?__LeaveGamePhase@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__LeaveGamePhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvObserverAddPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kObserverAddPacket$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
?RecvObserverAddPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvObserverAddPacket, COMDAT
; _this$ = ecx

; 882  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 883  : 	TPacketGCObserverAdd kObserverAddPacket;
; 884  : 	if (!Recv(sizeof(kObserverAddPacket), &kObserverAddPacket))

  00010	8d 45 f0	 lea	 eax, DWORD PTR _kObserverAddPacket$[ebp]
  00013	50		 push	 eax
  00014	6a 09		 push	 9
  00016	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001b	84 c0		 test	 al, al
  0001d	75 0e		 jne	 SHORT $LN1@RecvObserv

; 891  : 
; 892  : 	return true;
; 893  : }

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00022	33 cd		 xor	 ecx, ebp
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN1@RecvObserv:

; 885  : 		return false;
; 886  : 
; 887  : 	CPythonMiniMap::Instance().AddObserver(
; 888  : 		kObserverAddPacket.vid, 
; 889  : 		kObserverAddPacket.x*100.0f, 
; 890  : 		kObserverAddPacket.y*100.0f);

  0002d	0f b7 45 f7	 movzx	 eax, WORD PTR _kObserverAddPacket$[ebp+7]
  00031	ff 75 f1	 push	 DWORD PTR _kObserverAddPacket$[ebp+1]
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0003a	66 0f 6e d8	 movd	 xmm3, eax
  0003e	0f b7 45 f5	 movzx	 eax, WORD PTR _kObserverAddPacket$[ebp+5]
  00042	0f 5b db	 cvtdq2ps xmm3, xmm3
  00045	66 0f 6e d0	 movd	 xmm2, eax
  00049	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@42c80000
  00051	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00054	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@42c80000
  0005c	e8 00 00 00 00	 call	 ?AddObserver@CPythonMiniMap@@QAEXKMM@Z ; CPythonMiniMap::AddObserver

; 891  : 
; 892  : 	return true;
; 893  : }

  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	b0 01		 mov	 al, 1
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?RecvObserverAddPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvObserverAddPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvObserverRemovePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kObserverRemovePacket$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
?RecvObserverRemovePacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvObserverRemovePacket, COMDAT
; _this$ = ecx

; 896  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 897  : 	TPacketGCObserverAdd kObserverRemovePacket;
; 898  : 	if (!Recv(sizeof(kObserverRemovePacket), &kObserverRemovePacket))

  00010	8d 45 f0	 lea	 eax, DWORD PTR _kObserverRemovePacket$[ebp]
  00013	50		 push	 eax
  00014	6a 09		 push	 9
  00016	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001b	84 c0		 test	 al, al
  0001d	75 0e		 jne	 SHORT $LN1@RecvObserv

; 904  : 
; 905  : 	return true;
; 906  : }

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00022	33 cd		 xor	 ecx, ebp
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN1@RecvObserv:

; 899  : 		return false;
; 900  : 
; 901  : 	CPythonMiniMap::Instance().RemoveObserver(
; 902  : 		kObserverRemovePacket.vid
; 903  : 	);

  0002d	ff 75 f1	 push	 DWORD PTR _kObserverRemovePacket$[ebp+1]
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00036	e8 00 00 00 00	 call	 ?RemoveObserver@CPythonMiniMap@@QAEXK@Z ; CPythonMiniMap::RemoveObserver

; 904  : 
; 905  : 	return true;
; 906  : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	b0 01		 mov	 al, 1
  00040	33 cd		 xor	 ecx, ebp
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?RecvObserverRemovePacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvObserverRemovePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvObserverMovePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kObserverMovePacket$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
?RecvObserverMovePacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvObserverMovePacket, COMDAT
; _this$ = ecx

; 909  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 910  : 	TPacketGCObserverMove kObserverMovePacket;
; 911  : 	if (!Recv(sizeof(kObserverMovePacket), &kObserverMovePacket))

  00010	8d 45 f0	 lea	 eax, DWORD PTR _kObserverMovePacket$[ebp]
  00013	50		 push	 eax
  00014	6a 09		 push	 9
  00016	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001b	84 c0		 test	 al, al
  0001d	75 0e		 jne	 SHORT $LN1@RecvObserv

; 918  : 
; 919  : 	return true;
; 920  : }

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00022	33 cd		 xor	 ecx, ebp
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN1@RecvObserv:

; 912  : 		return false;
; 913  : 
; 914  : 	CPythonMiniMap::Instance().MoveObserver(
; 915  : 		kObserverMovePacket.vid, 
; 916  : 		kObserverMovePacket.x*100.0f, 
; 917  : 		kObserverMovePacket.y*100.0f);

  0002d	0f b7 45 f7	 movzx	 eax, WORD PTR _kObserverMovePacket$[ebp+7]
  00031	ff 75 f1	 push	 DWORD PTR _kObserverMovePacket$[ebp+1]
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0003a	66 0f 6e d8	 movd	 xmm3, eax
  0003e	0f b7 45 f5	 movzx	 eax, WORD PTR _kObserverMovePacket$[ebp+5]
  00042	0f 5b db	 cvtdq2ps xmm3, xmm3
  00045	66 0f 6e d0	 movd	 xmm2, eax
  00049	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@42c80000
  00051	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00054	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@42c80000
  0005c	e8 00 00 00 00	 call	 ?MoveObserver@CPythonMiniMap@@QAEXKMM@Z ; CPythonMiniMap::MoveObserver

; 918  : 
; 919  : 	return true;
; 920  : }

  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	b0 01		 mov	 al, 1
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?RecvObserverMovePacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvObserverMovePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvWarpPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kWarpPacket$ = -20					; size = 15
__$ArrayPad$ = -4					; size = 4
?RecvWarpPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvWarpPacket, COMDAT
; _this$ = ecx

; 924  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 925  : 	TPacketGCWarp kWarpPacket;
; 926  : 
; 927  : 	if (!Recv(sizeof(kWarpPacket), &kWarpPacket))

  00011	8d 45 ec	 lea	 eax, DWORD PTR _kWarpPacket$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 0f		 push	 15			; 0000000fH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN1@RecvWarpPa
  00022	5e		 pop	 esi

; 933  : 
; 934  : 	return true;
; 935  : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN1@RecvWarpPa:

; 928  : 		return false;
; 929  : 
; 930  : 	__DirectEnterMode_Set(m_dwSelectedCharacterIndex);

  00031	ff b6 10 79 00
	00		 push	 DWORD PTR [esi+30992]
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?__DirectEnterMode_Set@CPythonNetworkStream@@AAEXI@Z ; CPythonNetworkStream::__DirectEnterMode_Set

; 931  : 	
; 932  : 	CNetworkStream::Connect((DWORD)kWarpPacket.lAddr, kWarpPacket.wPort);

  0003e	0f b7 45 f9	 movzx	 eax, WORD PTR _kWarpPacket$[ebp+13]
  00042	6a 03		 push	 3
  00044	50		 push	 eax
  00045	ff 75 f5	 push	 DWORD PTR _kWarpPacket$[ebp+9]
  00048	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NKHH@Z ; CNetworkStream::Connect

; 933  : 
; 934  : 	return true;
; 935  : }

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00050	b0 01		 mov	 al, 1
  00052	33 cd		 xor	 ecx, ebp
  00054	5e		 pop	 esi
  00055	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?RecvWarpPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvWarpPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvDuelStartPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_rkChrMgr$1$ = -24					; size = 4
_pkInstMain$1$ = -20					; size = 4
_count$1$ = -16						; size = 4
_dwVIDDest$ = -12					; size = 4
_kDuelStartPacket$ = -4					; size = 3
?RecvDuelStartPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvDuelStartPacket, COMDAT
; _this$ = ecx

; 938  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 939  : 	TPacketGCDuelStart kDuelStartPacket;
; 940  : 	if (!Recv(sizeof(kDuelStartPacket), &kDuelStartPacket))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _kDuelStartPacket$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	6a 03		 push	 3
  0000f	8b d9		 mov	 ebx, ecx
  00011	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00016	84 c0		 test	 al, al
  00018	74 32		 je	 SHORT $LN19@RecvDuelSt

; 941  : 		return false;
; 942  : 	
; 943  : 	DWORD count = (kDuelStartPacket.wSize - sizeof(kDuelStartPacket))/sizeof(DWORD);

  0001a	0f b7 75 fd	 movzx	 esi, WORD PTR _kDuelStartPacket$[ebp+1]

; 944  : 
; 945  : 	CPythonCharacterManager & rkChrMgr = CPythonCharacterManager::Instance();

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00023	83 ee 03	 sub	 esi, 3
  00026	c1 ee 02	 shr	 esi, 2

; 946  : 
; 947  : 	CInstanceBase* pkInstMain=rkChrMgr.GetMainInstancePtr();

  00029	8b c8		 mov	 ecx, eax
  0002b	89 75 f0	 mov	 DWORD PTR _count$1$[ebp], esi
  0002e	89 45 e8	 mov	 DWORD PTR _rkChrMgr$1$[ebp], eax
  00031	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  00036	8b f8		 mov	 edi, eax
  00038	89 7d ec	 mov	 DWORD PTR _pkInstMain$1$[ebp], edi

; 948  : 	if (!pkInstMain)

  0003b	85 ff		 test	 edi, edi
  0003d	75 16		 jne	 SHORT $LN6@RecvDuelSt

; 949  : 	{
; 950  : 		TraceError("CPythonNetworkStream::RecvDuelStartPacket - MainCharacter is NULL");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@IHJJGCFB@CPythonNetworkStream?3?3RecvDuelSt@
  00044	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00049	83 c4 04	 add	 esp, 4
$LN19@RecvDuelSt:

; 951  : 		return false;

  0004c	32 c0		 xor	 al, al

; 970  : 
; 971  : 	return true;
; 972  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN6@RecvDuelSt:

; 952  : 	}
; 953  : 	DWORD dwVIDSrc = pkInstMain->GetVirtualID();

  00055	8b cf		 mov	 ecx, edi
  00057	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID

; 954  : 	DWORD dwVIDDest;
; 955  : 
; 956  : 	for ( DWORD i = 0; i < count; i++)

  0005c	85 f6		 test	 esi, esi
  0005e	74 28		 je	 SHORT $LN17@RecvDuelSt

; 952  : 	}
; 953  : 	DWORD dwVIDSrc = pkInstMain->GetVirtualID();

  00060	8b fe		 mov	 edi, esi
  00062	8b f0		 mov	 esi, eax
$LL5@RecvDuelSt:

; 957  : 	{
; 958  : 		Recv(sizeof(dwVIDDest),&dwVIDDest);

  00064	8d 45 f4	 lea	 eax, DWORD PTR _dwVIDDest$[ebp]
  00067	8b cb		 mov	 ecx, ebx
  00069	50		 push	 eax
  0006a	6a 04		 push	 4
  0006c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv

; 959  : 		CInstanceBase::InsertDUELKey(dwVIDSrc,dwVIDDest);

  00071	8b 55 f4	 mov	 edx, DWORD PTR _dwVIDDest$[ebp]
  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?InsertDUELKey@CInstanceBase@@SAXKK@Z ; CInstanceBase::InsertDUELKey
  0007b	4f		 dec	 edi
  0007c	75 e6		 jne	 SHORT $LL5@RecvDuelSt

; 960  : 	}
; 961  : 	
; 962  : 	if(count == 0)

  0007e	8b 75 f0	 mov	 esi, DWORD PTR _count$1$[ebp]
  00081	8b 7d ec	 mov	 edi, DWORD PTR _pkInstMain$1$[ebp]
  00084	85 f6		 test	 esi, esi
  00086	75 04		 jne	 SHORT $LN2@RecvDuelSt
$LN17@RecvDuelSt:

; 963  : 		pkInstMain->SetDuelMode(CInstanceBase::DUEL_CANNOTATTACK);

  00088	6a 01		 push	 1

; 964  : 	else

  0008a	eb 02		 jmp	 SHORT $LN18@RecvDuelSt
$LN2@RecvDuelSt:

; 965  : 		pkInstMain->SetDuelMode(CInstanceBase::DUEL_START);

  0008c	6a 02		 push	 2
$LN18@RecvDuelSt:
  0008e	8b cf		 mov	 ecx, edi
  00090	e8 00 00 00 00	 call	 ?SetDuelMode@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetDuelMode

; 966  : 	
; 967  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));

  00095	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000a0	83 c4 04	 add	 esp, 4
  000a3	50		 push	 eax
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPCBFHE@CloseTargetBoard?$AA@
  000a9	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  000af	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 968  : 	
; 969  : 	rkChrMgr.RefreshAllPCTextTail();

  000b4	8b 4d e8	 mov	 ecx, DWORD PTR _rkChrMgr$1$[ebp]
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ba	e8 00 00 00 00	 call	 ?RefreshAllPCTextTail@CPythonCharacterManager@@QAEXXZ ; CPythonCharacterManager::RefreshAllPCTextTail

; 970  : 
; 971  : 	return true;
; 972  : }

  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	b0 01		 mov	 al, 1
  000c3	5b		 pop	 ebx
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
?RecvDuelStartPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvDuelStartPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPVPPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_dwVictim$1$ = -24					; size = 4
_dwKiller$1$ = -20					; size = 4
_kPVPPacket$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?RecvPVPPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPVPPacket, COMDAT
; _this$ = ecx

; 975  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 976  : 	TPacketGCPVP kPVPPacket;
; 977  : 	if (!Recv(sizeof(kPVPPacket), &kPVPPacket))

  00013	8d 45 f0	 lea	 eax, DWORD PTR _kPVPPacket$[ebp]
  00016	8b d9		 mov	 ebx, ecx
  00018	50		 push	 eax
  00019	6a 0a		 push	 10			; 0000000aH
  0001b	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00020	84 c0		 test	 al, al
  00022	75 11		 jne	 SHORT $LN11@RecvPVPPac

; 1028 : 
; 1029 : 	return true;
; 1030 : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002a	33 cd		 xor	 ecx, ebp
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN11@RecvPVPPac:

; 978  : 		return false;
; 979  : 
; 980  : 	CPythonCharacterManager & rkChrMgr = CPythonCharacterManager::Instance();
; 981  : 	CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 982  : 
; 983  : 	switch (kPVPPacket.bMode)

  00035	0f b6 45 f9	 movzx	 eax, BYTE PTR _kPVPPacket$[ebp+9]
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0003f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00045	83 f8 03	 cmp	 eax, 3
  00048	0f 87 cb 00 00
	00		 ja	 $LN9@RecvPVPPac
  0004e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN20@RecvPVPPac[eax*4]
$LN8@RecvPVPPac:

; 984  : 	{
; 985  : 		case PVP_MODE_AGREE:
; 986  : 			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);

  00055	ff 75 f5	 push	 DWORD PTR _kPVPPacket$[ebp+5]
  00058	ff 75 f1	 push	 DWORD PTR _kPVPPacket$[ebp+1]
  0005b	e8 00 00 00 00	 call	 ?RemovePVPKey@CPythonCharacterManager@@QAEXKK@Z ; CPythonCharacterManager::RemovePVPKey

; 987  : 
; 988  : 			//  (Dst)  
; 989  : 			if (rkPlayer.IsMainCharacterIndex(kPVPPacket.dwVIDDst))

  00060	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00063	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00066	ff 75 f5	 push	 DWORD PTR _kPVPPacket$[ebp+5]
  00069	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0006c	ff d0		 call	 eax
  0006e	84 c0		 test	 al, al
  00070	74 0a		 je	 SHORT $LN7@RecvPVPPac

; 990  : 				rkPlayer.RememberChallengeInstance(kPVPPacket.dwVIDSrc);

  00072	ff 75 f1	 push	 DWORD PTR _kPVPPacket$[ebp+1]
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?RememberChallengeInstance@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RememberChallengeInstance
$LN7@RecvPVPPac:

; 991  : 
; 992  : 			//      
; 993  : 			if (rkPlayer.IsMainCharacterIndex(kPVPPacket.dwVIDSrc))

  0007c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0007f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00082	ff 75 f1	 push	 DWORD PTR _kPVPPacket$[ebp+1]
  00085	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00088	ff d0		 call	 eax
  0008a	84 c0		 test	 al, al
  0008c	0f 84 87 00 00
	00		 je	 $LN9@RecvPVPPac

; 994  : 				rkPlayer.RememberCantFightInstance(kPVPPacket.dwVIDDst);

  00092	ff 75 f5	 push	 DWORD PTR _kPVPPacket$[ebp+5]
  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?RememberCantFightInstance@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RememberCantFightInstance

; 995  : 			break;

  0009c	eb 7b		 jmp	 SHORT $LN9@RecvPVPPac
$LN5@RecvPVPPac:

; 996  : 		case PVP_MODE_REVENGE:
; 997  : 		{
; 998  : 			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);

  0009e	ff 75 f5	 push	 DWORD PTR _kPVPPacket$[ebp+5]
  000a1	ff 75 f1	 push	 DWORD PTR _kPVPPacket$[ebp+1]
  000a4	e8 00 00 00 00	 call	 ?RemovePVPKey@CPythonCharacterManager@@QAEXKK@Z ; CPythonCharacterManager::RemovePVPKey

; 999  : 
; 1000 : 			DWORD dwKiller = kPVPPacket.dwVIDSrc;

  000a9	8b 45 f1	 mov	 eax, DWORD PTR _kPVPPacket$[ebp+1]

; 1001 : 			DWORD dwVictim = kPVPPacket.dwVIDDst;

  000ac	8b 4d f5	 mov	 ecx, DWORD PTR _kPVPPacket$[ebp+5]
  000af	89 45 ec	 mov	 DWORD PTR _dwKiller$1$[ebp], eax

; 1002 : 
; 1003 : 			// (victim)    
; 1004 : 			if (rkPlayer.IsMainCharacterIndex(dwVictim))

  000b2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b5	89 4d e8	 mov	 DWORD PTR _dwVictim$1$[ebp], ecx
  000b8	51		 push	 ecx
  000b9	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000bc	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000bf	ff d0		 call	 eax
  000c1	84 c0		 test	 al, al
  000c3	74 0a		 je	 SHORT $LN4@RecvPVPPac

; 1005 : 				rkPlayer.RememberRevengeInstance(dwKiller);

  000c5	ff 75 ec	 push	 DWORD PTR _dwKiller$1$[ebp]
  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?RememberRevengeInstance@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RememberRevengeInstance
$LN4@RecvPVPPac:

; 1006 : 
; 1007 : 			// (victim)     
; 1008 : 			if (rkPlayer.IsMainCharacterIndex(dwKiller))

  000cf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000d2	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000d5	ff 75 ec	 push	 DWORD PTR _dwKiller$1$[ebp]
  000d8	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000db	ff d0		 call	 eax
  000dd	84 c0		 test	 al, al
  000df	74 38		 je	 SHORT $LN9@RecvPVPPac

; 1009 : 				rkPlayer.RememberCantFightInstance(dwVictim);

  000e1	ff 75 e8	 push	 DWORD PTR _dwVictim$1$[ebp]
  000e4	8b ce		 mov	 ecx, esi
  000e6	e8 00 00 00 00	 call	 ?RememberCantFightInstance@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RememberCantFightInstance

; 1010 : 			break;

  000eb	eb 2c		 jmp	 SHORT $LN9@RecvPVPPac
$LN2@RecvPVPPac:

; 1011 : 		}
; 1012 : 
; 1013 : 		case PVP_MODE_FIGHT:
; 1014 : 			rkChrMgr.InsertPVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);

  000ed	ff 75 f5	 push	 DWORD PTR _kPVPPacket$[ebp+5]
  000f0	ff 75 f1	 push	 DWORD PTR _kPVPPacket$[ebp+1]
  000f3	e8 00 00 00 00	 call	 ?InsertPVPKey@CPythonCharacterManager@@QAEXKK@Z ; CPythonCharacterManager::InsertPVPKey

; 1015 : 			rkPlayer.ForgetInstance(kPVPPacket.dwVIDSrc);
; 1016 : 			rkPlayer.ForgetInstance(kPVPPacket.dwVIDDst);
; 1017 : 			break;

  000f8	eb 0b		 jmp	 SHORT $LN18@RecvPVPPac
$LN1@RecvPVPPac:

; 1018 : 		case PVP_MODE_NONE:
; 1019 : 			rkChrMgr.RemovePVPKey(kPVPPacket.dwVIDSrc, kPVPPacket.dwVIDDst);

  000fa	ff 75 f5	 push	 DWORD PTR _kPVPPacket$[ebp+5]
  000fd	ff 75 f1	 push	 DWORD PTR _kPVPPacket$[ebp+1]
  00100	e8 00 00 00 00	 call	 ?RemovePVPKey@CPythonCharacterManager@@QAEXKK@Z ; CPythonCharacterManager::RemovePVPKey
$LN18@RecvPVPPac:

; 1020 : 			rkPlayer.ForgetInstance(kPVPPacket.dwVIDSrc);

  00105	ff 75 f1	 push	 DWORD PTR _kPVPPacket$[ebp+1]
  00108	8b ce		 mov	 ecx, esi
  0010a	e8 00 00 00 00	 call	 ?ForgetInstance@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::ForgetInstance

; 1021 : 			rkPlayer.ForgetInstance(kPVPPacket.dwVIDDst);

  0010f	ff 75 f5	 push	 DWORD PTR _kPVPPacket$[ebp+5]
  00112	8b ce		 mov	 ecx, esi
  00114	e8 00 00 00 00	 call	 ?ForgetInstance@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::ForgetInstance
$LN9@RecvPVPPac:

; 1022 : 			break;
; 1023 : 	}
; 1024 : 
; 1025 : 	// NOTE : PVP  TargetBoard   .
; 1026 : 	__RefreshTargetBoardByVID(kPVPPacket.dwVIDSrc);

  00119	ff 75 f1	 push	 DWORD PTR _kPVPPacket$[ebp+1]
  0011c	8b cb		 mov	 ecx, ebx
  0011e	e8 00 00 00 00	 call	 ?__RefreshTargetBoardByVID@CPythonNetworkStream@@IAEXK@Z ; CPythonNetworkStream::__RefreshTargetBoardByVID

; 1027 : 	__RefreshTargetBoardByVID(kPVPPacket.dwVIDDst);

  00123	ff 75 f5	 push	 DWORD PTR _kPVPPacket$[ebp+5]
  00126	8b cb		 mov	 ecx, ebx
  00128	e8 00 00 00 00	 call	 ?__RefreshTargetBoardByVID@CPythonNetworkStream@@IAEXK@Z ; CPythonNetworkStream::__RefreshTargetBoardByVID

; 1028 : 
; 1029 : 	return true;
; 1030 : }

  0012d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00130	b0 01		 mov	 al, 1
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	33 cd		 xor	 ecx, ebp
  00136	5b		 pop	 ebx
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
$LN20@RecvPVPPac:
  00140	00 00 00 00	 DD	 $LN1@RecvPVPPac
  00144	00 00 00 00	 DD	 $LN8@RecvPVPPac
  00148	00 00 00 00	 DD	 $LN2@RecvPVPPac
  0014c	00 00 00 00	 DD	 $LN5@RecvPVPPac
?RecvPVPPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPVPPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__SendHack@CPythonNetworkStream@@IAE_NPBD@Z
_TEXT	SEGMENT
_kPacketHack$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_c_szMsg$ = 8						; size = 4
?__SendHack@CPythonNetworkStream@@IAE_NPBD@Z PROC	; CPythonNetworkStream::__SendHack, COMDAT
; _this$ = ecx

; 1054 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _c_szMsg$[ebp]
  00017	57		 push	 edi

; 1055 : 	Tracen(c_szMsg);

  00018	56		 push	 esi
  00019	8b f9		 mov	 edi, ecx
  0001b	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen

; 1056 : 	
; 1057 : 	TPacketCGHack kPacketHack;
; 1058 : 	kPacketHack.bHeader=HEADER_CG_HACK;
; 1059 : 	strncpy(kPacketHack.szBuf, c_szMsg, sizeof(kPacketHack.szBuf)-1);

  00020	68 ff 00 00 00	 push	 255			; 000000ffH
  00025	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _kPacketHack$[ebp+1]
  0002b	c6 85 f8 fe ff
	ff 69		 mov	 BYTE PTR _kPacketHack$[ebp], 105 ; 00000069H
  00032	56		 push	 esi
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _strncpy
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 1060 : 
; 1061 : 	if (!Send(sizeof(kPacketHack), &kPacketHack))

  0003c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _kPacketHack$[ebp]
  00042	8b cf		 mov	 ecx, edi
  00044	50		 push	 eax
  00045	68 01 01 00 00	 push	 257			; 00000101H
  0004a	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0004f	84 c0		 test	 al, al
  00051	75 12		 jne	 SHORT $LN1@SendHack
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 1065 : }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
$LN1@SendHack:

; 1062 : 		return false;
; 1063 : 
; 1064 : 	return SendSequence();

  00065	8b cf		 mov	 ecx, edi
  00067	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 1065 : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	5f		 pop	 edi
  00070	33 cd		 xor	 ecx, ebp
  00072	5e		 pop	 esi
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?__SendHack@CPythonNetworkStream@@IAE_NPBD@Z ENDP	; CPythonNetworkStream::__SendHack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z
_TEXT	SEGMENT
tv207 = -32						; size = 8
_fDstRot$1$ = -32					; size = 4
_kStatePacket$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_c_rkPPosDst$ = 8					; size = 4
_fDstRot$ = 12						; size = 4
_eFunc$ = 16						; size = 4
_uArg$ = 20						; size = 4
?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z PROC ; CPythonNetworkStream::SendCharacterStatePacket, COMDAT
; _this$ = ecx

; 1112 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 38	 mov	 DWORD PTR __$ArrayPad$[esp+60], eax
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx

; 1113 : 	NANOBEGIN

  00017	eb		 DB	 -21			; ffffffebH
  00018	03		 DB	 3
  00019	d6		 DB	 -42			; ffffffd6H
  0001a	d7		 DB	 -41			; ffffffd7H
  0001b	01		 DB	 1

; 1114 : 	if (!__CanActMainInstance())

  0001c	e8 00 00 00 00	 call	 ?__CanActMainInstance@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__CanActMainInstance
  00021	84 c0		 test	 al, al
  00023	75 14		 jne	 SHORT $LN5@SendCharac

; 1115 : 		return true;

  00025	b0 01		 mov	 al, 1

; 1149 : }

  00027	5e		 pop	 esi
  00028	8b 4c 24 38	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+60]
  0002c	33 cc		 xor	 ecx, esp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 10 00	 ret	 16			; 00000010H
$LN5@SendCharac:

; 1116 : 
; 1117 : 	if (fDstRot < 0.0f)

  00039	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fDstRot$[ebp]
  0003e	0f 57 c0	 xorps	 xmm0, xmm0
  00041	0f 2f c1	 comiss	 xmm0, xmm1
  00044	f3 0f 11 4c 24
	20		 movss	 DWORD PTR _fDstRot$1$[esp+64], xmm1
  0004a	76 0a		 jbe	 SHORT $LN4@SendCharac

; 1118 : 		fDstRot = 360 + fDstRot;

  0004c	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@43b40000
  00054	eb 29		 jmp	 SHORT $LN10@SendCharac
$LN4@SendCharac:

; 1119 : 	else if (fDstRot > 360.0f)

  00056	0f 2f 0d 00 00
	00 00		 comiss	 xmm1, DWORD PTR __real@43b40000
  0005d	76 26		 jbe	 SHORT $LN2@SendCharac
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

  0005f	0f 5a c1	 cvtps2pd xmm0, xmm1
  00062	f2 0f 11 44 24
	20		 movsd	 QWORD PTR tv207[esp+64], xmm0
  00068	dd 44 24 20	 fld	 QWORD PTR tv207[esp+64]
  0006c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4076800000000000
  00072	e8 00 00 00 00	 call	 __CIfmod
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1120 : 		fDstRot = fmodf(fDstRot, 360.0f);

  00077	d9 5d 0c	 fstp	 DWORD PTR _fDstRot$[ebp]
  0007a	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fDstRot$[ebp]
$LN10@SendCharac:
  0007f	f3 0f 11 4c 24
	20		 movss	 DWORD PTR _fDstRot$1$[esp+64], xmm1
$LN2@SendCharac:

; 1121 : 
; 1122 : 	// TODO:   
; 1123 : 	TPacketCGMove kStatePacket;
; 1124 : 	kStatePacket.bHeader = HEADER_CG_CHARACTER_MOVE;
; 1125 : 	kStatePacket.bFunc = eFunc;
; 1126 : 	kStatePacket.bArg = uArg;
; 1127 : 	kStatePacket.bRot = fDstRot/5.0f;

  00085	0f 28 c1	 movaps	 xmm0, xmm1
  00088	8b 45 10	 mov	 eax, DWORD PTR _eFunc$[ebp]
  0008b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40a00000

; 1128 : 	kStatePacket.lX = long(c_rkPPosDst.x);

  00093	8b 4d 08	 mov	 ecx, DWORD PTR _c_rkPPosDst$[ebp]
  00096	88 44 24 2d	 mov	 BYTE PTR _kStatePacket$[esp+65], al
  0009a	8b 45 14	 mov	 eax, DWORD PTR _uArg$[ebp]
  0009d	88 44 24 2e	 mov	 BYTE PTR _kStatePacket$[esp+66], al
  000a1	c6 44 24 2c 07	 mov	 BYTE PTR _kStatePacket$[esp+64], 7
  000a6	f3 0f 2c c0	 cvttss2si eax, xmm0
  000aa	88 44 24 2f	 mov	 BYTE PTR _kStatePacket$[esp+67], al
  000ae	f3 0f 2c 01	 cvttss2si eax, DWORD PTR [ecx]
  000b2	89 44 24 30	 mov	 DWORD PTR _kStatePacket$[esp+68], eax

; 1129 : 	kStatePacket.lY = long(c_rkPPosDst.y);

  000b6	f3 0f 2c 41 04	 cvttss2si eax, DWORD PTR [ecx+4]
  000bb	89 44 24 34	 mov	 DWORD PTR _kStatePacket$[esp+72], eax

; 1130 : 	kStatePacket.dwTime = ELTimer_GetServerMSec();

  000bf	e8 00 00 00 00	 call	 ?ELTimer_GetServerMSec@@YAKXZ ; ELTimer_GetServerMSec
  000c4	89 44 24 38	 mov	 DWORD PTR _kStatePacket$[esp+76], eax

; 1131 : 	
; 1132 : 	assert(kStatePacket.lX >= 0 && kStatePacket.lX < 204800);
; 1133 : 
; 1134 : 	__LocalPositionToGlobalPosition(kStatePacket.lX, kStatePacket.lY);

  000c8	8d 44 24 34	 lea	 eax, DWORD PTR _kStatePacket$[esp+72]
  000cc	50		 push	 eax
  000cd	8d 44 24 34	 lea	 eax, DWORD PTR _kStatePacket$[esp+72]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?__LocalPositionToGlobalPosition@CPythonNetworkStream@@IAEXAAJ0@Z ; CPythonNetworkStream::__LocalPositionToGlobalPosition

; 1135 : 
; 1136 : 	if (!Send(sizeof(kStatePacket), &kStatePacket))

  000d7	8d 44 24 2c	 lea	 eax, DWORD PTR _kStatePacket$[esp+64]
  000db	8b ce		 mov	 ecx, esi
  000dd	50		 push	 eax
  000de	6a 10		 push	 16			; 00000010H
  000e0	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  000e5	84 c0		 test	 al, al
  000e7	75 66		 jne	 SHORT $LN1@SendCharac

; 1137 : 	{
; 1138 : 		Tracenf("CPythonNetworkStream::SendCharacterStatePacket(dwCmdTime=%u, fDstPos=(%f, %f), fDstRot=%f, eFunc=%d uArg=%d) - PACKET SEND ERROR",
; 1139 : 			kStatePacket.dwTime,
; 1140 : 			float(kStatePacket.lX),
; 1141 : 			float(kStatePacket.lY),
; 1142 : 			fDstRot,
; 1143 : 			kStatePacket.bFunc,
; 1144 : 			kStatePacket.bArg);

  000e9	0f b6 44 24 2e	 movzx	 eax, BYTE PTR _kStatePacket$[esp+66]
  000ee	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR _fDstRot$1$[esp+64]
  000f4	50		 push	 eax
  000f5	0f b6 44 24 31	 movzx	 eax, BYTE PTR _kStatePacket$[esp+69]
  000fa	0f 5a c0	 cvtps2pd xmm0, xmm0
  000fd	50		 push	 eax
  000fe	83 ec 18	 sub	 esp, 24			; 00000018H
  00101	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  00107	66 0f 6e 44 24
	54		 movd	 xmm0, DWORD PTR _kStatePacket$[esp+104]
  0010d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00110	0f 5a c0	 cvtps2pd xmm0, xmm0
  00113	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00119	66 0f 6e 44 24
	50		 movd	 xmm0, DWORD PTR _kStatePacket$[esp+100]
  0011f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00122	0f 5a c0	 cvtps2pd xmm0, xmm0
  00125	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0012a	ff 74 24 58	 push	 DWORD PTR _kStatePacket$[esp+108]
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0IB@FFAGJAOL@CPythonNetworkStream?3?3SendCharac@
  00133	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00138	83 c4 28	 add	 esp, 40			; 00000028H

; 1145 : 		return false;

  0013b	32 c0		 xor	 al, al

; 1149 : }

  0013d	5e		 pop	 esi
  0013e	8b 4c 24 38	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+60]
  00142	33 cc		 xor	 ecx, esp
  00144	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 10 00	 ret	 16			; 00000010H
$LN1@SendCharac:

; 1146 : 	}
; 1147 : 	NANOEND

  0014f	eb		 DB	 -21			; ffffffebH
  00150	03		 DB	 3
  00151	d6		 DB	 -42			; ffffffd6H
  00152	d7		 DB	 -41			; ffffffd7H
  00153	00		 DB	 0

; 1148 : 	return SendSequence();

  00154	8b ce		 mov	 ecx, esi
  00156	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 1149 : }

  0015b	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  0015f	5e		 pop	 esi
  00160	33 cc		 xor	 ecx, esp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c2 10 00	 ret	 16			; 00000010H
?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ENDP ; CPythonNetworkStream::SendCharacterStatePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendUseSkillPacket@CPythonNetworkStream@@QAE_NKK@Z
_TEXT	SEGMENT
_UseSkillPacket$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_dwSkillIndex$ = 8					; size = 4
_dwTargetVID$ = 12					; size = 4
?SendUseSkillPacket@CPythonNetworkStream@@QAE_NKK@Z PROC ; CPythonNetworkStream::SendUseSkillPacket, COMDAT
; _this$ = ecx

; 1153 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1154 : 	TPacketCGUseSkill UseSkillPacket;
; 1155 : 	UseSkillPacket.bHeader = HEADER_CG_USE_SKILL;
; 1156 : 	UseSkillPacket.dwVnum = dwSkillIndex;

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwSkillIndex$[ebp]
  00013	89 45 f1	 mov	 DWORD PTR _UseSkillPacket$[ebp+1], eax

; 1157 : 	UseSkillPacket.dwTargetVID = dwTargetVID;

  00016	8b 45 0c	 mov	 eax, DWORD PTR _dwTargetVID$[ebp]
  00019	56		 push	 esi
  0001a	89 45 f5	 mov	 DWORD PTR _UseSkillPacket$[ebp+5], eax
  0001d	8b f1		 mov	 esi, ecx

; 1158 : 	if (!Send(sizeof(TPacketCGUseSkill), &UseSkillPacket))

  0001f	8d 45 f0	 lea	 eax, DWORD PTR _UseSkillPacket$[ebp]
  00022	c6 45 f0 34	 mov	 BYTE PTR _UseSkillPacket$[ebp], 52 ; 00000034H
  00026	50		 push	 eax
  00027	6a 09		 push	 9
  00029	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0002e	84 c0		 test	 al, al
  00030	75 20		 jne	 SHORT $LN1@SendUseSki

; 1159 : 	{
; 1160 : 		Tracen("CPythonNetworkStream::SendUseSkillPacket - SEND PACKET ERROR");

  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EFFJHKOL@CPythonNetworkStream?3?3SendUseSki@
  00037	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0003c	83 c4 04	 add	 esp, 4

; 1161 : 		return false;

  0003f	32 c0		 xor	 al, al
  00041	5e		 pop	 esi

; 1165 : }

  00042	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00045	33 cd		 xor	 ecx, ebp
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
$LN1@SendUseSki:

; 1162 : 	}
; 1163 : 
; 1164 : 	return SendSequence();

  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 1165 : }

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	33 cd		 xor	 ecx, ebp
  0005e	5e		 pop	 esi
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
?SendUseSkillPacket@CPythonNetworkStream@@QAE_NKK@Z ENDP ; CPythonNetworkStream::SendUseSkillPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?ParseEmoticon@CPythonNetworkStream@@IAE_NPBDPAK@Z
_TEXT	SEGMENT
_dwEmoticonIndex$1$ = -4				; size = 4
_pChatMsg$ = 8						; size = 4
_pdwEmoticon$ = 12					; size = 4
?ParseEmoticon@CPythonNetworkStream@@IAE_NPBDPAK@Z PROC	; CPythonNetworkStream::ParseEmoticon, COMDAT
; _this$ = ecx

; 1219 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx

; 1220 : 	for (DWORD dwEmoticonIndex = 0; dwEmoticonIndex < m_EmoticonStringVector.size() ; ++dwEmoticonIndex)

  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwEmoticonIndex$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0000e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 93 24 03 00
	00		 mov	 edx, DWORD PTR [ebx+804]
  0001b	2b 93 20 03 00
	00		 sub	 edx, DWORD PTR [ebx+800]
  00021	f7 ea		 imul	 edx
  00023	c1 fa 02	 sar	 edx, 2
  00026	8b c2		 mov	 eax, edx
  00028	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002b	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1220 : 	for (DWORD dwEmoticonIndex = 0; dwEmoticonIndex < m_EmoticonStringVector.size() ; ++dwEmoticonIndex)

  0002d	74 65		 je	 SHORT $LN28@ParseEmoti
  0002f	8b 75 08	 mov	 esi, DWORD PTR _pChatMsg$[ebp]
  00032	33 ff		 xor	 edi, edi
$LL5@ParseEmoti:

; 1222 : 		if (strlen(pChatMsg) > m_EmoticonStringVector[dwEmoticonIndex].size())

  00034	8b c6		 mov	 eax, esi
  00036	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL29@ParseEmoti:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	40		 inc	 eax
  00043	84 c9		 test	 cl, cl
  00045	75 f9		 jne	 SHORT $LL29@ParseEmoti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

  00047	8b 8b 20 03 00
	00		 mov	 ecx, DWORD PTR [ebx+800]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1222 : 		if (strlen(pChatMsg) > m_EmoticonStringVector[dwEmoticonIndex].size())

  0004d	2b c2		 sub	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

  0004f	03 cf		 add	 ecx, edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1222 : 		if (strlen(pChatMsg) > m_EmoticonStringVector[dwEmoticonIndex].size())

  00051	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00054	77 16		 ja	 SHORT $LN4@ParseEmoti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00056	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0005a	72 02		 jb	 SHORT $LN20@ParseEmoti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0005c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN20@ParseEmoti:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1225 : 		const char * pcFind = strstr(pChatMsg, m_EmoticonStringVector[dwEmoticonIndex].c_str());

  0005e	51		 push	 ecx
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 _strstr
  00065	83 c4 08	 add	 esp, 8

; 1226 : 
; 1227 : 		if (pcFind != pChatMsg)

  00068	3b c6		 cmp	 eax, esi
  0006a	74 33		 je	 SHORT $LN1@ParseEmoti
$LN4@ParseEmoti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0006c	8b 8b 24 03 00
	00		 mov	 ecx, DWORD PTR [ebx+804]
  00072	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00077	2b 8b 20 03 00
	00		 sub	 ecx, DWORD PTR [ebx+800]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1220 : 	for (DWORD dwEmoticonIndex = 0; dwEmoticonIndex < m_EmoticonStringVector.size() ; ++dwEmoticonIndex)

  0007d	83 c7 18	 add	 edi, 24			; 00000018H
  00080	ff 45 fc	 inc	 DWORD PTR _dwEmoticonIndex$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00083	f7 e9		 imul	 ecx
  00085	c1 fa 02	 sar	 edx, 2
  00088	8b c2		 mov	 eax, edx
  0008a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008d	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1220 : 	for (DWORD dwEmoticonIndex = 0; dwEmoticonIndex < m_EmoticonStringVector.size() ; ++dwEmoticonIndex)

  0008f	39 45 fc	 cmp	 DWORD PTR _dwEmoticonIndex$1$[ebp], eax
  00092	72 a0		 jb	 SHORT $LL5@ParseEmoti
$LN28@ParseEmoti:
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi

; 1233 : 	}
; 1234 : 
; 1235 : 	return false;

  00096	32 c0		 xor	 al, al
  00098	5b		 pop	 ebx

; 1236 : }

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 08 00	 ret	 8
$LN1@ParseEmoti:

; 1228 : 			continue;
; 1229 : 
; 1230 : 		*pdwEmoticon = dwEmoticonIndex;

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _pdwEmoticon$[ebp]
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _dwEmoticonIndex$1$[ebp]
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	89 08		 mov	 DWORD PTR [eax], ecx

; 1231 : 
; 1232 : 		return true;

  000a9	b0 01		 mov	 al, 1
  000ab	5b		 pop	 ebx

; 1236 : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?ParseEmoticon@CPythonNetworkStream@@IAE_NPBDPAK@Z ENDP	; CPythonNetworkStream::ParseEmoticon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__ConvertEmpireText@CPythonNetworkStream@@IAEXKPAD@Z
_TEXT	SEGMENT
_dwEmpireID$ = 8					; size = 4
_szText$ = 12						; size = 4
?__ConvertEmpireText@CPythonNetworkStream@@IAEXKPAD@Z PROC ; CPythonNetworkStream::__ConvertEmpireText, COMDAT
; _this$ = ecx

; 1241 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1242 : 	if (dwEmpireID<1 || dwEmpireID>3)

  00003	8b 55 08	 mov	 edx, DWORD PTR _dwEmpireID$[ebp]
  00006	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00009	83 f8 02	 cmp	 eax, 2
  0000c	0f 87 8d 00 00
	00		 ja	 $LN9@ConvertEmp

; 1243 : 		return;
; 1244 : 
; 1245 : 	UINT uHanPos;
; 1246 : 
; 1247 : 	STextConvertTable& rkTextConvTable=m_aTextConvTable[dwEmpireID-1];

  00012	69 c2 44 27 00
	00		 imul	 eax, edx, 10052

; 1248 : 
; 1249 : 	BYTE* pbText=(BYTE*)szText;

  00018	8b 55 0c	 mov	 edx, DWORD PTR _szText$[ebp]
  0001b	56		 push	 esi

; 1250 : 	while (*pbText)

  0001c	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0001f	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00022	74 7a		 je	 SHORT $LN16@ConvertEmp
  00024	53		 push	 ebx
$LL8@ConvertEmp:

; 1251 : 	{
; 1252 : 		if (*pbText & 0x80)

  00025	8a 02		 mov	 al, BYTE PTR [edx]
  00027	84 c0		 test	 al, al
  00029	79 44		 jns	 SHORT $LN6@ConvertEmp

; 1253 : 		{
; 1254 : 			if (pbText[0]>=0xb0 && pbText[0]<=0xc8 && pbText[1]>=0xa1 && pbText[1]<=0xfe)

  0002b	3c b0		 cmp	 al, 176			; 000000b0H
  0002d	72 3b		 jb	 SHORT $LN5@ConvertEmp
  0002f	3c c8		 cmp	 al, 200			; 000000c8H
  00031	77 37		 ja	 SHORT $LN5@ConvertEmp
  00033	8a 5a 01	 mov	 bl, BYTE PTR [edx+1]
  00036	80 fb a1	 cmp	 bl, 161			; 000000a1H
  00039	72 2f		 jb	 SHORT $LN5@ConvertEmp
  0003b	80 fb fe	 cmp	 bl, 254			; 000000feH
  0003e	77 2a		 ja	 SHORT $LN5@ConvertEmp

; 1255 : 			{
; 1256 : 				uHanPos=(pbText[0]-0xb0)*(0xfe-0xa1+1)+(pbText[1]-0xa1);

  00040	0f b6 c0	 movzx	 eax, al
  00043	2d b0 00 00 00	 sub	 eax, 176		; 000000b0H
  00048	6b c8 5e	 imul	 ecx, eax, 94
  0004b	0f b6 c3	 movzx	 eax, bl
  0004e	05 5f ff ff ff	 add	 eax, -161		; ffffff5fH
  00053	03 c8		 add	 ecx, eax

; 1257 : 				pbText[0]=rkTextConvTable.aacHan[uHanPos][0];

  00055	0f b6 84 4e 1c
	dc ff ff	 movzx	 eax, BYTE PTR [esi+ecx*2-9188]
  0005d	88 02		 mov	 BYTE PTR [edx], al

; 1258 : 				pbText[1]=rkTextConvTable.aacHan[uHanPos][1];

  0005f	0f b6 84 4e 1d
	dc ff ff	 movzx	 eax, BYTE PTR [esi+ecx*2-9187]
  00067	88 42 01	 mov	 BYTE PTR [edx+1], al
$LN5@ConvertEmp:

; 1259 : 			}
; 1260 : 			pbText+=2;

  0006a	83 c2 02	 add	 edx, 2

; 1261 : 		}
; 1262 : 		else

  0006d	eb 29		 jmp	 SHORT $LN4@ConvertEmp
$LN6@ConvertEmp:

; 1263 : 		{
; 1264 : 			if (*pbText>='a' && *pbText<='z')

  0006f	3c 61		 cmp	 al, 97			; 00000061H
  00071	72 10		 jb	 SHORT $LN3@ConvertEmp
  00073	3c 7a		 cmp	 al, 122			; 0000007aH
  00075	77 0c		 ja	 SHORT $LN3@ConvertEmp

; 1265 : 			{
; 1266 : 				*pbText=rkTextConvTable.acLower[*pbText-'a'];

  00077	0f b6 c0	 movzx	 eax, al
  0007a	8a 84 30 a1 db
	ff ff		 mov	 al, BYTE PTR [eax+esi-9311]
  00081	eb 12		 jmp	 SHORT $LN18@ConvertEmp
$LN3@ConvertEmp:

; 1267 : 			}
; 1268 : 			else if (*pbText>='A' && *pbText<='Z')

  00083	3c 41		 cmp	 al, 65			; 00000041H
  00085	72 10		 jb	 SHORT $LN1@ConvertEmp
  00087	3c 5a		 cmp	 al, 90			; 0000005aH
  00089	77 0c		 ja	 SHORT $LN1@ConvertEmp

; 1269 : 			{
; 1270 : 				*pbText=rkTextConvTable.acUpper[*pbText-'A'];

  0008b	0f b6 c0	 movzx	 eax, al
  0008e	8a 84 30 a7 db
	ff ff		 mov	 al, BYTE PTR [eax+esi-9305]
$LN18@ConvertEmp:
  00095	88 02		 mov	 BYTE PTR [edx], al
$LN1@ConvertEmp:

; 1271 : 			}
; 1272 : 			pbText++;

  00097	42		 inc	 edx
$LN4@ConvertEmp:

; 1250 : 	while (*pbText)

  00098	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0009b	75 88		 jne	 SHORT $LL8@ConvertEmp
  0009d	5b		 pop	 ebx
$LN16@ConvertEmp:
  0009e	5e		 pop	 esi
$LN9@ConvertEmp:

; 1273 : 		}
; 1274 : 	}
; 1275 : }

  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
?__ConvertEmpireText@CPythonNetworkStream@@IAEXKPAD@Z ENDP ; CPythonNetworkStream::__ConvertEmpireText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvChatPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_dwEmoticon$1 = -2092					; size = 4
_rkChrMgr$1$ = -2088					; size = 4
_kChat$ = -2084						; size = 9
_line$ = -2072						; size = 1025
_buf$ = -1040						; size = 1025
__$ArrayPad$ = -4					; size = 4
?RecvChatPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvChatPacket, COMDAT
; _this$ = ecx

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 08 00
	00		 sub	 esp, 2092		; 0000082cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1279 : 	TPacketGCChat kChat;
; 1280 :     char buf[1024 + 1];
; 1281 : 	char line[1024 + 1];
; 1282 : 
; 1283 : 	if (!Recv(sizeof(kChat), &kChat))

  00016	8d 85 dc f7 ff
	ff		 lea	 eax, DWORD PTR _kChat$[ebp]
  0001c	8b f1		 mov	 esi, ecx
  0001e	50		 push	 eax
  0001f	6a 09		 push	 9
  00021	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00026	84 c0		 test	 al, al
  00028	75 13		 jne	 SHORT $LN31@RecvChatPa
$LN57@RecvChatPa:

; 1284 : 		return false;

  0002a	32 c0		 xor	 al, al

; 1403 : 		
; 1404 : 	}
; 1405 : 	return true;
; 1406 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN31@RecvChatPa:

; 1285 : 
; 1286 : 	UINT uChatSize=kChat.size - sizeof(kChat);

  0003d	0f b7 bd dd f7
	ff ff		 movzx	 edi, WORD PTR _kChat$[ebp+1]

; 1287 : 
; 1288 : 	if (!Recv(uChatSize, buf))

  00044	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0004a	50		 push	 eax
  0004b	83 ef 09	 sub	 edi, 9
  0004e	8b ce		 mov	 ecx, esi
  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAD@Z ; CNetworkStream::Recv
  00056	84 c0		 test	 al, al
  00058	74 d0		 je	 SHORT $LN57@RecvChatPa

; 1289 : 		return false;
; 1290 : 
; 1291 : 	buf[uChatSize]='\0';

  0005a	81 ff 01 04 00
	00		 cmp	 edi, 1025		; 00000401H
  00060	0f 83 be 02 00
	00		 jae	 $LN59@RecvChatPa
  00066	c6 84 3d f0 fb
	ff ff 00	 mov	 BYTE PTR _buf$[ebp+edi], 0

; 1292 : 	
; 1293 : 	//    
; 1294 : 	// ": "  ": "    (0x08) 
; 1295 : 	//     (1) : (2)   (2) : (1)   
; 1296 : 	if (LocaleService_IsEUROPE() && GetDefaultCodePage() == 1256)

  0006e	e8 00 00 00 00	 call	 ?LocaleService_IsEUROPE@@YA_NXZ ; LocaleService_IsEUROPE
  00073	84 c0		 test	 al, al
  00075	74 2b		 je	 SHORT $LN28@RecvChatPa
  00077	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  0007c	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  00081	75 1f		 jne	 SHORT $LN28@RecvChatPa
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

  00083	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00089	6a 3a		 push	 58			; 0000003aH
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _strchr
  00091	83 c4 08	 add	 esp, 8
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1299 : 		if (p && p[1] == ' ')

  00094	85 c0		 test	 eax, eax
  00096	74 0a		 je	 SHORT $LN28@RecvChatPa
  00098	80 78 01 20	 cmp	 BYTE PTR [eax+1], 32	; 00000020H
  0009c	75 04		 jne	 SHORT $LN28@RecvChatPa

; 1300 : 			p[1] = 0x08;

  0009e	c6 40 01 08	 mov	 BYTE PTR [eax+1], 8
$LN28@RecvChatPa:

; 1301 : 	}
; 1302 : 
; 1303 : 	if (kChat.type >= CHAT_TYPE_MAX_NUM)

  000a2	8a 9d df f7 ff
	ff		 mov	 bl, BYTE PTR _kChat$[ebp+3]
  000a8	80 fb 09	 cmp	 bl, 9
  000ab	73 13		 jae	 SHORT $LN58@RecvChatPa

; 1304 : 		return true;
; 1305 : 
; 1306 : 	if (CHAT_TYPE_COMMAND == kChat.type)

  000ad	80 fb 05	 cmp	 bl, 5
  000b0	75 21		 jne	 SHORT $LN26@RecvChatPa

; 1307 : 	{
; 1308 : 		ServerCommand(buf);

  000b2	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000b8	8b ce		 mov	 ecx, esi
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z ; CPythonNetworkStream::ServerCommand
$LN58@RecvChatPa:

; 1339 : 					return true;

  000c0	b0 01		 mov	 al, 1

; 1403 : 		
; 1404 : 	}
; 1405 : 	return true;
; 1406 : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	33 cd		 xor	 ecx, ebp
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
$LN26@RecvChatPa:

; 1309 : 		return true;
; 1310 : 	}
; 1311 : 
; 1312 : 	if (kChat.dwVID != 0)

  000d3	8b 95 e0 f7 ff
	ff		 mov	 edx, DWORD PTR _kChat$[ebp+4]
  000d9	85 d2		 test	 edx, edx
  000db	0f 84 7a 01 00
	00		 je	 $LN25@RecvChatPa

; 1313 : 	{
; 1314 : 		CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  000e6	89 85 d8 f7 ff
	ff		 mov	 DWORD PTR _rkChrMgr$1$[ebp], eax

; 1315 : 		CInstanceBase * pkInstChatter = rkChrMgr.GetInstancePtr(kChat.dwVID);

  000ec	52		 push	 edx
  000ed	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  000f0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f2	ff 50 08	 call	 DWORD PTR [eax+8]
  000f5	8b d8		 mov	 ebx, eax

; 1316 : 		if (NULL == pkInstChatter)

  000f7	85 db		 test	 ebx, ebx
  000f9	74 c5		 je	 SHORT $LN58@RecvChatPa

; 1317 : 			return true;
; 1318 : 		
; 1319 : 		switch (kChat.type)

  000fb	0f b6 85 df f7
	ff ff		 movzx	 eax, BYTE PTR _kChat$[ebp+3]
  00102	83 f8 07	 cmp	 eax, 7
  00105	0f 87 d0 00 00
	00		 ja	 $LN11@RecvChatPa
  0010b	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN50@RecvChatPa[eax]
  00112	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN60@RecvChatPa[eax*4]
$LN21@RecvChatPa:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

  00119	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0011f	6a 3a		 push	 58			; 0000003aH
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _strchr
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1327 : 				char * p = strchr(buf, ':');

  00127	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

  00129	83 c4 08	 add	 esp, 8
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1329 : 				if (p)

  0012c	85 ff		 test	 edi, edi
  0012e	74 05		 je	 SHORT $LN20@RecvChatPa

; 1330 : 					p += 2;

  00130	83 c7 02	 add	 edi, 2

; 1331 : 				else

  00133	eb 06		 jmp	 SHORT $LN19@RecvChatPa
$LN20@RecvChatPa:

; 1332 : 					p = buf;

  00135	8d bd f0 fb ff
	ff		 lea	 edi, DWORD PTR _buf$[ebp]
$LN19@RecvChatPa:

; 1333 : 
; 1334 : 				DWORD dwEmoticon;
; 1335 : 
; 1336 : 				if (ParseEmoticon(p, &dwEmoticon))

  0013b	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR _dwEmoticon$1[ebp]
  00141	8b ce		 mov	 ecx, esi
  00143	50		 push	 eax
  00144	57		 push	 edi
  00145	e8 00 00 00 00	 call	 ?ParseEmoticon@CPythonNetworkStream@@IAE_NPBDPAK@Z ; CPythonNetworkStream::ParseEmoticon
  0014a	84 c0		 test	 al, al
  0014c	74 20		 je	 SHORT $LN18@RecvChatPa

; 1337 : 				{
; 1338 : 					pkInstChatter->SetEmoticon(dwEmoticon);

  0014e	ff b5 d4 f7 ff
	ff		 push	 DWORD PTR _dwEmoticon$1[ebp]
  00154	8b cb		 mov	 ecx, ebx
  00156	e8 00 00 00 00	 call	 ?SetEmoticon@CInstanceBase@@QAEXI@Z ; CInstanceBase::SetEmoticon

; 1339 : 					return true;

  0015b	b0 01		 mov	 al, 1

; 1403 : 		
; 1404 : 	}
; 1405 : 	return true;
; 1406 : }

  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00163	33 cd		 xor	 ecx, ebp
  00165	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
$LN18@RecvChatPa:

; 1340 : 				}
; 1341 : 				else
; 1342 : 				{
; 1343 : 					if (gs_bEmpireLanuageEnable)

  0016e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gs_bEmpireLanuageEnable@@3HA, 0 ; gs_bEmpireLanuageEnable
  00175	74 2b		 je	 SHORT $LN14@RecvChatPa

; 1344 : 					{
; 1345 : 						CInstanceBase* pkInstMain=rkChrMgr.GetMainInstancePtr();

  00177	8b 8d d8 f7 ff
	ff		 mov	 ecx, DWORD PTR _rkChrMgr$1$[ebp]
  0017d	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr

; 1346 : 						if (pkInstMain)

  00182	85 c0		 test	 eax, eax
  00184	74 1c		 je	 SHORT $LN14@RecvChatPa

; 1347 : 							if (!pkInstMain->IsSameEmpire(*pkInstChatter))

  00186	53		 push	 ebx
  00187	8b c8		 mov	 ecx, eax
  00189	e8 00 00 00 00	 call	 ?IsSameEmpire@CInstanceBase@@QAEHAAV1@@Z ; CInstanceBase::IsSameEmpire
  0018e	85 c0		 test	 eax, eax
  00190	75 10		 jne	 SHORT $LN14@RecvChatPa

; 1348 : 								__ConvertEmpireText(pkInstChatter->GetEmpireID(), p);

  00192	57		 push	 edi
  00193	8b cb		 mov	 ecx, ebx
  00195	e8 00 00 00 00	 call	 ?GetEmpireID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetEmpireID
  0019a	50		 push	 eax
  0019b	8b ce		 mov	 ecx, esi
  0019d	e8 00 00 00 00	 call	 ?__ConvertEmpireText@CPythonNetworkStream@@IAEXKPAD@Z ; CPythonNetworkStream::__ConvertEmpireText
$LN14@RecvChatPa:

; 1349 : 					}
; 1350 : 
; 1351 : 					if (m_isEnableChatInsultFilter)

  001a2	80 be 20 79 00
	00 00		 cmp	 BYTE PTR [esi+31008], 0
  001a9	74 2d		 je	 SHORT $LN12@RecvChatPa

; 1352 : 					{
; 1353 : 						if (false == pkInstChatter->IsNPC() && false == pkInstChatter->IsEnemy())

  001ab	8b cb		 mov	 ecx, ebx
  001ad	e8 00 00 00 00	 call	 ?IsNPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsNPC
  001b2	85 c0		 test	 eax, eax
  001b4	75 22		 jne	 SHORT $LN12@RecvChatPa
  001b6	8b cb		 mov	 ecx, ebx
  001b8	e8 00 00 00 00	 call	 ?IsEnemy@CInstanceBase@@QAEHXZ ; CInstanceBase::IsEnemy
  001bd	85 c0		 test	 eax, eax
  001bf	75 17		 jne	 SHORT $LN12@RecvChatPa

; 1354 : 						{
; 1355 : 							__FilterInsult(p, strlen(p));

  001c1	8b cf		 mov	 ecx, edi
  001c3	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL51@RecvChatPa:
  001c6	8a 01		 mov	 al, BYTE PTR [ecx]
  001c8	41		 inc	 ecx
  001c9	84 c0		 test	 al, al
  001cb	75 f9		 jne	 SHORT $LL51@RecvChatPa
  001cd	2b ca		 sub	 ecx, edx
  001cf	51		 push	 ecx
  001d0	57		 push	 edi
  001d1	8b ce		 mov	 ecx, esi
  001d3	e8 00 00 00 00	 call	 ?__FilterInsult@CPythonNetworkStream@@IAEXPADI@Z ; CPythonNetworkStream::__FilterInsult
$LN12@RecvChatPa:

; 1356 : 						}
; 1357 : 					}
; 1358 : 
; 1359 : 					_snprintf(line, sizeof(line), "%s", p);

  001d8	57		 push	 edi

; 1360 : 				}
; 1361 : 			}
; 1362 : 			break;

  001d9	eb 07		 jmp	 SHORT $LN55@RecvChatPa
$LN11@RecvChatPa:

; 1363 : 		case CHAT_TYPE_COMMAND:	/*  */
; 1364 : 		case CHAT_TYPE_INFO:     /*  ( ,  . ) */
; 1365 : 		case CHAT_TYPE_NOTICE:   /*  */
; 1366 : 		case CHAT_TYPE_BIG_NOTICE:
; 1367 : 		case CHAT_TYPE_MAX_NUM:
; 1368 : 		default:
; 1369 : 			_snprintf(line, sizeof(line), "%s", buf);

  001db	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  001e1	50		 push	 eax
$LN55@RecvChatPa:
  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  001e7	8d 85 e8 f7 ff
	ff		 lea	 eax, DWORD PTR _line$[ebp]
  001ed	68 01 04 00 00	 push	 1025			; 00000401H
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 __snprintf
  001f8	83 c4 10	 add	 esp, 16			; 00000010H

; 1370 : 			break;
; 1371 : 		}
; 1372 : 
; 1373 : 		if (CHAT_TYPE_SHOUT != kChat.type)

  001fb	80 bd df f7 ff
	ff 06		 cmp	 BYTE PTR _kChat$[ebp+3], 6
  00202	74 18		 je	 SHORT $LN10@RecvChatPa

; 1374 : 		{
; 1375 : 			CPythonTextTail::Instance().RegisterChatTail(kChat.dwVID, line);

  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonTextTail@@@@0PAVCPythonTextTail@@A ; CSingleton<CPythonTextTail>::ms_singleton
  0020a	8d 85 e8 f7 ff
	ff		 lea	 eax, DWORD PTR _line$[ebp]
  00210	50		 push	 eax
  00211	ff b5 e0 f7 ff
	ff		 push	 DWORD PTR _kChat$[ebp+4]
  00217	e8 00 00 00 00	 call	 ?RegisterChatTail@CPythonTextTail@@QAEXKPBD@Z ; CPythonTextTail::RegisterChatTail
$LN10@RecvChatPa:

; 1376 : 		}
; 1377 : 
; 1378 : 		if (pkInstChatter->IsPC())

  0021c	8b cb		 mov	 ecx, ebx
  0021e	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  00223	85 c0		 test	 eax, eax
  00225	0f 84 95 fe ff
	ff		 je	 $LN58@RecvChatPa

; 1399 : 			}
; 1400 : 		}
; 1401 : 
; 1402 : 		CPythonChat::Instance().AppendChat(kChat.type, buf);

  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonChat@@@@0PAVCPythonChat@@A ; CSingleton<CPythonChat>::ms_singleton
  00231	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00237	83 c1 04	 add	 ecx, 4
  0023a	50		 push	 eax
  0023b	0f b6 85 df f7
	ff ff		 movzx	 eax, BYTE PTR _kChat$[ebp+3]
  00242	50		 push	 eax
  00243	8b 11		 mov	 edx, DWORD PTR [ecx]
  00245	ff 52 04	 call	 DWORD PTR [edx+4]
  00248	b0 01		 mov	 al, 1

; 1403 : 		
; 1404 : 	}
; 1405 : 	return true;
; 1406 : }

  0024a	5f		 pop	 edi
  0024b	5e		 pop	 esi
  0024c	5b		 pop	 ebx
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00250	33 cd		 xor	 ecx, ebp
  00252	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00257	8b e5		 mov	 esp, ebp
  00259	5d		 pop	 ebp
  0025a	c3		 ret	 0
$LN25@RecvChatPa:

; 1379 : 			CPythonChat::Instance().AppendChat(kChat.type, buf);
; 1380 : 	}
; 1381 : 	else
; 1382 : 	{
; 1383 : 		if (CHAT_TYPE_NOTICE == kChat.type)

  0025b	80 fb 02	 cmp	 bl, 2
  0025e	75 28		 jne	 SHORT $LN7@RecvChatPa

; 1384 : 		{
; 1385 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetTipMessage", Py_BuildValue("(s)", buf));

  00260	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00266	50		 push	 eax
  00267	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00272	50		 push	 eax
  00273	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EKLOHGBI@BINARY_SetTipMessage?$AA@
  00278	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0027e	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00283	83 c4 14	 add	 esp, 20			; 00000014H

; 1386 : 		}
; 1387 : 		else if (CHAT_TYPE_BIG_NOTICE == kChat.type)

  00286	eb 6a		 jmp	 SHORT $LN53@RecvChatPa
$LN7@RecvChatPa:
  00288	80 fb 08	 cmp	 bl, 8
  0028b	75 28		 jne	 SHORT $LN5@RecvChatPa

; 1388 : 		{
; 1389 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_SetBigMessage", Py_BuildValue("(s)", buf));

  0028d	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00293	50		 push	 eax
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  00299	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0029f	50		 push	 eax
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MEFMFHCI@BINARY_SetBigMessage?$AA@
  002a5	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  002ab	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  002b0	83 c4 14	 add	 esp, 20			; 00000014H

; 1390 : 		}
; 1391 : 		else if (CHAT_TYPE_SHOUT == kChat.type)

  002b3	eb 3d		 jmp	 SHORT $LN53@RecvChatPa
$LN5@RecvChatPa:
  002b5	80 fb 06	 cmp	 bl, 6
  002b8	75 3e		 jne	 SHORT $LN1@RecvChatPa
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

  002ba	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  002c0	6a 3a		 push	 58			; 0000003aH
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 _strchr
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1393 : 			char * p = strchr(buf, ':');

  002c8	8b d0		 mov	 edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

  002ca	83 c4 08	 add	 esp, 8
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1395 : 			if (p)

  002cd	85 d2		 test	 edx, edx
  002cf	74 21		 je	 SHORT $LN53@RecvChatPa

; 1396 : 			{
; 1397 : 				if (m_isEnableChatInsultFilter)

  002d1	80 be 20 79 00
	00 00		 cmp	 BYTE PTR [esi+31008], 0
  002d8	74 18		 je	 SHORT $LN53@RecvChatPa

; 1398 : 					__FilterInsult(p, strlen(p));

  002da	8b ca		 mov	 ecx, edx
  002dc	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  002df	90		 npad	 1
$LL52@RecvChatPa:
  002e0	8a 01		 mov	 al, BYTE PTR [ecx]
  002e2	41		 inc	 ecx
  002e3	84 c0		 test	 al, al
  002e5	75 f9		 jne	 SHORT $LL52@RecvChatPa
  002e7	2b cf		 sub	 ecx, edi
  002e9	51		 push	 ecx
  002ea	52		 push	 edx
  002eb	8b ce		 mov	 ecx, esi
  002ed	e8 00 00 00 00	 call	 ?__FilterInsult@CPythonNetworkStream@@IAEXPADI@Z ; CPythonNetworkStream::__FilterInsult
$LN53@RecvChatPa:
  002f2	8a 9d df f7 ff
	ff		 mov	 bl, BYTE PTR _kChat$[ebp+3]
$LN1@RecvChatPa:

; 1399 : 			}
; 1400 : 		}
; 1401 : 
; 1402 : 		CPythonChat::Instance().AppendChat(kChat.type, buf);

  002f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonChat@@@@0PAVCPythonChat@@A ; CSingleton<CPythonChat>::ms_singleton
  002fe	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00304	83 c1 04	 add	 ecx, 4
  00307	50		 push	 eax
  00308	0f b6 c3	 movzx	 eax, bl
  0030b	50		 push	 eax
  0030c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0030e	ff 52 04	 call	 DWORD PTR [edx+4]

; 1403 : 		
; 1404 : 	}
; 1405 : 	return true;
; 1406 : }

  00311	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00314	b0 01		 mov	 al, 1
  00316	5f		 pop	 edi
  00317	5e		 pop	 esi
  00318	33 cd		 xor	 ecx, ebp
  0031a	5b		 pop	 ebx
  0031b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00320	8b e5		 mov	 esp, ebp
  00322	5d		 pop	 ebp
  00323	c3		 ret	 0
$LN59@RecvChatPa:

; 1289 : 		return false;
; 1290 : 
; 1291 : 	buf[uChatSize]='\0';

  00324	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN61@RecvChatPa:
$LN54@RecvChatPa:
  00329	8d 49 00	 npad	 3
$LN60@RecvChatPa:

; 1403 : 		
; 1404 : 	}
; 1405 : 	return true;
; 1406 : }

  0032c	00 00 00 00	 DD	 $LN21@RecvChatPa
  00330	00 00 00 00	 DD	 $LN11@RecvChatPa
$LN50@RecvChatPa:
  00334	00		 DB	 0
  00335	01		 DB	 1
  00336	01		 DB	 1
  00337	00		 DB	 0
  00338	00		 DB	 0
  00339	01		 DB	 1
  0033a	00		 DB	 0
  0033b	00		 DB	 0
?RecvChatPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvChatPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_whisperPacket$ = -552					; size = 29
_buf$ = -520						; size = 513
__$ArrayPad$ = -4					; size = 4
?RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvWhisperPacket, COMDAT
; _this$ = ecx

; 1409 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 02 00
	00		 sub	 esp, 552		; 00000228H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 1410 : 	TPacketGCWhisper whisperPacket;
; 1411 :     char buf[512 + 1];
; 1412 : 
; 1413 : 	if (!Recv(sizeof(whisperPacket), &whisperPacket))

  00014	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _whisperPacket$[ebp]
  0001a	8b f1		 mov	 esi, ecx
  0001c	50		 push	 eax
  0001d	6a 1d		 push	 29			; 0000001dH
  0001f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00024	84 c0		 test	 al, al
  00026	75 11		 jne	 SHORT $LN8@RecvWhispe
$LN14@RecvWhispe:

; 1414 : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	5e		 pop	 esi

; 1439 : }

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002e	33 cd		 xor	 ecx, ebp
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN8@RecvWhispe:

; 1415 : 
; 1416 : 	assert(whisperPacket.wSize - sizeof(whisperPacket) < 512);
; 1417 : 
; 1418 : 	if (!Recv(whisperPacket.wSize - sizeof(whisperPacket), &buf))

  00039	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0003f	8b ce		 mov	 ecx, esi
  00041	50		 push	 eax
  00042	0f b7 85 d9 fd
	ff ff		 movzx	 eax, WORD PTR _whisperPacket$[ebp+1]
  00049	83 e8 1d	 sub	 eax, 29			; 0000001dH
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00052	84 c0		 test	 al, al
  00054	74 d2		 je	 SHORT $LN14@RecvWhispe

; 1419 : 		return false;
; 1420 : 
; 1421 : 	buf[whisperPacket.wSize - sizeof(whisperPacket)] = '\0';

  00056	0f b7 85 d9 fd
	ff ff		 movzx	 eax, WORD PTR _whisperPacket$[ebp+1]
  0005d	83 e8 1d	 sub	 eax, 29			; 0000001dH
  00060	3d 01 02 00 00	 cmp	 eax, 513		; 00000201H
  00065	0f 83 10 01 00
	00		 jae	 $LN15@RecvWhispe
  0006b	c6 84 05 f8 fd
	ff ff 00	 mov	 BYTE PTR _buf$[ebp+eax], 0

; 1422 : 
; 1423 : 	static char line[256];
; 1424 : 	if (CPythonChat::WHISPER_TYPE_CHAT == whisperPacket.bType || CPythonChat::WHISPER_TYPE_GM == whisperPacket.bType)

  00073	8a 85 db fd ff
	ff		 mov	 al, BYTE PTR _whisperPacket$[ebp+3]
  00079	84 c0		 test	 al, al
  0007b	0f 84 94 00 00
	00		 je	 $LN5@RecvWhispe
  00081	3c 05		 cmp	 al, 5
  00083	0f 84 8c 00 00
	00		 je	 $LN5@RecvWhispe

; 1428 : 	}
; 1429 : 	else if (CPythonChat::WHISPER_TYPE_SYSTEM == whisperPacket.bType || CPythonChat::WHISPER_TYPE_ERROR == whisperPacket.bType)

  00089	3c ff		 cmp	 al, 255			; 000000ffH
  0008b	74 46		 je	 SHORT $LN2@RecvWhispe
  0008d	3c 04		 cmp	 al, 4
  0008f	74 42		 je	 SHORT $LN2@RecvWhispe

; 1432 : 	}
; 1433 : 	else
; 1434 : 	{
; 1435 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisperError", Py_BuildValue("(iss)", (int) whisperPacket.bType, whisperPacket.szNameFrom, buf));

  00091	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  00097	0f b6 c0	 movzx	 eax, al
  0009a	51		 push	 ecx
  0009b	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _whisperPacket$[ebp+4]
  000a1	51		 push	 ecx
  000a2	50		 push	 eax
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_05FKJLIKKL@?$CIiss?$CJ?$AA@
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000ae	50		 push	 eax
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HFHHLLOG@OnRecvWhisperError?$AA@
  000b4	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  000ba	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000bf	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1436 : 	}
; 1437 : 
; 1438 : 	return true;

  000c2	b0 01		 mov	 al, 1
  000c4	5e		 pop	 esi

; 1439 : }

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	33 cd		 xor	 ecx, ebp
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
$LN2@RecvWhispe:

; 1430 : 	{
; 1431 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisperSystemMessage", Py_BuildValue("(iss)", (int) whisperPacket.bType, whisperPacket.szNameFrom, buf));

  000d3	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  000d9	0f b6 c0	 movzx	 eax, al
  000dc	51		 push	 ecx
  000dd	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _whisperPacket$[ebp+4]
  000e3	51		 push	 ecx
  000e4	50		 push	 eax
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_05FKJLIKKL@?$CIiss?$CJ?$AA@
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000f0	50		 push	 eax
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MJBHNNKO@OnRecvWhisperSystemMessage?$AA@
  000f6	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  000fc	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00101	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1436 : 	}
; 1437 : 
; 1438 : 	return true;

  00104	b0 01		 mov	 al, 1
  00106	5e		 pop	 esi

; 1439 : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
$LN5@RecvWhispe:

; 1425 : 	{		
; 1426 : 		_snprintf(line, sizeof(line), "%s : %s", whisperPacket.szNameFrom, buf);

  00115	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0011b	50		 push	 eax
  0011c	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _whisperPacket$[ebp+4]
  00122	50		 push	 eax
  00123	68 00 00 00 00	 push	 OFFSET ??_C@_07IAFACCAD@?$CFs?5?3?5?$CFs?$AA@
  00128	68 00 01 00 00	 push	 256			; 00000100H
  0012d	68 00 00 00 00	 push	 OFFSET ?line@?5??RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ@4PADA
  00132	e8 00 00 00 00	 call	 __snprintf

; 1427 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnRecvWhisper", Py_BuildValue("(iss)", (int) whisperPacket.bType, whisperPacket.szNameFrom, line));

  00137	68 00 00 00 00	 push	 OFFSET ?line@?5??RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ@4PADA
  0013c	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _whisperPacket$[ebp+4]
  00142	50		 push	 eax
  00143	0f b6 85 db fd
	ff ff		 movzx	 eax, BYTE PTR _whisperPacket$[ebp+3]
  0014a	50		 push	 eax
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_05FKJLIKKL@?$CIiss?$CJ?$AA@
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00156	50		 push	 eax
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MLMPGGOH@OnRecvWhisper?$AA@
  0015c	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00162	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 1439 : }

  00167	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016a	83 c4 30	 add	 esp, 48			; 00000030H
  0016d	33 cd		 xor	 ecx, ebp
  0016f	b0 01		 mov	 al, 1
  00171	5e		 pop	 esi
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
$LN15@RecvWhispe:

; 1419 : 		return false;
; 1420 : 
; 1421 : 	buf[whisperPacket.wSize - sizeof(whisperPacket)] = '\0';

  0017b	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN16@RecvWhispe:
$LN13@RecvWhispe:
  00180	cc		 int	 3
?RecvWhisperPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvWhisperPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPointChange@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_PointChange$ = -24					; size = 17
__$ArrayPad$ = -4					; size = 4
?RecvPointChange@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPointChange, COMDAT
; _this$ = ecx

; 1481 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 1482 : 	TPacketGCPointChange PointChange;
; 1483 : 
; 1484 : 	if (!Recv(sizeof(TPacketGCPointChange), &PointChange))

  00011	8d 45 e8	 lea	 eax, DWORD PTR _PointChange$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 11		 push	 17			; 00000011H
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 1e		 jne	 SHORT $LN13@RecvPointC

; 1485 : 	{
; 1486 : 		Tracen("Recv Point Change Packet Error");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DGLKKAJF@Recv?5Point?5Change?5Packet?5Error?$AA@
  00027	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002c	83 c4 04	 add	 esp, 4

; 1487 : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 1537 : 			}
; 1538 : 		}
; 1539 : 	}
; 1540 : 
; 1541 : 	return true;
; 1542 : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN13@RecvPointC:

; 1488 : 	}
; 1489 : 
; 1490 : 	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
; 1491 : 	rkChrMgr.ShowPointEffect(PointChange.Type, PointChange.dwVID);

  00040	ff 75 ec	 push	 DWORD PTR _PointChange$[ebp+4]
  00043	0f b6 45 f0	 movzx	 eax, BYTE PTR _PointChange$[ebp+8]
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?ShowPointEffect@CPythonCharacterManager@@QAEXKK@Z ; CPythonCharacterManager::ShowPointEffect

; 1492 : 
; 1493 : 	CInstanceBase * pInstance = CPythonCharacterManager::Instance().GetMainInstancePtr();

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00059	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr

; 1494 : 
; 1495 : 	//  Point  ..
; 1496 : 	if (pInstance)

  0005e	85 c0		 test	 eax, eax
  00060	0f 84 a2 00 00
	00		 je	 $LN1@RecvPointC

; 1497 : 	if (PointChange.dwVID == pInstance->GetVirtualID())

  00066	8b c8		 mov	 ecx, eax
  00068	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  0006d	39 45 ec	 cmp	 DWORD PTR _PointChange$[ebp+4], eax
  00070	0f 85 92 00 00
	00		 jne	 $LN1@RecvPointC

; 1498 : 	{
; 1499 : 		CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 1500 : 		rkPlayer.SetStatus(PointChange.Type, PointChange.value);

  00076	0f b6 45 f0	 movzx	 eax, BYTE PTR _PointChange$[ebp+8]
  0007a	57		 push	 edi
  0007b	ff 75 f5	 push	 DWORD PTR _PointChange$[ebp+13]
  0007e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00084	8b cf		 mov	 ecx, edi
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?SetStatus@CPythonPlayer@@QAEXKJ@Z ; CPythonPlayer::SetStatus

; 1501 : 
; 1502 : 		switch (PointChange.Type)

  0008c	8a 55 f0	 mov	 dl, BYTE PTR _PointChange$[ebp+8]
  0008f	0f b6 c2	 movzx	 eax, dl
  00092	48		 dec	 eax
  00093	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00096	77 3c		 ja	 SHORT $LN3@RecvPointC
  00098	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN22@RecvPointC[eax]
  0009f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@RecvPointC[eax*4]
$LN7@RecvPointC:

; 1503 : 		{
; 1504 : 			case POINT_STAT_RESET_COUNT:
; 1505 : 				__RefreshStatus();
; 1506 : 				break;
; 1507 : 			case POINT_LEVEL:
; 1508 : 			case POINT_ST:
; 1509 : 			case POINT_DX:
; 1510 : 			case POINT_HT:
; 1511 : 			case POINT_IQ:
; 1512 : 				__RefreshStatus();

  000a6	8b ce		 mov	 ecx, esi
  000a8	e8 00 00 00 00	 call	 ?__RefreshStatus@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshStatus

; 1513 : 				__RefreshSkillWindow();

  000ad	e8 00 00 00 00	 call	 ?__RefreshSkillWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshSkillWindow

; 1514 : 				break;

  000b2	eb 27		 jmp	 SHORT $LN9@RecvPointC
$LN6@RecvPointC:

; 1515 : 			case POINT_SKILL:
; 1516 : 			case POINT_SUB_SKILL:
; 1517 : 			case POINT_HORSE_SKILL:
; 1518 : 				__RefreshSkillWindow();

  000b4	8b ce		 mov	 ecx, esi
  000b6	e8 00 00 00 00	 call	 ?__RefreshSkillWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshSkillWindow

; 1519 : 				break;

  000bb	eb 1e		 jmp	 SHORT $LN9@RecvPointC
$LN5@RecvPointC:

; 1520 : 			case POINT_ENERGY:
; 1521 : 				if (PointChange.value == 0)

  000bd	83 7d f5 00	 cmp	 DWORD PTR _PointChange$[ebp+13], 0
  000c1	75 11		 jne	 SHORT $LN3@RecvPointC

; 1522 : 				{
; 1523 : 					rkPlayer.SetStatus(POINT_ENERGY_END_TIME, 0);

  000c3	6a 00		 push	 0
  000c5	68 81 00 00 00	 push	 129			; 00000081H
  000ca	8b cf		 mov	 ecx, edi
  000cc	e8 00 00 00 00	 call	 ?SetStatus@CPythonPlayer@@QAEXKJ@Z ; CPythonPlayer::SetStatus
  000d1	8a 55 f0	 mov	 dl, BYTE PTR _PointChange$[ebp+8]
$LN3@RecvPointC:

; 1524 : 				}
; 1525 : 				__RefreshStatus();
; 1526 : 				break;
; 1527 : 			default:
; 1528 : 				__RefreshStatus();

  000d4	8b ce		 mov	 ecx, esi
  000d6	e8 00 00 00 00	 call	 ?__RefreshStatus@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshStatus
$LN9@RecvPointC:

; 1529 : 				break;
; 1530 : 		}
; 1531 : 
; 1532 : 		if (POINT_GOLD == PointChange.Type)

  000db	5f		 pop	 edi
  000dc	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  000df	75 27		 jne	 SHORT $LN1@RecvPointC

; 1533 : 		{
; 1534 : 			if (PointChange.amount > 0)

  000e1	8b 45 f1	 mov	 eax, DWORD PTR _PointChange$[ebp+9]
  000e4	85 c0		 test	 eax, eax
  000e6	7e 20		 jle	 SHORT $LN1@RecvPointC

; 1535 : 			{
; 1536 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnPickMoney", Py_BuildValue("(i)", PointChange.amount));

  000e8	50		 push	 eax
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000f4	50		 push	 eax
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JJMCBALF@OnPickMoney?$AA@
  000fa	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00100	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00105	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@RecvPointC:

; 1537 : 			}
; 1538 : 		}
; 1539 : 	}
; 1540 : 
; 1541 : 	return true;
; 1542 : }

  00108	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010b	b0 01		 mov	 al, 1
  0010d	33 cd		 xor	 ecx, ebp
  0010f	5e		 pop	 esi
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c3		 ret	 0
  00119	8d 49 00	 npad	 3
$LN24@RecvPointC:
  0011c	00 00 00 00	 DD	 $LN7@RecvPointC
  00120	00 00 00 00	 DD	 $LN6@RecvPointC
  00124	00 00 00 00	 DD	 $LN3@RecvPointC
  00128	00 00 00 00	 DD	 $LN5@RecvPointC
  0012c	00 00 00 00	 DD	 $LN3@RecvPointC
$LN22@RecvPointC:
  00130	00		 DB	 0
  00131	04		 DB	 4
  00132	04		 DB	 4
  00133	04		 DB	 4
  00134	04		 DB	 4
  00135	04		 DB	 4
  00136	04		 DB	 4
  00137	04		 DB	 4
  00138	04		 DB	 4
  00139	04		 DB	 4
  0013a	04		 DB	 4
  0013b	00		 DB	 0
  0013c	00		 DB	 0
  0013d	00		 DB	 0
  0013e	00		 DB	 0
  0013f	04		 DB	 4
  00140	04		 DB	 4
  00141	04		 DB	 4
  00142	04		 DB	 4
  00143	04		 DB	 4
  00144	04		 DB	 4
  00145	04		 DB	 4
  00146	04		 DB	 4
  00147	04		 DB	 4
  00148	04		 DB	 4
  00149	04		 DB	 4
  0014a	01		 DB	 1
  0014b	01		 DB	 1
  0014c	04		 DB	 4
  0014d	04		 DB	 4
  0014e	04		 DB	 4
  0014f	04		 DB	 4
  00150	04		 DB	 4
  00151	04		 DB	 4
  00152	04		 DB	 4
  00153	04		 DB	 4
  00154	04		 DB	 4
  00155	04		 DB	 4
  00156	04		 DB	 4
  00157	04		 DB	 4
  00158	04		 DB	 4
  00159	04		 DB	 4
  0015a	04		 DB	 4
  0015b	04		 DB	 4
  0015c	04		 DB	 4
  0015d	04		 DB	 4
  0015e	04		 DB	 4
  0015f	04		 DB	 4
  00160	04		 DB	 4
  00161	04		 DB	 4
  00162	04		 DB	 4
  00163	04		 DB	 4
  00164	04		 DB	 4
  00165	04		 DB	 4
  00166	04		 DB	 4
  00167	04		 DB	 4
  00168	04		 DB	 4
  00169	04		 DB	 4
  0016a	04		 DB	 4
  0016b	04		 DB	 4
  0016c	04		 DB	 4
  0016d	04		 DB	 4
  0016e	04		 DB	 4
  0016f	04		 DB	 4
  00170	04		 DB	 4
  00171	04		 DB	 4
  00172	04		 DB	 4
  00173	04		 DB	 4
  00174	04		 DB	 4
  00175	04		 DB	 4
  00176	04		 DB	 4
  00177	04		 DB	 4
  00178	04		 DB	 4
  00179	04		 DB	 4
  0017a	04		 DB	 4
  0017b	04		 DB	 4
  0017c	04		 DB	 4
  0017d	04		 DB	 4
  0017e	04		 DB	 4
  0017f	04		 DB	 4
  00180	04		 DB	 4
  00181	04		 DB	 4
  00182	04		 DB	 4
  00183	04		 DB	 4
  00184	04		 DB	 4
  00185	04		 DB	 4
  00186	04		 DB	 4
  00187	04		 DB	 4
  00188	04		 DB	 4
  00189	04		 DB	 4
  0018a	04		 DB	 4
  0018b	04		 DB	 4
  0018c	04		 DB	 4
  0018d	04		 DB	 4
  0018e	04		 DB	 4
  0018f	04		 DB	 4
  00190	04		 DB	 4
  00191	04		 DB	 4
  00192	04		 DB	 4
  00193	04		 DB	 4
  00194	04		 DB	 4
  00195	04		 DB	 4
  00196	04		 DB	 4
  00197	04		 DB	 4
  00198	04		 DB	 4
  00199	04		 DB	 4
  0019a	04		 DB	 4
  0019b	04		 DB	 4
  0019c	04		 DB	 4
  0019d	04		 DB	 4
  0019e	04		 DB	 4
  0019f	02		 DB	 2
  001a0	01		 DB	 1
  001a1	04		 DB	 4
  001a2	04		 DB	 4
  001a3	04		 DB	 4
  001a4	04		 DB	 4
  001a5	04		 DB	 4
  001a6	04		 DB	 4
  001a7	04		 DB	 4
  001a8	04		 DB	 4
  001a9	04		 DB	 4
  001aa	04		 DB	 4
  001ab	04		 DB	 4
  001ac	04		 DB	 4
  001ad	04		 DB	 4
  001ae	04		 DB	 4
  001af	03		 DB	 3
?RecvPointChange@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPointChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvStunPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_StunPacket$ = -8					; size = 5
?RecvStunPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvStunPacket, COMDAT
; _this$ = ecx

; 1545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1546 : 	TPacketGCStun StunPacket;
; 1547 : 
; 1548 : 	if (!Recv(sizeof(StunPacket), &StunPacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _StunPacket$[ebp]
  00009	50		 push	 eax
  0000a	6a 05		 push	 5
  0000c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00011	84 c0		 test	 al, al
  00013	75 13		 jne	 SHORT $LN4@RecvStunPa

; 1549 : 	{
; 1550 : 		Tracen("CPythonNetworkStream::RecvStunPacket Error");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@MKMKFBIM@CPythonNetworkStream?3?3RecvStunPa@
  0001a	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0001f	83 c4 04	 add	 esp, 4

; 1551 : 		return false;

  00022	32 c0		 xor	 al, al

; 1568 : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN4@RecvStunPa:

; 1552 : 	}
; 1553 : 
; 1554 : 	//Tracef("RecvStunPacket %d\n", StunPacket.vid);
; 1555 : 
; 1556 : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton

; 1557 : 	CInstanceBase * pkInstSel = rkChrMgr.GetInstancePtr(StunPacket.vid);

  0002e	ff 75 f9	 push	 DWORD PTR _StunPacket$[ebp+1]
  00031	83 c1 04	 add	 ecx, 4
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	ff 50 08	 call	 DWORD PTR [eax+8]
  00039	8b d0		 mov	 edx, eax

; 1558 : 
; 1559 : 	if (pkInstSel)

  0003b	85 d2		 test	 edx, edx
  0003d	74 21		 je	 SHORT $LN1@RecvStunPa

; 1560 : 	{
; 1561 : 		if (CPythonCharacterManager::Instance().GetMainInstancePtr()==pkInstSel)

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00045	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr

; 1562 : 			pkInstSel->Die();

  0004a	8b ca		 mov	 ecx, edx
  0004c	3b c2		 cmp	 eax, edx
  0004e	75 0b		 jne	 SHORT $LN2@RecvStunPa
  00050	e8 00 00 00 00	 call	 ?Die@CInstanceBase@@QAEXXZ ; CInstanceBase::Die

; 1565 : 	}
; 1566 : 
; 1567 : 	return true;

  00055	b0 01		 mov	 al, 1

; 1568 : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN2@RecvStunPa:

; 1563 : 		else
; 1564 : 			pkInstSel->Stun();

  0005b	e8 00 00 00 00	 call	 ?Stun@CInstanceBase@@QAEXXZ ; CInstanceBase::Stun
$LN1@RecvStunPa:

; 1565 : 	}
; 1566 : 
; 1567 : 	return true;

  00060	b0 01		 mov	 al, 1

; 1568 : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?RecvStunPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvStunPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvDeadPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_DeadPacket$ = -8					; size = 5
?RecvDeadPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvDeadPacket, COMDAT
; _this$ = ecx

; 1571 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1572 : 	TPacketGCDead DeadPacket;
; 1573 : 	if (!Recv(sizeof(DeadPacket), &DeadPacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _DeadPacket$[ebp]
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	6a 05		 push	 5
  0000d	8b f9		 mov	 edi, ecx
  0000f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00014	84 c0		 test	 al, al
  00016	75 14		 jne	 SHORT $LN4@RecvDeadPa

; 1574 : 	{
; 1575 : 		Tracen("CPythonNetworkStream::RecvDeadPacket Error");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KJGPDLAC@CPythonNetworkStream?3?3RecvDeadPa@
  0001d	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00022	83 c4 04	 add	 esp, 4

; 1576 : 		return false;

  00025	32 c0		 xor	 al, al
  00027	5f		 pop	 edi

; 1598 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN4@RecvDeadPa:
  0002c	53		 push	 ebx

; 1577 : 	}
; 1578 : 
; 1579 : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  0002d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton

; 1580 : 	CInstanceBase * pkChrInstSel = rkChrMgr.GetInstancePtr(DeadPacket.vid);

  00033	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00036	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00039	56		 push	 esi
  0003a	ff 75 f9	 push	 DWORD PTR _DeadPacket$[ebp+1]
  0003d	ff 50 08	 call	 DWORD PTR [eax+8]
  00040	8b f0		 mov	 esi, eax

; 1581 : 	if (pkChrInstSel)

  00042	85 f6		 test	 esi, esi
  00044	74 56		 je	 SHORT $LN3@RecvDeadPa

; 1582 : 	{
; 1583 : 		CInstanceBase* pkInstMain=rkChrMgr.GetMainInstancePtr();

  00046	8b cb		 mov	 ecx, ebx
  00048	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  0004d	8b d8		 mov	 ebx, eax

; 1584 : 		if (pkInstMain==pkChrInstSel)

  0004f	3b de		 cmp	 ebx, esi
  00051	75 42		 jne	 SHORT $LN2@RecvDeadPa

; 1585 : 		{
; 1586 : 			Tracenf(" ");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BDKDPHGA@?A?V?$MA?N?$LA?x?5?$LL?g?$LI?A?$AA@
  00058	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0005d	83 c4 04	 add	 esp, 4

; 1587 : 			if (false == pkInstMain->GetDuelMode())

  00060	8b cb		 mov	 ecx, ebx
  00062	e8 00 00 00 00	 call	 ?GetDuelMode@CInstanceBase@@QAEKXZ ; CInstanceBase::GetDuelMode
  00067	85 c0		 test	 eax, eax
  00069	75 1f		 jne	 SHORT $LN1@RecvDeadPa

; 1588 : 			{
; 1589 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnGameOver", Py_BuildValue("()"));

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00076	50		 push	 eax
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MNOOMILJ@OnGameOver?$AA@
  0007c	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00082	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00087	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@RecvDeadPa:

; 1590 : 			}
; 1591 : 			CPythonPlayer::Instance().NotifyDeadMainCharacter();

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00090	e8 00 00 00 00	 call	 ?NotifyDeadMainCharacter@CPythonPlayer@@QAEXXZ ; CPythonPlayer::NotifyDeadMainCharacter
$LN2@RecvDeadPa:

; 1592 : 		}
; 1593 : 
; 1594 : 		pkChrInstSel->Die();

  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?Die@CInstanceBase@@QAEXXZ ; CInstanceBase::Die
$LN3@RecvDeadPa:

; 1595 : 	}
; 1596 : 
; 1597 : 	return true;

  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	b0 01		 mov	 al, 1
  000a0	5f		 pop	 edi

; 1598 : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?RecvDeadPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvDeadPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvCharacterPositionPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_PositionPacket$ = -8					; size = 6
?RecvCharacterPositionPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvCharacterPositionPacket, COMDAT
; _this$ = ecx

; 1633 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1634 : 	TPacketGCPosition PositionPacket;
; 1635 : 
; 1636 : 	if (!Recv(sizeof(TPacketGCPosition), &PositionPacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _PositionPacket$[ebp]
  00009	50		 push	 eax
  0000a	6a 06		 push	 6
  0000c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00011	84 c0		 test	 al, al
  00013	75 04		 jne	 SHORT $LN2@RecvCharac

; 1642 : 		return true;
; 1643 : 
; 1644 : 	//pChrInstance->UpdatePosition(PositionPacket.position);
; 1645 : 
; 1646 : 	return true;
; 1647 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN2@RecvCharac:

; 1637 : 		return false;
; 1638 : 
; 1639 : 	CInstanceBase * pChrInstance = CPythonCharacterManager::Instance().GetInstancePtr(PositionPacket.vid);

  00019	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0001f	ff 75 f9	 push	 DWORD PTR _PositionPacket$[ebp+1]
  00022	83 c1 04	 add	 ecx, 4
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	ff 50 08	 call	 DWORD PTR [eax+8]

; 1640 : 
; 1641 : 	if (!pChrInstance)

  0002a	b0 01		 mov	 al, 1

; 1642 : 		return true;
; 1643 : 
; 1644 : 	//pChrInstance->UpdatePosition(PositionPacket.position);
; 1645 : 
; 1646 : 	return true;
; 1647 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?RecvCharacterPositionPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvCharacterPositionPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvMotionPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_MotionPacket$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
?RecvMotionPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvMotionPacket, COMDAT
; _this$ = ecx

; 1650 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1651 : 	TPacketGCMotion MotionPacket;
; 1652 : 
; 1653 : 	if (!Recv(sizeof(TPacketGCMotion), &MotionPacket))

  00010	8d 45 f0	 lea	 eax, DWORD PTR _MotionPacket$[ebp]
  00013	50		 push	 eax
  00014	6a 0b		 push	 11			; 0000000bH
  00016	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001b	84 c0		 test	 al, al
  0001d	75 0e		 jne	 SHORT $LN3@RecvMotion

; 1661 : 
; 1662 : 	if (!pMainInstance)
; 1663 : 		return false;
; 1664 : 
; 1665 : 	return true;
; 1666 : }

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00022	33 cd		 xor	 ecx, ebp
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN3@RecvMotion:

; 1654 : 		return false;
; 1655 : 
; 1656 : 	CInstanceBase * pMainInstance = CPythonCharacterManager::Instance().GetInstancePtr(MotionPacket.vid);

  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00033	83 c1 04	 add	 ecx, 4
  00036	57		 push	 edi
  00037	ff 75 f1	 push	 DWORD PTR _MotionPacket$[ebp+1]
  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003c	ff 50 08	 call	 DWORD PTR [eax+8]

; 1657 : 	CInstanceBase * pVictimInstance = NULL;
; 1658 : 
; 1659 : 	if (0 != MotionPacket.victim_vid)

  0003f	83 7d f5 00	 cmp	 DWORD PTR _MotionPacket$[ebp+5], 0
  00043	8b f8		 mov	 edi, eax
  00045	74 11		 je	 SHORT $LN2@RecvMotion

; 1660 : 		pVictimInstance = CPythonCharacterManager::Instance().GetInstancePtr(MotionPacket.victim_vid);

  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0004d	ff 75 f5	 push	 DWORD PTR _MotionPacket$[ebp+5]
  00050	83 c1 04	 add	 ecx, 4
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	ff 52 08	 call	 DWORD PTR [edx+8]
$LN2@RecvMotion:

; 1661 : 
; 1662 : 	if (!pMainInstance)
; 1663 : 		return false;
; 1664 : 
; 1665 : 	return true;
; 1666 : }

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	85 ff		 test	 edi, edi
  0005d	5f		 pop	 edi
  0005e	0f 95 c0	 setne	 al
  00061	33 cd		 xor	 ecx, ebp
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?RecvMotionPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvMotionPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonshop.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonshop.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_vecBuffer$ = -52					; size = 12
_dwVID$1$ = -40						; size = 4
tv777 = -36						; size = 4
tv783 = -32						; size = 4
tv778 = -28						; size = 4
_this$1$ = -24						; size = 4
_i$1$ = -20						; size = 4
_dwVID$1$ = -20						; size = 4
_packet_shop$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvShopPacket, COMDAT
; _this$ = ecx

; 1669 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d e8	 mov	 DWORD PTR _this$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  0002d	33 f6		 xor	 esi, esi
  0002f	89 75 cc	 mov	 DWORD PTR _vecBuffer$[ebp], esi

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();

  00032	89 75 d4	 mov	 DWORD PTR _vecBuffer$[ebp+8], esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1674 : 	if (!Recv(sizeof(packet_shop), &packet_shop))

  00035	8d 45 f0	 lea	 eax, DWORD PTR _packet_shop$[ebp]
  00038	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  0003b	50		 push	 eax
  0003c	6a 04		 push	 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003e	89 75 d0	 mov	 DWORD PTR _vecBuffer$[ebp+4], esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1674 : 	if (!Recv(sizeof(packet_shop), &packet_shop))

  00041	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00046	84 c0		 test	 al, al
  00048	0f 84 3b 02 00
	00		 je	 $LN29@RecvShopPa

; 1675 : 		return false;
; 1676 : 
; 1677 : 	int iSize = packet_shop.size - sizeof(packet_shop);

  0004e	0f b7 7d f1	 movzx	 edi, WORD PTR _packet_shop$[ebp+1]
  00052	83 ef 04	 sub	 edi, 4

; 1678 : 	if (iSize > 0)

  00055	85 ff		 test	 edi, edi
  00057	7e 1d		 jle	 SHORT $LN23@RecvShopPa

; 1679 : 	{
; 1680 : 		vecBuffer.resize(iSize);

  00059	57		 push	 edi
  0005a	8d 4d cc	 lea	 ecx, DWORD PTR _vecBuffer$[ebp]
  0005d	e8 00 00 00 00	 call	 ?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::resize

; 1681 : 		if (!Recv(iSize, &vecBuffer[0]))

  00062	8b 75 cc	 mov	 esi, DWORD PTR _vecBuffer$[ebp]
  00065	8b cb		 mov	 ecx, ebx
  00067	56		 push	 esi
  00068	57		 push	 edi
  00069	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAD@Z ; CNetworkStream::Recv
  0006e	84 c0		 test	 al, al
  00070	0f 84 13 02 00
	00		 je	 $LN29@RecvShopPa
$LN23@RecvShopPa:

; 1682 : 			return false;
; 1683 : 	}
; 1684 : 
; 1685 : 	switch (packet_shop.subheader)

  00076	0f b6 45 f3	 movzx	 eax, BYTE PTR _packet_shop$[ebp+3]
  0007a	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0007d	0f 87 f2 01 00
	00		 ja	 $LN1@RecvShopPa
  00083	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN134@RecvShopPa[eax*4]
$LN20@RecvShopPa:

; 1689 : 				CPythonShop::Instance().Clear();

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00090	e8 00 00 00 00	 call	 ?Clear@CPythonShop@@QAEXXZ ; CPythonShop::Clear

; 1690 : 
; 1691 : 				DWORD dwVID = *(DWORD *)&vecBuffer[0];

  00095	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00097	83 c6 04	 add	 esi, 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1689 : 				CPythonShop::Instance().Clear();

  0009a	33 ff		 xor	 edi, edi

; 1690 : 
; 1691 : 				DWORD dwVID = *(DWORD *)&vecBuffer[0];

  0009c	89 45 ec	 mov	 DWORD PTR _dwVID$1$[ebp], eax
  0009f	8d 5f 28	 lea	 ebx, DWORD PTR [edi+40]
$LL19@RecvShopPa:

; 1692 : 
; 1693 : 				TPacketGCShopStart * pShopStartPacket = (TPacketGCShopStart *)&vecBuffer[4];
; 1694 : 				for (BYTE iItemIndex = 0; iItemIndex < SHOP_HOST_ITEM_MAX_NUM; ++iItemIndex)
; 1695 : 				{
; 1696 : 					CPythonShop::Instance().SetItemData(iItemIndex, pShopStartPacket->items[iItemIndex]);

  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  000a8	56		 push	 esi
  000a9	57		 push	 edi
  000aa	e8 00 00 00 00	 call	 ?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData
  000af	47		 inc	 edi
  000b0	83 c6 2b	 add	 esi, 43			; 0000002bH
  000b3	4b		 dec	 ebx
  000b4	75 ec		 jne	 SHORT $LL19@RecvShopPa

; 1697 : 				}
; 1698 : 
; 1699 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartShop", Py_BuildValue("(i)", dwVID));

  000b6	ff 75 ec	 push	 DWORD PTR _dwVID$1$[ebp]
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000c4	8b 5d e8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000c7	50		 push	 eax
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_09PJIJIJPH@StartShop?$AA@
  000cd	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  000d3	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 1778 : 	return true;

  000d8	8b 75 cc	 mov	 esi, DWORD PTR _vecBuffer$[ebp]
  000db	83 c4 14	 add	 esp, 20			; 00000014H
  000de	b3 01		 mov	 bl, 1
  000e0	e9 a6 01 00 00	 jmp	 $LN30@RecvShopPa
$LN16@RecvShopPa:

; 1700 : 			}
; 1701 : 			break;
; 1702 : 
; 1703 : 		case SHOP_SUBHEADER_GC_START_EX:
; 1704 : 			{
; 1705 : 				CPythonShop::Instance().Clear();

  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  000eb	e8 00 00 00 00	 call	 ?Clear@CPythonShop@@QAEXXZ ; CPythonShop::Clear

; 1710 : 				DWORD dwVID = pShopStartPacket->owner_vid;

  000f0	8b 06		 mov	 eax, DWORD PTR [esi]

; 1715 : 				for (size_t i = 0; i < shop_tab_count; i++)

  000f2	33 c9		 xor	 ecx, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonshop.h

; 34   : 		void SetTabCount(BYTE bTabCount) { m_bTabCount = bTabCount; }

  000f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1710 : 				DWORD dwVID = pShopStartPacket->owner_vid;

  000fa	89 45 d8	 mov	 DWORD PTR _dwVID$1$[ebp], eax

; 1711 : 				BYTE shop_tab_count = pShopStartPacket->shop_tab_count;

  000fd	8a 46 04	 mov	 al, BYTE PTR [esi+4]

; 1715 : 				for (size_t i = 0; i < shop_tab_count; i++)

  00100	89 4d ec	 mov	 DWORD PTR _i$1$[ebp], ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonshop.h

; 34   : 		void SetTabCount(BYTE bTabCount) { m_bTabCount = bTabCount; }

  00103	88 42 10	 mov	 BYTE PTR [edx+16], al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1715 : 				for (size_t i = 0; i < shop_tab_count; i++)

  00106	0f b6 c0	 movzx	 eax, al
  00109	89 45 e0	 mov	 DWORD PTR tv783[ebp], eax
  0010c	85 c0		 test	 eax, eax
  0010e	74 65		 je	 SHORT $LN130@RecvShopPa

; 1700 : 			}
; 1701 : 			break;
; 1702 : 
; 1703 : 		case SHOP_SUBHEADER_GC_START_EX:
; 1704 : 			{
; 1705 : 				CPythonShop::Instance().Clear();

  00110	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
$LL15@RecvShopPa:

; 1716 : 				{
; 1717 : 					TPacketGCShopStartEx::TSubPacketShopTab* pPackTab = (TPacketGCShopStartEx::TSubPacketShopTab*)&vecBuffer[read_point];

  00113	8b f0		 mov	 esi, eax

; 1718 : 					read_point += sizeof(TPacketGCShopStartEx::TSubPacketShopTab);
; 1719 : 					
; 1720 : 					CPythonShop::instance().SetTabCoinType(i, pPackTab->coin_type);

  00115	8a d9		 mov	 bl, cl
  00117	05 d9 06 00 00	 add	 eax, 1753		; 000006d9H
  0011c	89 5d e4	 mov	 DWORD PTR tv778[ebp], ebx
  0011f	89 45 dc	 mov	 DWORD PTR tv777[ebp], eax
  00122	8b ca		 mov	 ecx, edx
  00124	0f b6 46 20	 movzx	 eax, BYTE PTR [esi+32]
  00128	50		 push	 eax
  00129	53		 push	 ebx
  0012a	e8 00 00 00 00	 call	 ?SetTabCoinType@CPythonShop@@QAEXEE@Z ; CPythonShop::SetTabCoinType

; 1721 : 					CPythonShop::instance().SetTabName(i, pPackTab->name);

  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00135	56		 push	 esi
  00136	53		 push	 ebx
  00137	e8 00 00 00 00	 call	 ?SetTabName@CPythonShop@@QAEXEPBD@Z ; CPythonShop::SetTabName

; 1722 : 
; 1723 : 					struct packet_shop_item* item = &pPackTab->items[0];

  0013c	83 c6 21	 add	 esi, 33			; 00000021H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0013f	33 ff		 xor	 edi, edi
  00141	8d 5f 28	 lea	 ebx, DWORD PTR [edi+40]
$LL12@RecvShopPa:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1728 : 						CPythonShop::Instance().SetItemData(i, j, *itemData);

  00144	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0014a	56		 push	 esi
  0014b	57		 push	 edi
  0014c	ff 75 e4	 push	 DWORD PTR tv778[ebp]
  0014f	e8 00 00 00 00	 call	 ?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData
  00154	47		 inc	 edi
  00155	83 c6 2b	 add	 esi, 43			; 0000002bH
  00158	4b		 dec	 ebx
  00159	75 e9		 jne	 SHORT $LL12@RecvShopPa

; 1715 : 				for (size_t i = 0; i < shop_tab_count; i++)

  0015b	8b 4d ec	 mov	 ecx, DWORD PTR _i$1$[ebp]
  0015e	41		 inc	 ecx
  0015f	89 4d ec	 mov	 DWORD PTR _i$1$[ebp], ecx
  00162	3b 4d e0	 cmp	 ecx, DWORD PTR tv783[ebp]
  00165	73 0b		 jae	 SHORT $LN131@RecvShopPa

; 1700 : 			}
; 1701 : 			break;
; 1702 : 
; 1703 : 		case SHOP_SUBHEADER_GC_START_EX:
; 1704 : 			{
; 1705 : 				CPythonShop::Instance().Clear();

  00167	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0016d	8b 45 dc	 mov	 eax, DWORD PTR tv777[ebp]
  00170	eb a1		 jmp	 SHORT $LL15@RecvShopPa
$LN131@RecvShopPa:
  00172	8b 5d e8	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN130@RecvShopPa:

; 1729 : 					}
; 1730 : 				}
; 1731 : 
; 1732 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartShop", Py_BuildValue("(i)", dwVID));

  00175	ff 75 d8	 push	 DWORD PTR _dwVID$1$[ebp]
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00183	50		 push	 eax
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_09PJIJIJPH@StartShop?$AA@
  00189	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  0018f	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 1778 : 	return true;

  00194	8b 75 cc	 mov	 esi, DWORD PTR _vecBuffer$[ebp]
  00197	83 c4 14	 add	 esp, 20			; 00000014H
  0019a	b3 01		 mov	 bl, 1
  0019c	e9 ea 00 00 00	 jmp	 $LN30@RecvShopPa
$LN9@RecvShopPa:

; 1733 : 			}
; 1734 : 			break;
; 1735 : 
; 1736 : 
; 1737 : 		case SHOP_SUBHEADER_GC_END:
; 1738 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "EndShop", Py_BuildValue("()"));

  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  001ac	50		 push	 eax
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_07FONJAJPH@EndShop?$AA@
  001b2	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  001b8	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 1778 : 	return true;

  001bd	8b 75 cc	 mov	 esi, DWORD PTR _vecBuffer$[ebp]
  001c0	83 c4 10	 add	 esp, 16			; 00000010H
  001c3	b3 01		 mov	 bl, 1
  001c5	e9 c1 00 00 00	 jmp	 $LN30@RecvShopPa
$LN8@RecvShopPa:

; 1739 : 			break;
; 1740 : 
; 1741 : 		case SHOP_SUBHEADER_GC_UPDATE_ITEM:
; 1742 : 			{
; 1743 : 				TPacketGCShopUpdateItem * pShopUpdateItemPacket = (TPacketGCShopUpdateItem *)&vecBuffer[0];
; 1744 : 				CPythonShop::Instance().SetItemData(pShopUpdateItemPacket->pos, pShopUpdateItemPacket->item);

  001ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  001d0	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  001d3	50		 push	 eax
  001d4	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData

; 1745 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshShop", Py_BuildValue("()"));

  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  001e8	50		 push	 eax
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DLPMCOFP@RefreshShop?$AA@
  001ee	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  001f4	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 1778 : 	return true;

  001f9	8b 75 cc	 mov	 esi, DWORD PTR _vecBuffer$[ebp]
  001fc	83 c4 10	 add	 esp, 16			; 00000010H
  001ff	b3 01		 mov	 bl, 1
  00201	e9 85 00 00 00	 jmp	 $LN30@RecvShopPa
$LN7@RecvShopPa:

; 1746 : 			}
; 1747 : 			break;
; 1748 : 
; 1749 : 		case SHOP_SUBHEADER_GC_UPDATE_PRICE:
; 1750 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetShopSellingPrice", Py_BuildValue("(i)", *(int *)&vecBuffer[0]));

  00206	ff 36		 push	 DWORD PTR [esi]
  00208	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00213	50		 push	 eax
  00214	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MHMAEIEM@SetShopSellingPrice?$AA@
  00219	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  0021f	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 1778 : 	return true;

  00224	8b 75 cc	 mov	 esi, DWORD PTR _vecBuffer$[ebp]
  00227	83 c4 14	 add	 esp, 20			; 00000014H
  0022a	b3 01		 mov	 bl, 1
  0022c	eb 5d		 jmp	 SHORT $LN30@RecvShopPa
$LN6@RecvShopPa:

; 1751 : 			break;
; 1752 : 			
; 1753 : 		case SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY:
; 1754 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_MONEY"));

  0022e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GHBGEHD@NOT_ENOUGH_MONEY?$AA@
$LN133@RecvShopPa:
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0023e	50		 push	 eax
  0023f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NHHHAHOK@OnShopError?$AA@
  00244	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  0024a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 1778 : 	return true;

  0024f	8b 75 cc	 mov	 esi, DWORD PTR _vecBuffer$[ebp]
  00252	83 c4 14	 add	 esp, 20			; 00000014H
  00255	b3 01		 mov	 bl, 1
  00257	eb 32		 jmp	 SHORT $LN30@RecvShopPa
$LN5@RecvShopPa:

; 1755 : 			break;
; 1756 : 
; 1757 : 		case SHOP_SUBHEADER_GC_NOT_ENOUGH_MONEY_EX:
; 1758 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "NOT_ENOUGH_MONEY_EX"));

  00259	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@OHHJLOIF@NOT_ENOUGH_MONEY_EX?$AA@

; 1759 : 			break;

  0025e	eb d3		 jmp	 SHORT $LN133@RecvShopPa
$LN4@RecvShopPa:

; 1760 : 
; 1761 : 		case SHOP_SUBHEADER_GC_SOLDOUT:
; 1762 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "SOLDOUT"));

  00260	68 00 00 00 00	 push	 OFFSET ??_C@_07FBAJNJNN@SOLDOUT?$AA@

; 1763 : 			break;

  00265	eb cc		 jmp	 SHORT $LN133@RecvShopPa
$LN3@RecvShopPa:

; 1764 : 
; 1765 : 		case SHOP_SUBHEADER_GC_INVENTORY_FULL:
; 1766 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "INVENTORY_FULL"));

  00267	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HIHIAGBD@INVENTORY_FULL?$AA@

; 1767 : 			break;

  0026c	eb c5		 jmp	 SHORT $LN133@RecvShopPa
$LN2@RecvShopPa:

; 1768 : 
; 1769 : 		case SHOP_SUBHEADER_GC_INVALID_POS:
; 1770 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnShopError", Py_BuildValue("(s)", "INVALID_POS"));

  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HAELFLPD@INVALID_POS?$AA@

; 1771 : 			break;

  00273	eb be		 jmp	 SHORT $LN133@RecvShopPa
$LN1@RecvShopPa:

; 1772 : 
; 1773 : 		default:
; 1774 : 			TraceError("CPythonNetworkStream::RecvShopPacket: Unknown subheader\n");

  00275	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@IGANFIGP@CPythonNetworkStream?3?3RecvShopPa@
  0027a	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError

; 1778 : 	return true;

  0027f	8b 75 cc	 mov	 esi, DWORD PTR _vecBuffer$[ebp]
  00282	83 c4 04	 add	 esp, 4
  00285	b3 01		 mov	 bl, 1
  00287	eb 02		 jmp	 SHORT $LN30@RecvShopPa
$LN29@RecvShopPa:
  00289	32 db		 xor	 bl, bl
$LN30@RecvShopPa:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0028b	85 f6		 test	 esi, esi
  0028d	74 09		 je	 SHORT $LN126@RecvShopPa
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0028f	56		 push	 esi
  00290	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00295	83 c4 04	 add	 esp, 4
$LN126@RecvShopPa:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1778 : 	return true;

  00298	8a c3		 mov	 al, bl

; 1779 : }

  0029a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0029d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002a4	59		 pop	 ecx
  002a5	5f		 pop	 edi
  002a6	5e		 pop	 esi
  002a7	5b		 pop	 ebx
  002a8	8b e5		 mov	 esp, ebp
  002aa	5d		 pop	 ebp
  002ab	c3		 ret	 0
$LN134@RecvShopPa:
  002ac	00 00 00 00	 DD	 $LN20@RecvShopPa
  002b0	00 00 00 00	 DD	 $LN9@RecvShopPa
  002b4	00 00 00 00	 DD	 $LN8@RecvShopPa
  002b8	00 00 00 00	 DD	 $LN7@RecvShopPa
  002bc	00 00 00 00	 DD	 $LN1@RecvShopPa
  002c0	00 00 00 00	 DD	 $LN6@RecvShopPa
  002c4	00 00 00 00	 DD	 $LN4@RecvShopPa
  002c8	00 00 00 00	 DD	 $LN3@RecvShopPa
  002cc	00 00 00 00	 DD	 $LN2@RecvShopPa
  002d0	00 00 00 00	 DD	 $LN1@RecvShopPa
  002d4	00 00 00 00	 DD	 $LN16@RecvShopPa
  002d8	00 00 00 00	 DD	 $LN5@RecvShopPa
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _vecBuffer$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__ehhandler$?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvShopPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvShopPacket
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvExchangePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -60					; size = 4
_iSlotIndex$1$ = -56					; size = 4
_iSlotIndex$1$ = -56					; size = 4
_exchange_packet$ = -52					; size = 47
__$ArrayPad$ = -4					; size = 4
?RecvExchangePacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvExchangePacket, COMDAT
; _this$ = ecx

; 1782 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  00010	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00015	c6 45 d3 01	 mov	 BYTE PTR _exchange_packet$[ebp+7], 1
  00019	53		 push	 ebx
  0001a	66 89 45 d4	 mov	 WORD PTR _exchange_packet$[ebp+8], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 1782 : {

  0001e	8b d9		 mov	 ebx, ecx

; 1783 : 	TPacketGCExchange exchange_packet;
; 1784 : 
; 1785 : 	if (!Recv(sizeof(exchange_packet), &exchange_packet))

  00020	8d 45 cc	 lea	 eax, DWORD PTR _exchange_packet$[ebp]
  00023	89 5d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00026	50		 push	 eax
  00027	6a 2f		 push	 47			; 0000002fH
  00029	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0002e	84 c0		 test	 al, al
  00030	75 0f		 jne	 SHORT $LN32@RecvExchan
  00032	5b		 pop	 ebx

; 1879 : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN32@RecvExchan:

; 1786 : 		return false;
; 1787 : 
; 1788 : 	switch (exchange_packet.subheader)

  00041	0f b6 45 cd	 movzx	 eax, BYTE PTR _exchange_packet$[ebp+1]
  00045	83 f8 07	 cmp	 eax, 7
  00048	0f 87 97 02 00
	00		 ja	 $LN30@RecvExchan
  0004e	56		 push	 esi
  0004f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN97@RecvExchan[eax*4]
$LN29@RecvExchan:

; 1789 : 	{
; 1790 : 		case EXCHANGE_SUBHEADER_GC_START:
; 1791 : 			CPythonExchange::Instance().Clear();

  00056	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?Clear@CPythonExchange@@QAEXXZ ; CPythonExchange::Clear

; 1792 : 			CPythonExchange::Instance().Start();

  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?Start@CPythonExchange@@QAEXXZ ; CPythonExchange::Start

; 1793 : 			CPythonExchange::Instance().SetSelfName(CPythonPlayer::Instance().GetName());

  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00070	83 c1 04	 add	 ecx, 4
  00073	8b 01		 mov	 eax, DWORD PTR [ecx]
  00075	ff 50 14	 call	 DWORD PTR [eax+20]
  00078	50		 push	 eax
  00079	8b ce		 mov	 ecx, esi
  0007b	e8 00 00 00 00	 call	 ?SetSelfName@CPythonExchange@@QAEXPBD@Z ; CPythonExchange::SetSelfName

; 1794 : 
; 1795 : 			{
; 1796 : 				CInstanceBase * pCharacterInstance = CPythonCharacterManager::Instance().GetInstancePtr(exchange_packet.arg1);

  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00086	ff 75 cf	 push	 DWORD PTR _exchange_packet$[ebp+3]
  00089	83 c1 04	 add	 ecx, 4
  0008c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008e	ff 50 08	 call	 DWORD PTR [eax+8]

; 1797 : 
; 1798 : 				if (pCharacterInstance)

  00091	85 c0		 test	 eax, eax
  00093	74 13		 je	 SHORT $LN28@RecvExchan

; 1799 : 					CPythonExchange::Instance().SetTargetName(pCharacterInstance->GetNameString());

  00095	8b c8		 mov	 ecx, eax
  00097	e8 00 00 00 00	 call	 ?GetNameString@CInstanceBase@@QAEPBDXZ ; CInstanceBase::GetNameString
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?SetTargetName@CPythonExchange@@QAEXPBD@Z ; CPythonExchange::SetTargetName
$LN28@RecvExchan:

; 1800 : 			}
; 1801 : 
; 1802 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartExchange", Py_BuildValue("()"));

  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000b3	50		 push	 eax
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HKIIBLHD@StartExchange?$AA@
  000b9	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  000bf	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000c4	83 c4 10	 add	 esp, 16			; 00000010H

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  000c7	b0 01		 mov	 al, 1
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx

; 1879 : }

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 cd		 xor	 ecx, ebp
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
$LN27@RecvExchan:

; 1803 : 			break;
; 1804 : 
; 1805 : 		case EXCHANGE_SUBHEADER_GC_ITEM_ADD:
; 1806 : 			if (exchange_packet.is_me)

  000d9	80 7d ce 00	 cmp	 BYTE PTR _exchange_packet$[ebp+2], 0

; 1807 : 			{
; 1808 : 				int iSlotIndex = exchange_packet.arg2.cell;
; 1809 : 				CPythonExchange::Instance().SetItemToSelf(iSlotIndex, exchange_packet.arg1, (BYTE) exchange_packet.arg3);

  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  000e3	57		 push	 edi
  000e4	ff 75 d6	 push	 DWORD PTR _exchange_packet$[ebp+10]
  000e7	0f b7 7d d4	 movzx	 edi, WORD PTR _exchange_packet$[ebp+8]
  000eb	ff 75 cf	 push	 DWORD PTR _exchange_packet$[ebp+3]
  000ee	89 7d c8	 mov	 DWORD PTR _iSlotIndex$1$[ebp], edi
  000f1	57		 push	 edi
  000f2	74 4d		 je	 SHORT $LN26@RecvExchan
  000f4	e8 00 00 00 00	 call	 ?SetItemToSelf@CPythonExchange@@QAEXKKE@Z ; CPythonExchange::SetItemToSelf

; 1810 : 				for (int i = 0; i < ITEM_SOCKET_SLOT_MAX_NUM; ++i)

  000f9	33 f6		 xor	 esi, esi
  000fb	eb 03 8d 49 00	 npad	 5
$LL25@RecvExchan:

; 1811 : 					CPythonExchange::Instance().SetItemMetinSocketToSelf(iSlotIndex, i, exchange_packet.alValues[i]);

  00100	ff 74 b5 da	 push	 DWORD PTR _exchange_packet$[ebp+esi*4+14]
  00104	56		 push	 esi
  00105	57		 push	 edi
  00106	e8 00 00 00 00	 call	 ?SetItemMetinSocketToSelf@CPythonExchange@@QAEXHHK@Z ; CPythonExchange::SetItemMetinSocketToSelf
  0010b	46		 inc	 esi
  0010c	83 fe 03	 cmp	 esi, 3
  0010f	7c ef		 jl	 SHORT $LL25@RecvExchan

; 1812 : 				for (int j = 0; j < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++j)

  00111	8b 5d c8	 mov	 ebx, DWORD PTR _iSlotIndex$1$[ebp]
  00114	8d 7d e6	 lea	 edi, DWORD PTR _exchange_packet$[ebp+26]
  00117	33 f6		 xor	 esi, esi
  00119	8d a4 24 00 00
	00 00		 npad	 7
$LL22@RecvExchan:

; 1813 : 					CPythonExchange::Instance().SetItemAttributeToSelf(iSlotIndex, j, exchange_packet.aAttr[j].bType, exchange_packet.aAttr[j].sValue);

  00120	0f b7 47 01	 movzx	 eax, WORD PTR [edi+1]
  00124	50		 push	 eax
  00125	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00128	50		 push	 eax
  00129	56		 push	 esi
  0012a	53		 push	 ebx
  0012b	e8 00 00 00 00	 call	 ?SetItemAttributeToSelf@CPythonExchange@@QAEXHHEF@Z ; CPythonExchange::SetItemAttributeToSelf
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  00136	8d 7f 03	 lea	 edi, DWORD PTR [edi+3]
  00139	46		 inc	 esi
  0013a	83 fe 07	 cmp	 esi, 7
  0013d	7c e1		 jl	 SHORT $LL22@RecvExchan

; 1814 : 			}
; 1815 : 			else

  0013f	eb 3f		 jmp	 SHORT $LN94@RecvExchan
$LN26@RecvExchan:

; 1816 : 			{
; 1817 : 				int iSlotIndex = exchange_packet.arg2.cell;
; 1818 : 				CPythonExchange::Instance().SetItemToTarget(iSlotIndex, exchange_packet.arg1, (BYTE) exchange_packet.arg3);

  00141	e8 00 00 00 00	 call	 ?SetItemToTarget@CPythonExchange@@QAEXKKE@Z ; CPythonExchange::SetItemToTarget

; 1819 : 				for (int i = 0; i < ITEM_SOCKET_SLOT_MAX_NUM; ++i)

  00146	33 f6		 xor	 esi, esi
$LL18@RecvExchan:

; 1820 : 					CPythonExchange::Instance().SetItemMetinSocketToTarget(iSlotIndex, i, exchange_packet.alValues[i]);

  00148	ff 74 b5 da	 push	 DWORD PTR _exchange_packet$[ebp+esi*4+14]
  0014c	56		 push	 esi
  0014d	57		 push	 edi
  0014e	e8 00 00 00 00	 call	 ?SetItemMetinSocketToTarget@CPythonExchange@@QAEXHHK@Z ; CPythonExchange::SetItemMetinSocketToTarget
  00153	46		 inc	 esi
  00154	83 fe 03	 cmp	 esi, 3
  00157	7c ef		 jl	 SHORT $LL18@RecvExchan

; 1821 : 				for (int j = 0; j < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++j)

  00159	8b 5d c8	 mov	 ebx, DWORD PTR _iSlotIndex$1$[ebp]
  0015c	8d 7d e6	 lea	 edi, DWORD PTR _exchange_packet$[ebp+26]
  0015f	33 f6		 xor	 esi, esi
$LL15@RecvExchan:

; 1822 : 					CPythonExchange::Instance().SetItemAttributeToTarget(iSlotIndex, j, exchange_packet.aAttr[j].bType, exchange_packet.aAttr[j].sValue);

  00161	0f b7 47 01	 movzx	 eax, WORD PTR [edi+1]
  00165	50		 push	 eax
  00166	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00169	50		 push	 eax
  0016a	56		 push	 esi
  0016b	53		 push	 ebx
  0016c	e8 00 00 00 00	 call	 ?SetItemAttributeToTarget@CPythonExchange@@QAEXHHEF@Z ; CPythonExchange::SetItemAttributeToTarget
  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  00177	8d 7f 03	 lea	 edi, DWORD PTR [edi+3]
  0017a	46		 inc	 esi
  0017b	83 fe 07	 cmp	 esi, 7
  0017e	7c e1		 jl	 SHORT $LL15@RecvExchan
$LN94@RecvExchan:
  00180	8b 5d c4	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]

; 1823 : 			}
; 1824 : 
; 1825 : 			__RefreshExchangeWindow();

  00183	8b cb		 mov	 ecx, ebx
  00185	e8 00 00 00 00	 call	 ?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshExchangeWindow

; 1826 : 			__RefreshInventoryWindow();

  0018a	e8 00 00 00 00	 call	 ?__RefreshInventoryWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshInventoryWindow
  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  00191	b0 01		 mov	 al, 1
  00193	5b		 pop	 ebx

; 1879 : }

  00194	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00197	33 cd		 xor	 ecx, ebp
  00199	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
$LN12@RecvExchan:

; 1827 : 			break;
; 1828 : 
; 1829 : 		case EXCHANGE_SUBHEADER_GC_ITEM_DEL:
; 1830 : 			if (exchange_packet.is_me)

  001a2	80 7d ce 00	 cmp	 BYTE PTR _exchange_packet$[ebp+2], 0

; 1831 : 			{
; 1832 : 				CPythonExchange::Instance().DelItemOfSelf((BYTE) exchange_packet.arg1);

  001a6	ff 75 cf	 push	 DWORD PTR _exchange_packet$[ebp+3]
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  001af	74 23		 je	 SHORT $LN11@RecvExchan
  001b1	e8 00 00 00 00	 call	 ?DelItemOfSelf@CPythonExchange@@QAEXE@Z ; CPythonExchange::DelItemOfSelf

; 1837 : 			}
; 1838 : 			__RefreshExchangeWindow();

  001b6	8b cb		 mov	 ecx, ebx
  001b8	e8 00 00 00 00	 call	 ?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshExchangeWindow

; 1839 : 			__RefreshInventoryWindow();

  001bd	e8 00 00 00 00	 call	 ?__RefreshInventoryWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshInventoryWindow
  001c2	5e		 pop	 esi

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  001c3	b0 01		 mov	 al, 1
  001c5	5b		 pop	 ebx

; 1879 : }

  001c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c9	33 cd		 xor	 ecx, ebp
  001cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
$LN11@RecvExchan:

; 1833 : 			}
; 1834 : 			else
; 1835 : 			{
; 1836 : 				CPythonExchange::Instance().DelItemOfTarget((BYTE) exchange_packet.arg1);

  001d4	e8 00 00 00 00	 call	 ?DelItemOfTarget@CPythonExchange@@QAEXE@Z ; CPythonExchange::DelItemOfTarget

; 1837 : 			}
; 1838 : 			__RefreshExchangeWindow();

  001d9	8b cb		 mov	 ecx, ebx
  001db	e8 00 00 00 00	 call	 ?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshExchangeWindow

; 1839 : 			__RefreshInventoryWindow();

  001e0	e8 00 00 00 00	 call	 ?__RefreshInventoryWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshInventoryWindow
  001e5	5e		 pop	 esi

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  001e6	b0 01		 mov	 al, 1
  001e8	5b		 pop	 ebx

; 1879 : }

  001e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
$LN9@RecvExchan:

; 1840 : 			break;
; 1841 : 
; 1842 : 		case EXCHANGE_SUBHEADER_GC_ELK_ADD:
; 1843 : 			if (exchange_packet.is_me)

  001f7	80 7d ce 00	 cmp	 BYTE PTR _exchange_packet$[ebp+2], 0

; 1844 : 				CPythonExchange::Instance().SetElkToSelf(exchange_packet.arg1);

  001fb	ff 75 cf	 push	 DWORD PTR _exchange_packet$[ebp+3]
  001fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  00204	74 1e		 je	 SHORT $LN8@RecvExchan
  00206	e8 00 00 00 00	 call	 ?SetElkToSelf@CPythonExchange@@QAEXK@Z ; CPythonExchange::SetElkToSelf

; 1847 : 
; 1848 : 			__RefreshExchangeWindow();

  0020b	8b cb		 mov	 ecx, ebx
  0020d	e8 00 00 00 00	 call	 ?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshExchangeWindow
  00212	5e		 pop	 esi

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  00213	b0 01		 mov	 al, 1
  00215	5b		 pop	 ebx

; 1879 : }

  00216	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00219	33 cd		 xor	 ecx, ebp
  0021b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00220	8b e5		 mov	 esp, ebp
  00222	5d		 pop	 ebp
  00223	c3		 ret	 0
$LN8@RecvExchan:

; 1845 : 			else
; 1846 : 				CPythonExchange::Instance().SetElkToTarget(exchange_packet.arg1);

  00224	e8 00 00 00 00	 call	 ?SetElkToTarget@CPythonExchange@@QAEXK@Z ; CPythonExchange::SetElkToTarget

; 1847 : 
; 1848 : 			__RefreshExchangeWindow();

  00229	8b cb		 mov	 ecx, ebx
  0022b	e8 00 00 00 00	 call	 ?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshExchangeWindow
  00230	5e		 pop	 esi

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  00231	b0 01		 mov	 al, 1
  00233	5b		 pop	 ebx

; 1879 : }

  00234	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00237	33 cd		 xor	 ecx, ebp
  00239	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c3		 ret	 0
$LN6@RecvExchan:

; 1849 : 			break;
; 1850 : 
; 1851 : 		case EXCHANGE_SUBHEADER_GC_ACCEPT:
; 1852 : 			if (exchange_packet.is_me)

  00242	80 7d ce 00	 cmp	 BYTE PTR _exchange_packet$[ebp+2], 0

; 1853 : 			{
; 1854 : 				CPythonExchange::Instance().SetAcceptToSelf((BYTE) exchange_packet.arg1);

  00246	ff 75 cf	 push	 DWORD PTR _exchange_packet$[ebp+3]
  00249	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  0024f	74 1e		 je	 SHORT $LN5@RecvExchan
  00251	e8 00 00 00 00	 call	 ?SetAcceptToSelf@CPythonExchange@@QAEXE@Z ; CPythonExchange::SetAcceptToSelf

; 1859 : 			}
; 1860 : 			__RefreshExchangeWindow();

  00256	8b cb		 mov	 ecx, ebx
  00258	e8 00 00 00 00	 call	 ?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshExchangeWindow
  0025d	5e		 pop	 esi

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  0025e	b0 01		 mov	 al, 1
  00260	5b		 pop	 ebx

; 1879 : }

  00261	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00264	33 cd		 xor	 ecx, ebp
  00266	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026b	8b e5		 mov	 esp, ebp
  0026d	5d		 pop	 ebp
  0026e	c3		 ret	 0
$LN5@RecvExchan:

; 1855 : 			}
; 1856 : 			else
; 1857 : 			{
; 1858 : 				CPythonExchange::Instance().SetAcceptToTarget((BYTE) exchange_packet.arg1);

  0026f	e8 00 00 00 00	 call	 ?SetAcceptToTarget@CPythonExchange@@QAEXE@Z ; CPythonExchange::SetAcceptToTarget

; 1859 : 			}
; 1860 : 			__RefreshExchangeWindow();

  00274	8b cb		 mov	 ecx, ebx
  00276	e8 00 00 00 00	 call	 ?__RefreshExchangeWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshExchangeWindow
  0027b	5e		 pop	 esi

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  0027c	b0 01		 mov	 al, 1
  0027e	5b		 pop	 ebx

; 1879 : }

  0027f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00282	33 cd		 xor	 ecx, ebp
  00284	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c3		 ret	 0
$LN3@RecvExchan:

; 1861 : 			break;
; 1862 : 
; 1863 : 		case EXCHANGE_SUBHEADER_GC_END:
; 1864 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "EndExchange", Py_BuildValue("()"));

  0028d	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00298	50		 push	 eax
  00299	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GJLEGLOM@EndExchange?$AA@
  0029e	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  002a4	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  002a9	83 c4 10	 add	 esp, 16			; 00000010H

; 1865 : 			__RefreshInventoryWindow();

  002ac	8b cb		 mov	 ecx, ebx
  002ae	e8 00 00 00 00	 call	 ?__RefreshInventoryWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshInventoryWindow

; 1866 : 			CPythonExchange::Instance().End();

  002b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonExchange@@@@0PAVCPythonExchange@@A ; CSingleton<CPythonExchange>::ms_singleton
  002b9	e8 00 00 00 00	 call	 ?End@CPythonExchange@@QAEXXZ ; CPythonExchange::End
  002be	5e		 pop	 esi

; 1875 : 			break;
; 1876 : 	};
; 1877 : 
; 1878 : 	return true;

  002bf	b0 01		 mov	 al, 1
  002c1	5b		 pop	 ebx

; 1879 : }

  002c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c5	33 cd		 xor	 ecx, ebp
  002c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cc	8b e5		 mov	 esp, ebp
  002ce	5d		 pop	 ebp
  002cf	c3		 ret	 0
$LN2@RecvExchan:

; 1867 : 			break;
; 1868 : 
; 1869 : 		case EXCHANGE_SUBHEADER_GC_ALREADY:
; 1870 : 			Tracef("trade_already");

  002d0	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LLCGBEIB@trade_already?$AA@

; 1871 : 			break;

  002d5	eb 05		 jmp	 SHORT $LN95@RecvExchan
$LN1@RecvExchan:

; 1872 : 
; 1873 : 		case EXCHANGE_SUBHEADER_GC_LESS_ELK:
; 1874 : 			Tracef("trade_less_elk");

  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNLFDBJJ@trade_less_elk?$AA@
$LN95@RecvExchan:
  002dc	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  002e1	83 c4 04	 add	 esp, 4
$LN93@RecvExchan:
  002e4	5e		 pop	 esi
$LN30@RecvExchan:

; 1879 : }

  002e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e8	b0 01		 mov	 al, 1
  002ea	33 cd		 xor	 ecx, ebp
  002ec	5b		 pop	 ebx
  002ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f2	8b e5		 mov	 esp, ebp
  002f4	5d		 pop	 ebp
  002f5	c3		 ret	 0
  002f6	8b ff		 npad	 2
$LN97@RecvExchan:
  002f8	00 00 00 00	 DD	 $LN29@RecvExchan
  002fc	00 00 00 00	 DD	 $LN27@RecvExchan
  00300	00 00 00 00	 DD	 $LN12@RecvExchan
  00304	00 00 00 00	 DD	 $LN9@RecvExchan
  00308	00 00 00 00	 DD	 $LN6@RecvExchan
  0030c	00 00 00 00	 DD	 $LN3@RecvExchan
  00310	00 00 00 00	 DD	 $LN2@RecvExchan
  00314	00 00 00 00	 DD	 $LN1@RecvExchan
?RecvExchangePacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvExchangePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
;	COMDAT ??0packet_exchange@@QAE@XZ
_TEXT	SEGMENT
??0packet_exchange@@QAE@XZ PROC				; packet_exchange::packet_exchange, COMDAT
; _this$ = ecx

; 187  : 		cell = WORD_MAX;

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00005	c6 41 07 01	 mov	 BYTE PTR [ecx+7], 1
  00009	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0packet_exchange@@QAE@XZ ENDP				; packet_exchange::packet_exchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_iClockValue$ = -260					; size = 4
_iCounterValue$ = -256					; size = 4
_isBegin$2 = -249					; size = 1
_rkQuest$1$ = -248					; size = 4
tv467 = -244						; size = 4
tv465 = -244						; size = 4
tv463 = -244						; size = 4
tv461 = -244						; size = 4
tv459 = -244						; size = 4
tv280 = -244						; size = 4
_QuestInfo$ = -240					; size = 6
_QuestInstance$3 = -232					; size = 112
_szIconFileName$ = -116					; size = 25
_szTitle$ = -88						; size = 31
_szClockName$ = -56					; size = 17
_szCounterName$ = -36					; size = 17
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvQuestInfoPacket, COMDAT
; _this$ = ecx

; 1882 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx

; 1883 : 	TPacketGCQuestInfo QuestInfo;
; 1884 : 
; 1885 : 	if (!Peek(sizeof(TPacketGCQuestInfo), &QuestInfo))

  0002f	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _QuestInfo$[ebp]
  00035	50		 push	 eax
  00036	6a 06		 push	 6
  00038	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  0003d	84 c0		 test	 al, al
  0003f	75 14		 jne	 SHORT $LN31@RecvQuestI

; 1886 : 	{
; 1887 : 		Tracen("Recv Quest Info Packet Error #1");

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CACIOMDA@Recv?5Quest?5Info?5Packet?5Error?5?$CD1?$AA@
  00046	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0004b	83 c4 04	 add	 esp, 4
$LN54@RecvQuestI:

; 1888 : 		return false;

  0004e	32 c0		 xor	 al, al
  00050	e9 ac 03 00 00	 jmp	 $LN32@RecvQuestI
$LN31@RecvQuestI:

; 1889 : 	}
; 1890 : 
; 1891 : 	if (!Peek(QuestInfo.size))

  00055	0f b7 85 11 ff
	ff ff		 movzx	 eax, WORD PTR _QuestInfo$[ebp+1]
  0005c	8b cf		 mov	 ecx, edi
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NH@Z ; CNetworkStream::Peek
  00064	84 c0		 test	 al, al
  00066	75 14		 jne	 SHORT $LN30@RecvQuestI

; 1892 : 	{
; 1893 : 		Tracen("Recv Quest Info Packet Error #2");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LAFLPPD@Recv?5Quest?5Info?5Packet?5Error?5?$CD2?$AA@
  0006d	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00072	83 c4 04	 add	 esp, 4

; 1894 : 		return false;

  00075	32 c0		 xor	 al, al
  00077	e9 85 03 00 00	 jmp	 $LN32@RecvQuestI
$LN30@RecvQuestI:

; 1895 : 	}
; 1896 : 
; 1897 : 	Recv(sizeof(TPacketGCQuestInfo));

  0007c	6a 06		 push	 6
  0007e	8b cf		 mov	 ecx, edi
  00080	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NH@Z ; CNetworkStream::Recv

; 1898 : 
; 1899 : 	const BYTE & c_rFlag = QuestInfo.flag;
; 1900 : 
; 1901 : 	enum
; 1902 : 	{
; 1903 : 		QUEST_PACKET_TYPE_NONE,
; 1904 : 		QUEST_PACKET_TYPE_BEGIN,
; 1905 : 		QUEST_PACKET_TYPE_UPDATE,
; 1906 : 		QUEST_PACKET_TYPE_END,
; 1907 : 	};
; 1908 : 
; 1909 : 	BYTE byQuestPacketType = QUEST_PACKET_TYPE_NONE;
; 1910 : 
; 1911 : 	if (0 != (c_rFlag & QUEST_SEND_IS_BEGIN))

  00085	f6 85 15 ff ff
	ff 01		 test	 BYTE PTR _QuestInfo$[ebp+5], 1
  0008c	74 2d		 je	 SHORT $LN29@RecvQuestI

; 1912 : 	{
; 1913 : 		BYTE isBegin;
; 1914 : 		if (!Recv(sizeof(isBegin), &isBegin))

  0008e	8d 85 07 ff ff
	ff		 lea	 eax, DWORD PTR _isBegin$2[ebp]
  00094	8b cf		 mov	 ecx, edi
  00096	50		 push	 eax
  00097	6a 01		 push	 1
  00099	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0009e	84 c0		 test	 al, al
  000a0	74 ac		 je	 SHORT $LN54@RecvQuestI

; 1915 : 			return false;
; 1916 : 
; 1917 : 		if (isBegin)

  000a2	80 bd 07 ff ff
	ff 00		 cmp	 BYTE PTR _isBegin$2[ebp], 0
  000a9	0f 94 c0	 sete	 al
  000ac	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]
  000b3	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv280[ebp], eax

; 1918 : 			byQuestPacketType = QUEST_PACKET_TYPE_BEGIN;
; 1919 : 		else
; 1920 : 			byQuestPacketType = QUEST_PACKET_TYPE_END;
; 1921 : 	}
; 1922 : 	else

  000b9	eb 07		 jmp	 SHORT $LN25@RecvQuestI
$LN29@RecvQuestI:

; 1923 : 	{
; 1924 : 		byQuestPacketType = QUEST_PACKET_TYPE_UPDATE;

  000bb	c6 85 0c ff ff
	ff 02		 mov	 BYTE PTR tv280[ebp], 2
$LN25@RecvQuestI:

; 1925 : 	}
; 1926 : 
; 1927 : 	// Recv Data Start
; 1928 : 	char szTitle[30 + 1] = "";
; 1929 : 	char szClockName[16 + 1] = "";
; 1930 : 	int iClockValue = 0;
; 1931 : 	char szCounterName[16 + 1] = "";
; 1932 : 	int iCounterValue = 0;
; 1933 : 	char szIconFileName[24 + 1] = "";
; 1934 : 
; 1935 : 	if (0 != (c_rFlag & QUEST_SEND_TITLE))

  000c2	f6 85 15 ff ff
	ff 02		 test	 BYTE PTR _QuestInfo$[ebp+5], 2
  000c9	0f 57 c0	 xorps	 xmm0, xmm0
  000cc	c6 45 a8 00	 mov	 BYTE PTR _szTitle$[ebp], 0
  000d0	f3 0f 7f 45 a9	 movdqu	 XMMWORD PTR _szTitle$[ebp+1], xmm0
  000d5	c7 45 c1 00 00
	00 00		 mov	 DWORD PTR _szTitle$[ebp+25], 0
  000dc	66 0f d6 45 b9	 movq	 QWORD PTR _szTitle$[ebp+17], xmm0
  000e1	66 c7 45 c5 00
	00		 mov	 WORD PTR _szTitle$[ebp+29], 0
  000e7	c6 45 c8 00	 mov	 BYTE PTR _szClockName$[ebp], 0
  000eb	f3 0f 7f 45 c9	 movdqu	 XMMWORD PTR _szClockName$[ebp+1], xmm0
  000f0	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iClockValue$[ebp], 0
  000fa	c6 45 dc 00	 mov	 BYTE PTR _szCounterName$[ebp], 0
  000fe	f3 0f 7f 45 dd	 movdqu	 XMMWORD PTR _szCounterName$[ebp+1], xmm0
  00103	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _iCounterValue$[ebp], 0
  0010d	c6 45 8c 00	 mov	 BYTE PTR _szIconFileName$[ebp], 0
  00111	f3 0f 7f 45 8d	 movdqu	 XMMWORD PTR _szIconFileName$[ebp+1], xmm0
  00116	66 0f d6 45 9d	 movq	 QWORD PTR _szIconFileName$[ebp+17], xmm0
  0011b	74 19		 je	 SHORT $LN24@RecvQuestI

; 1936 : 	{
; 1937 : 		if (!Recv(sizeof(szTitle), &szTitle))

  0011d	8d 45 a8	 lea	 eax, DWORD PTR _szTitle$[ebp]
  00120	8b cf		 mov	 ecx, edi
  00122	50		 push	 eax
  00123	6a 1f		 push	 31			; 0000001fH
  00125	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0012a	84 c0		 test	 al, al
  0012c	0f 84 1c ff ff
	ff		 je	 $LN54@RecvQuestI

; 1938 : 			return false;
; 1939 : 
; 1940 : 		szTitle[30]='\0';

  00132	c6 45 c6 00	 mov	 BYTE PTR _szTitle$[ebp+30], 0
$LN24@RecvQuestI:

; 1941 : 	}
; 1942 : 	if (0 != (c_rFlag & QUEST_SEND_CLOCK_NAME))

  00136	f6 85 15 ff ff
	ff 04		 test	 BYTE PTR _QuestInfo$[ebp+5], 4
  0013d	74 19		 je	 SHORT $LN22@RecvQuestI

; 1943 : 	{
; 1944 : 		if (!Recv(sizeof(szClockName), &szClockName))

  0013f	8d 45 c8	 lea	 eax, DWORD PTR _szClockName$[ebp]
  00142	8b cf		 mov	 ecx, edi
  00144	50		 push	 eax
  00145	6a 11		 push	 17			; 00000011H
  00147	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0014c	84 c0		 test	 al, al
  0014e	0f 84 fa fe ff
	ff		 je	 $LN54@RecvQuestI

; 1945 : 			return false;
; 1946 : 
; 1947 : 		szClockName[16]='\0';

  00154	c6 45 d8 00	 mov	 BYTE PTR _szClockName$[ebp+16], 0
$LN22@RecvQuestI:

; 1948 : 	}
; 1949 : 	if (0 != (c_rFlag & QUEST_SEND_CLOCK_VALUE))

  00158	f6 85 15 ff ff
	ff 08		 test	 BYTE PTR _QuestInfo$[ebp+5], 8
  0015f	74 18		 je	 SHORT $LN51@RecvQuestI

; 1950 : 	{
; 1951 : 		if (!Recv(sizeof(iClockValue), &iClockValue))

  00161	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _iClockValue$[ebp]
  00167	8b cf		 mov	 ecx, edi
  00169	50		 push	 eax
  0016a	6a 04		 push	 4
  0016c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00171	84 c0		 test	 al, al
  00173	0f 84 d5 fe ff
	ff		 je	 $LN54@RecvQuestI
$LN51@RecvQuestI:

; 1952 : 			return false;
; 1953 : 	}
; 1954 : 	if (0 != (c_rFlag & QUEST_SEND_COUNTER_NAME))

  00179	f6 85 15 ff ff
	ff 10		 test	 BYTE PTR _QuestInfo$[ebp+5], 16 ; 00000010H
  00180	74 19		 je	 SHORT $LN18@RecvQuestI

; 1955 : 	{
; 1956 : 		if (!Recv(sizeof(szCounterName), &szCounterName))

  00182	8d 45 dc	 lea	 eax, DWORD PTR _szCounterName$[ebp]
  00185	8b cf		 mov	 ecx, edi
  00187	50		 push	 eax
  00188	6a 11		 push	 17			; 00000011H
  0018a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0018f	84 c0		 test	 al, al
  00191	0f 84 b7 fe ff
	ff		 je	 $LN54@RecvQuestI

; 1957 : 			return false;
; 1958 : 
; 1959 : 		szCounterName[16]='\0';

  00197	c6 45 ec 00	 mov	 BYTE PTR _szCounterName$[ebp+16], 0
$LN18@RecvQuestI:

; 1960 : 	}
; 1961 : 	if (0 != (c_rFlag & QUEST_SEND_COUNTER_VALUE))

  0019b	f6 85 15 ff ff
	ff 20		 test	 BYTE PTR _QuestInfo$[ebp+5], 32 ; 00000020H
  001a2	74 18		 je	 SHORT $LN52@RecvQuestI

; 1962 : 	{
; 1963 : 		if (!Recv(sizeof(iCounterValue), &iCounterValue))

  001a4	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _iCounterValue$[ebp]
  001aa	8b cf		 mov	 ecx, edi
  001ac	50		 push	 eax
  001ad	6a 04		 push	 4
  001af	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  001b4	84 c0		 test	 al, al
  001b6	0f 84 92 fe ff
	ff		 je	 $LN54@RecvQuestI
$LN52@RecvQuestI:

; 1964 : 			return false;
; 1965 : 	}
; 1966 : 	if (0 != (c_rFlag & QUEST_SEND_ICON_FILE))

  001bc	f6 85 15 ff ff
	ff 40		 test	 BYTE PTR _QuestInfo$[ebp+5], 64 ; 00000040H
  001c3	74 19		 je	 SHORT $LN14@RecvQuestI

; 1967 : 	{
; 1968 : 		if (!Recv(sizeof(szIconFileName), &szIconFileName))

  001c5	8d 45 8c	 lea	 eax, DWORD PTR _szIconFileName$[ebp]
  001c8	8b cf		 mov	 ecx, edi
  001ca	50		 push	 eax
  001cb	6a 19		 push	 25			; 00000019H
  001cd	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  001d2	84 c0		 test	 al, al
  001d4	0f 84 74 fe ff
	ff		 je	 $LN54@RecvQuestI

; 1969 : 			return false;
; 1970 : 
; 1971 : 		szIconFileName[24]='\0';

  001da	c6 45 a4 00	 mov	 BYTE PTR _szIconFileName$[ebp+24], 0
$LN14@RecvQuestI:

; 1972 : 	}
; 1973 : 	// Recv Data End
; 1974 : 
; 1975 : 	CPythonQuest& rkQuest=CPythonQuest::Instance();
; 1976 : 
; 1977 : 	// Process Start
; 1978 : 	if (QUEST_PACKET_TYPE_END == byQuestPacketType)

  001de	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv280[ebp]
  001e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonQuest@@@@0PAVCPythonQuest@@A ; CSingleton<CPythonQuest>::ms_singleton
  001ea	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _rkQuest$1$[ebp], ecx
  001f0	3c 03		 cmp	 al, 3
  001f2	75 12		 jne	 SHORT $LN12@RecvQuestI

; 1979 : 	{
; 1980 : 		rkQuest.DeleteQuestInstance(QuestInfo.index);

  001f4	0f b7 85 13 ff
	ff ff		 movzx	 eax, WORD PTR _QuestInfo$[ebp+3]
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 ?DeleteQuestInstance@CPythonQuest@@QAEXK@Z ; CPythonQuest::DeleteQuestInstance

; 1981 : 	}
; 1982 : 	else if (QUEST_PACKET_TYPE_UPDATE == byQuestPacketType)

  00201	e9 d7 01 00 00	 jmp	 $LN1@RecvQuestI
$LN12@RecvQuestI:
  00206	3c 02		 cmp	 al, 2
  00208	0f 85 33 01 00
	00		 jne	 $LN10@RecvQuestI

; 1983 : 	{
; 1984 : 		if (!rkQuest.IsQuest(QuestInfo.index))

  0020e	66 8b b5 13 ff
	ff ff		 mov	 si, WORD PTR _QuestInfo$[ebp+3]
  00215	0f b7 c6	 movzx	 eax, si
  00218	50		 push	 eax
  00219	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv467[ebp], eax
  0021f	e8 00 00 00 00	 call	 ?IsQuest@CPythonQuest@@QAE_NK@Z ; CPythonQuest::IsQuest
  00224	84 c0		 test	 al, al
  00226	75 18		 jne	 SHORT $LN9@RecvQuestI

; 1985 : 		{
; 1986 : 			rkQuest.MakeQuest(QuestInfo.index);

  00228	ff b5 0c ff ff
	ff		 push	 DWORD PTR tv467[ebp]
  0022e	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _rkQuest$1$[ebp]
  00234	e8 00 00 00 00	 call	 ?MakeQuest@CPythonQuest@@QAEXK@Z ; CPythonQuest::MakeQuest
  00239	66 8b b5 13 ff
	ff ff		 mov	 si, WORD PTR _QuestInfo$[ebp+3]
$LN9@RecvQuestI:

; 1987 : 		}
; 1988 : 
; 1989 : 		if (strlen(szTitle) > 0)

  00240	8d 4d a8	 lea	 ecx, DWORD PTR _szTitle$[ebp]
  00243	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL47@RecvQuestI:
  00246	8a 01		 mov	 al, BYTE PTR [ecx]
  00248	41		 inc	 ecx
  00249	84 c0		 test	 al, al
  0024b	75 f9		 jne	 SHORT $LL47@RecvQuestI
  0024d	2b ca		 sub	 ecx, edx
  0024f	74 1a		 je	 SHORT $LN8@RecvQuestI

; 1990 : 			rkQuest.SetQuestTitle(QuestInfo.index, szTitle);

  00251	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _rkQuest$1$[ebp]
  00257	8d 45 a8	 lea	 eax, DWORD PTR _szTitle$[ebp]
  0025a	50		 push	 eax
  0025b	0f b7 c6	 movzx	 eax, si
  0025e	50		 push	 eax
  0025f	e8 00 00 00 00	 call	 ?SetQuestTitle@CPythonQuest@@QAEXKPBD@Z ; CPythonQuest::SetQuestTitle
  00264	66 8b b5 13 ff
	ff ff		 mov	 si, WORD PTR _QuestInfo$[ebp+3]
$LN8@RecvQuestI:

; 1991 : 		if (strlen(szClockName) > 0)

  0026b	8d 4d c8	 lea	 ecx, DWORD PTR _szClockName$[ebp]
  0026e	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL48@RecvQuestI:
  00271	8a 01		 mov	 al, BYTE PTR [ecx]
  00273	41		 inc	 ecx
  00274	84 c0		 test	 al, al
  00276	75 f9		 jne	 SHORT $LL48@RecvQuestI
  00278	2b ca		 sub	 ecx, edx
  0027a	74 1a		 je	 SHORT $LN7@RecvQuestI

; 1992 : 			rkQuest.SetQuestClockName(QuestInfo.index, szClockName);

  0027c	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _rkQuest$1$[ebp]
  00282	8d 45 c8	 lea	 eax, DWORD PTR _szClockName$[ebp]
  00285	50		 push	 eax
  00286	0f b7 c6	 movzx	 eax, si
  00289	50		 push	 eax
  0028a	e8 00 00 00 00	 call	 ?SetQuestClockName@CPythonQuest@@QAEXKPBD@Z ; CPythonQuest::SetQuestClockName
  0028f	66 8b b5 13 ff
	ff ff		 mov	 si, WORD PTR _QuestInfo$[ebp+3]
$LN7@RecvQuestI:

; 1993 : 		if (strlen(szCounterName) > 0)

  00296	8d 4d dc	 lea	 ecx, DWORD PTR _szCounterName$[ebp]
  00299	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0029c	8d 64 24 00	 npad	 4
$LL49@RecvQuestI:
  002a0	8a 01		 mov	 al, BYTE PTR [ecx]
  002a2	41		 inc	 ecx
  002a3	84 c0		 test	 al, al
  002a5	75 f9		 jne	 SHORT $LL49@RecvQuestI
  002a7	2b ca		 sub	 ecx, edx
  002a9	74 1a		 je	 SHORT $LN6@RecvQuestI

; 1994 : 			rkQuest.SetQuestCounterName(QuestInfo.index, szCounterName);

  002ab	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _rkQuest$1$[ebp]
  002b1	8d 45 dc	 lea	 eax, DWORD PTR _szCounterName$[ebp]
  002b4	50		 push	 eax
  002b5	0f b7 c6	 movzx	 eax, si
  002b8	50		 push	 eax
  002b9	e8 00 00 00 00	 call	 ?SetQuestCounterName@CPythonQuest@@QAEXKPBD@Z ; CPythonQuest::SetQuestCounterName
  002be	66 8b b5 13 ff
	ff ff		 mov	 si, WORD PTR _QuestInfo$[ebp+3]
$LN6@RecvQuestI:

; 1995 : 		if (strlen(szIconFileName) > 0)

  002c5	8d 4d 8c	 lea	 ecx, DWORD PTR _szIconFileName$[ebp]
  002c8	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  002cb	eb 03 8d 49 00	 npad	 5
$LL50@RecvQuestI:
  002d0	8a 01		 mov	 al, BYTE PTR [ecx]
  002d2	41		 inc	 ecx
  002d3	84 c0		 test	 al, al
  002d5	75 f9		 jne	 SHORT $LL50@RecvQuestI
  002d7	2b ca		 sub	 ecx, edx
  002d9	74 1a		 je	 SHORT $LN5@RecvQuestI

; 1996 : 			rkQuest.SetQuestIconFileName(QuestInfo.index, szIconFileName);

  002db	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _rkQuest$1$[ebp]
  002e1	8d 45 8c	 lea	 eax, DWORD PTR _szIconFileName$[ebp]
  002e4	50		 push	 eax
  002e5	0f b7 c6	 movzx	 eax, si
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 ?SetQuestIconFileName@CPythonQuest@@QAEXKPBD@Z ; CPythonQuest::SetQuestIconFileName
  002ee	66 8b b5 13 ff
	ff ff		 mov	 si, WORD PTR _QuestInfo$[ebp+3]
$LN5@RecvQuestI:

; 1997 : 
; 1998 : 		if (c_rFlag & QUEST_SEND_CLOCK_VALUE)

  002f5	f6 85 15 ff ff
	ff 08		 test	 BYTE PTR _QuestInfo$[ebp+5], 8
  002fc	74 1c		 je	 SHORT $LN4@RecvQuestI

; 1999 : 			rkQuest.SetQuestClockValue(QuestInfo.index, iClockValue);

  002fe	ff b5 fc fe ff
	ff		 push	 DWORD PTR _iClockValue$[ebp]
  00304	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _rkQuest$1$[ebp]
  0030a	0f b7 c6	 movzx	 eax, si
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 ?SetQuestClockValue@CPythonQuest@@QAEXKH@Z ; CPythonQuest::SetQuestClockValue
  00313	66 8b b5 13 ff
	ff ff		 mov	 si, WORD PTR _QuestInfo$[ebp+3]
$LN4@RecvQuestI:

; 2000 : 		if (c_rFlag & QUEST_SEND_COUNTER_VALUE)

  0031a	f6 85 15 ff ff
	ff 20		 test	 BYTE PTR _QuestInfo$[ebp+5], 32 ; 00000020H
  00321	0f 84 b6 00 00
	00		 je	 $LN1@RecvQuestI

; 2001 : 			rkQuest.SetQuestCounterValue(QuestInfo.index, iCounterValue);

  00327	ff b5 00 ff ff
	ff		 push	 DWORD PTR _iCounterValue$[ebp]
  0032d	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _rkQuest$1$[ebp]
  00333	0f b7 c6	 movzx	 eax, si
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 ?SetQuestCounterValue@CPythonQuest@@QAEXKH@Z ; CPythonQuest::SetQuestCounterValue

; 2002 : 	}
; 2003 : 	else if (QUEST_PACKET_TYPE_BEGIN == byQuestPacketType)

  0033c	e9 9c 00 00 00	 jmp	 $LN1@RecvQuestI
$LN10@RecvQuestI:
  00341	3c 01		 cmp	 al, 1
  00343	0f 85 94 00 00
	00		 jne	 $LN1@RecvQuestI

; 2004 : 	{
; 2005 : 		CPythonQuest::SQuestInstance QuestInstance;

  00349	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _QuestInstance$3[ebp]
  0034f	e8 00 00 00 00	 call	 ??0SQuestInstance@CPythonQuest@@QAE@XZ ; CPythonQuest::SQuestInstance::SQuestInstance
  00354	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2006 : 		QuestInstance.dwIndex = QuestInfo.index;
; 2007 : 		QuestInstance.strTitle = szTitle;

  0035b	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _QuestInstance$3[ebp+28]
  00361	0f b7 85 13 ff
	ff ff		 movzx	 eax, WORD PTR _QuestInfo$[ebp+3]
  00368	89 85 18 ff ff
	ff		 mov	 DWORD PTR _QuestInstance$3[ebp], eax
  0036e	8d 45 a8	 lea	 eax, DWORD PTR _szTitle$[ebp]
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 2008 : 		QuestInstance.strClockName = szClockName;

  00377	8d 45 c8	 lea	 eax, DWORD PTR _szClockName$[ebp]
  0037a	50		 push	 eax
  0037b	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _QuestInstance$3[ebp+52]
  00381	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 2009 : 		QuestInstance.iClockValue = iClockValue;

  00386	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iClockValue$[ebp]

; 2010 : 		QuestInstance.strCounterName = szCounterName;

  0038c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _QuestInstance$3[ebp+76]
  00392	89 85 7c ff ff
	ff		 mov	 DWORD PTR _QuestInstance$3[ebp+100], eax
  00398	8d 45 dc	 lea	 eax, DWORD PTR _szCounterName$[ebp]
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 2011 : 		QuestInstance.iCounterValue = iCounterValue;

  003a1	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _iCounterValue$[ebp]

; 2012 : 		QuestInstance.strIconFileName = szIconFileName;

  003a7	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _QuestInstance$3[ebp+4]
  003ad	89 45 80	 mov	 DWORD PTR _QuestInstance$3[ebp+104], eax
  003b0	8d 45 8c	 lea	 eax, DWORD PTR _szIconFileName$[ebp]
  003b3	50		 push	 eax
  003b4	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 2013 : 		CPythonQuest::Instance().RegisterQuestInstance(QuestInstance);

  003b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonQuest@@@@0PAVCPythonQuest@@A ; CSingleton<CPythonQuest>::ms_singleton
  003bf	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _QuestInstance$3[ebp]
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 ?RegisterQuestInstance@CPythonQuest@@QAEXABUSQuestInstance@1@@Z ; CPythonQuest::RegisterQuestInstance

; 2014 : 	}

  003cb	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _QuestInstance$3[ebp]
  003d1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003d8	e8 00 00 00 00	 call	 ??1SQuestInstance@CPythonQuest@@QAE@XZ
$LN1@RecvQuestI:

; 2015 : 	// Process Start End
; 2016 : 
; 2017 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshQuest", Py_BuildValue("()"));

  003dd	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  003e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  003e8	83 c4 04	 add	 esp, 4
  003eb	50		 push	 eax
  003ec	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IPPKALM@RefreshQuest?$AA@
  003f1	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  003f7	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  003fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2018 : 	return true;

  003ff	b0 01		 mov	 al, 1
$LN32@RecvQuestI:

; 2019 : }

  00401	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00404	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0040b	59		 pop	 ecx
  0040c	5f		 pop	 edi
  0040d	5e		 pop	 esi
  0040e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00411	33 cd		 xor	 ecx, ebp
  00413	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00418	8b e5		 mov	 esp, ebp
  0041a	5d		 pop	 ebp
  0041b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ$0:
  00000	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _QuestInstance$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SQuestInstance@CPythonQuest@@QAE@XZ
__ehhandler$?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a fc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-260]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvQuestInfoPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvQuestInfoPacket
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1SQuestInstance@CPythonQuest@@QAE@XZ
_TEXT	SEGMENT
??1SQuestInstance@CPythonQuest@@QAE@XZ PROC		; CPythonQuest::SQuestInstance::~SQuestInstance, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 60 10	 cmp	 DWORD PTR [esi+96], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN23@SQuestInst
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 76 4c	 push	 DWORD PTR [esi+76]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN23@SQuestInst:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00014	c7 46 60 0f 00
	00 00		 mov	 DWORD PTR [esi+96], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001b	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00022	c6 46 4c 00	 mov	 BYTE PTR [esi+76], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00026	83 7e 48 10	 cmp	 DWORD PTR [esi+72], 16	; 00000010H
  0002a	72 0b		 jb	 SHORT $LN55@SQuestInst
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0002c	ff 76 34	 push	 DWORD PTR [esi+52]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	83 c4 04	 add	 esp, 4
$LN55@SQuestInst:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00037	c7 46 48 0f 00
	00 00		 mov	 DWORD PTR [esi+72], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0003e	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00045	c6 46 34 00	 mov	 BYTE PTR [esi+52], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00049	83 7e 30 10	 cmp	 DWORD PTR [esi+48], 16	; 00000010H
  0004d	72 0b		 jb	 SHORT $LN87@SQuestInst
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0004f	ff 76 1c	 push	 DWORD PTR [esi+28]
  00052	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00057	83 c4 04	 add	 esp, 4
$LN87@SQuestInst:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0005a	c7 46 30 0f 00
	00 00		 mov	 DWORD PTR [esi+48], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00061	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00068	c6 46 1c 00	 mov	 BYTE PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0006c	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00070	72 0b		 jb	 SHORT $LN119@SQuestInst
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00072	ff 76 04	 push	 DWORD PTR [esi+4]
  00075	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007a	83 c4 04	 add	 esp, 4
$LN119@SQuestInst:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0007d	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00084	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0008b	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0008f	5e		 pop	 esi
  00090	c3		 ret	 0
??1SQuestInstance@CPythonQuest@@QAE@XZ ENDP		; CPythonQuest::SQuestInstance::~SQuestInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvQuestConfirmPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kQuestConfirmPacket$ = -80				; size = 74
__$ArrayPad$ = -4					; size = 4
?RecvQuestConfirmPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvQuestConfirmPacket, COMDAT
; _this$ = ecx

; 2022 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 2023 : 	TPacketGCQuestConfirm kQuestConfirmPacket;
; 2024 : 	if (!Recv(sizeof(kQuestConfirmPacket), &kQuestConfirmPacket))

  00011	8d 45 b0	 lea	 eax, DWORD PTR _kQuestConfirmPacket$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 4a		 push	 74			; 0000004aH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 1e		 jne	 SHORT $LN1@RecvQuestC

; 2025 : 	{
; 2026 : 		Tracen("RecvQuestConfirmPacket Error");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JBCFOMDG@RecvQuestConfirmPacket?5Error?$AA@
  00027	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002c	83 c4 04	 add	 esp, 4

; 2027 : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 2032 : 	return true;
; 2033 : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN1@RecvQuestC:

; 2028 : 	}
; 2029 : 
; 2030 : 	PyObject * poArg = Py_BuildValue("(sii)", kQuestConfirmPacket.msg, kQuestConfirmPacket.timeout, kQuestConfirmPacket.requestPID);

  00040	ff 75 f6	 push	 DWORD PTR _kQuestConfirmPacket$[ebp+70]
  00043	8d 45 b1	 lea	 eax, DWORD PTR _kQuestConfirmPacket$[ebp+1]
  00046	ff 75 f2	 push	 DWORD PTR _kQuestConfirmPacket$[ebp+66]
  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_05FONOJENF@?$CIsii?$CJ?$AA@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue

; 2031 :  	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_OnQuestConfirm", poArg);

  00055	50		 push	 eax
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@KIBJJMEI@BINARY_OnQuestConfirm?$AA@
  0005b	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00061	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 2032 : 	return true;
; 2033 : }

  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	83 c4 1c	 add	 esp, 28			; 0000001cH
  0006c	33 cd		 xor	 ecx, ebp
  0006e	b0 01		 mov	 al, 1
  00070	5e		 pop	 esi
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?RecvQuestConfirmPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvQuestConfirmPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvRequestMakeGuild@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_blank$ = -1						; size = 1
?RecvRequestMakeGuild@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvRequestMakeGuild, COMDAT
; _this$ = ecx

; 2036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2037 : 	TPacketGCBlank blank;
; 2038 : 	if (!Recv(sizeof(blank), &blank))

  00005	8d 45 ff	 lea	 eax, DWORD PTR _blank$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 14		 jne	 SHORT $LN1@RecvReques

; 2039 : 	{
; 2040 : 		Tracen("RecvRequestMakeGuild Packet Error");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@ELOCPLFN@RecvRequestMakeGuild?5Packet?5Erro@
  0001b	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00020	83 c4 04	 add	 esp, 4

; 2041 : 		return false;

  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 2047 : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN1@RecvReques:

; 2042 : 	}
; 2043 : 
; 2044 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AskGuildName", Py_BuildValue("()"));

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FKOIEIPK@AskGuildName?$AA@
  0003b	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00041	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00046	83 c4 10	 add	 esp, 16			; 00000010H

; 2045 : 
; 2046 : 	return true;

  00049	b0 01		 mov	 al, 1
  0004b	5e		 pop	 esi

; 2047 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?RecvRequestMakeGuild@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvRequestMakeGuild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
;	COMDAT ??0command_exchange@@QAE@XZ
_TEXT	SEGMENT
??0command_exchange@@QAE@XZ PROC			; command_exchange::command_exchange, COMDAT
; _this$ = ecx

; 187  : 		cell = WORD_MAX;

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00005	c6 41 07 01	 mov	 BYTE PTR [ecx+7], 1
  00009	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0command_exchange@@QAE@XZ ENDP			; command_exchange::command_exchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?__IsPlayerAttacking@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
?__IsPlayerAttacking@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::__IsPlayerAttacking, COMDAT
; _this$dead$ = ecx

; 2186 : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();
; 2187 : 	CInstanceBase* pkInstMain=rkChrMgr.GetMainInstancePtr();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr

; 2188 : 	if (!pkInstMain)

  0000b	85 c0		 test	 eax, eax
  0000d	75 03		 jne	 SHORT $LN2@IsPlayerAt

; 2189 : 		return false;

  0000f	32 c0		 xor	 al, al

; 2192 : 		return false;
; 2193 : 
; 2194 : 	return true;
; 2195 : }

  00011	c3		 ret	 0
$LN2@IsPlayerAt:

; 2190 : 
; 2191 : 	if (!pkInstMain->IsAttacking())

  00012	8b c8		 mov	 ecx, eax
  00014	e8 00 00 00 00	 call	 ?IsAttacking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsAttacking
  00019	85 c0		 test	 eax, eax
  0001b	0f 95 c0	 setne	 al

; 2192 : 		return false;
; 2193 : 
; 2194 : 	return true;
; 2195 : }

  0001e	c3		 ret	 0
?__IsPlayerAttacking@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::__IsPlayerAttacking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_ScriptPacket$ = -8					; size = 6
?RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvScriptPacket, COMDAT
; _this$ = ecx

; 2198 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2199 : 	TPacketGCScript ScriptPacket;
; 2200 : 
; 2201 : 	if (!Recv(sizeof(TPacketGCScript), &ScriptPacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _ScriptPacket$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	6a 06		 push	 6
  0000e	8b f9		 mov	 edi, ecx
  00010	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00015	84 c0		 test	 al, al
  00017	75 15		 jne	 SHORT $LN5@RecvScript

; 2202 : 	{
; 2203 : 		TraceError("RecvScriptPacket_RecvError");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GIIBIOJB@RecvScriptPacket_RecvError?$AA@
  0001e	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00023	83 c4 04	 add	 esp, 4
$LN96@RecvScript:

; 2204 : 		return false;

  00026	32 c0		 xor	 al, al

; 2230 : 	}
; 2231 : 
; 2232 : 	return true;
; 2233 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN5@RecvScript:

; 2205 : 	}
; 2206 : 
; 2207 : 	if (ScriptPacket.size < sizeof(TPacketGCScript))

  0002e	66 8b 45 f9	 mov	 ax, WORD PTR _ScriptPacket$[ebp+1]
  00032	66 83 f8 06	 cmp	 ax, 6
  00036	73 15		 jae	 SHORT $LN4@RecvScript

; 2208 : 	{
; 2209 : 		TraceError("RecvScriptPacket_SizeError");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FELFLKOI@RecvScriptPacket_SizeError?$AA@
  0003d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00042	83 c4 04	 add	 esp, 4

; 2210 : 		return false;

  00045	32 c0		 xor	 al, al

; 2230 : 	}
; 2231 : 
; 2232 : 	return true;
; 2233 : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN4@RecvScript:

; 2211 : 	}
; 2212 : 
; 2213 : 	ScriptPacket.size -= sizeof(TPacketGCScript);

  0004d	b9 fa ff 00 00	 mov	 ecx, 65530		; 0000fffaH
  00052	66 03 c1	 add	 ax, cx
  00055	66 89 45 f9	 mov	 WORD PTR _ScriptPacket$[ebp+1], ax

; 2215 : 	static string str;

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S3@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4IA
  0005e	a8 01		 test	 al, 1
  00060	75 30		 jne	 SHORT $LN95@RecvScript
  00062	83 c8 01	 or	 eax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00065	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2215 : 	static string str;

  0006f	68 00 00 00 00	 push	 OFFSET ??__Fstr@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@YAXXZ ; `CPythonNetworkStream::RecvScriptPacket'::`8'::`dynamic atexit destructor for 'str''
  00074	a3 00 00 00 00	 mov	 DWORD PTR ?$S3@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4IA, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00079	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00083	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2215 : 	static string str;

  0008a	e8 00 00 00 00	 call	 _atexit
  0008f	83 c4 04	 add	 esp, 4
$LN95@RecvScript:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00092	6a 00		 push	 0
  00094	be 00 00 00 00	 mov	 esi, OFFSET ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0009e	8b ce		 mov	 ecx, esi
  000a0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2217 : 	str.resize(ScriptPacket.size+1);

  000a5	0f b7 4d f9	 movzx	 ecx, WORD PTR _ScriptPacket$[ebp+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

  000a9	a1 10 00 00 00	 mov	 eax, DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2217 : 	str.resize(ScriptPacket.size+1);

  000ae	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

  000af	3b c8		 cmp	 ecx, eax
  000b1	77 1c		 ja	 SHORT $LN58@RecvScript

; 513  : 			: this->_Bx._Buf);

  000b3	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
  000ba	8b c6		 mov	 eax, esi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000bc	89 0d 10 00 00
	00		 mov	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, ecx

; 513  : 			: this->_Bx._Buf);

  000c2	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000c9	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1772 : 		else

  000cd	eb 0c		 jmp	 SHORT $LN57@RecvScript
$LN58@RecvScript:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

  000cf	2b c8		 sub	 ecx, eax
  000d1	6a 00		 push	 0
  000d3	51		 push	 ecx
  000d4	8b ce		 mov	 ecx, esi
  000d6	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN57@RecvScript:

; 513  : 			: this->_Bx._Buf);

  000db	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
  000e2	8b c6		 mov	 eax, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2219 : 	if (!Recv(ScriptPacket.size, &str[0]))

  000e4	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000e6	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2219 : 	if (!Recv(ScriptPacket.size, &str[0]))

  000ed	50		 push	 eax
  000ee	0f b7 45 f9	 movzx	 eax, WORD PTR _ScriptPacket$[ebp+1]
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAD@Z ; CNetworkStream::Recv
  000f8	84 c0		 test	 al, al
  000fa	0f 84 26 ff ff
	ff		 je	 $LN96@RecvScript
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00100	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2222 : 	str[str.size()-1] = '\0';

  00107	a1 10 00 00 00	 mov	 eax, DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0010c	0f 43 35 00 00
	00 00		 cmovae	 esi, DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2224 : 	int iIndex = CPythonEventManager::Instance().RegisterEventSetFromString(str);

  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A ; CSingleton<CPythonEventManager>::ms_singleton
  00119	68 00 00 00 00	 push	 OFFSET ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  0011e	c6 44 06 ff 00	 mov	 BYTE PTR [esi+eax-1], 0
  00123	e8 00 00 00 00	 call	 ?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonEventManager::RegisterEventSetFromString
  00128	8b f0		 mov	 esi, eax

; 2225 : 
; 2226 : 	if (-1 != iIndex)

  0012a	83 fe ff	 cmp	 esi, -1
  0012d	74 1e		 je	 SHORT $LN1@RecvScript

; 2227 : 	{
; 2228 : 		CPythonEventManager::Instance().SetVisibleLineCount(iIndex, 30);

  0012f	51		 push	 ecx
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A ; CSingleton<CPythonEventManager>::ms_singleton
  00136	56		 push	 esi
  00137	e8 00 00 00 00	 call	 ?SetVisibleLineCount@CPythonEventManager@@QAEXHH@Z ; CPythonEventManager::SetVisibleLineCount

; 2229 : 		CPythonNetworkStream::Instance().OnScriptEventStart(ScriptPacket.skin,iIndex);

  0013c	0f b6 45 fb	 movzx	 eax, BYTE PTR _ScriptPacket$[ebp+3]
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00146	56		 push	 esi
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ?OnScriptEventStart@CPythonNetworkStream@@IAEXHH@Z ; CPythonNetworkStream::OnScriptEventStart
$LN1@RecvScript:

; 2230 : 	}
; 2231 : 
; 2232 : 	return true;
; 2233 : }

  0014d	5f		 pop	 edi
  0014e	b0 01		 mov	 al, 1
  00150	5e		 pop	 esi
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
?RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvScriptPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__Fstr@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__Fstr@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@YAXXZ PROC ; `CPythonNetworkStream::RecvScriptPacket'::`8'::`dynamic atexit destructor for 'str'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
  0000b	72 2e		 jb	 SHORT $LN23@dynamic
  0000d	56		 push	 esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

  0000e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 684  : 		return (_Alty());

  00014	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

  0001c	68 00 00 00 00	 push	 OFFSET ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00021	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00024	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

  00029	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00037	83 c4 04	 add	 esp, 4
  0003a	5e		 pop	 esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003b	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00045	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0004f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?str@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??__Fstr@?7??RecvScriptPacket@CPythonNetworkStream@@IAE_NXZ@YAXXZ ENDP ; `CPythonNetworkStream::RecvScriptPacket'::`8'::`dynamic atexit destructor for 'str''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvSkillLevel@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_dwSlotIndex$ = -268					; size = 4
_packet$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
?RecvSkillLevel@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvSkillLevel, COMDAT
; _this$ = ecx

; 2330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2331 : 	assert(!"CPythonNetworkStream::RecvSkillLevel -   ");
; 2332 : 	TPacketGCSkillLevel packet;
; 2333 : 	if (!Recv(sizeof(TPacketGCSkillLevel), &packet))

  00016	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _packet$[ebp]
  0001c	8b d9		 mov	 ebx, ecx
  0001e	50		 push	 eax
  0001f	68 00 01 00 00	 push	 256			; 00000100H
  00024	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00029	84 c0		 test	 al, al
  0002b	75 20		 jne	 SHORT $LN5@RecvSkillL

; 2334 : 	{
; 2335 : 		Tracen("CPythonNetworkStream::RecvSkillLevel - RecvError");

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OELACDEA@CPythonNetworkStream?3?3RecvSkillL@
  00032	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00037	83 c4 04	 add	 esp, 4

; 2336 : 		return false;

  0003a	32 c0		 xor	 al, al

; 2351 : 	return true;
; 2352 : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN5@RecvSkillL:

; 2337 : 	}
; 2338 : 
; 2339 : 	DWORD dwSlotIndex;
; 2340 : 
; 2341 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();

  0004d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 2342 : 	for (int i = 0; i < SKILL_MAX_NUM; ++i)

  00053	33 f6		 xor	 esi, esi
$LL4@RecvSkillL:

; 2343 : 	{
; 2344 : 		if (rkPlayer.GetSkillSlotIndex(i, &dwSlotIndex))

  00055	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _dwSlotIndex$[ebp]
  0005b	8b cf		 mov	 ecx, edi
  0005d	50		 push	 eax
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ?GetSkillSlotIndex@CPythonPlayer@@QAE_NKPAK@Z ; CPythonPlayer::GetSkillSlotIndex
  00064	84 c0		 test	 al, al
  00066	74 16		 je	 SHORT $LN3@RecvSkillL

; 2345 : 			rkPlayer.SetSkillLevel(dwSlotIndex, packet.abSkillLevels[i]);

  00068	0f b6 84 35 f9
	fe ff ff	 movzx	 eax, BYTE PTR _packet$[ebp+esi+1]
  00070	8b cf		 mov	 ecx, edi
  00072	50		 push	 eax
  00073	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _dwSlotIndex$[ebp]
  00079	e8 00 00 00 00	 call	 ?SetSkillLevel@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::SetSkillLevel
$LN3@RecvSkillL:

; 2342 : 	for (int i = 0; i < SKILL_MAX_NUM; ++i)

  0007e	46		 inc	 esi
  0007f	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00085	7c ce		 jl	 SHORT $LL4@RecvSkillL

; 2346 : 	}
; 2347 : 
; 2348 : 	__RefreshSkillWindow();

  00087	8b cb		 mov	 ecx, ebx
  00089	e8 00 00 00 00	 call	 ?__RefreshSkillWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshSkillWindow

; 2349 : 	__RefreshStatus();

  0008e	e8 00 00 00 00	 call	 ?__RefreshStatus@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshStatus

; 2350 : 	Tracef(" >> RecvSkillLevel\n");

  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@OJMAIMGE@?5?$DO?$DO?5RecvSkillLevel?6?$AA@
  00098	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 2351 : 	return true;
; 2352 : }

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	83 c4 04	 add	 esp, 4
  000a3	33 cd		 xor	 ecx, ebp
  000a5	b0 01		 mov	 al, 1
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?RecvSkillLevel@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvSkillLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvSkillLevelNew@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -1540					; size = 4
_packet$ = -1536					; size = 1531
__$ArrayPad$ = -4					; size = 4
?RecvSkillLevelNew@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvSkillLevelNew, COMDAT
; _this$ = ecx

; 2355 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 06 00
	00		 sub	 esp, 1540		; 00000604H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b c1		 mov	 eax, ecx

; 2356 : 	TPacketGCSkillLevelNew packet;
; 2357 : 
; 2358 : 	if (!Recv(sizeof(TPacketGCSkillLevelNew), &packet))

  00015	8d 8d 00 fa ff
	ff		 lea	 ecx, DWORD PTR _packet$[ebp]
  0001b	51		 push	 ecx
  0001c	68 fb 05 00 00	 push	 1531			; 000005fbH
  00021	8b c8		 mov	 ecx, eax
  00023	89 85 fc f9 ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
  00029	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0002e	84 c0		 test	 al, al
  00030	75 1d		 jne	 SHORT $LN6@RecvSkillL

; 2359 : 	{
; 2360 : 		Tracen("CPythonNetworkStream::RecvSkillLevelNew - RecvError");

  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@EBNCHOOM@CPythonNetworkStream?3?3RecvSkillL@
  00037	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0003c	83 c4 04	 add	 esp, 4

; 2361 : 		return false;

  0003f	32 c0		 xor	 al, al

; 2384 : 	//Tracef(" >> RecvSkillLevelNew\n");
; 2385 : 	return true;
; 2386 : }

  00041	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00044	33 cd		 xor	 ecx, ebp
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN6@RecvSkillL:
  0004f	53		 push	 ebx

; 2362 : 	}
; 2363 : 
; 2364 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();

  00050	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 2365 : 
; 2366 : 	rkPlayer.SetSkill(7, 0);

  00056	8b cb		 mov	 ecx, ebx
  00058	56		 push	 esi
  00059	57		 push	 edi
  0005a	6a 00		 push	 0
  0005c	6a 07		 push	 7
  0005e	e8 00 00 00 00	 call	 ?SetSkill@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::SetSkill

; 2367 : 	rkPlayer.SetSkill(8, 0);

  00063	6a 00		 push	 0
  00065	6a 08		 push	 8
  00067	8b cb		 mov	 ecx, ebx
  00069	e8 00 00 00 00	 call	 ?SetSkill@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::SetSkill

; 2368 : 
; 2369 : 	for (int i = 0; i < SKILL_MAX_NUM; ++i)

  0006e	33 f6		 xor	 esi, esi
  00070	8d bd 02 fa ff
	ff		 lea	 edi, DWORD PTR _packet$[ebp+2]
$LL5@RecvSkillL:

; 2370 : 	{
; 2371 : 		TPlayerSkill & rPlayerSkill = packet.skills[i];
; 2372 : 
; 2373 : 		if (i >= 112 && i <= 115 && rPlayerSkill.bLevel)

  00076	8d 46 90	 lea	 eax, DWORD PTR [esi-112]
  00079	83 f8 03	 cmp	 eax, 3
  0007c	77 0f		 ja	 SHORT $LN2@RecvSkillL
  0007e	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00081	74 0a		 je	 SHORT $LN2@RecvSkillL

; 2374 : 			rkPlayer.SetSkill(7, i);

  00083	56		 push	 esi
  00084	6a 07		 push	 7
  00086	8b cb		 mov	 ecx, ebx
  00088	e8 00 00 00 00	 call	 ?SetSkill@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::SetSkill
$LN2@RecvSkillL:

; 2375 : 
; 2376 : 		if (i >= 116 && i <= 119 && rPlayerSkill.bLevel)

  0008d	8d 46 8c	 lea	 eax, DWORD PTR [esi-116]
  00090	83 f8 03	 cmp	 eax, 3
  00093	77 0f		 ja	 SHORT $LN1@RecvSkillL
  00095	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00098	74 0a		 je	 SHORT $LN1@RecvSkillL

; 2377 : 			rkPlayer.SetSkill(8, i);

  0009a	56		 push	 esi
  0009b	6a 08		 push	 8
  0009d	8b cb		 mov	 ecx, ebx
  0009f	e8 00 00 00 00	 call	 ?SetSkill@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::SetSkill
$LN1@RecvSkillL:

; 2378 : 
; 2379 : 		rkPlayer.SetSkillLevel_(i, rPlayerSkill.bMasterType, rPlayerSkill.bLevel);

  000a4	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000a7	8b cb		 mov	 ecx, ebx
  000a9	50		 push	 eax
  000aa	0f b6 47 ff	 movzx	 eax, BYTE PTR [edi-1]
  000ae	50		 push	 eax
  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 ?SetSkillLevel_@CPythonPlayer@@QAEXKKK@Z ; CPythonPlayer::SetSkillLevel_
  000b5	46		 inc	 esi
  000b6	83 c7 06	 add	 edi, 6
  000b9	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  000bf	7c b5		 jl	 SHORT $LL5@RecvSkillL

; 2380 : 	}
; 2381 : 
; 2382 : 	__RefreshSkillWindow();

  000c1	8b 8d fc f9 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000c7	e8 00 00 00 00	 call	 ?__RefreshSkillWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshSkillWindow

; 2383 : 	__RefreshStatus();

  000cc	e8 00 00 00 00	 call	 ?__RefreshStatus@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshStatus

; 2384 : 	//Tracef(" >> RecvSkillLevelNew\n");
; 2385 : 	return true;
; 2386 : }

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d4	b0 01		 mov	 al, 1
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	33 cd		 xor	 ecx, ebp
  000da	5b		 pop	 ebx
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
?RecvSkillLevelNew@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvSkillLevelNew
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvDamageInfoPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_DamageInfoPacket$ = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
?RecvDamageInfoPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvDamageInfoPacket, COMDAT
; _this$ = ecx

; 2390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 2391 : 	TPacketGCDamageInfo DamageInfoPacket;
; 2392 : 
; 2393 : 	if (!Recv(sizeof(TPacketGCDamageInfo), &DamageInfoPacket))

  00012	8d 45 f0	 lea	 eax, DWORD PTR _DamageInfoPacket$[ebp]
  00015	8b f9		 mov	 edi, ecx
  00017	50		 push	 eax
  00018	6a 0a		 push	 10			; 0000000aH
  0001a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001f	84 c0		 test	 al, al
  00021	75 1f		 jne	 SHORT $LN4@RecvDamage

; 2394 : 	{
; 2395 : 		Tracen("Recv Target Packet Error");

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HIJGCIDI@Recv?5Target?5Packet?5Error?$AA@
  00028	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002d	83 c4 04	 add	 esp, 4

; 2396 : 		return false;

  00030	32 c0		 xor	 al, al

; 2411 : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00037	33 cd		 xor	 ecx, ebp
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN4@RecvDamage:

; 2397 : 	}
; 2398 : 	
; 2399 : 	CInstanceBase * pInstTarget = CPythonCharacterManager::Instance().GetInstancePtr(DamageInfoPacket.dwVID);

  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00048	ff 75 f1	 push	 DWORD PTR _DamageInfoPacket$[ebp+1]
  0004b	83 c1 04	 add	 ecx, 4
  0004e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00050	ff 50 08	 call	 DWORD PTR [eax+8]
  00053	8b f0		 mov	 esi, eax

; 2402 : 	if (pInstTarget)

  00055	85 f6		 test	 esi, esi
  00057	74 50		 je	 SHORT $LN1@RecvDamage

; 2403 : 	{
; 2404 : 		if(DamageInfoPacket.damage >= 0)

  00059	8b 55 f6	 mov	 edx, DWORD PTR _DamageInfoPacket$[ebp+6]
  0005c	85 d2		 test	 edx, edx
  0005e	78 3c		 js	 SHORT $LN2@RecvDamage

; 2400 : 	bool bSelf = (pInstTarget == CPythonCharacterManager::Instance().GetMainInstancePtr());
; 2401 : 	bool bTarget = (pInstTarget==m_pInstTarget);

  00060	33 c9		 xor	 ecx, ecx
  00062	3b b7 48 79 00
	00		 cmp	 esi, DWORD PTR [edi+31048]
  00068	0f 94 c1	 sete	 cl

; 2405 : 			pInstTarget->AddDamageEffect(DamageInfoPacket.damage,DamageInfoPacket.flag,bSelf,bTarget);

  0006b	51		 push	 ecx
  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00072	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  00077	33 c9		 xor	 ecx, ecx
  00079	3b f0		 cmp	 esi, eax
  0007b	0f 94 c1	 sete	 cl
  0007e	51		 push	 ecx
  0007f	ff 75 f5	 push	 DWORD PTR _DamageInfoPacket$[ebp+5]
  00082	8b ce		 mov	 ecx, esi
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?AddDamageEffect@CInstanceBase@@QAEXKEHH@Z ; CInstanceBase::AddDamageEffect

; 2408 : 	}
; 2409 : 
; 2410 : 	return true;

  0008a	b0 01		 mov	 al, 1

; 2411 : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	33 cd		 xor	 ecx, ebp
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
$LN2@RecvDamage:

; 2406 : 		else
; 2407 : 			TraceError("Damage is equal or below 0.");

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PIHJNOHE@Damage?5is?5equal?5or?5below?50?4?$AA@
  000a1	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000a6	83 c4 04	 add	 esp, 4
$LN1@RecvDamage:

; 2411 : }

  000a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ac	b0 01		 mov	 al, 1
  000ae	5f		 pop	 edi
  000af	33 cd		 xor	 ecx, ebp
  000b1	5e		 pop	 esi
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?RecvDamageInfoPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvDamageInfoPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvTargetPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_TargetPacket$ = -8					; size = 6
?RecvTargetPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvTargetPacket, COMDAT
; _this$ = ecx

; 2413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2414 : 	TPacketGCTarget TargetPacket;
; 2415 : 
; 2416 : 	if (!Recv(sizeof(TPacketGCTarget), &TargetPacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _TargetPacket$[ebp]
  00009	53		 push	 ebx
  0000a	50		 push	 eax
  0000b	6a 06		 push	 6
  0000d	8b d9		 mov	 ebx, ecx
  0000f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00014	84 c0		 test	 al, al
  00016	75 14		 jne	 SHORT $LN9@RecvTarget

; 2417 : 	{
; 2418 : 		Tracen("Recv Target Packet Error");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HIJGCIDI@Recv?5Target?5Packet?5Error?$AA@
  0001d	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00022	83 c4 04	 add	 esp, 4

; 2419 : 		return false;

  00025	32 c0		 xor	 al, al
  00027	5b		 pop	 ebx

; 2444 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN9@RecvTarget:

; 2420 : 	}
; 2421 : 
; 2422 : 	CInstanceBase * pInstPlayer = CPythonCharacterManager::Instance().GetMainInstancePtr();

  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00032	56		 push	 esi
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr

; 2423 : 	CInstanceBase * pInstTarget = CPythonCharacterManager::Instance().GetInstancePtr(TargetPacket.dwVID);

  00039	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003c	83 c1 04	 add	 ecx, 4
  0003f	ff 75 f9	 push	 DWORD PTR _TargetPacket$[ebp+1]
  00042	8b f0		 mov	 esi, eax
  00044	ff 52 08	 call	 DWORD PTR [edx+8]
  00047	8b f8		 mov	 edi, eax

; 2424 : 	if (pInstPlayer && pInstTarget)

  00049	85 f6		 test	 esi, esi
  0004b	0f 84 cc 00 00
	00		 je	 $LN8@RecvTarget
  00051	85 ff		 test	 edi, edi
  00053	0f 84 c4 00 00
	00		 je	 $LN8@RecvTarget

; 2425 : 	{
; 2426 : 		if (!pInstTarget->IsDead())

  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?IsDead@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDead
  00060	85 c0		 test	 eax, eax
  00062	0f 85 d4 00 00
	00		 jne	 $LN1@RecvTarget

; 2427 : 		{
; 2428 : 			if (pInstTarget->IsPC() || pInstTarget->IsBuilding())

  00068	8b cf		 mov	 ecx, edi
  0006a	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  0006f	85 c0		 test	 eax, eax
  00071	75 79		 jne	 SHORT $LN5@RecvTarget
  00073	8b cf		 mov	 ecx, edi
  00075	e8 00 00 00 00	 call	 ?IsBuilding@CInstanceBase@@QAEHXZ ; CInstanceBase::IsBuilding
  0007a	85 c0		 test	 eax, eax
  0007c	75 6e		 jne	 SHORT $LN5@RecvTarget

; 2430 : 			else if (pInstPlayer->CanViewTargetHP(*pInstTarget))

  0007e	57		 push	 edi
  0007f	e8 00 00 00 00	 call	 ?CanViewTargetHP@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::CanViewTargetHP
  00084	84 c0		 test	 al, al
  00086	74 36		 je	 SHORT $LN3@RecvTarget

; 2431 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetHPTargetBoard", Py_BuildValue("(ii)", TargetPacket.dwVID, TargetPacket.bHPPercent));

  00088	0f b6 45 fd	 movzx	 eax, BYTE PTR _TargetPacket$[ebp+5]
  0008c	50		 push	 eax
  0008d	ff 75 f9	 push	 DWORD PTR _TargetPacket$[ebp+1]
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0009b	50		 push	 eax
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PDPGJKAD@SetHPTargetBoard?$AA@
  000a1	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  000a7	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000ac	83 c4 18	 add	 esp, 24			; 00000018H

; 2434 : 			
; 2435 : 			m_pInstTarget = pInstTarget;

  000af	89 bb 48 79 00
	00		 mov	 DWORD PTR [ebx+31048], edi

; 2441 : 	}
; 2442 : 
; 2443 : 	return true;

  000b5	b0 01		 mov	 al, 1
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 2444 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN3@RecvTarget:

; 2432 : 			else
; 2433 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));

  000be	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000c9	50		 push	 eax
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPCBFHE@CloseTargetBoard?$AA@
  000cf	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  000d5	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000da	83 c4 10	 add	 esp, 16			; 00000010H

; 2434 : 			
; 2435 : 			m_pInstTarget = pInstTarget;

  000dd	89 bb 48 79 00
	00		 mov	 DWORD PTR [ebx+31048], edi

; 2441 : 	}
; 2442 : 
; 2443 : 	return true;

  000e3	b0 01		 mov	 al, 1
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx

; 2444 : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
$LN5@RecvTarget:

; 2429 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoardIfDifferent", Py_BuildValue("(i)", TargetPacket.dwVID));

  000ec	ff 75 f9	 push	 DWORD PTR _TargetPacket$[ebp+1]
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000fa	50		 push	 eax
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KLEOIHKF@CloseTargetBoardIfDifferent?$AA@
  00100	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  00106	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0010b	83 c4 14	 add	 esp, 20			; 00000014H

; 2434 : 			
; 2435 : 			m_pInstTarget = pInstTarget;

  0010e	89 bb 48 79 00
	00		 mov	 DWORD PTR [ebx+31048], edi

; 2441 : 	}
; 2442 : 
; 2443 : 	return true;

  00114	b0 01		 mov	 al, 1
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx

; 2444 : }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
$LN8@RecvTarget:

; 2436 : 		}
; 2437 : 	}
; 2438 : 	else
; 2439 : 	{
; 2440 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "CloseTargetBoard", Py_BuildValue("()"));

  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00128	50		 push	 eax
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPCBFHE@CloseTargetBoard?$AA@
  0012e	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]
  00134	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00139	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@RecvTarget:

; 2441 : 	}
; 2442 : 
; 2443 : 	return true;

  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	b0 01		 mov	 al, 1
  00140	5b		 pop	 ebx

; 2444 : }

  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
?RecvTargetPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvTargetPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvMountPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_MountPacket$ = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
?RecvMountPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvMountPacket, COMDAT
; _this$ = ecx

; 2447 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2448 : 	TPacketGCMount MountPacket;
; 2449 : 
; 2450 : 	if (!Recv(sizeof(TPacketGCMount), &MountPacket))

  00010	8d 45 e8	 lea	 eax, DWORD PTR _MountPacket$[ebp]
  00013	50		 push	 eax
  00014	6a 12		 push	 18			; 00000012H
  00016	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001b	84 c0		 test	 al, al
  0001d	75 1d		 jne	 SHORT $LN5@RecvMountP

; 2451 : 	{
; 2452 : 		Tracen("Recv Mount Packet Error");

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LEDBDCKL@Recv?5Mount?5Packet?5Error?$AA@
  00024	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00029	83 c4 04	 add	 esp, 4

; 2453 : 		return false;

  0002c	32 c0		 xor	 al, al

; 2473 : 	{
; 2474 : //		CPythonPlayer::Instance().SetRidingVehicleIndex(MountPacket.mount_vid);
; 2475 : 	}
; 2476 : 
; 2477 : 	return true;
; 2478 : }

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00031	33 cd		 xor	 ecx, ebp
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN5@RecvMountP:

; 2454 : 	}
; 2455 : 
; 2456 : 	CInstanceBase * pInstance = CPythonCharacterManager::Instance().GetInstancePtr(MountPacket.vid);

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00042	ff 75 e9	 push	 DWORD PTR _MountPacket$[ebp+1]
  00045	83 c1 04	 add	 ecx, 4
  00048	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004a	ff 50 08	 call	 DWORD PTR [eax+8]

; 2457 : 
; 2458 : 	if (pInstance)
; 2459 : 	{
; 2460 : 		// Mount
; 2461 : 		if (0 != MountPacket.mount_vid)
; 2462 : 		{
; 2463 : //			pInstance->Ride(MountPacket.pos, MountPacket.mount_vid);
; 2464 : 		}
; 2465 : 		// Unmount
; 2466 : 		else
; 2467 : 		{
; 2468 : //			pInstance->Unride(MountPacket.pos, MountPacket.x, MountPacket.y);
; 2469 : 		}
; 2470 : 	}
; 2471 : 
; 2472 : 	if (CPythonPlayer::Instance().IsMainCharacterIndex(MountPacket.vid))

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00053	ff 75 e9	 push	 DWORD PTR _MountPacket$[ebp+1]
  00056	83 c1 04	 add	 ecx, 4
  00059	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005b	ff 50 0c	 call	 DWORD PTR [eax+12]

; 2473 : 	{
; 2474 : //		CPythonPlayer::Instance().SetRidingVehicleIndex(MountPacket.mount_vid);
; 2475 : 	}
; 2476 : 
; 2477 : 	return true;
; 2478 : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	b0 01		 mov	 al, 1
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?RecvMountPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvMountPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvChangeSpeedPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_SpeedPacket$ = -8					; size = 7
?RecvChangeSpeedPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvChangeSpeedPacket, COMDAT
; _this$ = ecx

; 2481 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2482 : 	TPacketGCChangeSpeed SpeedPacket;
; 2483 : 
; 2484 : 	if (!Recv(sizeof(TPacketGCChangeSpeed), &SpeedPacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _SpeedPacket$[ebp]
  00009	50		 push	 eax
  0000a	6a 07		 push	 7
  0000c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00011	84 c0		 test	 al, al
  00013	75 13		 jne	 SHORT $LN2@RecvChange

; 2485 : 	{
; 2486 : 		Tracen("Recv Speed Packet Error");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OCDKMKMI@Recv?5Speed?5Packet?5Error?$AA@
  0001a	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0001f	83 c4 04	 add	 esp, 4

; 2487 : 		return false;

  00022	32 c0		 xor	 al, al

; 2493 : 		return true;
; 2494 : 
; 2495 : //	pInstance->SetWalkSpeed(SpeedPacket.walking_speed);
; 2496 : //	pInstance->SetRunSpeed(SpeedPacket.running_speed);
; 2497 : 	return true;
; 2498 : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN2@RecvChange:

; 2488 : 	}
; 2489 : 
; 2490 : 	CInstanceBase * pInstance = CPythonCharacterManager::Instance().GetInstancePtr(SpeedPacket.vid);

  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0002e	ff 75 f9	 push	 DWORD PTR _SpeedPacket$[ebp+1]
  00031	83 c1 04	 add	 ecx, 4
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	ff 50 08	 call	 DWORD PTR [eax+8]

; 2491 : 
; 2492 : 	if (!pInstance)

  00039	b0 01		 mov	 al, 1

; 2493 : 		return true;
; 2494 : 
; 2495 : //	pInstance->SetWalkSpeed(SpeedPacket.walking_speed);
; 2496 : //	pInstance->SetRunSpeed(SpeedPacket.running_speed);
; 2497 : 	return true;
; 2498 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?RecvChangeSpeedPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvChangeSpeedPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendAttackPacket@CPythonNetworkStream@@QAE_NIK@Z
_TEXT	SEGMENT
_kPacketAtk$ = -8					; size = 8
_uMotAttack$ = 8					; size = 4
_dwVIDVictim$ = 12					; size = 4
?SendAttackPacket@CPythonNetworkStream@@QAE_NIK@Z PROC	; CPythonNetworkStream::SendAttackPacket, COMDAT
; _this$ = ecx

; 2504 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2505 : 	if (!__CanActMainInstance())

  00009	e8 00 00 00 00	 call	 ?__CanActMainInstance@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__CanActMainInstance
  0000e	84 c0		 test	 al, al
  00010	75 09		 jne	 SHORT $LN2@SendAttack

; 2506 : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi

; 2528 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
$LN2@SendAttack:

; 2507 : 
; 2508 : #ifdef ATTACK_TIME_LOG
; 2509 : 	static DWORD prevTime = timeGetTime();
; 2510 : 	DWORD curTime = timeGetTime();
; 2511 : 	TraceError("TIME: %.4f(%.4f) ATTACK_PACKET: %d TARGET: %d", curTime/1000.0f, (curTime-prevTime)/1000.0f, uMotAttack, dwVIDVictim);
; 2512 : 	prevTime = curTime;
; 2513 : #endif
; 2514 : 
; 2515 : 	TPacketCGAttack kPacketAtk;
; 2516 : 
; 2517 : 	kPacketAtk.header = HEADER_CG_ATTACK;
; 2518 : 	kPacketAtk.bType = uMotAttack;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _uMotAttack$[ebp]
  0001e	88 45 f9	 mov	 BYTE PTR _kPacketAtk$[ebp+1], al

; 2519 : 	kPacketAtk.dwVictimVID = dwVIDVictim;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _dwVIDVictim$[ebp]
  00024	89 45 fa	 mov	 DWORD PTR _kPacketAtk$[ebp+2], eax

; 2520 : 
; 2521 : 	if (!SendSpecial(sizeof(kPacketAtk), &kPacketAtk))

  00027	8d 45 f8	 lea	 eax, DWORD PTR _kPacketAtk$[ebp]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8b ce		 mov	 ecx, esi
  0002e	c6 45 f8 02	 mov	 BYTE PTR _kPacketAtk$[ebp], 2
  00032	e8 00 00 00 00	 call	 ?SendSpecial@CPythonNetworkStream@@QAE_NHPAX@Z ; CPythonNetworkStream::SendSpecial
  00037	84 c0		 test	 al, al
  00039	75 16		 jne	 SHORT $LN1@SendAttack

; 2522 : 	{
; 2523 : 		Tracen("Send Battle Attack Packet Error");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IBBLODAF@Send?5Battle?5Attack?5Packet?5Error?$AA@
  00040	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00045	83 c4 04	 add	 esp, 4

; 2524 : 		return false;

  00048	32 c0		 xor	 al, al
  0004a	5e		 pop	 esi

; 2528 : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
$LN1@SendAttack:

; 2525 : 	}
; 2526 : 
; 2527 : 	return SendSequence();

  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00058	5e		 pop	 esi

; 2528 : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
?SendAttackPacket@CPythonNetworkStream@@QAE_NIK@Z ENDP	; CPythonNetworkStream::SendAttackPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendSpecial@CPythonNetworkStream@@QAE_NHPAX@Z
_TEXT	SEGMENT
_nLen$dead$ = 8						; size = 4
_pvBuf$ = 12						; size = 4
?SendSpecial@CPythonNetworkStream@@QAE_NHPAX@Z PROC	; CPythonNetworkStream::SendSpecial, COMDAT
; _this$ = ecx

; 2531 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2532 : 	BYTE bHeader = *(BYTE *) pvBuf;
; 2533 : 
; 2534 : 	switch (bHeader)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _pvBuf$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0000d	83 e8 02	 sub	 eax, 2
  00010	75 12		 jne	 SHORT $LN6@SendSpecia

; 2535 : 	{
; 2536 : 		case HEADER_CG_ATTACK:
; 2537 : 			{
; 2538 : 				TPacketCGAttack * pkPacketAtk = (TPacketCGAttack *) pvBuf;
; 2539 : 				pkPacketAtk->bCRCMagicCubeProcPiece = GetProcessCRCMagicCubePiece();

  00012	e8 00 00 00 00	 call	 ?GetProcessCRCMagicCubePiece@@YAEXZ ; GetProcessCRCMagicCubePiece
  00017	88 46 06	 mov	 BYTE PTR [esi+6], al

; 2540 : 				pkPacketAtk->bCRCMagicCubeFilePiece = GetProcessCRCMagicCubePiece();

  0001a	e8 00 00 00 00	 call	 ?GetProcessCRCMagicCubePiece@@YAEXZ ; GetProcessCRCMagicCubePiece
  0001f	88 46 07	 mov	 BYTE PTR [esi+7], al

; 2541 : 				return Send(nLen, pvBuf);

  00022	8b cf		 mov	 ecx, edi
$LN6@SendSpecia:
  00024	56		 push	 esi
  00025	6a 08		 push	 8
  00027	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 2542 : 			}
; 2543 : 			break;
; 2544 : 	}
; 2545 : 
; 2546 : 	return Send(nLen, pvBuf);
; 2547 : }

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?SendSpecial@CPythonNetworkStream@@QAE_NHPAX@Z ENDP	; CPythonNetworkStream::SendSpecial
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_h$2 = -100						; size = 4
_kPacket$ = -96						; size = 17
$T3 = -76						; size = 24
$T4 = -52						; size = 24
$T5 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvAddFlyTargetingPacket, COMDAT
; _this$ = ecx

; 2550 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2551 : 	TPacketGCFlyTargeting kPacket;
; 2552 : 	if (!Recv(sizeof(kPacket), &kPacket))

  0002a	8d 45 a0	 lea	 eax, DWORD PTR _kPacket$[ebp]
  0002d	50		 push	 eax
  0002e	6a 11		 push	 17			; 00000011H
  00030	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00035	84 c0		 test	 al, al
  00037	0f 84 27 01 00
	00		 je	 $LN5@RecvAddFly
$LN4@RecvAddFly:

; 2553 : 		return false;
; 2554 : 
; 2555 : 	__GlobalPositionToLocalPosition(kPacket.lX, kPacket.lY);

  0003d	8d 45 ad	 lea	 eax, DWORD PTR _kPacket$[ebp+13]
  00040	50		 push	 eax
  00041	8d 45 a9	 lea	 eax, DWORD PTR _kPacket$[ebp+9]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?__GlobalPositionToLocalPosition@CPythonNetworkStream@@IAEXAAJ0@Z ; CPythonNetworkStream::__GlobalPositionToLocalPosition

; 2556 : 
; 2557 : 	Tracef("VID [%d]   \n",kPacket.dwShooterVID);

  0004a	ff 75 a1	 push	 DWORD PTR _kPacket$[ebp+1]
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KNAMGOGH@VID?5?$FL?$CFd?$FN?$LA?$KB?5?E?$LI?$LA?Y?$MA?$LL?5?C?$NP?$LA?$KB?5?$LM?$LD?A?$KE?6?$AA@
  00052	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 2558 : 
; 2559 : 	CPythonCharacterManager & rpcm = CPythonCharacterManager::Instance();

  00057	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0005d	83 c4 08	 add	 esp, 8

; 2560 : 
; 2561 : 	CInstanceBase * pShooter = rpcm.GetInstancePtr(kPacket.dwShooterVID);

  00060	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00063	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00066	ff 75 a1	 push	 DWORD PTR _kPacket$[ebp+1]
  00069	ff 50 08	 call	 DWORD PTR [eax+8]
  0006c	8b f8		 mov	 edi, eax

; 2562 : 
; 2563 : 	if (!pShooter)

  0006e	85 ff		 test	 edi, edi
  00070	75 15		 jne	 SHORT $LN3@RecvAddFly

; 2564 : 	{
; 2565 : #ifndef _DEBUG		
; 2566 : 		TraceError("CPythonNetworkStream::RecvFlyTargetingPacket() - dwShooterVID[%d] NOT EXIST", kPacket.dwShooterVID);

  00072	ff 75 a1	 push	 DWORD PTR _kPacket$[ebp+1]
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@NIJLGOIC@CPythonNetworkStream?3?3RecvFlyTar@
  0007a	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0007f	83 c4 08	 add	 esp, 8

; 2567 : #endif
; 2568 : 		return true;

  00082	e9 db 00 00 00	 jmp	 $LN1@RecvAddFly
$LN3@RecvAddFly:

; 2569 : 	}
; 2570 : 
; 2571 : 	CInstanceBase * pTarget = rpcm.GetInstancePtr(kPacket.dwTargetVID);

  00087	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0008a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0008d	ff 75 a5	 push	 DWORD PTR _kPacket$[ebp+5]
  00090	ff 50 08	 call	 DWORD PTR [eax+8]

; 2572 : 
; 2573 : 	if (kPacket.dwTargetVID && pTarget)

  00093	83 7d a5 00	 cmp	 DWORD PTR _kPacket$[ebp+5], 0
  00097	74 3f		 je	 SHORT $LN2@RecvAddFly
  00099	85 c0		 test	 eax, eax
  0009b	74 3b		 je	 SHORT $LN2@RecvAddFly

; 2574 : 	{
; 2575 : 		pShooter->GetGraphicThingInstancePtr()->AddFlyTarget(pTarget->GetGraphicThingInstancePtr());

  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  000a4	85 c0		 test	 eax, eax
  000a6	74 07		 je	 SHORT $LN7@RecvAddFly
  000a8	05 dc 01 00 00	 add	 eax, 476		; 000001dcH
  000ad	eb 02		 jmp	 SHORT $LN8@RecvAddFly
$LN7@RecvAddFly:
  000af	33 c0		 xor	 eax, eax
$LN8@RecvAddFly:
  000b1	50		 push	 eax
  000b2	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  000b5	e8 00 00 00 00	 call	 ??0CFlyTarget@@QAE@PAVIFlyTargetableObject@@@Z ; CFlyTarget::CFlyTarget
  000ba	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c4	50		 push	 eax
  000c5	8b cf		 mov	 ecx, edi
  000c7	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  000cc	8b c8		 mov	 ecx, eax
  000ce	e8 00 00 00 00	 call	 ?AddFlyTarget@CActorInstance@@QAEXABVCFlyTarget@@@Z ; CActorInstance::AddFlyTarget
  000d3	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]

; 2576 : 	}
; 2577 : 	else

  000d6	eb 7e		 jmp	 SHORT $LN18@RecvAddFly
$LN2@RecvAddFly:
  000d8	66 0f 6e 45 ad	 movd	 xmm0, DWORD PTR _kPacket$[ebp+13]

; 2578 : 	{
; 2579 : 		float h = CPythonBackground::Instance().GetHeight(kPacket.lX,kPacket.lY) + 60.0f; // TEMPORARY HEIGHT

  000dd	83 ec 08	 sub	 esp, 8
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  000e6	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000e9	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000ef	66 0f 6e 45 a9	 movd	 xmm0, DWORD PTR _kPacket$[ebp+9]
  000f4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fc	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight
  00101	66 0f 6e 45 a9	 movd	 xmm0, DWORD PTR _kPacket$[ebp+9]

; 2580 : 		pShooter->GetGraphicThingInstancePtr()->AddFlyTarget(D3DXVECTOR3(kPacket.lX,kPacket.lY,h));

  00106	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  00109	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@42700000
  0010f	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  00112	50		 push	 eax
  00113	66 0f 6e 4d ad	 movd	 xmm1, DWORD PTR _kPacket$[ebp+13]
  00118	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0011b	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0011e	d9 5d 9c	 fstp	 DWORD PTR _h$2[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00121	f3 0f 11 45 e4	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;
; 182  :     z = fz;

  00126	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _h$2[ebp]
  0012b	f3 0f 11 4d e8	 movss	 DWORD PTR $T5[ebp+4], xmm1
  00130	f3 0f 11 45 ec	 movss	 DWORD PTR $T5[ebp+8], xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2580 : 		pShooter->GetGraphicThingInstancePtr()->AddFlyTarget(D3DXVECTOR3(kPacket.lX,kPacket.lY,h));

  00135	e8 00 00 00 00	 call	 ??0CFlyTarget@@QAE@ABUD3DXVECTOR3@@@Z ; CFlyTarget::CFlyTarget
  0013a	8d 45 cc	 lea	 eax, DWORD PTR $T4[ebp]
  0013d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00144	50		 push	 eax
  00145	8b cf		 mov	 ecx, edi
  00147	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  0014c	8b c8		 mov	 ecx, eax
  0014e	e8 00 00 00 00	 call	 ?AddFlyTarget@CActorInstance@@QAEXABVCFlyTarget@@@Z ; CActorInstance::AddFlyTarget
  00153	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
$LN18@RecvAddFly:
  00156	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0015d	e8 00 00 00 00	 call	 ??1CFlyTarget@@UAE@XZ	; CFlyTarget::~CFlyTarget
$LN1@RecvAddFly:

; 2581 : 		//pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(kPacket.kPPosTarget.x,kPacket.kPPosTarget.y,);
; 2582 : 	}
; 2583 : 
; 2584 : 	return true;

  00162	b0 01		 mov	 al, 1
$LN5@RecvAddFly:

; 2585 : }

  00164	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00167	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016e	59		 pop	 ecx
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00174	33 cd		 xor	 ecx, ebp
  00176	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFlyTarget@@UAE@XZ	; CFlyTarget::~CFlyTarget
__unwindfunclet$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CFlyTarget@@UAE@XZ	; CFlyTarget::~CFlyTarget
__ehhandler$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvAddFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvAddFlyTargetingPacket
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_h$2 = -100						; size = 4
_kPacket$ = -96						; size = 17
$T3 = -76						; size = 24
$T4 = -52						; size = 24
$T5 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvFlyTargetingPacket, COMDAT
; _this$ = ecx

; 2588 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2589 : 	TPacketGCFlyTargeting kPacket;
; 2590 : 	if (!Recv(sizeof(kPacket), &kPacket))

  0002a	8d 45 a0	 lea	 eax, DWORD PTR _kPacket$[ebp]
  0002d	50		 push	 eax
  0002e	6a 11		 push	 17			; 00000011H
  00030	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00035	84 c0		 test	 al, al
  00037	0f 84 06 01 00
	00		 je	 $LN5@RecvFlyTar
$LN4@RecvFlyTar:

; 2591 : 		return false;
; 2592 : 
; 2593 : 	__GlobalPositionToLocalPosition(kPacket.lX, kPacket.lY);

  0003d	8d 45 ad	 lea	 eax, DWORD PTR _kPacket$[ebp+13]
  00040	50		 push	 eax
  00041	8d 45 a9	 lea	 eax, DWORD PTR _kPacket$[ebp+9]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?__GlobalPositionToLocalPosition@CPythonNetworkStream@@IAEXAAJ0@Z ; CPythonNetworkStream::__GlobalPositionToLocalPosition

; 2594 : 
; 2595 : 	//Tracef("CPythonNetworkStream::RecvFlyTargetingPacket - VID [%d]\n",kPacket.dwShooterVID);
; 2596 : 
; 2597 : 	CPythonCharacterManager & rpcm = CPythonCharacterManager::Instance();

  0004a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton

; 2598 : 
; 2599 : 	CInstanceBase * pShooter = rpcm.GetInstancePtr(kPacket.dwShooterVID);

  00050	ff 75 a1	 push	 DWORD PTR _kPacket$[ebp+1]
  00053	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00056	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00059	ff 50 08	 call	 DWORD PTR [eax+8]
  0005c	8b f8		 mov	 edi, eax

; 2600 : 
; 2601 : 	if (!pShooter)

  0005e	85 ff		 test	 edi, edi
  00060	0f 84 db 00 00
	00		 je	 $LN1@RecvFlyTar

; 2602 : 	{
; 2603 : #ifdef _DEBUG
; 2604 : 		TraceError("CPythonNetworkStream::RecvFlyTargetingPacket() - dwShooterVID[%d] NOT EXIST", kPacket.dwShooterVID);
; 2605 : #endif
; 2606 : 		return true;
; 2607 : 	}
; 2608 : 
; 2609 : 	CInstanceBase * pTarget = rpcm.GetInstancePtr(kPacket.dwTargetVID);

  00066	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00069	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0006c	ff 75 a5	 push	 DWORD PTR _kPacket$[ebp+5]
  0006f	ff 50 08	 call	 DWORD PTR [eax+8]

; 2610 : 
; 2611 : 	if (kPacket.dwTargetVID && pTarget)

  00072	83 7d a5 00	 cmp	 DWORD PTR _kPacket$[ebp+5], 0
  00076	74 3f		 je	 SHORT $LN2@RecvFlyTar
  00078	85 c0		 test	 eax, eax
  0007a	74 3b		 je	 SHORT $LN2@RecvFlyTar

; 2612 : 	{
; 2613 : 		pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(pTarget->GetGraphicThingInstancePtr());

  0007c	8b c8		 mov	 ecx, eax
  0007e	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  00083	85 c0		 test	 eax, eax
  00085	74 07		 je	 SHORT $LN7@RecvFlyTar
  00087	05 dc 01 00 00	 add	 eax, 476		; 000001dcH
  0008c	eb 02		 jmp	 SHORT $LN8@RecvFlyTar
$LN7@RecvFlyTar:
  0008e	33 c0		 xor	 eax, eax
$LN8@RecvFlyTar:
  00090	50		 push	 eax
  00091	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  00094	e8 00 00 00 00	 call	 ??0CFlyTarget@@QAE@PAVIFlyTargetableObject@@@Z ; CFlyTarget::CFlyTarget
  00099	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a3	50		 push	 eax
  000a4	8b cf		 mov	 ecx, edi
  000a6	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  000ab	8b c8		 mov	 ecx, eax
  000ad	e8 00 00 00 00	 call	 ?SetFlyTarget@CActorInstance@@QAEXABVCFlyTarget@@@Z ; CActorInstance::SetFlyTarget
  000b2	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]

; 2614 : 	}
; 2615 : 	else

  000b5	eb 7e		 jmp	 SHORT $LN18@RecvFlyTar
$LN2@RecvFlyTar:
  000b7	66 0f 6e 45 ad	 movd	 xmm0, DWORD PTR _kPacket$[ebp+13]

; 2616 : 	{
; 2617 : 		float h = CPythonBackground::Instance().GetHeight(kPacket.lX, kPacket.lY) + 60.0f; // TEMPORARY HEIGHT

  000bc	83 ec 08	 sub	 esp, 8
  000bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  000c5	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000c8	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000ce	66 0f 6e 45 a9	 movd	 xmm0, DWORD PTR _kPacket$[ebp+9]
  000d3	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000db	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight
  000e0	66 0f 6e 45 a9	 movd	 xmm0, DWORD PTR _kPacket$[ebp+9]

; 2618 : 		pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(D3DXVECTOR3(kPacket.lX,kPacket.lY,h));

  000e5	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  000e8	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@42700000
  000ee	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  000f1	50		 push	 eax
  000f2	66 0f 6e 4d ad	 movd	 xmm1, DWORD PTR _kPacket$[ebp+13]
  000f7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000fa	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000fd	d9 5d 9c	 fstp	 DWORD PTR _h$2[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00100	f3 0f 11 45 e4	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;
; 182  :     z = fz;

  00105	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _h$2[ebp]
  0010a	f3 0f 11 4d e8	 movss	 DWORD PTR $T5[ebp+4], xmm1
  0010f	f3 0f 11 45 ec	 movss	 DWORD PTR $T5[ebp+8], xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 2618 : 		pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(D3DXVECTOR3(kPacket.lX,kPacket.lY,h));

  00114	e8 00 00 00 00	 call	 ??0CFlyTarget@@QAE@ABUD3DXVECTOR3@@@Z ; CFlyTarget::CFlyTarget
  00119	8d 45 cc	 lea	 eax, DWORD PTR $T4[ebp]
  0011c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00123	50		 push	 eax
  00124	8b cf		 mov	 ecx, edi
  00126	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  0012b	8b c8		 mov	 ecx, eax
  0012d	e8 00 00 00 00	 call	 ?SetFlyTarget@CActorInstance@@QAEXABVCFlyTarget@@@Z ; CActorInstance::SetFlyTarget
  00132	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
$LN18@RecvFlyTar:
  00135	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0013c	e8 00 00 00 00	 call	 ??1CFlyTarget@@UAE@XZ	; CFlyTarget::~CFlyTarget
$LN1@RecvFlyTar:

; 2619 : 		//pShooter->GetGraphicThingInstancePtr()->SetFlyTarget(kPacket.kPPosTarget.x,kPacket.kPPosTarget.y,);
; 2620 : 	}
; 2621 : 
; 2622 : 	return true;

  00141	b0 01		 mov	 al, 1
$LN5@RecvFlyTar:

; 2623 : }

  00143	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00146	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014d	59		 pop	 ecx
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFlyTarget@@UAE@XZ	; CFlyTarget::~CFlyTarget
__unwindfunclet$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CFlyTarget@@UAE@XZ	; CFlyTarget::~CFlyTarget
__ehhandler$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvFlyTargetingPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvFlyTargetingPacket
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendShootPacket@CPythonNetworkStream@@QAE_NI@Z
_TEXT	SEGMENT
_kPacketShoot$ = -4					; size = 2
_uSkill$ = 8						; size = 4
?SendShootPacket@CPythonNetworkStream@@QAE_NI@Z PROC	; CPythonNetworkStream::SendShootPacket, COMDAT
; _this$ = ecx

; 2626 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2627 : 	TPacketCGShoot kPacketShoot;
; 2628 : 	kPacketShoot.bHeader=HEADER_CG_SHOOT;
; 2629 : 	kPacketShoot.bType=uSkill;

  00004	8b 45 08	 mov	 eax, DWORD PTR _uSkill$[ebp]
  00007	56		 push	 esi
  00008	88 45 fd	 mov	 BYTE PTR _kPacketShoot$[ebp+1], al
  0000b	8b f1		 mov	 esi, ecx

; 2630 : 
; 2631 : 	if (!Send(sizeof(kPacketShoot), &kPacketShoot))

  0000d	8d 45 fc	 lea	 eax, DWORD PTR _kPacketShoot$[ebp]
  00010	c6 45 fc 36	 mov	 BYTE PTR _kPacketShoot$[ebp], 54 ; 00000036H
  00014	50		 push	 eax
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001c	84 c0		 test	 al, al
  0001e	75 16		 jne	 SHORT $LN1@SendShootP

; 2632 : 	{
; 2633 : 		Tracen("SendShootPacket Error");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GKKFNNN@SendShootPacket?5Error?$AA@
  00025	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002a	83 c4 04	 add	 esp, 4

; 2634 : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	5e		 pop	 esi

; 2638 : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN1@SendShootP:

; 2635 : 	}
; 2636 : 
; 2637 : 	return SendSequence();

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0003d	5e		 pop	 esi

; 2638 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?SendShootPacket@CPythonNetworkStream@@QAE_NI@Z ENDP	; CPythonNetworkStream::SendShootPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendAddFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_packet$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_dwTargetVID$ = 8					; size = 4
_kPPosTarget$ = 12					; size = 4
?SendAddFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z PROC ; CPythonNetworkStream::SendAddFlyTargetingPacket, COMDAT
; _this$ = ecx

; 2641 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2642 : 	TPacketCGFlyTargeting packet;
; 2643 : 
; 2644 : 	//CPythonCharacterManager & rpcm = CPythonCharacterManager::Instance();
; 2645 : 
; 2646 : 	packet.bHeader	= HEADER_CG_ADD_FLY_TARGETING;
; 2647 : 	packet.dwTargetVID = dwTargetVID;

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwTargetVID$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	89 45 ed	 mov	 DWORD PTR _packet$[ebp+1], eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _kPPosTarget$[ebp]
  0001c	c6 45 ec 35	 mov	 BYTE PTR _packet$[ebp], 53 ; 00000035H

; 2648 : 	packet.lX = kPPosTarget.x;

  00020	f3 0f 2c 01	 cvttss2si eax, DWORD PTR [ecx]
  00024	89 45 f1	 mov	 DWORD PTR _packet$[ebp+5], eax

; 2649 : 	packet.lY = kPPosTarget.y;

  00027	f3 0f 2c 41 04	 cvttss2si eax, DWORD PTR [ecx+4]
  0002c	89 45 f5	 mov	 DWORD PTR _packet$[ebp+9], eax

; 2650 : 
; 2651 : 	__LocalPositionToGlobalPosition(packet.lX, packet.lY);

  0002f	8d 45 f5	 lea	 eax, DWORD PTR _packet$[ebp+9]
  00032	50		 push	 eax
  00033	8d 45 f1	 lea	 eax, DWORD PTR _packet$[ebp+5]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?__LocalPositionToGlobalPosition@CPythonNetworkStream@@IAEXAAJ0@Z ; CPythonNetworkStream::__LocalPositionToGlobalPosition

; 2652 : 	
; 2653 : 	if (!Send(sizeof(packet), &packet))

  0003c	8d 45 ec	 lea	 eax, DWORD PTR _packet$[ebp]
  0003f	8b ce		 mov	 ecx, esi
  00041	50		 push	 eax
  00042	6a 0d		 push	 13			; 0000000dH
  00044	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00049	84 c0		 test	 al, al
  0004b	75 20		 jne	 SHORT $LN1@SendAddFly

; 2654 : 	{
; 2655 : 		Tracen("Send FlyTargeting Packet Error");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MONNHODC@Send?5FlyTargeting?5Packet?5Error?$AA@
  00052	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00057	83 c4 04	 add	 esp, 4

; 2656 : 		return false;

  0005a	32 c0		 xor	 al, al
  0005c	5e		 pop	 esi

; 2660 : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	33 cd		 xor	 ecx, ebp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
$LN1@SendAddFly:

; 2657 : 	}
; 2658 : 
; 2659 : 	return SendSequence();

  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 2660 : }

  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 cd		 xor	 ecx, ebp
  00079	5e		 pop	 esi
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
?SendAddFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z ENDP ; CPythonNetworkStream::SendAddFlyTargetingPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_packet$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_dwTargetVID$ = 8					; size = 4
_kPPosTarget$ = 12					; size = 4
?SendFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z PROC ; CPythonNetworkStream::SendFlyTargetingPacket, COMDAT
; _this$ = ecx

; 2664 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2665 : 	TPacketCGFlyTargeting packet;
; 2666 : 
; 2667 : 	//CPythonCharacterManager & rpcm = CPythonCharacterManager::Instance();
; 2668 : 
; 2669 : 	packet.bHeader	= HEADER_CG_FLY_TARGETING;
; 2670 : 	packet.dwTargetVID = dwTargetVID;

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwTargetVID$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	89 45 ed	 mov	 DWORD PTR _packet$[ebp+1], eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _kPPosTarget$[ebp]
  0001c	c6 45 ec 33	 mov	 BYTE PTR _packet$[ebp], 51 ; 00000033H

; 2671 : 	packet.lX = kPPosTarget.x;

  00020	f3 0f 2c 01	 cvttss2si eax, DWORD PTR [ecx]
  00024	89 45 f1	 mov	 DWORD PTR _packet$[ebp+5], eax

; 2672 : 	packet.lY = kPPosTarget.y;

  00027	f3 0f 2c 41 04	 cvttss2si eax, DWORD PTR [ecx+4]
  0002c	89 45 f5	 mov	 DWORD PTR _packet$[ebp+9], eax

; 2673 : 
; 2674 : 	__LocalPositionToGlobalPosition(packet.lX, packet.lY);

  0002f	8d 45 f5	 lea	 eax, DWORD PTR _packet$[ebp+9]
  00032	50		 push	 eax
  00033	8d 45 f1	 lea	 eax, DWORD PTR _packet$[ebp+5]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?__LocalPositionToGlobalPosition@CPythonNetworkStream@@IAEXAAJ0@Z ; CPythonNetworkStream::__LocalPositionToGlobalPosition

; 2675 : 	
; 2676 : 	if (!Send(sizeof(packet), &packet))

  0003c	8d 45 ec	 lea	 eax, DWORD PTR _packet$[ebp]
  0003f	8b ce		 mov	 ecx, esi
  00041	50		 push	 eax
  00042	6a 0d		 push	 13			; 0000000dH
  00044	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00049	84 c0		 test	 al, al
  0004b	75 20		 jne	 SHORT $LN1@SendFlyTar

; 2677 : 	{
; 2678 : 		Tracen("Send FlyTargeting Packet Error");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MONNHODC@Send?5FlyTargeting?5Packet?5Error?$AA@
  00052	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00057	83 c4 04	 add	 esp, 4

; 2679 : 		return false;

  0005a	32 c0		 xor	 al, al
  0005c	5e		 pop	 esi

; 2683 : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	33 cd		 xor	 ecx, ebp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
$LN1@SendFlyTar:

; 2680 : 	}
; 2681 : 
; 2682 : 	return SendSequence();

  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 2683 : }

  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 cd		 xor	 ecx, ebp
  00079	5e		 pop	 esi
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
?SendFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z ENDP ; CPythonNetworkStream::SendFlyTargetingPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvCreateFlyPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kPacket$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
?RecvCreateFlyPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvCreateFlyPacket, COMDAT
; _this$ = ecx

; 2686 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2687 : 	TPacketGCCreateFly kPacket;
; 2688 : 	if (!Recv(sizeof(TPacketGCCreateFly), &kPacket))

  00010	8d 45 f0	 lea	 eax, DWORD PTR _kPacket$[ebp]
  00013	50		 push	 eax
  00014	6a 0a		 push	 10			; 0000000aH
  00016	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001b	84 c0		 test	 al, al
  0001d	75 0e		 jne	 SHORT $LN3@RecvCreate

; 2700 : 
; 2701 : 	return true;
; 2702 : }

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00022	33 cd		 xor	 ecx, ebp
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN3@RecvCreate:
  0002d	53		 push	 ebx

; 2689 : 		return false;
; 2690 : 
; 2691 : 	CFlyingManager& rkFlyMgr = CFlyingManager::Instance();

  0002e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?ms_singleton@?$CSingleton@VCFlyingManager@@@@0PAVCFlyingManager@@A ; CSingleton<CFlyingManager>::ms_singleton
  00034	56		 push	 esi

; 2692 : 	CPythonCharacterManager & rkChrMgr = CPythonCharacterManager::Instance();

  00035	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0003b	57		 push	 edi

; 2693 : 
; 2694 : 	CInstanceBase * pkStartInst = rkChrMgr.GetInstancePtr(kPacket.dwStartVID);

  0003c	ff 75 f2	 push	 DWORD PTR _kPacket$[ebp+2]
  0003f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00042	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00045	ff 50 08	 call	 DWORD PTR [eax+8]

; 2695 : 	CInstanceBase * pkEndInst = rkChrMgr.GetInstancePtr(kPacket.dwEndVID);

  00048	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0004b	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0004e	ff 75 f6	 push	 DWORD PTR _kPacket$[ebp+6]
  00051	8b f8		 mov	 edi, eax
  00053	ff 52 08	 call	 DWORD PTR [edx+8]

; 2696 : 	if (!pkStartInst || !pkEndInst)

  00056	85 ff		 test	 edi, edi
  00058	74 20		 je	 SHORT $LN1@RecvCreate
  0005a	85 c0		 test	 eax, eax
  0005c	74 1c		 je	 SHORT $LN1@RecvCreate

; 2697 : 		return true;
; 2698 : 
; 2699 : 	rkFlyMgr.CreateIndexedFly(kPacket.bType, pkStartInst->GetGraphicThingInstancePtr(), pkEndInst->GetGraphicThingInstancePtr());

  0005e	8b c8		 mov	 ecx, eax
  00060	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  00065	50		 push	 eax
  00066	8b cf		 mov	 ecx, edi
  00068	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  0006d	50		 push	 eax
  0006e	0f b6 45 f1	 movzx	 eax, BYTE PTR _kPacket$[ebp+1]
  00072	8b cb		 mov	 ecx, ebx
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?CreateIndexedFly@CFlyingManager@@QAEXKPAVCActorInstance@@0@Z ; CFlyingManager::CreateIndexedFly
$LN1@RecvCreate:

; 2700 : 
; 2701 : 	return true;
; 2702 : }

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	b0 01		 mov	 al, 1
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	33 cd		 xor	 ecx, ebp
  00083	5b		 pop	 ebx
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?RecvCreateFlyPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvCreateFlyPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendTargetPacket@CPythonNetworkStream@@QAE_NK@Z
_TEXT	SEGMENT
_packet$ = -8						; size = 5
_dwVID$ = 8						; size = 4
?SendTargetPacket@CPythonNetworkStream@@QAE_NK@Z PROC	; CPythonNetworkStream::SendTargetPacket, COMDAT
; _this$ = ecx

; 2705 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2706 : 	TPacketCGTarget packet;
; 2707 : 	packet.header = HEADER_CG_TARGET;
; 2708 : 	packet.dwVID = dwVID;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dwVID$[ebp]
  00009	56		 push	 esi
  0000a	89 45 f9	 mov	 DWORD PTR _packet$[ebp+1], eax
  0000d	8b f1		 mov	 esi, ecx

; 2709 : 
; 2710 : 	if (!Send(sizeof(packet), &packet))

  0000f	8d 45 f8	 lea	 eax, DWORD PTR _packet$[ebp]
  00012	c6 45 f8 3d	 mov	 BYTE PTR _packet$[ebp], 61 ; 0000003dH
  00016	50		 push	 eax
  00017	6a 05		 push	 5
  00019	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001e	84 c0		 test	 al, al
  00020	75 16		 jne	 SHORT $LN1@SendTarget

; 2711 : 	{
; 2712 : 		Tracen("Send Target Packet Error");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MBCMDDJG@Send?5Target?5Packet?5Error?$AA@
  00027	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0002c	83 c4 04	 add	 esp, 4

; 2713 : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 2717 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN1@SendTarget:

; 2714 : 	}
; 2715 : 
; 2716 : 	return SendSequence();

  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0003f	5e		 pop	 esi

; 2717 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?SendTargetPacket@CPythonNetworkStream@@QAE_NK@Z ENDP	; CPythonNetworkStream::SendTargetPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendSyncPositionElementPacket@CPythonNetworkStream@@QAE_NKKK@Z
_TEXT	SEGMENT
_kSyncPos$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_dwVictimVID$ = 8					; size = 4
_dwVictimX$ = 12					; size = 4
_dwVictimY$ = 16					; size = 4
?SendSyncPositionElementPacket@CPythonNetworkStream@@QAE_NKKK@Z PROC ; CPythonNetworkStream::SendSyncPositionElementPacket, COMDAT
; _this$ = ecx

; 2720 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2721 : 	TPacketCGSyncPositionElement kSyncPos;
; 2722 : 	kSyncPos.dwVID=dwVictimVID;

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwVictimVID$[ebp]
  00013	89 45 f0	 mov	 DWORD PTR _kSyncPos$[ebp], eax

; 2723 : 	kSyncPos.lX=dwVictimX;

  00016	8b 45 0c	 mov	 eax, DWORD PTR _dwVictimX$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR _kSyncPos$[ebp+4], eax

; 2724 : 	kSyncPos.lY=dwVictimY;

  0001c	8b 45 10	 mov	 eax, DWORD PTR _dwVictimY$[ebp]
  0001f	56		 push	 esi
  00020	89 45 f8	 mov	 DWORD PTR _kSyncPos$[ebp+8], eax
  00023	8b f1		 mov	 esi, ecx

; 2725 : 
; 2726 : 	__LocalPositionToGlobalPosition(kSyncPos.lX, kSyncPos.lY);

  00025	8d 45 f8	 lea	 eax, DWORD PTR _kSyncPos$[ebp+8]
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR _kSyncPos$[ebp+4]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?__LocalPositionToGlobalPosition@CPythonNetworkStream@@IAEXAAJ0@Z ; CPythonNetworkStream::__LocalPositionToGlobalPosition

; 2727 : 
; 2728 : 	if (!Send(sizeof(kSyncPos), &kSyncPos))

  00032	8d 45 f0	 lea	 eax, DWORD PTR _kSyncPos$[ebp]
  00035	8b ce		 mov	 ecx, esi
  00037	50		 push	 eax
  00038	6a 0c		 push	 12			; 0000000cH
  0003a	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0003f	5e		 pop	 esi
  00040	84 c0		 test	 al, al
  00042	75 1f		 jne	 SHORT $LN1@SendSyncPo

; 2729 : 	{
; 2730 : 		Tracen("CPythonNetworkStream::SendSyncPositionElementPacket - ERROR");

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@NAODJGJE@CPythonNetworkStream?3?3SendSyncPo@
  00049	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0004e	83 c4 04	 add	 esp, 4

; 2731 : 		return false;

  00051	32 c0		 xor	 al, al

; 2732 : 	}
; 2733 : 
; 2734 : 	return true;
; 2735 : }

  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SendSyncPo:
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	b0 01		 mov	 al, 1
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 0c 00	 ret	 12			; 0000000cH
?SendSyncPositionElementPacket@CPythonNetworkStream@@QAE_NKKK@Z ENDP ; CPythonNetworkStream::SendSyncPositionElementPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvMessenger@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_byState$1 = -44					; size = 1
_p$ = -40						; size = 4
_on$2 = -36						; size = 2
_byLength$3 = -35					; size = 1
_logout$4 = -35						; size = 1
_p$5 = -35						; size = 1
_char_name$ = -32					; size = 25
__$ArrayPad$ = -4					; size = 4
?RecvMessenger@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvMessenger, COMDAT
; _this$ = ecx

; 2738 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 2739 :     TPacketGCMessenger p;
; 2740 : 	if (!Recv(sizeof(p), &p))

  00012	8d 45 d8	 lea	 eax, DWORD PTR _p$[ebp]
  00015	8b f1		 mov	 esi, ecx
  00017	50		 push	 eax
  00018	6a 04		 push	 4
  0001a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001f	84 c0		 test	 al, al
  00021	75 12		 jne	 SHORT $LN21@RecvMessen
$LN45@RecvMessen:

; 2741 : 		return false;

  00023	32 c0		 xor	 al, al

; 2816 : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002a	33 cd		 xor	 ecx, ebp
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN21@RecvMessen:

; 2742 : 
; 2743 : 	int iSize = p.size - sizeof(p);

  00035	0f b7 7d d9	 movzx	 edi, WORD PTR _p$[ebp+1]

; 2744 : 	char char_name[24+1];
; 2745 : 
; 2746 : 	switch (p.subheader)

  00039	0f b6 45 db	 movzx	 eax, BYTE PTR _p$[ebp+3]
  0003d	83 ef 04	 sub	 edi, 4
  00040	83 f8 04	 cmp	 eax, 4
  00043	0f 87 cd 01 00
	00		 ja	 $LN19@RecvMessen
  00049	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN52@RecvMessen[eax*4]
$LN44@RecvMessen:

; 2747 : 	{
; 2748 : 		case MESSENGER_SUBHEADER_GC_LIST:
; 2749 : 		{
; 2750 : 			TPacketGCMessengerListOnline on;
; 2751 : 			while(iSize)

  00050	85 ff		 test	 edi, edi
  00052	0f 84 be 01 00
	00		 je	 $LN19@RecvMessen
$LL17@RecvMessen:

; 2752 : 			{
; 2753 : 				if (!Recv(sizeof(TPacketGCMessengerListOffline),&on))

  00058	8d 45 dc	 lea	 eax, DWORD PTR _on$2[ebp]
  0005b	8b ce		 mov	 ecx, esi
  0005d	50		 push	 eax
  0005e	6a 02		 push	 2
  00060	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00065	84 c0		 test	 al, al
  00067	74 ba		 je	 SHORT $LN45@RecvMessen

; 2754 : 					return false;
; 2755 : 
; 2756 : 				if (!Recv(on.length, char_name))

  00069	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  0006c	8b ce		 mov	 ecx, esi
  0006e	50		 push	 eax
  0006f	0f b6 45 dd	 movzx	 eax, BYTE PTR _on$2[ebp+1]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAD@Z ; CNetworkStream::Recv
  00079	84 c0		 test	 al, al
  0007b	74 a6		 je	 SHORT $LN45@RecvMessen

; 2757 : 					return false;
; 2758 : 
; 2759 : 				char_name[on.length] = 0;

  0007d	66 8b 45 dc	 mov	 ax, WORD PTR _on$2[ebp]
  00081	0f b6 cc	 movzx	 ecx, ah
  00084	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00087	0f 83 9b 01 00
	00		 jae	 $LN51@RecvMessen

; 2760 : 
; 2761 : 				if (on.connected & MESSENGER_CONNECTED_STATE_ONLINE)

  0008d	a8 01		 test	 al, 1
  0008f	c6 44 0d e0 00	 mov	 BYTE PTR _char_name$[ebp+ecx], 0

; 2762 : 					CPythonMessenger::Instance().OnFriendLogin(char_name);

  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  0009a	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  0009d	50		 push	 eax
  0009e	74 07		 je	 SHORT $LN13@RecvMessen
  000a0	e8 00 00 00 00	 call	 ?OnFriendLogin@CPythonMessenger@@QAEXPBD@Z ; CPythonMessenger::OnFriendLogin

; 2763 : 				else

  000a5	eb 05		 jmp	 SHORT $LN12@RecvMessen
$LN13@RecvMessen:

; 2764 : 					CPythonMessenger::Instance().OnFriendLogout(char_name);

  000a7	e8 00 00 00 00	 call	 ?OnFriendLogout@CPythonMessenger@@QAEXPBD@Z ; CPythonMessenger::OnFriendLogout
$LN12@RecvMessen:

; 2765 : 
; 2766 : 				if (on.connected & MESSENGER_CONNECTED_STATE_MOBILE)

  000ac	66 8b 45 dc	 mov	 ax, WORD PTR _on$2[ebp]
  000b0	a8 02		 test	 al, 2
  000b2	74 15		 je	 SHORT $LN11@RecvMessen

; 2767 : 					CPythonMessenger::Instance().SetMobile(char_name, TRUE);

  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  000ba	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  000bd	6a 01		 push	 1
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?SetMobile@CPythonMessenger@@QAEXPBDE@Z ; CPythonMessenger::SetMobile
  000c5	66 8b 45 dc	 mov	 ax, WORD PTR _on$2[ebp]
$LN11@RecvMessen:

; 2768 : 
; 2769 : 				iSize -= sizeof(TPacketGCMessengerListOffline);
; 2770 : 				iSize -= on.length;

  000c9	0f b6 c4	 movzx	 eax, ah
  000cc	b9 fe ff ff ff	 mov	 ecx, -2			; fffffffeH
  000d1	2b c8		 sub	 ecx, eax
  000d3	03 f9		 add	 edi, ecx
  000d5	75 81		 jne	 SHORT $LL17@RecvMessen

; 2812 : 			break;
; 2813 : 		}
; 2814 : 	}
; 2815 : 	return true;

  000d7	b0 01		 mov	 al, 1

; 2816 : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000de	33 cd		 xor	 ecx, ebp
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
$LN10@RecvMessen:

; 2771 : 			}
; 2772 : 			break;
; 2773 : 		}
; 2774 : 
; 2775 : 		case MESSENGER_SUBHEADER_GC_LOGIN:
; 2776 : 		{
; 2777 : 			TPacketGCMessengerLogin p;
; 2778 : 			if (!Recv(sizeof(p),&p))

  000e9	8d 45 dd	 lea	 eax, DWORD PTR _p$5[ebp]
  000ec	8b ce		 mov	 ecx, esi
  000ee	50		 push	 eax
  000ef	6a 01		 push	 1
  000f1	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  000f6	84 c0		 test	 al, al
  000f8	0f 84 25 ff ff
	ff		 je	 $LN45@RecvMessen

; 2779 : 				return false;
; 2780 : 			if (!Recv(p.length, char_name))

  000fe	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  00101	8b ce		 mov	 ecx, esi
  00103	50		 push	 eax
  00104	0f b6 45 dd	 movzx	 eax, BYTE PTR _p$5[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAD@Z ; CNetworkStream::Recv
  0010e	84 c0		 test	 al, al
  00110	0f 84 0d ff ff
	ff		 je	 $LN45@RecvMessen

; 2781 : 				return false;
; 2782 : 			char_name[p.length] = 0;

  00116	0f b6 45 dd	 movzx	 eax, BYTE PTR _p$5[ebp]
  0011a	83 f8 19	 cmp	 eax, 25			; 00000019H
  0011d	0f 83 05 01 00
	00		 jae	 $LN51@RecvMessen

; 2783 : 			CPythonMessenger::Instance().OnFriendLogin(char_name);

  00123	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  00129	c6 44 05 e0 00	 mov	 BYTE PTR _char_name$[ebp+eax], 0
  0012e	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ?OnFriendLogin@CPythonMessenger@@QAEXPBD@Z ; CPythonMessenger::OnFriendLogin

; 2784 : 			__RefreshTargetBoardByName(char_name);

  00137	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  0013a	8b ce		 mov	 ecx, esi
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?__RefreshTargetBoardByName@CPythonNetworkStream@@IAEXPBD@Z ; CPythonNetworkStream::__RefreshTargetBoardByName

; 2812 : 			break;
; 2813 : 		}
; 2814 : 	}
; 2815 : 	return true;

  00142	b0 01		 mov	 al, 1

; 2816 : }

  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00149	33 cd		 xor	 ecx, ebp
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
$LN7@RecvMessen:

; 2785 : 			break;
; 2786 : 		}
; 2787 : 
; 2788 : 		case MESSENGER_SUBHEADER_GC_LOGOUT:
; 2789 : 		{
; 2790 : 			TPacketGCMessengerLogout logout;
; 2791 : 			if (!Recv(sizeof(logout),&logout))

  00154	8d 45 dd	 lea	 eax, DWORD PTR _logout$4[ebp]
  00157	8b ce		 mov	 ecx, esi
  00159	50		 push	 eax
  0015a	6a 01		 push	 1
  0015c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00161	84 c0		 test	 al, al
  00163	0f 84 ba fe ff
	ff		 je	 $LN45@RecvMessen

; 2792 : 				return false;
; 2793 : 			if (!Recv(logout.length, char_name))

  00169	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  0016c	8b ce		 mov	 ecx, esi
  0016e	50		 push	 eax
  0016f	0f b6 45 dd	 movzx	 eax, BYTE PTR _logout$4[ebp]
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAD@Z ; CNetworkStream::Recv
  00179	84 c0		 test	 al, al
  0017b	0f 84 a2 fe ff
	ff		 je	 $LN45@RecvMessen

; 2794 : 				return false;
; 2795 : 			char_name[logout.length] = 0;

  00181	0f b6 45 dd	 movzx	 eax, BYTE PTR _logout$4[ebp]
  00185	83 f8 19	 cmp	 eax, 25			; 00000019H
  00188	0f 83 9a 00 00
	00		 jae	 $LN51@RecvMessen

; 2796 : 			CPythonMessenger::Instance().OnFriendLogout(char_name);

  0018e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  00194	c6 44 05 e0 00	 mov	 BYTE PTR _char_name$[ebp+eax], 0
  00199	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 ?OnFriendLogout@CPythonMessenger@@QAEXPBD@Z ; CPythonMessenger::OnFriendLogout

; 2812 : 			break;
; 2813 : 		}
; 2814 : 	}
; 2815 : 	return true;

  001a2	b0 01		 mov	 al, 1

; 2816 : }

  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a9	33 cd		 xor	 ecx, ebp
  001ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c3		 ret	 0
$LN4@RecvMessen:

; 2797 : 			break;
; 2798 : 		}
; 2799 : 
; 2800 : 		case MESSENGER_SUBHEADER_GC_MOBILE:
; 2801 : 		{
; 2802 : 			BYTE byState; //    
; 2803 : 			BYTE byLength;
; 2804 : 			if (!Recv(sizeof(byState), &byState))

  001b4	8d 45 d4	 lea	 eax, DWORD PTR _byState$1[ebp]
  001b7	8b ce		 mov	 ecx, esi
  001b9	50		 push	 eax
  001ba	6a 01		 push	 1
  001bc	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  001c1	84 c0		 test	 al, al
  001c3	0f 84 5a fe ff
	ff		 je	 $LN45@RecvMessen

; 2805 : 				return false;
; 2806 : 			if (!Recv(sizeof(byLength), &byLength))

  001c9	8d 45 dd	 lea	 eax, DWORD PTR _byLength$3[ebp]
  001cc	8b ce		 mov	 ecx, esi
  001ce	50		 push	 eax
  001cf	6a 01		 push	 1
  001d1	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  001d6	84 c0		 test	 al, al
  001d8	0f 84 45 fe ff
	ff		 je	 $LN45@RecvMessen

; 2807 : 				return false;
; 2808 : 			if (!Recv(byLength, char_name))

  001de	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  001e1	8b ce		 mov	 ecx, esi
  001e3	50		 push	 eax
  001e4	0f b6 45 dd	 movzx	 eax, BYTE PTR _byLength$3[ebp]
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAD@Z ; CNetworkStream::Recv
  001ee	84 c0		 test	 al, al
  001f0	0f 84 2d fe ff
	ff		 je	 $LN45@RecvMessen

; 2809 : 				return false;
; 2810 : 			char_name[byLength] = 0;

  001f6	0f b6 45 dd	 movzx	 eax, BYTE PTR _byLength$3[ebp]
  001fa	83 f8 19	 cmp	 eax, 25			; 00000019H
  001fd	73 29		 jae	 SHORT $LN51@RecvMessen

; 2811 : 			CPythonMessenger::Instance().SetMobile(char_name, byState);

  001ff	ff 75 d4	 push	 DWORD PTR _byState$1[ebp]
  00202	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  00208	c6 44 05 e0 00	 mov	 BYTE PTR _char_name$[ebp+eax], 0
  0020d	8d 45 e0	 lea	 eax, DWORD PTR _char_name$[ebp]
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 ?SetMobile@CPythonMessenger@@QAEXPBDE@Z ; CPythonMessenger::SetMobile
$LN19@RecvMessen:

; 2816 : }

  00216	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00219	b0 01		 mov	 al, 1
  0021b	5f		 pop	 edi
  0021c	33 cd		 xor	 ecx, ebp
  0021e	5e		 pop	 esi
  0021f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
$LN51@RecvMessen:

; 2757 : 					return false;
; 2758 : 
; 2759 : 				char_name[on.length] = 0;

  00228	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN53@RecvMessen:
$LN50@RecvMessen:
  0022d	8d 49 00	 npad	 3
$LN52@RecvMessen:

; 2816 : }

  00230	00 00 00 00	 DD	 $LN44@RecvMessen
  00234	00 00 00 00	 DD	 $LN10@RecvMessen
  00238	00 00 00 00	 DD	 $LN7@RecvMessen
  0023c	00 00 00 00	 DD	 $LN19@RecvMessen
  00240	00 00 00 00	 DD	 $LN4@RecvMessen
?RecvMessenger@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvMessenger
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPartyInvite@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kPartyInvitePacket$ = -8				; size = 5
?RecvPartyInvite@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPartyInvite, COMDAT
; _this$ = ecx

; 2922 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2923 : 	TPacketGCPartyInvite kPartyInvitePacket;
; 2924 : 	if (!Recv(sizeof(kPartyInvitePacket), &kPartyInvitePacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _kPartyInvitePacket$[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	6a 05		 push	 5
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00014	84 c0		 test	 al, al
  00016	75 05		 jne	 SHORT $LN2@RecvPartyI
  00018	5e		 pop	 esi

; 2938 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN2@RecvPartyI:

; 2925 : 		return false;
; 2926 : 
; 2927 : 	CInstanceBase * pInstance = CPythonCharacterManager::Instance().GetInstancePtr(kPartyInvitePacket.leader_pid);

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00023	83 c1 04	 add	 ecx, 4
  00026	57		 push	 edi
  00027	ff 75 f9	 push	 DWORD PTR _kPartyInvitePacket$[ebp+1]
  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	ff 50 08	 call	 DWORD PTR [eax+8]
  0002f	8b f8		 mov	 edi, eax

; 2928 : 	if (!pInstance)

  00031	85 ff		 test	 edi, edi
  00033	75 18		 jne	 SHORT $LN1@RecvPartyI

; 2929 : 	{
; 2930 : 		TraceError(" CPythonNetworkStream::RecvPartyInvite - Failed to find leader instance [%d]\n", kPartyInvitePacket.leader_pid);

  00035	ff 75 f9	 push	 DWORD PTR _kPartyInvitePacket$[ebp+1]
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@GALKDEGO@?5CPythonNetworkStream?3?3RecvParty@
  0003d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00042	83 c4 08	 add	 esp, 8

; 2936 : 
; 2937 : 	return true;

  00045	b0 01		 mov	 al, 1
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 2938 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN1@RecvPartyI:

; 2931 : 		return true;
; 2932 : 	}
; 2933 : 
; 2934 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RecvPartyInviteQuestion", Py_BuildValue("(is)", kPartyInvitePacket.leader_pid, pInstance->GetNameString()));

  0004d	8b cf		 mov	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?GetNameString@CInstanceBase@@QAEPBDXZ ; CInstanceBase::GetNameString
  00054	50		 push	 eax
  00055	ff 75 f9	 push	 DWORD PTR _kPartyInvitePacket$[ebp+1]
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00063	50		 push	 eax
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FPJOLEHH@RecvPartyInviteQuestion?$AA@
  00069	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0006f	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00074	83 c4 18	 add	 esp, 24			; 00000018H

; 2935 : 	Tracef(" >> RecvPartyInvite : %d, %s\n", kPartyInvitePacket.leader_pid, pInstance->GetNameString());

  00077	8b cf		 mov	 ecx, edi
  00079	e8 00 00 00 00	 call	 ?GetNameString@CInstanceBase@@QAEPBDXZ ; CInstanceBase::GetNameString
  0007e	50		 push	 eax
  0007f	ff 75 f9	 push	 DWORD PTR _kPartyInvitePacket$[ebp+1]
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@EBDJDNJB@?5?$DO?$DO?5RecvPartyInvite?5?3?5?$CFd?0?5?$CFs?6?$AA@
  00087	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2936 : 
; 2937 : 	return true;

  0008f	b0 01		 mov	 al, 1
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi

; 2938 : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?RecvPartyInvite@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPartyInvite
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPartyAdd@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kPartyAddPacket$ = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
?RecvPartyAdd@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPartyAdd, COMDAT
; _this$ = ecx

; 2941 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 2942 : 	TPacketGCPartyAdd kPartyAddPacket;
; 2943 : 	if (!Recv(sizeof(kPartyAddPacket), &kPartyAddPacket))

  00011	8d 45 dc	 lea	 eax, DWORD PTR _kPartyAddPacket$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 1e		 push	 30			; 0000001eH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN1@RecvPartyA

; 2949 : 
; 2950 : 	return true;
; 2951 : }

  00022	5e		 pop	 esi
  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN1@RecvPartyA:

; 2944 : 		return false;
; 2945 : 
; 2946 : 	CPythonPlayer::Instance().AppendPartyMember(kPartyAddPacket.pid, kPartyAddPacket.name);

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00037	8d 45 e1	 lea	 eax, DWORD PTR _kPartyAddPacket$[ebp+5]
  0003a	50		 push	 eax
  0003b	ff 75 dd	 push	 DWORD PTR _kPartyAddPacket$[ebp+1]
  0003e	e8 00 00 00 00	 call	 ?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z ; CPythonPlayer::AppendPartyMember

; 2947 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AddPartyMember", Py_BuildValue("(is)", kPartyAddPacket.pid, kPartyAddPacket.name));

  00043	8d 45 e1	 lea	 eax, DWORD PTR _kPartyAddPacket$[ebp+5]
  00046	50		 push	 eax
  00047	ff 75 dd	 push	 DWORD PTR _kPartyAddPacket$[ebp+1]
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	50		 push	 eax
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JPKHKGNP@AddPartyMember?$AA@
  0005e	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00064	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2948 : 	Tracef(" >> RecvPartyAdd : %d, %s\n", kPartyAddPacket.pid, kPartyAddPacket.name);

  0006c	8d 45 e1	 lea	 eax, DWORD PTR _kPartyAddPacket$[ebp+5]
  0006f	50		 push	 eax
  00070	ff 75 dd	 push	 DWORD PTR _kPartyAddPacket$[ebp+1]
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GPMBAKEI@?5?$DO?$DO?5RecvPartyAdd?5?3?5?$CFd?0?5?$CFs?6?$AA@
  00078	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 2949 : 
; 2950 : 	return true;
; 2951 : }

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	33 cd		 xor	 ecx, ebp
  00085	b0 01		 mov	 al, 1
  00087	5e		 pop	 esi
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?RecvPartyAdd@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPartyAdd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPartyUpdate@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_dwVID$ = -36						; size = 4
_pPartyMemberInfo$ = -36				; size = 4
_byOldState$1$ = -29					; size = 1
_kPartyUpdatePacket$ = -28				; size = 21
__$ArrayPad$ = -4					; size = 4
?RecvPartyUpdate@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPartyUpdate, COMDAT
; _this$ = ecx

; 2954 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 2955 : 	TPacketGCPartyUpdate kPartyUpdatePacket;
; 2956 : 	if (!Recv(sizeof(kPartyUpdatePacket), &kPartyUpdatePacket))

  00011	8d 45 e4	 lea	 eax, DWORD PTR _kPartyUpdatePacket$[ebp]
  00014	8b f9		 mov	 edi, ecx
  00016	50		 push	 eax
  00017	6a 15		 push	 21			; 00000015H
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN7@RecvPartyU
  00022	5f		 pop	 edi

; 2979 : 	}
; 2980 : 
; 2981 : // 	Tracef(" >> RecvPartyUpdate : %d, %d, %d\n", kPartyUpdatePacket.pid, kPartyUpdatePacket.state, kPartyUpdatePacket.percent_hp);
; 2982 : 
; 2983 : 	return true;
; 2984 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN7@RecvPartyU:

; 2957 : 		return false;
; 2958 : 
; 2959 : 	CPythonPlayer::TPartyMemberInfo * pPartyMemberInfo;
; 2960 : 	if (!CPythonPlayer::Instance().GetPartyMemberPtr(kPartyUpdatePacket.pid, &pPartyMemberInfo))

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00037	8d 45 dc	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  0003a	56		 push	 esi
  0003b	8b 75 e5	 mov	 esi, DWORD PTR _kPartyUpdatePacket$[ebp+1]
  0003e	50		 push	 eax
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  00045	84 c0		 test	 al, al
  00047	0f 84 88 00 00
	00		 je	 $LN1@RecvPartyU

; 2961 : 		return true;
; 2962 : 
; 2963 : 	BYTE byOldState = pPartyMemberInfo->byState;
; 2964 : 
; 2965 : 	CPythonPlayer::Instance().UpdatePartyMemberInfo(kPartyUpdatePacket.pid, kPartyUpdatePacket.state, kPartyUpdatePacket.percent_hp);

  0004d	ff 75 ea	 push	 DWORD PTR _kPartyUpdatePacket$[ebp+6]
  00050	8b 45 dc	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00053	ff 75 e9	 push	 DWORD PTR _kPartyUpdatePacket$[ebp+5]
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0005c	56		 push	 esi
  0005d	8a 40 20	 mov	 al, BYTE PTR [eax+32]
  00060	88 45 e3	 mov	 BYTE PTR _byOldState$1$[ebp], al
  00063	e8 00 00 00 00	 call	 ?UpdatePartyMemberInfo@CPythonPlayer@@QAEXKEE@Z ; CPythonPlayer::UpdatePartyMemberInfo

; 2966 : 	for (int i = 0; i < PARTY_AFFECT_SLOT_MAX_NUM; ++i)

  00068	33 f6		 xor	 esi, esi
  0006a	8d 9b 00 00 00
	00		 npad	 6
$LL5@RecvPartyU:

; 2967 : 	{
; 2968 : 		CPythonPlayer::Instance().UpdatePartyMemberAffect(kPartyUpdatePacket.pid, i, kPartyUpdatePacket.affects[i]);

  00070	0f b7 44 75 eb	 movzx	 eax, WORD PTR _kPartyUpdatePacket$[ebp+esi*2+7]
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0007b	50		 push	 eax
  0007c	56		 push	 esi
  0007d	ff 75 e5	 push	 DWORD PTR _kPartyUpdatePacket$[ebp+1]
  00080	e8 00 00 00 00	 call	 ?UpdatePartyMemberAffect@CPythonPlayer@@QAEXKEF@Z ; CPythonPlayer::UpdatePartyMemberAffect
  00085	46		 inc	 esi
  00086	83 fe 07	 cmp	 esi, 7
  00089	7c e5		 jl	 SHORT $LL5@RecvPartyU

; 2969 : 	}
; 2970 : 
; 2971 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UpdatePartyMemberInfo", Py_BuildValue("(i)", kPartyUpdatePacket.pid));

  0008b	ff 75 e5	 push	 DWORD PTR _kPartyUpdatePacket$[ebp+1]
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JOKFDABD@UpdatePartyMemberInfo?$AA@
  0009f	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  000a5	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 2972 : 
; 2973 : 	//   , TargetBoard    .
; 2974 : 	DWORD dwVID;
; 2975 : 	if (CPythonPlayer::Instance().PartyMemberPIDToVID(kPartyUpdatePacket.pid, &dwVID))

  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000b0	8d 45 dc	 lea	 eax, DWORD PTR _dwVID$[ebp]
  000b3	83 c4 14	 add	 esp, 20			; 00000014H
  000b6	50		 push	 eax
  000b7	ff 75 e5	 push	 DWORD PTR _kPartyUpdatePacket$[ebp+1]
  000ba	e8 00 00 00 00	 call	 ?PartyMemberPIDToVID@CPythonPlayer@@QAE_NKPAK@Z ; CPythonPlayer::PartyMemberPIDToVID
  000bf	84 c0		 test	 al, al
  000c1	74 12		 je	 SHORT $LN1@RecvPartyU

; 2976 : 	if (byOldState != kPartyUpdatePacket.state)

  000c3	8a 45 e3	 mov	 al, BYTE PTR _byOldState$1$[ebp]
  000c6	3a 45 e9	 cmp	 al, BYTE PTR _kPartyUpdatePacket$[ebp+5]
  000c9	74 0a		 je	 SHORT $LN1@RecvPartyU

; 2977 : 	{
; 2978 : 		__RefreshTargetBoardByVID(dwVID);

  000cb	ff 75 dc	 push	 DWORD PTR _dwVID$[ebp]
  000ce	8b cf		 mov	 ecx, edi
  000d0	e8 00 00 00 00	 call	 ?__RefreshTargetBoardByVID@CPythonNetworkStream@@IAEXK@Z ; CPythonNetworkStream::__RefreshTargetBoardByVID
$LN1@RecvPartyU:

; 2979 : 	}
; 2980 : 
; 2981 : // 	Tracef(" >> RecvPartyUpdate : %d, %d, %d\n", kPartyUpdatePacket.pid, kPartyUpdatePacket.state, kPartyUpdatePacket.percent_hp);
; 2982 : 
; 2983 : 	return true;
; 2984 : }

  000d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d8	b0 01		 mov	 al, 1
  000da	5e		 pop	 esi
  000db	33 cd		 xor	 ecx, ebp
  000dd	5f		 pop	 edi
  000de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
?RecvPartyUpdate@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPartyUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPartyRemove@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kPartyRemovePacket$ = -8				; size = 5
?RecvPartyRemove@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPartyRemove, COMDAT
; _this$ = ecx

; 2987 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2988 : 	TPacketGCPartyRemove kPartyRemovePacket;
; 2989 : 	if (!Recv(sizeof(kPartyRemovePacket), &kPartyRemovePacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _kPartyRemovePacket$[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	6a 05		 push	 5
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00014	84 c0		 test	 al, al
  00016	75 05		 jne	 SHORT $LN1@RecvPartyR
  00018	5e		 pop	 esi

; 2996 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN1@RecvPartyR:

; 2990 : 		return false;
; 2991 : 
; 2992 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RemovePartyMember", Py_BuildValue("(i)", kPartyRemovePacket.pid));

  0001d	ff 75 f9	 push	 DWORD PTR _kPartyRemovePacket$[ebp+1]
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DGCJFOHN@RemovePartyMember?$AA@
  00031	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00037	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 2993 : 	Tracef(" >> RecvPartyRemove : %d\n", kPartyRemovePacket.pid);

  0003c	ff 75 f9	 push	 DWORD PTR _kPartyRemovePacket$[ebp+1]
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FHNAOGNK@?5?$DO?$DO?5RecvPartyRemove?5?3?5?$CFd?6?$AA@
  00044	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2994 : 
; 2995 : 	return true;

  0004c	b0 01		 mov	 al, 1
  0004e	5e		 pop	 esi

; 2996 : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?RecvPartyRemove@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPartyRemove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPartyLink@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kPartyLinkPacket$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
?RecvPartyLink@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPartyLink, COMDAT
; _this$ = ecx

; 2999 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 3000 : 	TPacketGCPartyLink kPartyLinkPacket;
; 3001 : 	if (!Recv(sizeof(kPartyLinkPacket), &kPartyLinkPacket))

  00011	8d 45 f0	 lea	 eax, DWORD PTR _kPartyLinkPacket$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 09		 push	 9
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN1@RecvPartyL
  00022	5e		 pop	 esi

; 3007 : 
; 3008 : 	return true;
; 3009 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN1@RecvPartyL:

; 3002 : 		return false;
; 3003 : 
; 3004 : 	CPythonPlayer::Instance().LinkPartyMember(kPartyLinkPacket.pid, kPartyLinkPacket.vid);

  00031	ff 75 f5	 push	 DWORD PTR _kPartyLinkPacket$[ebp+5]
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0003a	ff 75 f1	 push	 DWORD PTR _kPartyLinkPacket$[ebp+1]
  0003d	e8 00 00 00 00	 call	 ?LinkPartyMember@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::LinkPartyMember

; 3005 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "LinkPartyMember", Py_BuildValue("(ii)", kPartyLinkPacket.pid, kPartyLinkPacket.vid));

  00042	ff 75 f5	 push	 DWORD PTR _kPartyLinkPacket$[ebp+5]
  00045	ff 75 f1	 push	 DWORD PTR _kPartyLinkPacket$[ebp+1]
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JPJIDGOI@LinkPartyMember?$AA@
  00059	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0005f	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 3006 : 	Tracef(" >> RecvPartyLink : %d, %d\n", kPartyLinkPacket.pid, kPartyLinkPacket.vid);

  00064	ff 75 f5	 push	 DWORD PTR _kPartyLinkPacket$[ebp+5]
  00067	ff 75 f1	 push	 DWORD PTR _kPartyLinkPacket$[ebp+1]
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@FEBFPLO@?5?$DO?$DO?5RecvPartyLink?5?3?5?$CFd?0?5?$CFd?6?$AA@
  0006f	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 3007 : 
; 3008 : 	return true;
; 3009 : }

  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	83 c4 24	 add	 esp, 36			; 00000024H
  0007a	33 cd		 xor	 ecx, ebp
  0007c	b0 01		 mov	 al, 1
  0007e	5e		 pop	 esi
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?RecvPartyLink@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPartyLink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPartyUnlink@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kPartyUnlinkPacket$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
?RecvPartyUnlink@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPartyUnlink, COMDAT
; _this$ = ecx

; 3012 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 3013 : 	TPacketGCPartyUnlink kPartyUnlinkPacket;
; 3014 : 	if (!Recv(sizeof(kPartyUnlinkPacket), &kPartyUnlinkPacket))

  00011	8d 45 f0	 lea	 eax, DWORD PTR _kPartyUnlinkPacket$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 09		 push	 9
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN3@RecvPartyU
  00022	5e		 pop	 esi

; 3029 : 
; 3030 : 	return true;
; 3031 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN3@RecvPartyU:

; 3015 : 		return false;
; 3016 : 
; 3017 : 	CPythonPlayer::Instance().UnlinkPartyMember(kPartyUnlinkPacket.pid);

  00031	ff 75 f1	 push	 DWORD PTR _kPartyUnlinkPacket$[ebp+1]
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0003a	e8 00 00 00 00	 call	 ?UnlinkPartyMember@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::UnlinkPartyMember

; 3018 : 
; 3019 : 	if (CPythonPlayer::Instance().IsMainCharacterIndex(kPartyUnlinkPacket.vid))

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00045	ff 75 f5	 push	 DWORD PTR _kPartyUnlinkPacket$[ebp+5]
  00048	83 c1 04	 add	 ecx, 4
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00050	ff d0		 call	 eax
  00052	84 c0		 test	 al, al
  00054	74 21		 je	 SHORT $LN2@RecvPartyU

; 3020 : 	{
; 3021 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UnlinkAllPartyMember", Py_BuildValue("()"));

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00061	50		 push	 eax
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KBCGJNOO@UnlinkAllPartyMember?$AA@
  00067	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0006d	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00072	83 c4 10	 add	 esp, 16			; 00000010H

; 3022 : 	}
; 3023 : 	else

  00075	eb 22		 jmp	 SHORT $LN1@RecvPartyU
$LN2@RecvPartyU:

; 3024 : 	{
; 3025 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "UnlinkPartyMember", Py_BuildValue("(i)", kPartyUnlinkPacket.pid));

  00077	ff 75 f1	 push	 DWORD PTR _kPartyUnlinkPacket$[ebp+1]
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EBBCCLIK@UnlinkPartyMember?$AA@
  0008b	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00091	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00096	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@RecvPartyU:

; 3026 : 	}
; 3027 : 
; 3028 : 	Tracef(" >> RecvPartyUnlink : %d, %d\n", kPartyUnlinkPacket.pid, kPartyUnlinkPacket.vid);

  00099	ff 75 f5	 push	 DWORD PTR _kPartyUnlinkPacket$[ebp+5]
  0009c	ff 75 f1	 push	 DWORD PTR _kPartyUnlinkPacket$[ebp+1]
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JOBNIIPD@?5?$DO?$DO?5RecvPartyUnlink?5?3?5?$CFd?0?5?$CFd?6?$AA@
  000a4	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 3029 : 
; 3030 : 	return true;
; 3031 : }

  000a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	33 cd		 xor	 ecx, ebp
  000b1	b0 01		 mov	 al, 1
  000b3	5e		 pop	 esi
  000b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?RecvPartyUnlink@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPartyUnlink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvPartyParameter@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kPartyParameterPacket$ = -4				; size = 2
?RecvPartyParameter@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPartyParameter, COMDAT
; _this$ = ecx

; 3034 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3035 : 	TPacketGCPartyParameter kPartyParameterPacket;
; 3036 : 	if (!Recv(sizeof(kPartyParameterPacket), &kPartyParameterPacket))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _kPartyParameterPacket$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 02		 push	 2
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 05		 jne	 SHORT $LN1@RecvPartyP
  00016	5e		 pop	 esi

; 3043 : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN1@RecvPartyP:

; 3037 : 		return false;
; 3038 : 
; 3039 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "ChangePartyParameter", Py_BuildValue("(i)", kPartyParameterPacket.bDistributeMode));

  0001b	0f b6 45 fd	 movzx	 eax, BYTE PTR _kPartyParameterPacket$[ebp+1]
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FFLEPOCB@ChangePartyParameter?$AA@
  00031	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00037	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 3040 : 	Tracef(" >> RecvPartyParameter : %d\n", kPartyParameterPacket.bDistributeMode);

  0003c	0f b6 45 fd	 movzx	 eax, BYTE PTR _kPartyParameterPacket$[ebp+1]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HDHIECAG@?5?$DO?$DO?5RecvPartyParameter?5?3?5?$CFd?6?$AA@
  00046	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0004b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3041 : 
; 3042 : 	return true;

  0004e	b0 01		 mov	 al, 1
  00050	5e		 pop	 esi

; 3043 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?RecvPartyParameter@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPartyParameter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvGuild@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_GuildPacket$ = -192					; size = 4
_dwMoney$2 = -188					; size = 4
_pMemberData$3 = -188					; size = 4
_pData$4 = -188						; size = 4
_pGuildMemberData$5 = -188				; size = 4
_pGuildMemberData$6 = -188				; size = 4
_i$1$ = -182						; size = 1
_byCount$7 = -182					; size = 1
_i$1$ = -181						; size = 1
_byCount$8 = -181					; size = 1
_byLevel$9 = -180					; size = 1
_byGradeNumber$10 = -180				; size = 1
_dwSrcGuildID$11 = -180					; size = 4
_dwDstGuildID$12 = -180					; size = 4
_dwPID$13 = -180					; size = 4
_dwPID$14 = -180					; size = 4
_dwPID$15 = -180					; size = 4
_byFlag$16 = -176					; size = 1
_byGrade$17 = -176					; size = 1
_byAuthorityFlag$18 = -176				; size = 1
_byGradeNumber$19 = -176				; size = 1
_byIndex$20 = -176					; size = 1
_dwDstGuildID$21 = -176					; size = 4
_dwSrcGuildID$22 = -176					; size = 4
_dwID$23 = -176						; size = 4
_dwGuildID$24 = -176					; size = 4
_dwEXP$25 = -176					; size = 4
_dwCommentID$26 = -176					; size = 4
_dwPID$27 = -176					; size = 4
_dwPID$28 = -176					; size = 4
$T29 = -172						; size = 28
_strMemberName$30 = -144				; size = 24
_GuildInfo$31 = -120					; size = 35
_szName$32 = -112					; size = 25
_szName$33 = -112					; size = 25
_szComment$34 = -84					; size = 51
_GuildMemberData$35 = -72				; size = 36
_GradePacket$36 = -32					; size = 10
_GuildWarPoint$37 = -32					; size = 12
_szGuildName$38 = -32					; size = 13
_kGuildWar$39 = -32					; size = 10
_szGuildName$40 = -32					; size = 13
_memberPacket$41 = -32					; size = 13
_szGradeName$42 = -28					; size = 9
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RecvGuild@CPythonNetworkStream@@IAE_NXZ PROC		; CPythonNetworkStream::RecvGuild, COMDAT
; _this$ = ecx

; 3294 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvGuild@CPythonNetworkStream@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx

; 3295 :     TPacketGCGuild GuildPacket;
; 3296 : 	if (!Recv(sizeof(GuildPacket), &GuildPacket))

  0002f	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _GuildPacket$[ebp]
  00035	50		 push	 eax
  00036	6a 04		 push	 4
  00038	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0003d	84 c0		 test	 al, al
  0003f	75 07		 jne	 SHORT $LN92@RecvGuild
$LN389@RecvGuild:

; 3297 : 		return false;

  00041	32 c0		 xor	 al, al
  00043	e9 ad 0c 00 00	 jmp	 $LN93@RecvGuild
$LN92@RecvGuild:

; 3298 : 
; 3299 : 	switch(GuildPacket.subheader)

  00048	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _GuildPacket$[ebp+3]
  0004f	83 f8 14	 cmp	 eax, 20			; 00000014H
  00052	0f 87 9b 0c 00
	00		 ja	 $LN90@RecvGuild
  00058	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN390@RecvGuild[eax*4]
$LN89@RecvGuild:

; 3300 : 	{
; 3301 : 		case GUILD_SUBHEADER_GC_LOGIN:
; 3302 : 		{
; 3303 : 			DWORD dwPID;
; 3304 : 			if (!Recv(sizeof(DWORD), &dwPID))

  0005f	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _dwPID$28[ebp]
  00065	8b cf		 mov	 ecx, edi
  00067	50		 push	 eax
  00068	6a 04		 push	 4
  0006a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0006f	84 c0		 test	 al, al
  00071	74 ce		 je	 SHORT $LN389@RecvGuild

; 3305 : 				return false;
; 3306 : 
; 3307 : 			// Messenger
; 3308 : 			CPythonGuild::TGuildMemberData * pGuildMemberData;
; 3309 : 			if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pGuildMemberData))

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00079	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _pGuildMemberData$6[ebp]
  0007f	50		 push	 eax
  00080	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwPID$28[ebp]
  00086	e8 00 00 00 00	 call	 ?GetMemberDataPtrByPID@CPythonGuild@@QAEHKPAPAUSGuildMemberData@1@@Z ; CPythonGuild::GetMemberDataPtrByPID
  0008b	85 c0		 test	 eax, eax
  0008d	0f 84 60 0c 00
	00		 je	 $LN90@RecvGuild

; 3310 : 				if (0 != pGuildMemberData->strName.compare(CPythonPlayer::Instance().GetName()))

  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00099	8b b5 44 ff ff
	ff		 mov	 esi, DWORD PTR _pGuildMemberData$6[ebp]
  0009f	83 c1 04	 add	 ecx, 4
  000a2	83 c6 04	 add	 esi, 4
  000a5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a7	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000aa	ff d0		 call	 eax
  000ac	50		 push	 eax
  000ad	8b ce		 mov	 ecx, esi
  000af	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  000b4	85 c0		 test	 eax, eax
  000b6	0f 84 37 0c 00
	00		 je	 $LN90@RecvGuild
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000bc	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c0	72 02		 jb	 SHORT $LN111@RecvGuild
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000c2	8b 36		 mov	 esi, DWORD PTR [esi]
$LN111@RecvGuild:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3311 : 					CPythonMessenger::Instance().LoginGuildMember(pGuildMemberData->strName.c_str());

  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  000ca	56		 push	 esi
  000cb	e8 00 00 00 00	 call	 ?LoginGuildMember@CPythonMessenger@@QAEXPBD@Z ; CPythonMessenger::LoginGuildMember

; 3312 : 
; 3313 : 			//Tracef(" <Login> %d\n", dwPID);
; 3314 : 			break;

  000d0	e9 1e 0c 00 00	 jmp	 $LN90@RecvGuild
$LN85@RecvGuild:

; 3315 : 		}
; 3316 : 		case GUILD_SUBHEADER_GC_LOGOUT:
; 3317 : 		{
; 3318 : 			DWORD dwPID;
; 3319 : 			if (!Recv(sizeof(DWORD), &dwPID))

  000d5	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _dwPID$27[ebp]
  000db	8b cf		 mov	 ecx, edi
  000dd	50		 push	 eax
  000de	6a 04		 push	 4
  000e0	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  000e5	84 c0		 test	 al, al
  000e7	0f 84 54 ff ff
	ff		 je	 $LN389@RecvGuild

; 3320 : 				return false;
; 3321 : 
; 3322 : 			// Messenger
; 3323 : 			CPythonGuild::TGuildMemberData * pGuildMemberData;
; 3324 : 			if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pGuildMemberData))

  000ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  000f3	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _pGuildMemberData$5[ebp]
  000f9	50		 push	 eax
  000fa	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwPID$27[ebp]
  00100	e8 00 00 00 00	 call	 ?GetMemberDataPtrByPID@CPythonGuild@@QAEHKPAPAUSGuildMemberData@1@@Z ; CPythonGuild::GetMemberDataPtrByPID
  00105	85 c0		 test	 eax, eax
  00107	0f 84 e6 0b 00
	00		 je	 $LN90@RecvGuild

; 3325 : 				if (0 != pGuildMemberData->strName.compare(CPythonPlayer::Instance().GetName()))

  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00113	8b b5 44 ff ff
	ff		 mov	 esi, DWORD PTR _pGuildMemberData$5[ebp]
  00119	83 c1 04	 add	 ecx, 4
  0011c	83 c6 04	 add	 esi, 4
  0011f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00121	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00124	ff d0		 call	 eax
  00126	50		 push	 eax
  00127	8b ce		 mov	 ecx, esi
  00129	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  0012e	85 c0		 test	 eax, eax
  00130	0f 84 bd 0b 00
	00		 je	 $LN90@RecvGuild
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00136	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0013a	72 02		 jb	 SHORT $LN125@RecvGuild
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0013c	8b 36		 mov	 esi, DWORD PTR [esi]
$LN125@RecvGuild:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3326 : 					CPythonMessenger::Instance().LogoutGuildMember(pGuildMemberData->strName.c_str());

  0013e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  00144	56		 push	 esi
  00145	e8 00 00 00 00	 call	 ?LogoutGuildMember@CPythonMessenger@@QAEXPBD@Z ; CPythonMessenger::LogoutGuildMember

; 3327 : 
; 3328 : 			//Tracef(" <Logout> %d\n", dwPID);
; 3329 : 			break;

  0014a	e9 a4 0b 00 00	 jmp	 $LN90@RecvGuild
$LN81@RecvGuild:

; 3330 : 		}
; 3331 : 		case GUILD_SUBHEADER_GC_REMOVE:
; 3332 : 		{
; 3333 : 			DWORD dwPID;
; 3334 : 			if (!Recv(sizeof(dwPID), &dwPID))

  0014f	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _dwPID$15[ebp]
  00155	8b cf		 mov	 ecx, edi
  00157	50		 push	 eax
  00158	6a 04		 push	 4
  0015a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0015f	84 c0		 test	 al, al
  00161	0f 84 da fe ff
	ff		 je	 $LN389@RecvGuild

; 3335 : 				return false;
; 3336 : 
; 3337 : 			// Main Player   DeleteGuild
; 3338 : 			if (CPythonGuild::Instance().IsMainPlayer(dwPID))

  00167	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwPID$15[ebp]
  0016d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00173	e8 00 00 00 00	 call	 ?IsMainPlayer@CPythonGuild@@QAEHK@Z ; CPythonGuild::IsMainPlayer
  00178	85 c0		 test	 eax, eax
  0017a	74 64		 je	 SHORT $LN79@RecvGuild

; 3339 : 			{
; 3340 : 				CPythonGuild::Instance().Destroy();

  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00182	e8 00 00 00 00	 call	 ?Destroy@CPythonGuild@@QAEXXZ ; CPythonGuild::Destroy

; 3341 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "DeleteGuild", Py_BuildValue("()"));

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00192	83 c4 04	 add	 esp, 4
  00195	50		 push	 eax
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JPGKCCFN@DeleteGuild?$AA@
  0019b	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  001a1	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 3342 : 				CPythonMessenger::Instance().RemoveAllGuildMember();

  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  001ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  001af	e8 00 00 00 00	 call	 ?RemoveAllGuildMember@CPythonMessenger@@QAEXXZ ; CPythonMessenger::RemoveAllGuildMember

; 3343 : 				__SetGuildID(0);

  001b4	6a 00		 push	 0
  001b6	8b cf		 mov	 ecx, edi
  001b8	e8 00 00 00 00	 call	 ?__SetGuildID@CPythonNetworkStream@@IAEXK@Z ; CPythonNetworkStream::__SetGuildID

; 3344 : 				__RefreshMessengerWindow();

  001bd	8b cf		 mov	 ecx, edi
  001bf	e8 00 00 00 00	 call	 ?__RefreshMessengerWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshMessengerWindow

; 3345 : 				__RefreshTargetBoard();

  001c4	e8 00 00 00 00	 call	 ?__RefreshTargetBoard@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshTargetBoard

; 3346 : 				__RefreshCharacterWindow();

  001c9	8b cf		 mov	 ecx, edi
  001cb	e8 00 00 00 00	 call	 ?__RefreshCharacterWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshCharacterWindow

; 3365 : 
; 3366 : 			Tracef(" <Remove> %d\n", dwPID);

  001d0	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwPID$15[ebp]
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@EGDOPDJO@?5?$DMRemove?$DO?5?$CFd?6?$AA@

; 3367 : 			break;

  001db	e9 0b 0b 00 00	 jmp	 $LN388@RecvGuild
$LN79@RecvGuild:

; 3347 : 			}
; 3348 : 			else
; 3349 : 			{
; 3350 : 				// Get Member Name
; 3351 : 				std::string strMemberName = "";

  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  001e5	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _strMemberName$30[ebp]
  001eb	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 3352 : 				CPythonGuild::TGuildMemberData * pData;
; 3353 : 				if (CPythonGuild::Instance().GetMemberDataPtrByPID(dwPID, &pData))

  001f0	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _pData$4[ebp]
  001f6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001fd	8b b5 4c ff ff
	ff		 mov	 esi, DWORD PTR _dwPID$15[ebp]
  00203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00209	50		 push	 eax
  0020a	56		 push	 esi
  0020b	e8 00 00 00 00	 call	 ?GetMemberDataPtrByPID@CPythonGuild@@QAEHKPAPAUSGuildMemberData@1@@Z ; CPythonGuild::GetMemberDataPtrByPID
  00210	85 c0		 test	 eax, eax
  00212	74 39		 je	 SHORT $LN77@RecvGuild

; 3355 : 					strMemberName = pData->strName;

  00214	8b b5 44 ff ff
	ff		 mov	 esi, DWORD PTR _pData$4[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 998  : 		if (this != &_Right)

  0021a	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _strMemberName$30[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3355 : 					strMemberName = pData->strName;

  00220	83 c6 04	 add	 esi, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 998  : 		if (this != &_Right)

  00223	3b c6		 cmp	 eax, esi
  00225	74 0c		 je	 SHORT $LN190@RecvGuild

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));

  00227	6a ff		 push	 -1
  00229	6a 00		 push	 0
  0022b	56		 push	 esi
  0022c	8b c8		 mov	 ecx, eax
  0022e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN190@RecvGuild:

; 520  : 			: this->_Bx._Buf);

  00233	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00237	72 02		 jb	 SHORT $LN197@RecvGuild
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00239	8b 36		 mov	 esi, DWORD PTR [esi]
$LN197@RecvGuild:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3356 : 					CPythonMessenger::Instance().RemoveGuildMember(pData->strName.c_str());

  0023b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  00241	56		 push	 esi
  00242	e8 00 00 00 00	 call	 ?RemoveGuildMember@CPythonMessenger@@QAEXPBD@Z ; CPythonMessenger::RemoveGuildMember
  00247	8b b5 4c ff ff
	ff		 mov	 esi, DWORD PTR _dwPID$15[ebp]
$LN77@RecvGuild:

; 3357 : 				}
; 3358 : 
; 3359 : 				CPythonGuild::Instance().RemoveMember(dwPID);

  0024d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00253	56		 push	 esi
  00254	e8 00 00 00 00	 call	 ?RemoveMember@CPythonGuild@@QAEXK@Z ; CPythonGuild::RemoveMember
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00259	83 7d 84 10	 cmp	 DWORD PTR _strMemberName$30[ebp+20], 16 ; 00000010H
  0025d	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _strMemberName$30[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3362 : 				__RefreshTargetBoardByName(strMemberName.c_str());

  00263	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00265	0f 43 85 70 ff
	ff ff		 cmovae	 eax, DWORD PTR _strMemberName$30[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3362 : 				__RefreshTargetBoardByName(strMemberName.c_str());

  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 ?__RefreshTargetBoardByName@CPythonNetworkStream@@IAEXPBD@Z ; CPythonNetworkStream::__RefreshTargetBoardByName

; 3363 : 				__RefreshGuildWindowMemberPage();

  00272	8b cf		 mov	 ecx, edi
  00274	e8 00 00 00 00	 call	 ?__RefreshGuildWindowMemberPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowMemberPage

; 3364 : 			}

  00279	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _strMemberName$30[ebp]
  0027f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00286	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 3365 : 
; 3366 : 			Tracef(" <Remove> %d\n", dwPID);

  0028b	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwPID$15[ebp]
  00291	68 00 00 00 00	 push	 OFFSET ??_C@_0O@EGDOPDJO@?5?$DMRemove?$DO?5?$CFd?6?$AA@

; 3367 : 			break;

  00296	e9 50 0a 00 00	 jmp	 $LN388@RecvGuild
$LN76@RecvGuild:

; 3368 : 		}
; 3369 : 		case GUILD_SUBHEADER_GC_LIST:
; 3370 : 		{
; 3371 : 			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);

  0029b	0f b7 b5 41 ff
	ff ff		 movzx	 esi, WORD PTR _GuildPacket$[ebp+1]
  002a2	83 ee 04	 sub	 esi, 4

; 3373 : 			for (; iPacketSize > 0;)

  002a5	85 f6		 test	 esi, esi
  002a7	0f 8e 6d 01 00
	00		 jle	 $LN74@RecvGuild
  002ad	8d 49 00	 npad	 3
$LL75@RecvGuild:

; 3374 : 			{
; 3375 : 				TPacketGCGuildSubMember memberPacket;
; 3376 : 				if (!Recv(sizeof(memberPacket), &memberPacket))

  002b0	8d 45 e0	 lea	 eax, DWORD PTR _memberPacket$41[ebp]
  002b3	8b cf		 mov	 ecx, edi
  002b5	50		 push	 eax
  002b6	6a 0d		 push	 13			; 0000000dH
  002b8	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  002bd	84 c0		 test	 al, al
  002bf	0f 84 7c fd ff
	ff		 je	 $LN389@RecvGuild

; 3377 : 					return false;
; 3378 : 
; 3379 : 				char szName[CHARACTER_NAME_MAX_LEN+1] = "";
; 3380 : 				if (memberPacket.byNameFlag)

  002c5	80 7d ec 00	 cmp	 BYTE PTR _memberPacket$41[ebp+12], 0
  002c9	0f 57 c0	 xorps	 xmm0, xmm0
  002cc	c6 45 90 00	 mov	 BYTE PTR _szName$33[ebp], 0
  002d0	f3 0f 7f 45 91	 movdqu	 XMMWORD PTR _szName$33[ebp+1], xmm0
  002d5	66 0f d6 45 a1	 movq	 QWORD PTR _szName$33[ebp+17], xmm0
  002da	74 1a		 je	 SHORT $LN72@RecvGuild

; 3381 : 				{
; 3382 : 					if (!Recv(sizeof(szName), &szName))

  002dc	8d 45 90	 lea	 eax, DWORD PTR _szName$33[ebp]
  002df	8b cf		 mov	 ecx, edi
  002e1	50		 push	 eax
  002e2	6a 19		 push	 25			; 00000019H
  002e4	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  002e9	84 c0		 test	 al, al
  002eb	0f 84 50 fd ff
	ff		 je	 $LN389@RecvGuild

; 3383 : 						return false;
; 3384 : 
; 3385 : 					iPacketSize -= CHARACTER_NAME_MAX_LEN+1;

  002f1	83 ee 19	 sub	 esi, 25			; 00000019H

; 3386 : 				}
; 3387 : 				else

  002f4	eb 39		 jmp	 SHORT $LN69@RecvGuild
$LN72@RecvGuild:

; 3388 : 				{
; 3389 : 					CPythonGuild::TGuildMemberData * pMemberData;
; 3390 : 					if (CPythonGuild::Instance().GetMemberDataPtrByPID(memberPacket.pid, &pMemberData))

  002f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  002fc	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _pMemberData$3[ebp]
  00302	50		 push	 eax
  00303	ff 75 e0	 push	 DWORD PTR _memberPacket$41[ebp]
  00306	e8 00 00 00 00	 call	 ?GetMemberDataPtrByPID@CPythonGuild@@QAEHKPAPAUSGuildMemberData@1@@Z ; CPythonGuild::GetMemberDataPtrByPID
  0030b	85 c0		 test	 eax, eax
  0030d	74 20		 je	 SHORT $LN69@RecvGuild

; 3392 : 						strncpy(szName, pMemberData->strName.c_str(), CHARACTER_NAME_MAX_LEN);

  0030f	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _pMemberData$3[ebp]
  00315	83 c0 04	 add	 eax, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00318	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0031c	72 02		 jb	 SHORT $LN219@RecvGuild
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0031e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN219@RecvGuild:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3392 : 						strncpy(szName, pMemberData->strName.c_str(), CHARACTER_NAME_MAX_LEN);

  00320	6a 18		 push	 24			; 00000018H
  00322	50		 push	 eax
  00323	8d 45 90	 lea	 eax, DWORD PTR _szName$33[ebp]
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 _strncpy
  0032c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN69@RecvGuild:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0032f	c7 45 d0 0f 00
	00 00		 mov	 DWORD PTR _GuildMemberData$35[ebp+24], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00336	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _GuildMemberData$35[ebp+20], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0033d	c6 45 bc 00	 mov	 BYTE PTR _GuildMemberData$35[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3398 : 				CPythonGuild::SGuildMemberData GuildMemberData;

  00341	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00348	80 7d 90 00	 cmp	 BYTE PTR _szName$33[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3399 : 				GuildMemberData.dwPID = memberPacket.pid;

  0034c	8b 45 e0	 mov	 eax, DWORD PTR _memberPacket$41[ebp]
  0034f	89 45 b8	 mov	 DWORD PTR _GuildMemberData$35[ebp], eax

; 3400 : 				GuildMemberData.byGrade = memberPacket.byGrade;

  00352	8a 45 e4	 mov	 al, BYTE PTR _memberPacket$41[ebp+4]
  00355	88 45 d4	 mov	 BYTE PTR _GuildMemberData$35[ebp+28], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00358	75 04		 jne	 SHORT $LN268@RecvGuild
  0035a	33 c9		 xor	 ecx, ecx
  0035c	eb 0f		 jmp	 SHORT $LN269@RecvGuild
$LN268@RecvGuild:
  0035e	8d 4d 90	 lea	 ecx, DWORD PTR _szName$33[ebp]
  00361	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL382@RecvGuild:
  00364	8a 01		 mov	 al, BYTE PTR [ecx]
  00366	41		 inc	 ecx
  00367	84 c0		 test	 al, al
  00369	75 f9		 jne	 SHORT $LL382@RecvGuild
  0036b	2b ca		 sub	 ecx, edx
$LN269@RecvGuild:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0036d	51		 push	 ecx
  0036e	8d 45 90	 lea	 eax, DWORD PTR _szName$33[ebp]
  00371	50		 push	 eax
  00372	8d 4d bc	 lea	 ecx, DWORD PTR _GuildMemberData$35[ebp+4]
  00375	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3402 : 				GuildMemberData.byJob = memberPacket.byJob;

  0037a	8a 45 e6	 mov	 al, BYTE PTR _memberPacket$41[ebp+6]

; 3403 : 				GuildMemberData.byLevel = memberPacket.byLevel;
; 3404 : 				GuildMemberData.dwOffer = memberPacket.dwOffer;
; 3405 : 				GuildMemberData.byGeneralFlag = memberPacket.byIsGeneral;
; 3406 : 				CPythonGuild::Instance().RegisterMember(GuildMemberData);

  0037d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00383	88 45 d5	 mov	 BYTE PTR _GuildMemberData$35[ebp+29], al
  00386	8a 45 e7	 mov	 al, BYTE PTR _memberPacket$41[ebp+7]
  00389	88 45 d6	 mov	 BYTE PTR _GuildMemberData$35[ebp+30], al
  0038c	8b 45 e8	 mov	 eax, DWORD PTR _memberPacket$41[ebp+8]
  0038f	89 45 d8	 mov	 DWORD PTR _GuildMemberData$35[ebp+32], eax
  00392	8a 45 e5	 mov	 al, BYTE PTR _memberPacket$41[ebp+5]
  00395	88 45 d7	 mov	 BYTE PTR _GuildMemberData$35[ebp+31], al
  00398	8d 45 b8	 lea	 eax, DWORD PTR _GuildMemberData$35[ebp]
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 ?RegisterMember@CPythonGuild@@QAEXAAUSGuildMemberData@1@@Z ; CPythonGuild::RegisterMember

; 3407 : 
; 3408 : 				// Messenger
; 3409 : 				if (strcmp(szName, CPythonPlayer::Instance().GetName()))

  003a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  003a7	83 c1 04	 add	 ecx, 4
  003aa	8b 01		 mov	 eax, DWORD PTR [ecx]
  003ac	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  003af	ff d0		 call	 eax
  003b1	8d 4d 90	 lea	 ecx, DWORD PTR _szName$33[ebp]
$LL383@RecvGuild:
  003b4	8a 11		 mov	 dl, BYTE PTR [ecx]
  003b6	3a 10		 cmp	 dl, BYTE PTR [eax]
  003b8	75 1a		 jne	 SHORT $LN384@RecvGuild
  003ba	84 d2		 test	 dl, dl
  003bc	74 12		 je	 SHORT $LN385@RecvGuild
  003be	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  003c1	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  003c4	75 0e		 jne	 SHORT $LN384@RecvGuild
  003c6	83 c1 02	 add	 ecx, 2
  003c9	83 c0 02	 add	 eax, 2
  003cc	84 d2		 test	 dl, dl
  003ce	75 e4		 jne	 SHORT $LL383@RecvGuild
$LN385@RecvGuild:
  003d0	33 c0		 xor	 eax, eax
  003d2	eb 05		 jmp	 SHORT $LN386@RecvGuild
$LN384@RecvGuild:
  003d4	1b c0		 sbb	 eax, eax
  003d6	83 c8 01	 or	 eax, 1
$LN386@RecvGuild:
  003d9	85 c0		 test	 eax, eax
  003db	74 0f		 je	 SHORT $LN68@RecvGuild

; 3410 : 					CPythonMessenger::Instance().AppendGuildMember(szName);

  003dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMessenger@@@@0PAVCPythonMessenger@@A ; CSingleton<CPythonMessenger>::ms_singleton
  003e3	8d 45 90	 lea	 eax, DWORD PTR _szName$33[ebp]
  003e6	50		 push	 eax
  003e7	e8 00 00 00 00	 call	 ?AppendGuildMember@CPythonMessenger@@QAEXPBD@Z ; CPythonMessenger::AppendGuildMember
$LN68@RecvGuild:

; 3411 : 
; 3412 : 				__RefreshTargetBoardByName(szName);

  003ec	8d 45 90	 lea	 eax, DWORD PTR _szName$33[ebp]
  003ef	8b cf		 mov	 ecx, edi
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 ?__RefreshTargetBoardByName@CPythonNetworkStream@@IAEXPBD@Z ; CPythonNetworkStream::__RefreshTargetBoardByName

; 3413 : 
; 3414 : 				iPacketSize -= sizeof(memberPacket);

  003f7	83 ee 0d	 sub	 esi, 13			; 0000000dH

; 3415 : 			}

  003fa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00401	83 7d d0 10	 cmp	 DWORD PTR _GuildMemberData$35[ebp+24], 16 ; 00000010H
  00405	72 0b		 jb	 SHORT $LN298@RecvGuild
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00407	ff 75 bc	 push	 DWORD PTR _GuildMemberData$35[ebp+4]
  0040a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0040f	83 c4 04	 add	 esp, 4
$LN298@RecvGuild:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3373 : 			for (; iPacketSize > 0;)

  00412	85 f6		 test	 esi, esi
  00414	0f 8f 96 fe ff
	ff		 jg	 $LL75@RecvGuild
$LN74@RecvGuild:

; 3416 : 
; 3417 : 			__RefreshGuildWindowInfoPage();

  0041a	8b cf		 mov	 ecx, edi
  0041c	e8 00 00 00 00	 call	 ?__RefreshGuildWindowInfoPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowInfoPage

; 3418 : 			__RefreshGuildWindowMemberPage();

  00421	e8 00 00 00 00	 call	 ?__RefreshGuildWindowMemberPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowMemberPage

; 3419 : 			__RefreshMessengerWindow();

  00426	e8 00 00 00 00	 call	 ?__RefreshMessengerWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshMessengerWindow

; 3420 : 			__RefreshCharacterWindow();

  0042b	e8 00 00 00 00	 call	 ?__RefreshCharacterWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshCharacterWindow

; 3421 : 			break;

  00430	e9 be 08 00 00	 jmp	 $LN90@RecvGuild
$LN67@RecvGuild:

; 3422 : 		}
; 3423 : 		case GUILD_SUBHEADER_GC_GRADE:
; 3424 : 		{
; 3425 : 			BYTE byCount;
; 3426 : 			if (!Recv(sizeof(byCount), &byCount))

  00435	8d 85 4a ff ff
	ff		 lea	 eax, DWORD PTR _byCount$7[ebp]
  0043b	8b cf		 mov	 ecx, edi
  0043d	50		 push	 eax
  0043e	6a 01		 push	 1
  00440	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00445	84 c0		 test	 al, al
  00447	0f 84 f4 fb ff
	ff		 je	 $LN389@RecvGuild

; 3427 : 				return false;
; 3428 : 
; 3429 : 			for (BYTE i = 0; i < byCount; ++ i)

  0044d	80 bd 4a ff ff
	ff 00		 cmp	 BYTE PTR _byCount$7[ebp], 0
  00454	c6 85 4b ff ff
	ff 00		 mov	 BYTE PTR _i$1$[ebp], 0
  0045b	0f 86 80 00 00
	00		 jbe	 $LN63@RecvGuild
$LL65@RecvGuild:

; 3430 : 			{
; 3431 : 				BYTE byIndex;
; 3432 : 				if (!Recv(sizeof(byCount), &byIndex))

  00461	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _byIndex$20[ebp]
  00467	8b cf		 mov	 ecx, edi
  00469	50		 push	 eax
  0046a	6a 01		 push	 1
  0046c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00471	84 c0		 test	 al, al
  00473	0f 84 c8 fb ff
	ff		 je	 $LN389@RecvGuild

; 3433 : 					return false;
; 3434 : 				TPacketGCGuildSubGrade GradePacket;
; 3435 : 				if (!Recv(sizeof(GradePacket), &GradePacket))

  00479	8d 45 e0	 lea	 eax, DWORD PTR _GradePacket$36[ebp]
  0047c	8b cf		 mov	 ecx, edi
  0047e	50		 push	 eax
  0047f	6a 0a		 push	 10			; 0000000aH
  00481	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00486	84 c0		 test	 al, al
  00488	0f 84 b3 fb ff
	ff		 je	 $LN389@RecvGuild

; 3436 : 					return false;
; 3437 : 
; 3438 : 				CPythonGuild::Instance().SetGradeData(byIndex, CPythonGuild::SGuildGradeData(GradePacket.auth_flag, GradePacket.grade_name));

  0048e	8d 45 e0	 lea	 eax, DWORD PTR _GradePacket$36[ebp]
  00491	50		 push	 eax
  00492	ff 75 e9	 push	 DWORD PTR _GradePacket$36[ebp+9]
  00495	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  0049b	e8 00 00 00 00	 call	 ??0SGuildGradeData@CPythonGuild@@QAE@EPBD@Z ; CPythonGuild::SGuildGradeData::SGuildGradeData
  004a0	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  004a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  004ad	50		 push	 eax
  004ae	ff b5 50 ff ff
	ff		 push	 DWORD PTR _byIndex$20[ebp]
  004b4	e8 00 00 00 00	 call	 ?SetGradeData@CPythonGuild@@QAEXEAAUSGuildGradeData@1@@Z ; CPythonGuild::SetGradeData
  004b9	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  004bf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004c6	e8 00 00 00 00	 call	 ??1SGuildGradeData@CPythonGuild@@QAE@XZ
  004cb	8a 85 4b ff ff
	ff		 mov	 al, BYTE PTR _i$1$[ebp]
  004d1	fe c0		 inc	 al
  004d3	88 85 4b ff ff
	ff		 mov	 BYTE PTR _i$1$[ebp], al
  004d9	3a 85 4a ff ff
	ff		 cmp	 al, BYTE PTR _byCount$7[ebp]
  004df	72 80		 jb	 SHORT $LL65@RecvGuild
$LN63@RecvGuild:

; 3439 : 				//Tracef(" <Grade> [%d/%d] : %s, %d\n", byIndex, byCount, GradePacket.grade_name, GradePacket.auth_flag);
; 3440 : 			}
; 3441 : 			__RefreshGuildWindowGradePage();

  004e1	8b cf		 mov	 ecx, edi
  004e3	e8 00 00 00 00	 call	 ?__RefreshGuildWindowGradePage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowGradePage

; 3442 : 			__RefreshGuildWindowMemberPageGradeComboBox();

  004e8	e8 00 00 00 00	 call	 ?__RefreshGuildWindowMemberPageGradeComboBox@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowMemberPageGradeComboBox

; 3443 : 			break;

  004ed	e9 01 08 00 00	 jmp	 $LN90@RecvGuild
$LN60@RecvGuild:

; 3444 : 		}
; 3445 : 		case GUILD_SUBHEADER_GC_GRADE_NAME:
; 3446 : 		{
; 3447 : 			BYTE byGradeNumber;
; 3448 : 			if (!Recv(sizeof(byGradeNumber), &byGradeNumber))

  004f2	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _byGradeNumber$19[ebp]
  004f8	8b cf		 mov	 ecx, edi
  004fa	50		 push	 eax
  004fb	6a 01		 push	 1
  004fd	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00502	84 c0		 test	 al, al
  00504	0f 84 37 fb ff
	ff		 je	 $LN389@RecvGuild

; 3449 : 				return false;
; 3450 : 
; 3451 : 			char szGradeName[GUILD_GRADE_NAME_MAX_LEN+1] = "";
; 3452 : 			if (!Recv(sizeof(szGradeName), &szGradeName))

  0050a	8d 45 e4	 lea	 eax, DWORD PTR _szGradeName$42[ebp]
  0050d	c6 45 e4 00	 mov	 BYTE PTR _szGradeName$42[ebp], 0
  00511	50		 push	 eax
  00512	0f 57 c0	 xorps	 xmm0, xmm0
  00515	8b cf		 mov	 ecx, edi
  00517	6a 09		 push	 9
  00519	66 0f d6 45 e5	 movq	 QWORD PTR _szGradeName$42[ebp+1], xmm0
  0051e	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00523	84 c0		 test	 al, al
  00525	0f 84 16 fb ff
	ff		 je	 $LN389@RecvGuild

; 3453 : 				return false;
; 3454 : 
; 3455 : 			CPythonGuild::Instance().SetGradeName(byGradeNumber, szGradeName);

  0052b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00531	8d 45 e4	 lea	 eax, DWORD PTR _szGradeName$42[ebp]
  00534	50		 push	 eax
  00535	ff b5 50 ff ff
	ff		 push	 DWORD PTR _byGradeNumber$19[ebp]
  0053b	e8 00 00 00 00	 call	 ?SetGradeName@CPythonGuild@@QAEXEPBD@Z ; CPythonGuild::SetGradeName

; 3456 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGrade", Py_BuildValue("()"));

  00540	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00545	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0054b	83 c4 04	 add	 esp, 4
  0054e	50		 push	 eax
  0054f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MJKOOFCD@RefreshGuildGrade?$AA@
  00554	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  0055a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0055f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3457 : 
; 3458 : 			Tracef(" <Change Grade Name> %d, %s\n", byGradeNumber, szGradeName);

  00562	8d 45 e4	 lea	 eax, DWORD PTR _szGradeName$42[ebp]
  00565	50		 push	 eax
  00566	0f b6 85 50 ff
	ff ff		 movzx	 eax, BYTE PTR _byGradeNumber$19[ebp]
  0056d	50		 push	 eax
  0056e	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JFJPHNLH@?5?$DMChange?5Grade?5Name?$DO?5?$CFd?0?5?$CFs?6?$AA@
  00573	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00578	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3459 : 			__RefreshGuildWindowGradePage();

  0057b	8b cf		 mov	 ecx, edi
  0057d	e8 00 00 00 00	 call	 ?__RefreshGuildWindowGradePage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowGradePage

; 3460 : 			__RefreshGuildWindowMemberPageGradeComboBox();

  00582	e8 00 00 00 00	 call	 ?__RefreshGuildWindowMemberPageGradeComboBox@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowMemberPageGradeComboBox

; 3461 : 			break;

  00587	e9 67 07 00 00	 jmp	 $LN90@RecvGuild
$LN57@RecvGuild:

; 3462 : 		}
; 3463 : 		case GUILD_SUBHEADER_GC_GRADE_AUTH:
; 3464 : 		{
; 3465 : 			BYTE byGradeNumber;
; 3466 : 			if (!Recv(sizeof(byGradeNumber), &byGradeNumber))

  0058c	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _byGradeNumber$10[ebp]
  00592	8b cf		 mov	 ecx, edi
  00594	50		 push	 eax
  00595	6a 01		 push	 1
  00597	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0059c	84 c0		 test	 al, al
  0059e	0f 84 9d fa ff
	ff		 je	 $LN389@RecvGuild

; 3467 : 				return false;
; 3468 : 			BYTE byAuthorityFlag;
; 3469 : 			if (!Recv(sizeof(byAuthorityFlag), &byAuthorityFlag))

  005a4	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _byAuthorityFlag$18[ebp]
  005aa	8b cf		 mov	 ecx, edi
  005ac	50		 push	 eax
  005ad	6a 01		 push	 1
  005af	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  005b4	84 c0		 test	 al, al
  005b6	0f 84 85 fa ff
	ff		 je	 $LN389@RecvGuild

; 3470 : 				return false;
; 3471 : 
; 3472 : 			CPythonGuild::Instance().SetGradeAuthority(byGradeNumber, byAuthorityFlag);

  005bc	ff b5 50 ff ff
	ff		 push	 DWORD PTR _byAuthorityFlag$18[ebp]
  005c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  005c8	ff b5 4c ff ff
	ff		 push	 DWORD PTR _byGradeNumber$10[ebp]
  005ce	e8 00 00 00 00	 call	 ?SetGradeAuthority@CPythonGuild@@QAEXEE@Z ; CPythonGuild::SetGradeAuthority

; 3473 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshGuildGrade", Py_BuildValue("()"));

  005d3	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  005d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  005de	83 c4 04	 add	 esp, 4
  005e1	50		 push	 eax
  005e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MJKOOFCD@RefreshGuildGrade?$AA@
  005e7	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  005ed	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 3474 : 
; 3475 : 			Tracef(" <Change Grade Authority> %d, %d\n", byGradeNumber, byAuthorityFlag);

  005f2	0f b6 85 50 ff
	ff ff		 movzx	 eax, BYTE PTR _byAuthorityFlag$18[ebp]
  005f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  005fc	50		 push	 eax
  005fd	0f b6 85 4c ff
	ff ff		 movzx	 eax, BYTE PTR _byGradeNumber$10[ebp]
  00604	50		 push	 eax
  00605	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KDHBOMAA@?5?$DMChange?5Grade?5Authority?$DO?5?$CFd?0?5?$CFd@
  0060a	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0060f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3476 : 			__RefreshGuildWindowGradePage();

  00612	8b cf		 mov	 ecx, edi
  00614	e8 00 00 00 00	 call	 ?__RefreshGuildWindowGradePage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowGradePage

; 3477 : 			break;

  00619	e9 d5 06 00 00	 jmp	 $LN90@RecvGuild
$LN54@RecvGuild:

; 3478 : 		}
; 3479 : 		case GUILD_SUBHEADER_GC_INFO:
; 3480 : 		{
; 3481 : 			TPacketGCGuildInfo GuildInfo;
; 3482 : 			if (!Recv(sizeof(GuildInfo), &GuildInfo))

  0061e	8d 45 88	 lea	 eax, DWORD PTR _GuildInfo$31[ebp]
  00621	8b cf		 mov	 ecx, edi
  00623	50		 push	 eax
  00624	6a 23		 push	 35			; 00000023H
  00626	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0062b	84 c0		 test	 al, al
  0062d	0f 84 0e fa ff
	ff		 je	 $LN389@RecvGuild

; 3483 : 				return false;
; 3484 : 
; 3485 : 			CPythonGuild::Instance().EnableGuild();

  00633	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00639	e8 00 00 00 00	 call	 ?EnableGuild@CPythonGuild@@QAEXXZ ; CPythonGuild::EnableGuild

; 3486 : 			CPythonGuild::TGuildInfo & rGuildInfo = CPythonGuild::Instance().GetGuildInfoRef();

  0063e	e8 00 00 00 00	 call	 ?GetGuildInfoRef@CPythonGuild@@QAEAAUSGulidInfo@1@XZ ; CPythonGuild::GetGuildInfoRef
  00643	8b f0		 mov	 esi, eax

; 3487 : 			strncpy(rGuildInfo.szGuildName, GuildInfo.name, GUILD_NAME_MAX_LEN);

  00645	8d 45 99	 lea	 eax, DWORD PTR _GuildInfo$31[ebp+17]
  00648	6a 0c		 push	 12			; 0000000cH
  0064a	50		 push	 eax
  0064b	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0064e	51		 push	 ecx
  0064f	e8 00 00 00 00	 call	 _strncpy

; 3488 : 			rGuildInfo.szGuildName[GUILD_NAME_MAX_LEN] = '\0';

  00654	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  00658	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3489 : 
; 3490 : 			rGuildInfo.dwGuildID = GuildInfo.guild_id;

  0065b	8b 4d 8c	 mov	 ecx, DWORD PTR _GuildInfo$31[ebp+4]
  0065e	89 0e		 mov	 DWORD PTR [esi], ecx

; 3491 : 			rGuildInfo.dwMasterPID = GuildInfo.master_pid;
; 3492 : 			rGuildInfo.dwGuildLevel = GuildInfo.level;
; 3493 : 			rGuildInfo.dwCurrentExperience = GuildInfo.exp;
; 3494 : 			rGuildInfo.dwCurrentMemberCount = GuildInfo.member_count;
; 3495 : 			rGuildInfo.dwMaxMemberCount = GuildInfo.max_member_count;
; 3496 : 			rGuildInfo.dwGuildMoney = GuildInfo.gold;
; 3497 : 			rGuildInfo.bHasLand = GuildInfo.hasLand;
; 3498 : 
; 3499 : 			//Tracef(" <Info> %s, %d, %d : %d\n", GuildInfo.name, GuildInfo.master_pid, GuildInfo.level, rGuildInfo.bHasLand);
; 3500 : 			__RefreshGuildWindowInfoPage();

  00660	8b cf		 mov	 ecx, edi
  00662	8b 45 90	 mov	 eax, DWORD PTR _GuildInfo$31[ebp+8]
  00665	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00668	0f b6 45 98	 movzx	 eax, BYTE PTR _GuildInfo$31[ebp+16]
  0066c	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0066f	8b 45 94	 mov	 eax, DWORD PTR _GuildInfo$31[ebp+12]
  00672	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00675	0f b7 45 88	 movzx	 eax, WORD PTR _GuildInfo$31[ebp]
  00679	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0067c	0f b7 45 8a	 movzx	 eax, WORD PTR _GuildInfo$31[ebp+2]
  00680	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00683	8b 45 a6	 mov	 eax, DWORD PTR _GuildInfo$31[ebp+30]
  00686	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00689	0f b6 45 aa	 movzx	 eax, BYTE PTR _GuildInfo$31[ebp+34]
  0068d	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00690	e8 00 00 00 00	 call	 ?__RefreshGuildWindowInfoPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowInfoPage

; 3501 : 			break;

  00695	e9 59 06 00 00	 jmp	 $LN90@RecvGuild
$LN52@RecvGuild:

; 3502 : 		}
; 3503 : 		case GUILD_SUBHEADER_GC_COMMENTS:
; 3504 : 		{
; 3505 : 			BYTE byCount;
; 3506 : 			if (!Recv(sizeof(byCount), &byCount))

  0069a	8d 85 4b ff ff
	ff		 lea	 eax, DWORD PTR _byCount$8[ebp]
  006a0	8b cf		 mov	 ecx, edi
  006a2	50		 push	 eax
  006a3	6a 01		 push	 1
  006a5	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  006aa	84 c0		 test	 al, al
  006ac	0f 84 8f f9 ff
	ff		 je	 $LN389@RecvGuild

; 3507 : 				return false;
; 3508 : 
; 3509 : 			CPythonGuild::Instance().ClearComment();

  006b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  006b8	e8 00 00 00 00	 call	 ?ClearComment@CPythonGuild@@QAEXXZ ; CPythonGuild::ClearComment

; 3510 : 			//Tracef(" >>> Comments Count : %d\n", byCount);
; 3511 : 
; 3512 : 			for (BYTE i = 0; i < byCount; ++i)

  006bd	80 bd 4b ff ff
	ff 00		 cmp	 BYTE PTR _byCount$8[ebp], 0
  006c4	c6 85 4a ff ff
	ff 00		 mov	 BYTE PTR _i$1$[ebp], 0
  006cb	0f 86 9a 00 00
	00		 jbe	 $LN48@RecvGuild
$LL50@RecvGuild:

; 3513 : 			{
; 3514 : 				DWORD dwCommentID;
; 3515 : 				if (!Recv(sizeof(dwCommentID), &dwCommentID))

  006d1	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _dwCommentID$26[ebp]
  006d7	8b cf		 mov	 ecx, edi
  006d9	50		 push	 eax
  006da	6a 04		 push	 4
  006dc	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  006e1	84 c0		 test	 al, al
  006e3	0f 84 58 f9 ff
	ff		 je	 $LN389@RecvGuild

; 3516 : 					return false;
; 3517 : 
; 3518 : 				char szName[CHARACTER_NAME_MAX_LEN+1] = "";
; 3519 : 				if (!Recv(sizeof(szName), &szName))

  006e9	8d 45 90	 lea	 eax, DWORD PTR _szName$32[ebp]
  006ec	c6 45 90 00	 mov	 BYTE PTR _szName$32[ebp], 0
  006f0	0f 57 c0	 xorps	 xmm0, xmm0
  006f3	8b cf		 mov	 ecx, edi
  006f5	50		 push	 eax
  006f6	6a 19		 push	 25			; 00000019H
  006f8	f3 0f 7f 45 91	 movdqu	 XMMWORD PTR _szName$32[ebp+1], xmm0
  006fd	66 0f d6 45 a1	 movq	 QWORD PTR _szName$32[ebp+17], xmm0
  00702	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00707	84 c0		 test	 al, al
  00709	0f 84 32 f9 ff
	ff		 je	 $LN389@RecvGuild

; 3520 : 					return false;
; 3521 : 
; 3522 : 				char szComment[GULID_COMMENT_MAX_LEN+1] = "";

  0070f	6a 32		 push	 50			; 00000032H
  00711	8d 45 ad	 lea	 eax, DWORD PTR _szComment$34[ebp+1]
  00714	c6 45 ac 00	 mov	 BYTE PTR _szComment$34[ebp], 0
  00718	6a 00		 push	 0
  0071a	50		 push	 eax
  0071b	e8 00 00 00 00	 call	 _memset
  00720	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3523 : 				if (!Recv(sizeof(szComment), &szComment))

  00723	8d 45 ac	 lea	 eax, DWORD PTR _szComment$34[ebp]
  00726	8b cf		 mov	 ecx, edi
  00728	50		 push	 eax
  00729	6a 33		 push	 51			; 00000033H
  0072b	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00730	84 c0		 test	 al, al
  00732	0f 84 09 f9 ff
	ff		 je	 $LN389@RecvGuild

; 3524 : 					return false;
; 3525 : 
; 3526 : 				//Tracef(" [Comment-%d] : %s, %s\n", dwCommentID, szName, szComment);
; 3527 : 				CPythonGuild::Instance().RegisterComment(dwCommentID, szName, szComment);

  00738	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  0073e	8d 45 ac	 lea	 eax, DWORD PTR _szComment$34[ebp]
  00741	50		 push	 eax
  00742	8d 45 90	 lea	 eax, DWORD PTR _szName$32[ebp]
  00745	50		 push	 eax
  00746	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwCommentID$26[ebp]
  0074c	e8 00 00 00 00	 call	 ?RegisterComment@CPythonGuild@@QAEXKPBD0@Z ; CPythonGuild::RegisterComment
  00751	8a 85 4a ff ff
	ff		 mov	 al, BYTE PTR _i$1$[ebp]
  00757	fe c0		 inc	 al
  00759	88 85 4a ff ff
	ff		 mov	 BYTE PTR _i$1$[ebp], al
  0075f	3a 85 4b ff ff
	ff		 cmp	 al, BYTE PTR _byCount$8[ebp]
  00765	0f 82 66 ff ff
	ff		 jb	 $LL50@RecvGuild
$LN48@RecvGuild:

; 3528 : 			}
; 3529 : 
; 3530 : 			__RefreshGuildWindowBoardPage();

  0076b	8b cf		 mov	 ecx, edi
  0076d	e8 00 00 00 00	 call	 ?__RefreshGuildWindowBoardPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowBoardPage

; 3531 : 			break;

  00772	e9 7c 05 00 00	 jmp	 $LN90@RecvGuild
$LN44@RecvGuild:

; 3532 : 		}
; 3533 : 		case GUILD_SUBHEADER_GC_CHANGE_EXP:
; 3534 : 		{
; 3535 : 			BYTE byLevel;
; 3536 : 			if (!Recv(sizeof(byLevel), &byLevel))

  00777	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _byLevel$9[ebp]
  0077d	8b cf		 mov	 ecx, edi
  0077f	50		 push	 eax
  00780	6a 01		 push	 1
  00782	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00787	84 c0		 test	 al, al
  00789	0f 84 b2 f8 ff
	ff		 je	 $LN389@RecvGuild

; 3537 : 				return false;
; 3538 : 			DWORD dwEXP;
; 3539 : 			if (!Recv(sizeof(dwEXP), &dwEXP))

  0078f	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _dwEXP$25[ebp]
  00795	8b cf		 mov	 ecx, edi
  00797	50		 push	 eax
  00798	6a 04		 push	 4
  0079a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0079f	84 c0		 test	 al, al
  007a1	0f 84 9a f8 ff
	ff		 je	 $LN389@RecvGuild

; 3540 : 				return false;
; 3541 : 			CPythonGuild::Instance().SetGuildEXP(byLevel, dwEXP);

  007a7	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwEXP$25[ebp]
  007ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  007b3	ff b5 4c ff ff
	ff		 push	 DWORD PTR _byLevel$9[ebp]
  007b9	e8 00 00 00 00	 call	 ?SetGuildEXP@CPythonGuild@@QAEXEK@Z ; CPythonGuild::SetGuildEXP

; 3542 : 			Tracef(" <ChangeEXP> %d, %d\n", byLevel, dwEXP);

  007be	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwEXP$25[ebp]
  007c4	0f b6 85 4c ff
	ff ff		 movzx	 eax, BYTE PTR _byLevel$9[ebp]
  007cb	50		 push	 eax
  007cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GJIHEANJ@?5?$DMChangeEXP?$DO?5?$CFd?0?5?$CFd?6?$AA@
  007d1	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  007d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3543 : 			__RefreshGuildWindowInfoPage();

  007d9	8b cf		 mov	 ecx, edi
  007db	e8 00 00 00 00	 call	 ?__RefreshGuildWindowInfoPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowInfoPage

; 3544 : 			break;

  007e0	e9 0e 05 00 00	 jmp	 $LN90@RecvGuild
$LN41@RecvGuild:

; 3545 : 		}
; 3546 : 		case GUILD_SUBHEADER_GC_CHANGE_MEMBER_GRADE:
; 3547 : 		{
; 3548 : 			DWORD dwPID;
; 3549 : 			if (!Recv(sizeof(dwPID), &dwPID))

  007e5	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _dwPID$14[ebp]
  007eb	8b cf		 mov	 ecx, edi
  007ed	50		 push	 eax
  007ee	6a 04		 push	 4
  007f0	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  007f5	84 c0		 test	 al, al
  007f7	0f 84 44 f8 ff
	ff		 je	 $LN389@RecvGuild

; 3550 : 				return false;
; 3551 : 			BYTE byGrade;
; 3552 : 			if (!Recv(sizeof(byGrade), &byGrade))

  007fd	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _byGrade$17[ebp]
  00803	8b cf		 mov	 ecx, edi
  00805	50		 push	 eax
  00806	6a 01		 push	 1
  00808	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0080d	84 c0		 test	 al, al
  0080f	0f 84 2c f8 ff
	ff		 je	 $LN389@RecvGuild

; 3553 : 				return false;
; 3554 : 			CPythonGuild::Instance().ChangeGuildMemberGrade(dwPID, byGrade);

  00815	ff b5 50 ff ff
	ff		 push	 DWORD PTR _byGrade$17[ebp]
  0081b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00821	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwPID$14[ebp]
  00827	e8 00 00 00 00	 call	 ?ChangeGuildMemberGrade@CPythonGuild@@QAEXKE@Z ; CPythonGuild::ChangeGuildMemberGrade

; 3555 : 			Tracef(" <ChangeMemberGrade> %d, %d\n", dwPID, byGrade);

  0082c	0f b6 85 50 ff
	ff ff		 movzx	 eax, BYTE PTR _byGrade$17[ebp]
  00833	50		 push	 eax
  00834	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwPID$14[ebp]
  0083a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HEKKNAEA@?5?$DMChangeMemberGrade?$DO?5?$CFd?0?5?$CFd?6?$AA@
  0083f	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00844	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3556 : 			__RefreshGuildWindowMemberPage();

  00847	8b cf		 mov	 ecx, edi
  00849	e8 00 00 00 00	 call	 ?__RefreshGuildWindowMemberPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowMemberPage

; 3557 : 			break;

  0084e	e9 a0 04 00 00	 jmp	 $LN90@RecvGuild
$LN38@RecvGuild:

; 3558 : 		}
; 3559 : 		case GUILD_SUBHEADER_GC_SKILL_INFO:
; 3560 : 		{
; 3561 : 			CPythonGuild::TGuildSkillData & rSkillData = CPythonGuild::Instance().GetGuildSkillDataRef();

  00853	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00859	e8 00 00 00 00	 call	 ?GetGuildSkillDataRef@CPythonGuild@@QAEAAUSGuildSkillData@1@XZ ; CPythonGuild::GetGuildSkillDataRef
  0085e	8b f0		 mov	 esi, eax

; 3562 : 			if (!Recv(sizeof(rSkillData.bySkillPoint), &rSkillData.bySkillPoint))

  00860	8b cf		 mov	 ecx, edi
  00862	56		 push	 esi
  00863	6a 01		 push	 1
  00865	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0086a	84 c0		 test	 al, al
  0086c	0f 84 cf f7 ff
	ff		 je	 $LN389@RecvGuild

; 3563 : 				return false;
; 3564 : 			if (!Recv(sizeof(rSkillData.bySkillLevel), rSkillData.bySkillLevel))

  00872	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00875	8b cf		 mov	 ecx, edi
  00877	50		 push	 eax
  00878	6a 0c		 push	 12			; 0000000cH
  0087a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0087f	84 c0		 test	 al, al
  00881	0f 84 ba f7 ff
	ff		 je	 $LN389@RecvGuild

; 3565 : 				return false;
; 3566 : 			if (!Recv(sizeof(rSkillData.wGuildPoint), &rSkillData.wGuildPoint))

  00887	8d 46 0e	 lea	 eax, DWORD PTR [esi+14]
  0088a	8b cf		 mov	 ecx, edi
  0088c	50		 push	 eax
  0088d	6a 02		 push	 2
  0088f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00894	84 c0		 test	 al, al
  00896	0f 84 a5 f7 ff
	ff		 je	 $LN389@RecvGuild

; 3567 : 				return false;
; 3568 : 			if (!Recv(sizeof(rSkillData.wMaxGuildPoint), &rSkillData.wMaxGuildPoint))

  0089c	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0089f	8b cf		 mov	 ecx, edi
  008a1	50		 push	 eax
  008a2	6a 02		 push	 2
  008a4	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  008a9	84 c0		 test	 al, al
  008ab	0f 84 90 f7 ff
	ff		 je	 $LN389@RecvGuild

; 3569 : 				return false;
; 3570 : 
; 3571 : 			Tracef(" <SkillInfo> %d / %d, %d\n", rSkillData.bySkillPoint, rSkillData.wGuildPoint, rSkillData.wMaxGuildPoint);

  008b1	0f b7 46 10	 movzx	 eax, WORD PTR [esi+16]
  008b5	50		 push	 eax
  008b6	0f b7 46 0e	 movzx	 eax, WORD PTR [esi+14]
  008ba	50		 push	 eax
  008bb	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  008be	50		 push	 eax
  008bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FEHNPJOD@?5?$DMSkillInfo?$DO?5?$CFd?5?1?5?$CFd?0?5?$CFd?6?$AA@
  008c4	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  008c9	83 c4 10	 add	 esp, 16			; 00000010H

; 3572 : 			__RefreshGuildWindowSkillPage();

  008cc	8b cf		 mov	 ecx, edi
  008ce	e8 00 00 00 00	 call	 ?__RefreshGuildWindowSkillPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowSkillPage

; 3573 : 			break;

  008d3	e9 1b 04 00 00	 jmp	 $LN90@RecvGuild
$LN33@RecvGuild:

; 3574 : 		}
; 3575 : 		case GUILD_SUBHEADER_GC_CHANGE_MEMBER_GENERAL:
; 3576 : 		{
; 3577 : 			DWORD dwPID;
; 3578 : 			if (!Recv(sizeof(dwPID), &dwPID))

  008d8	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _dwPID$13[ebp]
  008de	8b cf		 mov	 ecx, edi
  008e0	50		 push	 eax
  008e1	6a 04		 push	 4
  008e3	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  008e8	84 c0		 test	 al, al
  008ea	0f 84 51 f7 ff
	ff		 je	 $LN389@RecvGuild

; 3579 : 				return false;
; 3580 : 			BYTE byFlag;
; 3581 : 			if (!Recv(sizeof(byFlag), &byFlag))

  008f0	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _byFlag$16[ebp]
  008f6	8b cf		 mov	 ecx, edi
  008f8	50		 push	 eax
  008f9	6a 01		 push	 1
  008fb	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00900	84 c0		 test	 al, al
  00902	0f 84 39 f7 ff
	ff		 je	 $LN389@RecvGuild

; 3582 : 				return false;
; 3583 : 
; 3584 : 			CPythonGuild::Instance().ChangeGuildMemberGeneralFlag(dwPID, byFlag);

  00908	ff b5 50 ff ff
	ff		 push	 DWORD PTR _byFlag$16[ebp]
  0090e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00914	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwPID$13[ebp]
  0091a	e8 00 00 00 00	 call	 ?ChangeGuildMemberGeneralFlag@CPythonGuild@@QAEXKE@Z ; CPythonGuild::ChangeGuildMemberGeneralFlag

; 3585 : 			Tracef(" <ChangeMemberGeneralFlag> %d, %d\n", dwPID, byFlag);

  0091f	0f b6 85 50 ff
	ff ff		 movzx	 eax, BYTE PTR _byFlag$16[ebp]
  00926	50		 push	 eax
  00927	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwPID$13[ebp]
  0092d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@MPFPDEHG@?5?$DMChangeMemberGeneralFlag?$DO?5?$CFd?0?5?$CF@
  00932	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00937	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3586 : 			__RefreshGuildWindowMemberPage();

  0093a	8b cf		 mov	 ecx, edi
  0093c	e8 00 00 00 00	 call	 ?__RefreshGuildWindowMemberPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowMemberPage

; 3587 : 			break;

  00941	e9 ad 03 00 00	 jmp	 $LN90@RecvGuild
$LN30@RecvGuild:

; 3588 : 		}
; 3589 : 		case GUILD_SUBHEADER_GC_GUILD_INVITE:
; 3590 : 		{
; 3591 : 			DWORD dwGuildID;
; 3592 : 			if (!Recv(sizeof(dwGuildID), &dwGuildID))

  00946	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _dwGuildID$24[ebp]
  0094c	8b cf		 mov	 ecx, edi
  0094e	50		 push	 eax
  0094f	6a 04		 push	 4
  00951	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00956	84 c0		 test	 al, al
  00958	0f 84 e3 f6 ff
	ff		 je	 $LN389@RecvGuild

; 3593 : 				return false;
; 3594 : 			char szGuildName[GUILD_NAME_MAX_LEN+1];
; 3595 : 			if (!Recv(GUILD_NAME_MAX_LEN, &szGuildName))

  0095e	8d 45 e0	 lea	 eax, DWORD PTR _szGuildName$40[ebp]
  00961	8b cf		 mov	 ecx, edi
  00963	50		 push	 eax
  00964	6a 0c		 push	 12			; 0000000cH
  00966	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0096b	84 c0		 test	 al, al
  0096d	0f 84 ce f6 ff
	ff		 je	 $LN389@RecvGuild

; 3596 : 				return false;
; 3597 : 
; 3598 : 			szGuildName[GUILD_NAME_MAX_LEN] = 0;
; 3599 : 
; 3600 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RecvGuildInviteQuestion", Py_BuildValue("(is)", dwGuildID, szGuildName));

  00973	8d 45 e0	 lea	 eax, DWORD PTR _szGuildName$40[ebp]
  00976	c6 45 ec 00	 mov	 BYTE PTR _szGuildName$40[ebp+12], 0
  0097a	50		 push	 eax
  0097b	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwGuildID$24[ebp]
  00981	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  00986	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0098c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0098f	50		 push	 eax
  00990	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GJGOAKHL@RecvGuildInviteQuestion?$AA@
  00995	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  0099b	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  009a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3601 : 			Tracef(" <Guild Invite> %d, %s\n", dwGuildID, szGuildName);

  009a3	8d 45 e0	 lea	 eax, DWORD PTR _szGuildName$40[ebp]
  009a6	50		 push	 eax
  009a7	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwGuildID$24[ebp]
  009ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EECNELJB@?5?$DMGuild?5Invite?$DO?5?$CFd?0?5?$CFs?6?$AA@
  009b2	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  009b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3602 : 			break;

  009ba	e9 34 03 00 00	 jmp	 $LN90@RecvGuild
$LN27@RecvGuild:

; 3603 : 		}
; 3604 : 		case GUILD_SUBHEADER_GC_WAR:
; 3605 : 		{
; 3606 : 			TPacketGCGuildWar kGuildWar;
; 3607 : 			if (!Recv(sizeof(kGuildWar), &kGuildWar))

  009bf	8d 45 e0	 lea	 eax, DWORD PTR _kGuildWar$39[ebp]
  009c2	8b cf		 mov	 ecx, edi
  009c4	50		 push	 eax
  009c5	6a 0a		 push	 10			; 0000000aH
  009c7	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  009cc	84 c0		 test	 al, al
  009ce	0f 84 6d f6 ff
	ff		 je	 $LN389@RecvGuild

; 3608 : 				return false;
; 3609 : 
; 3610 : 			switch (kGuildWar.bWarState)

  009d4	0f b6 45 e9	 movzx	 eax, BYTE PTR _kGuildWar$39[ebp+9]
  009d8	48		 dec	 eax
  009d9	83 f8 06	 cmp	 eax, 6
  009dc	0f 87 11 03 00
	00		 ja	 $LN90@RecvGuild
  009e2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN391@RecvGuild[eax*4]
$LN23@RecvGuild:

; 3611 : 			{
; 3612 : 				case GUILD_WAR_SEND_DECLARE:
; 3613 : 					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_SEND_DECLARE\n");

  009e9	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@PELONEKB@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@
  009ee	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  009f3	83 c4 04	 add	 esp, 4

; 3614 : 					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 3615 : 						"BINARY_GuildWar_OnSendDeclare", 
; 3616 : 						Py_BuildValue("(i)", kGuildWar.dwGuildOpp)
; 3617 : 					);

  009f6	ff 75 e4	 push	 DWORD PTR _kGuildWar$39[ebp+4]
  009f9	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  009fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00a04	50		 push	 eax
  00a05	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HMPGICIO@BINARY_GuildWar_OnSendDeclare?$AA@
  00a0a	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00a10	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00a15	83 c4 14	 add	 esp, 20			; 00000014H

; 3618 : 					break;

  00a18	e9 d6 02 00 00	 jmp	 $LN90@RecvGuild
$LN22@RecvGuild:

; 3619 : 				case GUILD_WAR_RECV_DECLARE:
; 3620 : 					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_RECV_DECLARE\n");

  00a1d	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BIEEJDD@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@
  00a22	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 3621 : 					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 3622 : 						"BINARY_GuildWar_OnRecvDeclare", 
; 3623 : 						Py_BuildValue("(ii)", kGuildWar.dwGuildOpp, kGuildWar.bType)
; 3624 : 					);

  00a27	0f b6 45 e8	 movzx	 eax, BYTE PTR _kGuildWar$39[ebp+8]
  00a2b	83 c4 04	 add	 esp, 4
  00a2e	50		 push	 eax
  00a2f	ff 75 e4	 push	 DWORD PTR _kGuildWar$39[ebp+4]
  00a32	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00a37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00a3d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a40	50		 push	 eax
  00a41	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JAJLCPKG@BINARY_GuildWar_OnRecvDeclare?$AA@
  00a46	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00a4c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00a51	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3625 : 					break;

  00a54	e9 9a 02 00 00	 jmp	 $LN90@RecvGuild
$LN21@RecvGuild:

; 3626 : 				case GUILD_WAR_ON_WAR:
; 3627 : 					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_ON_WAR : %d, %d\n", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp);

  00a59	ff 75 e4	 push	 DWORD PTR _kGuildWar$39[ebp+4]
  00a5c	ff 75 e0	 push	 DWORD PTR _kGuildWar$39[ebp]
  00a5f	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LOGKJDI@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@
  00a64	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00a69	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3628 : 					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 3629 : 						"BINARY_GuildWar_OnStart", 
; 3630 : 						Py_BuildValue("(ii)", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp)
; 3631 : 					);

  00a6c	ff 75 e4	 push	 DWORD PTR _kGuildWar$39[ebp+4]
  00a6f	ff 75 e0	 push	 DWORD PTR _kGuildWar$39[ebp]
  00a72	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00a77	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00a7d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a80	50		 push	 eax
  00a81	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JKFNHMFD@BINARY_GuildWar_OnStart?$AA@
  00a86	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00a8c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 3632 : 					CPythonGuild::Instance().StartGuildWar(kGuildWar.dwGuildOpp);

  00a91	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00a97	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a9a	ff 75 e4	 push	 DWORD PTR _kGuildWar$39[ebp+4]
  00a9d	e8 00 00 00 00	 call	 ?StartGuildWar@CPythonGuild@@QAEXK@Z ; CPythonGuild::StartGuildWar

; 3633 : 					break;

  00aa2	e9 4c 02 00 00	 jmp	 $LN90@RecvGuild
$LN20@RecvGuild:

; 3634 : 				case GUILD_WAR_END:
; 3635 : 					Tracef(" >> GUILD_SUBHEADER_GC_WAR : GUILD_WAR_END\n");

  00aa7	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@HGKOKFIL@?5?$DO?$DO?5GUILD_SUBHEADER_GC_WAR?5?3?5GUI@
  00aac	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00ab1	83 c4 04	 add	 esp, 4

; 3636 : 					PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 3637 : 						"BINARY_GuildWar_OnEnd", 
; 3638 : 						Py_BuildValue("(ii)", kGuildWar.dwGuildSelf, kGuildWar.dwGuildOpp)
; 3639 : 					);

  00ab4	ff 75 e4	 push	 DWORD PTR _kGuildWar$39[ebp+4]
  00ab7	ff 75 e0	 push	 DWORD PTR _kGuildWar$39[ebp]
  00aba	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00abf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00ac5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ac8	50		 push	 eax
  00ac9	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NACAFPAN@BINARY_GuildWar_OnEnd?$AA@
  00ace	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00ad4	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 3640 : 					CPythonGuild::Instance().EndGuildWar(kGuildWar.dwGuildOpp);

  00ad9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00adf	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ae2	ff 75 e4	 push	 DWORD PTR _kGuildWar$39[ebp+4]
  00ae5	e8 00 00 00 00	 call	 ?EndGuildWar@CPythonGuild@@QAEXK@Z ; CPythonGuild::EndGuildWar

; 3641 : 					break;
; 3642 : 			}
; 3643 : 			break;

  00aea	e9 04 02 00 00	 jmp	 $LN90@RecvGuild
$LN19@RecvGuild:

; 3644 : 		}
; 3645 : 		case GUILD_SUBHEADER_GC_GUILD_NAME:
; 3646 : 		{
; 3647 : 			DWORD dwID;
; 3648 : 			char szGuildName[GUILD_NAME_MAX_LEN+1];
; 3649 : 
; 3650 : 			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);

  00aef	0f b7 b5 41 ff
	ff ff		 movzx	 esi, WORD PTR _GuildPacket$[ebp+1]
  00af6	83 ee 04	 sub	 esi, 4

; 3651 : 
; 3652 : 			int nItemSize = sizeof(dwID) + GUILD_NAME_MAX_LEN;
; 3653 : 
; 3654 : 			assert(iPacketSize%nItemSize==0 && "GUILD_SUBHEADER_GC_GUILD_NAME");
; 3655 : 
; 3656 : 			for (; iPacketSize > 0;)

  00af9	85 f6		 test	 esi, esi
  00afb	0f 8e f2 01 00
	00		 jle	 $LN90@RecvGuild
$LL18@RecvGuild:

; 3657 : 			{
; 3658 : 				if (!Recv(sizeof(dwID), &dwID))

  00b01	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _dwID$23[ebp]
  00b07	8b cf		 mov	 ecx, edi
  00b09	50		 push	 eax
  00b0a	6a 04		 push	 4
  00b0c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00b11	84 c0		 test	 al, al
  00b13	0f 84 28 f5 ff
	ff		 je	 $LN389@RecvGuild

; 3659 : 					return false;
; 3660 : 				
; 3661 : 				if (!Recv(GUILD_NAME_MAX_LEN, &szGuildName))

  00b19	8d 45 e0	 lea	 eax, DWORD PTR _szGuildName$38[ebp]
  00b1c	8b cf		 mov	 ecx, edi
  00b1e	50		 push	 eax
  00b1f	6a 0c		 push	 12			; 0000000cH
  00b21	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00b26	84 c0		 test	 al, al
  00b28	0f 84 13 f5 ff
	ff		 je	 $LN389@RecvGuild

; 3662 : 					return false;
; 3663 : 
; 3664 : 				szGuildName[GUILD_NAME_MAX_LEN] = 0;
; 3665 : 
; 3666 : 				//Tracef(" >> GulidName [%d : %s]\n", dwID, szGuildName);
; 3667 : 				CPythonGuild::Instance().RegisterGuildName(dwID, szGuildName);

  00b2e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00b34	8d 45 e0	 lea	 eax, DWORD PTR _szGuildName$38[ebp]
  00b37	50		 push	 eax
  00b38	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwID$23[ebp]
  00b3e	c6 45 ec 00	 mov	 BYTE PTR _szGuildName$38[ebp+12], 0
  00b42	e8 00 00 00 00	 call	 ?RegisterGuildName@CPythonGuild@@QAEXKPBD@Z ; CPythonGuild::RegisterGuildName

; 3668 : 				iPacketSize -= nItemSize;

  00b47	83 ee 10	 sub	 esi, 16			; 00000010H
  00b4a	85 f6		 test	 esi, esi
  00b4c	7f b3		 jg	 SHORT $LL18@RecvGuild

; 3711 : 					return false;
; 3712 : 				
; 3713 : 				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))

  00b4e	e9 a0 01 00 00	 jmp	 $LN90@RecvGuild
$LN14@RecvGuild:

; 3669 : 			}
; 3670 : 			break;
; 3671 : 		}
; 3672 : 		case GUILD_SUBHEADER_GC_GUILD_WAR_LIST:
; 3673 : 		{
; 3674 : 			DWORD dwSrcGuildID;
; 3675 : 			DWORD dwDstGuildID;
; 3676 : 
; 3677 : 			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);

  00b53	0f b7 b5 41 ff
	ff ff		 movzx	 esi, WORD PTR _GuildPacket$[ebp+1]
  00b5a	83 ee 04	 sub	 esi, 4

; 3678 : 			int nItemSize = sizeof(dwSrcGuildID) + sizeof(dwDstGuildID);
; 3679 : 
; 3680 : 			assert(iPacketSize%nItemSize==0 && "GUILD_SUBHEADER_GC_GUILD_WAR_LIST");
; 3681 : 
; 3682 : 			for (; iPacketSize > 0;)

  00b5d	85 f6		 test	 esi, esi
  00b5f	0f 8e 8e 01 00
	00		 jle	 $LN90@RecvGuild
$LL13@RecvGuild:

; 3683 : 			{				
; 3684 : 				if (!Recv(sizeof(dwSrcGuildID), &dwSrcGuildID))

  00b65	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _dwSrcGuildID$22[ebp]
  00b6b	8b cf		 mov	 ecx, edi
  00b6d	50		 push	 eax
  00b6e	6a 04		 push	 4
  00b70	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00b75	84 c0		 test	 al, al
  00b77	0f 84 c4 f4 ff
	ff		 je	 $LN389@RecvGuild

; 3685 : 					return false;
; 3686 : 				
; 3687 : 				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))

  00b7d	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _dwDstGuildID$12[ebp]
  00b83	8b cf		 mov	 ecx, edi
  00b85	50		 push	 eax
  00b86	6a 04		 push	 4
  00b88	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00b8d	84 c0		 test	 al, al
  00b8f	0f 84 ac f4 ff
	ff		 je	 $LN389@RecvGuild

; 3688 : 					return false;
; 3689 : 
; 3690 : 				Tracef(" >> GulidWarList [%d vs %d]\n", dwSrcGuildID, dwDstGuildID);

  00b95	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwDstGuildID$12[ebp]
  00b9b	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwSrcGuildID$22[ebp]
  00ba1	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PIMGMDLK@?5?$DO?$DO?5GulidWarList?5?$FL?$CFd?5vs?5?$CFd?$FN?6?$AA@
  00ba6	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 3691 : 				CInstanceBase::InsertGVGKey(dwSrcGuildID, dwDstGuildID);

  00bab	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _dwDstGuildID$12[ebp]
  00bb1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bb4	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _dwSrcGuildID$22[ebp]
  00bba	e8 00 00 00 00	 call	 ?InsertGVGKey@CInstanceBase@@SAXKK@Z ; CInstanceBase::InsertGVGKey

; 3692 : 				CPythonCharacterManager::Instance().ChangeGVG(dwSrcGuildID, dwDstGuildID);

  00bbf	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwDstGuildID$12[ebp]
  00bc5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00bcb	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwSrcGuildID$22[ebp]
  00bd1	e8 00 00 00 00	 call	 ?ChangeGVG@CPythonCharacterManager@@QAEXKK@Z ; CPythonCharacterManager::ChangeGVG

; 3693 : 				iPacketSize -= nItemSize;

  00bd6	83 ee 08	 sub	 esi, 8
  00bd9	85 f6		 test	 esi, esi
  00bdb	7f 88		 jg	 SHORT $LL13@RecvGuild

; 3711 : 					return false;
; 3712 : 				
; 3713 : 				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))

  00bdd	e9 11 01 00 00	 jmp	 $LN90@RecvGuild
$LN9@RecvGuild:

; 3694 : 			}
; 3695 : 			break;
; 3696 : 		}
; 3697 : 		case GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST:
; 3698 : 		{
; 3699 : 			DWORD dwSrcGuildID;
; 3700 : 			DWORD dwDstGuildID;
; 3701 : 
; 3702 : 			int iPacketSize = int(GuildPacket.size) - sizeof(GuildPacket);

  00be2	0f b7 b5 41 ff
	ff ff		 movzx	 esi, WORD PTR _GuildPacket$[ebp+1]
  00be9	83 ee 04	 sub	 esi, 4

; 3703 : 			int nItemSize = sizeof(dwSrcGuildID) + sizeof(dwDstGuildID);
; 3704 : 
; 3705 : 			assert(iPacketSize%nItemSize==0 && "GUILD_SUBHEADER_GC_GUILD_WAR_END_LIST");
; 3706 : 
; 3707 : 			for (; iPacketSize > 0;)

  00bec	85 f6		 test	 esi, esi
  00bee	0f 8e ff 00 00
	00		 jle	 $LN90@RecvGuild
$LL8@RecvGuild:

; 3708 : 			{
; 3709 : 				
; 3710 : 				if (!Recv(sizeof(dwSrcGuildID), &dwSrcGuildID))

  00bf4	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _dwSrcGuildID$11[ebp]
  00bfa	8b cf		 mov	 ecx, edi
  00bfc	50		 push	 eax
  00bfd	6a 04		 push	 4
  00bff	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00c04	84 c0		 test	 al, al
  00c06	0f 84 35 f4 ff
	ff		 je	 $LN389@RecvGuild

; 3711 : 					return false;
; 3712 : 				
; 3713 : 				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))

  00c0c	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _dwDstGuildID$21[ebp]
  00c12	8b cf		 mov	 ecx, edi
  00c14	50		 push	 eax
  00c15	6a 04		 push	 4
  00c17	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00c1c	84 c0		 test	 al, al
  00c1e	0f 84 1d f4 ff
	ff		 je	 $LN389@RecvGuild

; 3714 : 					return false;
; 3715 : 
; 3716 : 				Tracef(" >> GulidWarEndList [%d vs %d]\n", dwSrcGuildID, dwDstGuildID);

  00c24	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwDstGuildID$21[ebp]
  00c2a	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwSrcGuildID$11[ebp]
  00c30	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FNEJFGNL@?5?$DO?$DO?5GulidWarEndList?5?$FL?$CFd?5vs?5?$CFd?$FN?6?$AA@
  00c35	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 3717 : 				CInstanceBase::RemoveGVGKey(dwSrcGuildID, dwDstGuildID);

  00c3a	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _dwDstGuildID$21[ebp]
  00c40	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c43	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _dwSrcGuildID$11[ebp]
  00c49	e8 00 00 00 00	 call	 ?RemoveGVGKey@CInstanceBase@@SAXKK@Z ; CInstanceBase::RemoveGVGKey

; 3718 : 				CPythonCharacterManager::Instance().ChangeGVG(dwSrcGuildID, dwDstGuildID);

  00c4e	ff b5 50 ff ff
	ff		 push	 DWORD PTR _dwDstGuildID$21[ebp]
  00c54	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00c5a	ff b5 4c ff ff
	ff		 push	 DWORD PTR _dwSrcGuildID$11[ebp]
  00c60	e8 00 00 00 00	 call	 ?ChangeGVG@CPythonCharacterManager@@QAEXKK@Z ; CPythonCharacterManager::ChangeGVG

; 3719 : 				iPacketSize -= nItemSize;

  00c65	83 ee 08	 sub	 esi, 8
  00c68	85 f6		 test	 esi, esi
  00c6a	7f 88		 jg	 SHORT $LL8@RecvGuild

; 3711 : 					return false;
; 3712 : 				
; 3713 : 				if (!Recv(sizeof(dwDstGuildID), &dwDstGuildID))

  00c6c	e9 82 00 00 00	 jmp	 $LN90@RecvGuild
$LN4@RecvGuild:

; 3720 : 			}
; 3721 : 			break;
; 3722 : 		}
; 3723 : 		case GUILD_SUBHEADER_GC_WAR_POINT:
; 3724 : 		{
; 3725 : 			TPacketGuildWarPoint GuildWarPoint;
; 3726 : 			if (!Recv(sizeof(GuildWarPoint), &GuildWarPoint))

  00c71	8d 45 e0	 lea	 eax, DWORD PTR _GuildWarPoint$37[ebp]
  00c74	8b cf		 mov	 ecx, edi
  00c76	50		 push	 eax
  00c77	6a 0c		 push	 12			; 0000000cH
  00c79	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00c7e	84 c0		 test	 al, al
  00c80	0f 84 bb f3 ff
	ff		 je	 $LN389@RecvGuild

; 3727 : 				return false;
; 3728 : 
; 3729 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 3730 : 				"BINARY_GuildWar_OnRecvPoint", 
; 3731 : 				Py_BuildValue("(iii)", GuildWarPoint.dwGainGuildID, GuildWarPoint.dwOpponentGuildID, GuildWarPoint.lPoint)
; 3732 : 			);

  00c86	ff 75 e8	 push	 DWORD PTR _GuildWarPoint$37[ebp+8]
  00c89	ff 75 e4	 push	 DWORD PTR _GuildWarPoint$37[ebp+4]
  00c8c	ff 75 e0	 push	 DWORD PTR _GuildWarPoint$37[ebp]
  00c8f	68 00 00 00 00	 push	 OFFSET ??_C@_05HEIOBLPG@?$CIiii?$CJ?$AA@
  00c94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00c9a	50		 push	 eax
  00c9b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LBOEDDLE@BINARY_GuildWar_OnRecvPoint?$AA@
  00ca0	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00ca6	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00cab	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3733 : 			break;

  00cae	eb 43		 jmp	 SHORT $LN90@RecvGuild
$LN2@RecvGuild:

; 3734 : 		}
; 3735 : 		case GUILD_SUBHEADER_GC_MONEY_CHANGE:
; 3736 : 		{
; 3737 : 			DWORD dwMoney;
; 3738 : 			if (!Recv(sizeof(dwMoney), &dwMoney))

  00cb0	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _dwMoney$2[ebp]
  00cb6	8b cf		 mov	 ecx, edi
  00cb8	50		 push	 eax
  00cb9	6a 04		 push	 4
  00cbb	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00cc0	84 c0		 test	 al, al
  00cc2	0f 84 79 f3 ff
	ff		 je	 $LN389@RecvGuild

; 3739 : 				return false;
; 3740 : 
; 3741 : 			CPythonGuild::Instance().SetGuildMoney(dwMoney);

  00cc8	ff b5 44 ff ff
	ff		 push	 DWORD PTR _dwMoney$2[ebp]
  00cce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  00cd4	e8 00 00 00 00	 call	 ?SetGuildMoney@CPythonGuild@@QAEXK@Z ; CPythonGuild::SetGuildMoney

; 3742 : 
; 3743 : 			__RefreshGuildWindowInfoPage();

  00cd9	8b cf		 mov	 ecx, edi
  00cdb	e8 00 00 00 00	 call	 ?__RefreshGuildWindowInfoPage@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshGuildWindowInfoPage

; 3744 : 			Tracef(" >> Guild Money Change : %d\n", dwMoney);

  00ce0	ff b5 44 ff ff
	ff		 push	 DWORD PTR _dwMoney$2[ebp]
  00ce6	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IAMOHDFF@?5?$DO?$DO?5Guild?5Money?5Change?5?3?5?$CFd?6?$AA@
$LN388@RecvGuild:
  00ceb	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00cf0	83 c4 08	 add	 esp, 8
$LN90@RecvGuild:

; 3745 : 			break;
; 3746 : 		}
; 3747 : 	}
; 3748 : 
; 3749 : 	return true;

  00cf3	b0 01		 mov	 al, 1
$LN93@RecvGuild:

; 3750 : }

  00cf5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00cf8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00cff	59		 pop	 ecx
  00d00	5f		 pop	 edi
  00d01	5e		 pop	 esi
  00d02	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d05	33 cd		 xor	 ecx, ebp
  00d07	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d0c	8b e5		 mov	 esp, ebp
  00d0e	5d		 pop	 ebp
  00d0f	c3		 ret	 0
$LN390@RecvGuild:
  00d10	00 00 00 00	 DD	 $LN89@RecvGuild
  00d14	00 00 00 00	 DD	 $LN85@RecvGuild
  00d18	00 00 00 00	 DD	 $LN76@RecvGuild
  00d1c	00 00 00 00	 DD	 $LN67@RecvGuild
  00d20	00 00 00 00	 DD	 $LN90@RecvGuild
  00d24	00 00 00 00	 DD	 $LN81@RecvGuild
  00d28	00 00 00 00	 DD	 $LN60@RecvGuild
  00d2c	00 00 00 00	 DD	 $LN57@RecvGuild
  00d30	00 00 00 00	 DD	 $LN54@RecvGuild
  00d34	00 00 00 00	 DD	 $LN52@RecvGuild
  00d38	00 00 00 00	 DD	 $LN44@RecvGuild
  00d3c	00 00 00 00	 DD	 $LN41@RecvGuild
  00d40	00 00 00 00	 DD	 $LN38@RecvGuild
  00d44	00 00 00 00	 DD	 $LN33@RecvGuild
  00d48	00 00 00 00	 DD	 $LN30@RecvGuild
  00d4c	00 00 00 00	 DD	 $LN27@RecvGuild
  00d50	00 00 00 00	 DD	 $LN19@RecvGuild
  00d54	00 00 00 00	 DD	 $LN14@RecvGuild
  00d58	00 00 00 00	 DD	 $LN9@RecvGuild
  00d5c	00 00 00 00	 DD	 $LN4@RecvGuild
  00d60	00 00 00 00	 DD	 $LN2@RecvGuild
$LN391@RecvGuild:
  00d64	00 00 00 00	 DD	 $LN23@RecvGuild
  00d68	00 00 00 00	 DD	 $LN90@RecvGuild
  00d6c	00 00 00 00	 DD	 $LN22@RecvGuild
  00d70	00 00 00 00	 DD	 $LN90@RecvGuild
  00d74	00 00 00 00	 DD	 $LN90@RecvGuild
  00d78	00 00 00 00	 DD	 $LN21@RecvGuild
  00d7c	00 00 00 00	 DD	 $LN20@RecvGuild
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvGuild@CPythonNetworkStream@@IAE_NXZ$0:
  00000	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _strMemberName$30[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RecvGuild@CPythonNetworkStream@@IAE_NXZ$1:
  0000b	8d 4d b8	 lea	 ecx, DWORD PTR _GuildMemberData$35[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1SGuildMemberData@CPythonGuild@@QAE@XZ
__unwindfunclet$?RecvGuild@CPythonNetworkStream@@IAE_NXZ$2:
  00013	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1SGuildGradeData@CPythonGuild@@QAE@XZ
__ehhandler$?RecvGuild@CPythonNetworkStream@@IAE_NXZ:
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 8a 3c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-196]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvGuild@CPythonNetworkStream@@IAE_NXZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvGuild@CPythonNetworkStream@@IAE_NXZ ENDP		; CPythonNetworkStream::RecvGuild
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??0SGuildMemberData@CPythonGuild@@QAE@XZ
_TEXT	SEGMENT
??0SGuildMemberData@CPythonGuild@@QAE@XZ PROC		; CPythonGuild::SGuildMemberData::SGuildMemberData, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00000	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00007	8b c1		 mov	 eax, ecx

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
??0SGuildMemberData@CPythonGuild@@QAE@XZ ENDP		; CPythonGuild::SGuildMemberData::SGuildMemberData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendFishingPacket@CPythonNetworkStream@@QAE_NH@Z
_TEXT	SEGMENT
_byPacketRotation$ = -2					; size = 1
_byHeader$ = -1						; size = 1
_iRotation$ = 8						; size = 4
?SendFishingPacket@CPythonNetworkStream@@QAE_NH@Z PROC	; CPythonNetworkStream::SendFishingPacket, COMDAT
; _this$ = ecx

; 3760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3761 : 	BYTE byHeader = HEADER_CG_FISHING;
; 3762 : 	if (!Send(sizeof(byHeader), &byHeader))

  00005	8d 45 ff	 lea	 eax, DWORD PTR _byHeader$[ebp]
  00008	c6 45 ff 52	 mov	 BYTE PTR _byHeader$[ebp], 82 ; 00000052H
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	8b f1		 mov	 esi, ecx
  00011	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00016	84 c0		 test	 al, al
  00018	75 09		 jne	 SHORT $LN2@SendFishin
$LN5@SendFishin:

; 3763 : 		return false;

  0001a	32 c0		 xor	 al, al
  0001c	5e		 pop	 esi

; 3769 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN2@SendFishin:

; 3764 : 	BYTE byPacketRotation = iRotation / 5;

  00023	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H

; 3765 : 	if (!Send(sizeof(BYTE), &byPacketRotation))

  00028	8b ce		 mov	 ecx, esi
  0002a	f7 6d 08	 imul	 DWORD PTR _iRotation$[ebp]
  0002d	d1 fa		 sar	 edx, 1
  0002f	8b c2		 mov	 eax, edx
  00031	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00034	03 c2		 add	 eax, edx
  00036	88 45 fe	 mov	 BYTE PTR _byPacketRotation$[ebp], al
  00039	8d 45 fe	 lea	 eax, DWORD PTR _byPacketRotation$[ebp]
  0003c	50		 push	 eax
  0003d	6a 01		 push	 1
  0003f	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00044	84 c0		 test	 al, al
  00046	74 d2		 je	 SHORT $LN5@SendFishin

; 3766 : 		return false;
; 3767 : 
; 3768 : 	return SendSequence();

  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0004f	5e		 pop	 esi

; 3769 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?SendFishingPacket@CPythonNetworkStream@@QAE_NH@Z ENDP	; CPythonNetworkStream::SendFishingPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
;	COMDAT ??0command_give_item@@QAE@XZ
_TEXT	SEGMENT
??0command_give_item@@QAE@XZ PROC			; command_give_item::command_give_item, COMDAT
; _this$ = ecx

; 187  : 		cell = WORD_MAX;

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00005	c6 41 05 01	 mov	 BYTE PTR [ecx+5], 1
  00009	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0command_give_item@@QAE@XZ ENDP			; command_give_item::command_give_item
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvFishing@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_FishingPacket$ = -12					; size = 7
_pItemData$1 = -4					; size = 4
?RecvFishing@CPythonNetworkStream@@IAE_NXZ PROC		; CPythonNetworkStream::RecvFishing, COMDAT
; _this$ = ecx

; 3786 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 3787 : 	TPacketGCFishing FishingPacket;
; 3788 : 	if (!Recv(sizeof(FishingPacket), &FishingPacket))

  00006	8d 45 f4	 lea	 eax, DWORD PTR _FishingPacket$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	6a 07		 push	 7
  0000e	8b f9		 mov	 edi, ecx
  00010	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00015	84 c0		 test	 al, al
  00017	75 06		 jne	 SHORT $LN19@RecvFishin

; 3856 : }

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN19@RecvFishin:

; 3789 : 		return false;
; 3790 : 
; 3791 : 	CInstanceBase * pFishingInstance = NULL;
; 3792 : 	if (FISHING_SUBHEADER_GC_FISH != FishingPacket.subheader)

  0001f	8a 45 f5	 mov	 al, BYTE PTR _FishingPacket$[ebp+1]
  00022	33 f6		 xor	 esi, esi
  00024	3c 05		 cmp	 al, 5
  00026	74 1e		 je	 SHORT $LN17@RecvFishin

; 3793 : 	{
; 3794 : 		pFishingInstance = CPythonCharacterManager::Instance().GetInstancePtr(FishingPacket.info);

  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0002e	ff 75 f6	 push	 DWORD PTR _FishingPacket$[ebp+2]
  00031	83 c1 04	 add	 ecx, 4
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	ff 50 08	 call	 DWORD PTR [eax+8]
  00039	8b f0		 mov	 esi, eax

; 3795 : 		if (!pFishingInstance)

  0003b	85 f6		 test	 esi, esi
  0003d	0f 84 76 01 00
	00		 je	 $LN1@RecvFishin

; 3796 : 			return true;

  00043	8a 45 f5	 mov	 al, BYTE PTR _FishingPacket$[ebp+1]
$LN17@RecvFishin:

; 3797 : 	}
; 3798 : 
; 3799 : 	switch (FishingPacket.subheader)

  00046	0f b6 c0	 movzx	 eax, al
  00049	83 f8 05	 cmp	 eax, 5
  0004c	0f 87 67 01 00
	00		 ja	 $LN1@RecvFishin
  00052	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN33@RecvFishin[eax*4]
$LN14@RecvFishin:

; 3800 : 	{
; 3801 : 		case FISHING_SUBHEADER_GC_START:
; 3802 : 			pFishingInstance->StartFishing(float(FishingPacket.dir) * 5.0f);

  00059	0f b6 45 fa	 movzx	 eax, BYTE PTR _FishingPacket$[ebp+6]
  0005d	8b ce		 mov	 ecx, esi
  0005f	66 0f 6e c8	 movd	 xmm1, eax
  00063	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00066	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40a00000
  0006e	e8 00 00 00 00	 call	 ?StartFishing@CInstanceBase@@QAEXM@Z ; CInstanceBase::StartFishing

; 3850 : 			}
; 3851 : 			break;
; 3852 : 		}
; 3853 : 	}
; 3854 : 
; 3855 : 	return true;

  00073	b0 01		 mov	 al, 1

; 3856 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN13@RecvFishin:

; 3803 : 			break;
; 3804 : 		case FISHING_SUBHEADER_GC_STOP:
; 3805 : 			if (pFishingInstance->IsFishing())

  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?IsFishing@CInstanceBase@@QAEHXZ ; CInstanceBase::IsFishing
  00082	85 c0		 test	 eax, eax
  00084	0f 84 2f 01 00
	00		 je	 $LN1@RecvFishin

; 3806 : 				pFishingInstance->StopFishing();

  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?StopFishing@CInstanceBase@@QAEXXZ ; CInstanceBase::StopFishing

; 3850 : 			}
; 3851 : 			break;
; 3852 : 		}
; 3853 : 	}
; 3854 : 
; 3855 : 	return true;

  00091	b0 01		 mov	 al, 1

; 3856 : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN11@RecvFishin:

; 3807 : 			break;
; 3808 : 		case FISHING_SUBHEADER_GC_REACT:
; 3809 : 			if (pFishingInstance->IsFishing())

  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ?IsFishing@CInstanceBase@@QAEHXZ ; CInstanceBase::IsFishing
  000a0	85 c0		 test	 eax, eax
  000a2	0f 84 11 01 00
	00		 je	 $LN1@RecvFishin

; 3810 : 			{
; 3811 : 				pFishingInstance->SetFishEmoticon(); // Fish Emoticon

  000a8	8b ce		 mov	 ecx, esi
  000aa	e8 00 00 00 00	 call	 ?SetFishEmoticon@CInstanceBase@@QAEXXZ ; CInstanceBase::SetFishEmoticon

; 3812 : 				pFishingInstance->ReactFishing();

  000af	8b ce		 mov	 ecx, esi
  000b1	e8 00 00 00 00	 call	 ?ReactFishing@CInstanceBase@@QAEXXZ ; CInstanceBase::ReactFishing

; 3850 : 			}
; 3851 : 			break;
; 3852 : 		}
; 3853 : 	}
; 3854 : 
; 3855 : 	return true;

  000b6	b0 01		 mov	 al, 1

; 3856 : }

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN9@RecvFishin:

; 3813 : 			}
; 3814 : 			break;
; 3815 : 		case FISHING_SUBHEADER_GC_SUCCESS:
; 3816 : 			pFishingInstance->CatchSuccess();

  000be	8b ce		 mov	 ecx, esi
  000c0	e8 00 00 00 00	 call	 ?CatchSuccess@CInstanceBase@@QAEXXZ ; CInstanceBase::CatchSuccess

; 3850 : 			}
; 3851 : 			break;
; 3852 : 		}
; 3853 : 	}
; 3854 : 
; 3855 : 	return true;

  000c5	b0 01		 mov	 al, 1

; 3856 : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN8@RecvFishin:

; 3817 : 			break;
; 3818 : 		case FISHING_SUBHEADER_GC_FAIL:
; 3819 : 			pFishingInstance->CatchFail();

  000cd	8b ce		 mov	 ecx, esi
  000cf	e8 00 00 00 00	 call	 ?CatchFail@CInstanceBase@@QAEXXZ ; CInstanceBase::CatchFail

; 3820 : 			if (pFishingInstance == CPythonCharacterManager::Instance().GetMainInstancePtr())

  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  000da	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr
  000df	3b f0		 cmp	 esi, eax
  000e1	0f 85 d2 00 00
	00		 jne	 $LN1@RecvFishin

; 3821 : 			{
; 3822 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingFailure", Py_BuildValue("()"));

  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000f2	83 c4 04	 add	 esp, 4
  000f5	50		 push	 eax
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CJFMLNJB@OnFishingFailure?$AA@

; 3823 : 			}
; 3824 : 			break;

  000fb	e9 ab 00 00 00	 jmp	 $LN31@RecvFishin
$LN6@RecvFishin:

; 3825 : 		case FISHING_SUBHEADER_GC_FISH:
; 3826 : 		{
; 3827 : 			DWORD dwFishID = FishingPacket.info;
; 3828 : 
; 3829 : 			if (0 == FishingPacket.info)

  00100	8b 45 f6	 mov	 eax, DWORD PTR _FishingPacket$[ebp+2]
  00103	85 c0		 test	 eax, eax
  00105	75 19		 jne	 SHORT $LN5@RecvFishin

; 3830 : 			{
; 3831 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingNotifyUnknown", Py_BuildValue("()"));

  00107	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00112	83 c4 04	 add	 esp, 4
  00115	50		 push	 eax
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DPEJLPAP@OnFishingNotifyUnknown?$AA@

; 3832 : 				return true;

  0011b	e9 8b 00 00 00	 jmp	 $LN31@RecvFishin
$LN5@RecvFishin:

; 3833 : 			}
; 3834 : 
; 3835 : 			CItemData * pItemData;
; 3836 : 			if (!CItemManager::Instance().GetItemDataPointer(dwFishID, &pItemData))

  00120	8d 4d fc	 lea	 ecx, DWORD PTR _pItemData$1[ebp]
  00123	51		 push	 ecx
  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  00130	85 c0		 test	 eax, eax
  00132	0f 84 81 00 00
	00		 je	 $LN1@RecvFishin

; 3837 : 				return true;
; 3838 : 
; 3839 : 			CInstanceBase * pMainInstance = CPythonCharacterManager::Instance().GetMainInstancePtr();

  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0013e	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr

; 3840 : 			if (!pMainInstance)

  00143	85 c0		 test	 eax, eax
  00145	74 72		 je	 SHORT $LN1@RecvFishin

; 3841 : 				return true;
; 3842 : 
; 3843 : 			if (pMainInstance->IsFishing())

  00147	8b c8		 mov	 ecx, eax
  00149	e8 00 00 00 00	 call	 ?IsFishing@CInstanceBase@@QAEHXZ ; CInstanceBase::IsFishing

; 3844 : 			{
; 3845 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingNotify", Py_BuildValue("(is)", CItemData::ITEM_TYPE_FISH == pItemData->GetType(), pItemData->GetName()));

  0014e	8b 4d fc	 mov	 ecx, DWORD PTR _pItemData$1[ebp]
  00151	85 c0		 test	 eax, eax
  00153	74 2c		 je	 SHORT $LN2@RecvFishin
  00155	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _pItemData$1[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType
  00163	33 c9		 xor	 ecx, ecx
  00165	3c 0c		 cmp	 al, 12			; 0000000cH
  00167	0f 94 c1	 sete	 cl
  0016a	51		 push	 ecx
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00176	83 c4 0c	 add	 esp, 12			; 0000000cH
  00179	50		 push	 eax
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ODHDNEFK@OnFishingNotify?$AA@

; 3846 : 			}
; 3847 : 			else

  0017f	eb 2a		 jmp	 SHORT $LN31@RecvFishin
$LN2@RecvFishin:

; 3848 : 			{
; 3849 : 				PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnFishingSuccess", Py_BuildValue("(is)", CItemData::ITEM_TYPE_FISH == pItemData->GetType(), pItemData->GetName()));

  00181	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  00186	8b 4d fc	 mov	 ecx, DWORD PTR _pItemData$1[ebp]
  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType
  0018f	33 c9		 xor	 ecx, ecx
  00191	3c 0c		 cmp	 al, 12			; 0000000cH
  00193	0f 94 c1	 sete	 cl
  00196	51		 push	 ecx
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a5	50		 push	 eax
  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OABOAGML@OnFishingSuccess?$AA@
$LN31@RecvFishin:
  001ab	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  001b1	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@RecvFishin:

; 3856 : }

  001b9	5f		 pop	 edi
  001ba	b0 01		 mov	 al, 1
  001bc	5e		 pop	 esi
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
  001c1	8d 49 00	 npad	 3
$LN33@RecvFishin:
  001c4	00 00 00 00	 DD	 $LN14@RecvFishin
  001c8	00 00 00 00	 DD	 $LN13@RecvFishin
  001cc	00 00 00 00	 DD	 $LN11@RecvFishin
  001d0	00 00 00 00	 DD	 $LN9@RecvFishin
  001d4	00 00 00 00	 DD	 $LN8@RecvFishin
  001d8	00 00 00 00	 DD	 $LN6@RecvFishin
?RecvFishing@CPythonNetworkStream@@IAE_NXZ ENDP		; CPythonNetworkStream::RecvFishing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvDungeon@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_ulx$1 = -12						; size = 4
_uly$2 = -8						; size = 4
_DungeonPacket$ = -4					; size = 4
?RecvDungeon@CPythonNetworkStream@@IAE_NXZ PROC		; CPythonNetworkStream::RecvDungeon, COMDAT
; _this$ = ecx

; 3863 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3864 : 	TPacketGCDungeon DungeonPacket;
; 3865 : 	if (!Recv(sizeof(DungeonPacket), &DungeonPacket))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _DungeonPacket$[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	6a 04		 push	 4
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00014	84 c0		 test	 al, al
  00016	75 07		 jne	 SHORT $LN7@RecvDungeo
$LN12@RecvDungeo:

; 3866 : 		return false;

  00018	32 c0		 xor	 al, al

; 3888 : }

  0001a	5e		 pop	 esi
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN7@RecvDungeo:

; 3867 : 
; 3868 : 	switch (DungeonPacket.subheader)

  0001f	0f b6 45 ff	 movzx	 eax, BYTE PTR _DungeonPacket$[ebp+3]
  00023	48		 dec	 eax
  00024	75 33		 jne	 SHORT $LN5@RecvDungeo

; 3869 : 	{
; 3870 : 		case DUNGEON_SUBHEADER_GC_TIME_ATTACK_START:
; 3871 : 		{
; 3872 : 			break;
; 3873 : 		}
; 3874 : 		case DUNGEON_SUBHEADER_GC_DESTINATION_POSITION:
; 3875 : 		{
; 3876 : 			unsigned long ulx, uly;
; 3877 : 			if (!Recv(sizeof(ulx), &ulx))

  00026	8d 45 f4	 lea	 eax, DWORD PTR _ulx$1[ebp]
  00029	8b ce		 mov	 ecx, esi
  0002b	50		 push	 eax
  0002c	6a 04		 push	 4
  0002e	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00033	84 c0		 test	 al, al
  00035	74 e1		 je	 SHORT $LN12@RecvDungeo

; 3878 : 				return false;
; 3879 : 			if (!Recv(sizeof(uly), &uly))

  00037	8d 45 f8	 lea	 eax, DWORD PTR _uly$2[ebp]
  0003a	8b ce		 mov	 ecx, esi
  0003c	50		 push	 eax
  0003d	6a 04		 push	 4
  0003f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00044	84 c0		 test	 al, al
  00046	74 d0		 je	 SHORT $LN12@RecvDungeo

; 3880 : 				return false;
; 3881 : 
; 3882 : 			CPythonPlayer::Instance().SetDungeonDestinationPosition(ulx, uly);

  00048	ff 75 f8	 push	 DWORD PTR _uly$2[ebp]
  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00051	ff 75 f4	 push	 DWORD PTR _ulx$1[ebp]
  00054	e8 00 00 00 00	 call	 ?SetDungeonDestinationPosition@CPythonPlayer@@QAEXHH@Z ; CPythonPlayer::SetDungeonDestinationPosition
$LN5@RecvDungeo:

; 3883 : 			break;
; 3884 : 		}
; 3885 : 	}
; 3886 : 
; 3887 : 	return true;

  00059	b0 01		 mov	 al, 1

; 3888 : }

  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?RecvDungeon@CPythonNetworkStream@@IAE_NXZ ENDP		; CPythonNetworkStream::RecvDungeon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendBuildPrivateShopPacket@CPythonNetworkStream@@QAE_NPBDABV?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@@Z
_TEXT	SEGMENT
_packet$ = -40						; size = 35
__$ArrayPad$ = -4					; size = 4
_c_szName$ = 8						; size = 4
_c_rSellingItemStock$ = 12				; size = 4
?SendBuildPrivateShopPacket@CPythonNetworkStream@@QAE_NPBDABV?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@@Z PROC ; CPythonNetworkStream::SendBuildPrivateShopPacket, COMDAT
; _this$ = ecx

; 3895 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _c_szName$[ebp]
  00013	53		 push	 ebx
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _c_rSellingItemStock$[ebp]
  00018	8b d9		 mov	 ebx, ecx

; 3898 : 	strncpy(packet.szSign, c_szName, SHOP_SIGN_MAX_LEN);

  0001a	6a 20		 push	 32			; 00000020H
  0001c	50		 push	 eax
  0001d	8d 45 d9	 lea	 eax, DWORD PTR _packet$[ebp+1]
  00020	c6 45 d8 37	 mov	 BYTE PTR _packet$[ebp], 55 ; 00000037H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _strncpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0002a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0002d	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00032	2b 0f		 sub	 ecx, DWORD PTR [edi]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3898 : 	strncpy(packet.szSign, c_szName, SHOP_SIGN_MAX_LEN);

  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00037	f7 e9		 imul	 ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3900 : 	if (!Send(sizeof(packet), &packet))

  00039	8b cb		 mov	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0003b	c1 fa 02	 sar	 edx, 2
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00043	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3899 : 	packet.bCount = c_rSellingItemStock.size();

  00045	88 45 fa	 mov	 BYTE PTR _packet$[ebp+34], al

; 3900 : 	if (!Send(sizeof(packet), &packet))

  00048	8d 45 d8	 lea	 eax, DWORD PTR _packet$[ebp]
  0004b	50		 push	 eax
  0004c	6a 23		 push	 35			; 00000023H
  0004e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00053	84 c0		 test	 al, al
  00055	75 12		 jne	 SHORT $LN5@SendBuildP
  00057	5f		 pop	 edi
  00058	5b		 pop	 ebx

; 3911 : }

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	33 cd		 xor	 ecx, ebp
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
$LN5@SendBuildP:
  00069	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  0006a	8b 37		 mov	 esi, DWORD PTR [edi]

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);

  0006c	3b 77 04	 cmp	 esi, DWORD PTR [edi+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3903 : 	for (std::vector<TShopItemTable>::const_iterator itor = c_rSellingItemStock.begin(); itor < c_rSellingItemStock.end(); ++itor)

  0006f	73 16		 jae	 SHORT $LN2@SendBuildP
$LL16@SendBuildP:

; 3904 : 	{
; 3905 : 		const TShopItemTable & c_rItem = *itor;
; 3906 : 		if (!Send(sizeof(c_rItem), &c_rItem))

  00071	56		 push	 esi
  00072	6a 0d		 push	 13			; 0000000dH
  00074	8b cb		 mov	 ecx, ebx
  00076	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0007b	84 c0		 test	 al, al
  0007d	74 22		 je	 SHORT $LN31@SendBuildP
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

  0007f	83 c6 0d	 add	 esi, 13			; 0000000dH

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);

  00082	3b 77 04	 cmp	 esi, DWORD PTR [edi+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 3903 : 	for (std::vector<TShopItemTable>::const_iterator itor = c_rSellingItemStock.begin(); itor < c_rSellingItemStock.end(); ++itor)

  00085	72 ea		 jb	 SHORT $LL16@SendBuildP
$LN2@SendBuildP:

; 3907 : 			return false;
; 3908 : 	}
; 3909 : 
; 3910 : 	return SendSequence();

  00087	8b cb		 mov	 ecx, ebx
  00089	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0008e	5e		 pop	 esi
  0008f	5f		 pop	 edi
  00090	5b		 pop	 ebx

; 3911 : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
$LN31@SendBuildP:
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a4	32 c0		 xor	 al, al
  000a6	5e		 pop	 esi
  000a7	5f		 pop	 edi
  000a8	33 cd		 xor	 ecx, ebp
  000aa	5b		 pop	 ebx
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
?SendBuildPrivateShopPacket@CPythonNetworkStream@@QAE_NPBDABV?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@@Z ENDP ; CPythonNetworkStream::SendBuildPrivateShopPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvShopSignPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_p$ = -44						; size = 38
__$ArrayPad$ = -4					; size = 4
?RecvShopSignPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvShopSignPacket, COMDAT
; _this$ = ecx

; 3914 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 3915 : 	TPacketGCShopSign p;
; 3916 : 	if (!Recv(sizeof(TPacketGCShopSign), &p))

  00011	8d 45 d4	 lea	 eax, DWORD PTR _p$[ebp]
  00014	8b f9		 mov	 edi, ecx
  00016	50		 push	 eax
  00017	6a 26		 push	 38			; 00000026H
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN5@RecvShopSi
  00022	5f		 pop	 edi

; 3943 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN5@RecvShopSi:

; 3917 : 		return false;
; 3918 : 
; 3919 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 3920 : 	
; 3921 : 	if (0 == strlen(p.szSign))

  00031	8d 4d d9	 lea	 ecx, DWORD PTR _p$[ebp+5]
  00034	56		 push	 esi
  00035	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0003b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0003e	8b ff		 npad	 2
$LL10@RecvShopSi:
  00040	8a 01		 mov	 al, BYTE PTR [ecx]
  00042	41		 inc	 ecx
  00043	84 c0		 test	 al, al
  00045	75 f9		 jne	 SHORT $LL10@RecvShopSi
  00047	2b ca		 sub	 ecx, edx
  00049	75 4d		 jne	 SHORT $LN4@RecvShopSi

; 3922 : 	{
; 3923 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 3924 : 			"BINARY_PrivateShop_Disappear", 
; 3925 : 			Py_BuildValue("(i)", p.dwVID)
; 3926 : 		);

  0004b	ff 75 d5	 push	 DWORD PTR _p$[ebp+1]
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00059	50		 push	 eax
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BEOHMMCM@BINARY_PrivateShop_Disappear?$AA@
  0005f	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00065	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 3927 : 
; 3928 : 		if (rkPlayer.IsMainCharacterIndex(p.dwVID))

  0006a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0006d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00070	83 c4 14	 add	 esp, 20			; 00000014H
  00073	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00076	ff 75 d5	 push	 DWORD PTR _p$[ebp+1]
  00079	ff d0		 call	 eax
  0007b	84 c0		 test	 al, al
  0007d	74 58		 je	 SHORT $LN1@RecvShopSi

; 3929 : 			rkPlayer.ClosePrivateShop();

  0007f	8b ce		 mov	 ecx, esi
  00081	e8 00 00 00 00	 call	 ?ClosePrivateShop@CPythonPlayer@@QAEXXZ ; CPythonPlayer::ClosePrivateShop
  00086	5e		 pop	 esi

; 3940 : 	}
; 3941 : 
; 3942 : 	return true;

  00087	b0 01		 mov	 al, 1
  00089	5f		 pop	 edi

; 3943 : }

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
$LN4@RecvShopSi:

; 3930 : 	}
; 3931 : 	else
; 3932 : 	{
; 3933 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 3934 : 			"BINARY_PrivateShop_Appear", 
; 3935 : 			Py_BuildValue("(is)", p.dwVID, p.szSign)
; 3936 : 		);

  00098	8d 45 d9	 lea	 eax, DWORD PTR _p$[ebp+5]
  0009b	50		 push	 eax
  0009c	ff 75 d5	 push	 DWORD PTR _p$[ebp+1]
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000aa	50		 push	 eax
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CKEFNKBC@BINARY_PrivateShop_Appear?$AA@
  000b0	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  000b6	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 3937 : 
; 3938 : 		if (rkPlayer.IsMainCharacterIndex(p.dwVID))

  000bb	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000be	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000c1	83 c4 18	 add	 esp, 24			; 00000018H
  000c4	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000c7	ff 75 d5	 push	 DWORD PTR _p$[ebp+1]
  000ca	ff d0		 call	 eax
  000cc	84 c0		 test	 al, al
  000ce	74 07		 je	 SHORT $LN1@RecvShopSi

; 3939 : 			rkPlayer.OpenPrivateShop();

  000d0	8b ce		 mov	 ecx, esi
  000d2	e8 00 00 00 00	 call	 ?OpenPrivateShop@CPythonPlayer@@QAEXXZ ; CPythonPlayer::OpenPrivateShop
$LN1@RecvShopSi:

; 3943 : }

  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	b0 01		 mov	 al, 1
  000dc	5e		 pop	 esi
  000dd	33 cd		 xor	 ecx, ebp
  000df	5f		 pop	 edi
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?RecvShopSignPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvShopSignPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvTimePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_TimePacket$ = -8					; size = 5
?RecvTimePacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvTimePacket, COMDAT
; _this$ = ecx

; 3947 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3948 : 	TPacketGCTime TimePacket;
; 3949 : 	if (!Recv(sizeof(TimePacket), &TimePacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _TimePacket$[ebp]
  00009	50		 push	 eax
  0000a	6a 05		 push	 5
  0000c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00011	84 c0		 test	 al, al
  00013	75 04		 jne	 SHORT $LN1@RecvTimePa

; 3956 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN1@RecvTimePa:

; 3950 : 		return false;
; 3951 : 
; 3952 : 	IAbstractApplication& rkApp=IAbstractApplication::GetSingleton();

  00019	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A ; TAbstractSingleton<IAbstractApplication>::ms_singleton

; 3953 : 	rkApp.SetServerTime(TimePacket.time);

  0001f	ff 75 f9	 push	 DWORD PTR _TimePacket$[ebp+1]
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	ff 50 14	 call	 DWORD PTR [eax+20]

; 3954 : 
; 3955 : 	return true;

  00027	b0 01		 mov	 al, 1

; 3956 : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?RecvTimePacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvTimePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvWalkModePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_WalkModePacket$ = -8					; size = 6
?RecvWalkModePacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvWalkModePacket, COMDAT
; _this$ = ecx

; 3959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3960 : 	TPacketGCWalkMode WalkModePacket;
; 3961 : 	if (!Recv(sizeof(WalkModePacket), &WalkModePacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _WalkModePacket$[ebp]
  00009	50		 push	 eax
  0000a	6a 06		 push	 6
  0000c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00011	84 c0		 test	 al, al
  00013	75 04		 jne	 SHORT $LN4@RecvWalkMo

; 3978 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN4@RecvWalkMo:

; 3962 : 		return false;
; 3963 : 
; 3964 : 	CInstanceBase * pInstance = CPythonCharacterManager::Instance().GetInstancePtr(WalkModePacket.vid);

  00019	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0001f	ff 75 f9	 push	 DWORD PTR _WalkModePacket$[ebp+1]
  00022	83 c1 04	 add	 ecx, 4
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	ff 50 08	 call	 DWORD PTR [eax+8]

; 3965 : 	if (pInstance)

  0002a	85 c0		 test	 eax, eax
  0002c	74 18		 je	 SHORT $LN1@RecvWalkMo

; 3966 : 	{
; 3967 : 		if (WALKMODE_RUN == WalkModePacket.mode)

  0002e	80 7d fd 00	 cmp	 BYTE PTR _WalkModePacket$[ebp+5], 0

; 3968 : 		{
; 3969 : 			pInstance->SetRunMode();

  00032	8b c8		 mov	 ecx, eax
  00034	75 0b		 jne	 SHORT $LN2@RecvWalkMo
  00036	e8 00 00 00 00	 call	 ?SetRunMode@CInstanceBase@@QAEXXZ ; CInstanceBase::SetRunMode

; 3974 : 		}
; 3975 : 	}
; 3976 : 
; 3977 : 	return true;

  0003b	b0 01		 mov	 al, 1

; 3978 : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN2@RecvWalkMo:

; 3970 : 		}
; 3971 : 		else
; 3972 : 		{
; 3973 : 			pInstance->SetWalkMode();

  00041	e8 00 00 00 00	 call	 ?SetWalkMode@CInstanceBase@@QAEXXZ ; CInstanceBase::SetWalkMode
$LN1@RecvWalkMo:

; 3974 : 		}
; 3975 : 	}
; 3976 : 
; 3977 : 	return true;

  00046	b0 01		 mov	 al, 1

; 3978 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?RecvWalkModePacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvWalkModePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvChangeSkillGroupPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_ChangeSkillGroup$ = -4					; size = 2
?RecvChangeSkillGroupPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvChangeSkillGroupPacket, COMDAT
; _this$ = ecx

; 3981 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 3982 : 	TPacketGCChangeSkillGroup ChangeSkillGroup;
; 3983 : 	if (!Recv(sizeof(ChangeSkillGroup), &ChangeSkillGroup))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _ChangeSkillGroup$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 02		 push	 2
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 05		 jne	 SHORT $LN1@RecvChange
  00016	5e		 pop	 esi

; 3991 : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN1@RecvChange:

; 3984 : 		return false;
; 3985 : 
; 3986 : 	m_dwMainActorSkillGroup = ChangeSkillGroup.skill_group;

  0001b	0f b6 45 fd	 movzx	 eax, BYTE PTR _ChangeSkillGroup$[ebp+1]

; 3987 : 
; 3988 : 	CPythonPlayer::Instance().NEW_ClearSkillData();

  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00025	6a 00		 push	 0
  00027	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  0002d	e8 00 00 00 00	 call	 ?NEW_ClearSkillData@CPythonPlayer@@QAEX_N@Z ; CPythonPlayer::NEW_ClearSkillData

; 3989 : 	__RefreshCharacterWindow();

  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?__RefreshCharacterWindow@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshCharacterWindow

; 3990 : 	return true;

  00039	b0 01		 mov	 al, 1
  0003b	5e		 pop	 esi

; 3991 : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?RecvChangeSkillGroupPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvChangeSkillGroupPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvRefineInformationPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kRefineInfoPacket$ = -64				; size = 59
__$ArrayPad$ = -4					; size = 4
?RecvRefineInformationPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvRefineInformationPacket, COMDAT
; _this$ = ecx

; 4027 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 4028 : 	TPacketGCRefineInformation kRefineInfoPacket;
; 4029 : 	if (!Recv(sizeof(kRefineInfoPacket), &kRefineInfoPacket))

  00011	8d 45 c0	 lea	 eax, DWORD PTR _kRefineInfoPacket$[ebp]
  00014	8b f9		 mov	 edi, ecx
  00016	50		 push	 eax
  00017	6a 3b		 push	 59			; 0000003bH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN4@RecvRefine
  00022	5f		 pop	 edi

; 4044 : 	}
; 4045 : 
; 4046 : #ifdef _DEBUG
; 4047 : 	Tracef(" >> RecvRefineInformationPacket(pos=%d, result_vnum=%d, cost=%d, prob=%d)\n",
; 4048 : 														kRefineInfoPacket.pos,
; 4049 : 														kRefineInfoPacket.refine_table.result_vnum,
; 4050 : 														rkRefineTable.cost,
; 4051 : 														rkRefineTable.prob);
; 4052 : #endif
; 4053 : 
; 4054 : 	return true;
; 4055 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN4@RecvRefine:

; 4030 : 		return false;
; 4031 : 
; 4032 : 	TRefineTable & rkRefineTable = kRefineInfoPacket.refine_table;
; 4033 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 4034 : 		"OpenRefineDialog", 
; 4035 : 		Py_BuildValue("(iiii)", 
; 4036 : 			kRefineInfoPacket.pos, 
; 4037 : 			kRefineInfoPacket.refine_table.result_vnum, 
; 4038 : 			rkRefineTable.cost, 
; 4039 : 			rkRefineTable.prob));

  00031	0f b6 45 c1	 movzx	 eax, BYTE PTR _kRefineInfoPacket$[ebp+1]
  00035	53		 push	 ebx
  00036	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__Py_BuildValue
  0003c	56		 push	 esi
  0003d	ff 75 cf	 push	 DWORD PTR _kRefineInfoPacket$[ebp+15]
  00040	ff 75 cb	 push	 DWORD PTR _kRefineInfoPacket$[ebp+11]
  00043	ff 75 c6	 push	 DWORD PTR _kRefineInfoPacket$[ebp+6]
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_06GAHGMLBJ@?$CIiiii?$CJ?$AA@
  0004c	ff d3		 call	 ebx
  0004e	50		 push	 eax
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CHHJLMHC@OpenRefineDialog?$AA@
  00054	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  0005a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0005f	83 c4 20	 add	 esp, 32			; 00000020H

; 4040 : 
; 4041 : 	for (int i = 0; i < rkRefineTable.material_count; ++i)

  00062	33 f6		 xor	 esi, esi
  00064	80 7d ca 00	 cmp	 BYTE PTR _kRefineInfoPacket$[ebp+10], 0
  00068	76 32		 jbe	 SHORT $LN1@RecvRefine
  0006a	8d 9b 00 00 00
	00		 npad	 6
$LL3@RecvRefine:

; 4042 : 	{
; 4043 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AppendMaterialToRefineDialog", Py_BuildValue("(ii)", rkRefineTable.materials[i].vnum, rkRefineTable.materials[i].count));

  00070	ff 74 f5 d7	 push	 DWORD PTR _kRefineInfoPacket$[ebp+esi*8+23]
  00074	ff 74 f5 d3	 push	 DWORD PTR _kRefineInfoPacket$[ebp+esi*8+19]
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  0007d	ff d3		 call	 ebx
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KLPAAKFJ@AppendMaterialToRefineDialog?$AA@
  00085	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  0008b	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00090	0f b6 45 ca	 movzx	 eax, BYTE PTR _kRefineInfoPacket$[ebp+10]
  00094	46		 inc	 esi
  00095	83 c4 18	 add	 esp, 24			; 00000018H
  00098	3b f0		 cmp	 esi, eax
  0009a	7c d4		 jl	 SHORT $LL3@RecvRefine
$LN1@RecvRefine:

; 4044 : 	}
; 4045 : 
; 4046 : #ifdef _DEBUG
; 4047 : 	Tracef(" >> RecvRefineInformationPacket(pos=%d, result_vnum=%d, cost=%d, prob=%d)\n",
; 4048 : 														kRefineInfoPacket.pos,
; 4049 : 														kRefineInfoPacket.refine_table.result_vnum,
; 4050 : 														rkRefineTable.cost,
; 4051 : 														rkRefineTable.prob);
; 4052 : #endif
; 4053 : 
; 4054 : 	return true;
; 4055 : }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	b0 01		 mov	 al, 1
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	33 cd		 xor	 ecx, ebp
  000a5	5f		 pop	 edi
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?RecvRefineInformationPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvRefineInformationPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvRefineInformationPacketNew@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kRefineInfoPacket$ = -64				; size = 60
__$ArrayPad$ = -4					; size = 4
?RecvRefineInformationPacketNew@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvRefineInformationPacketNew, COMDAT
; _this$ = ecx

; 4058 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 4059 : 	TPacketGCRefineInformationNew kRefineInfoPacket;
; 4060 : 	if (!Recv(sizeof(kRefineInfoPacket), &kRefineInfoPacket))

  00011	8d 45 c0	 lea	 eax, DWORD PTR _kRefineInfoPacket$[ebp]
  00014	8b f9		 mov	 edi, ecx
  00016	50		 push	 eax
  00017	6a 3c		 push	 60			; 0000003cH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN4@RecvRefine
  00022	5f		 pop	 edi

; 4077 : 	}
; 4078 : 
; 4079 : #ifdef _DEBUG
; 4080 : 	Tracef(" >> RecvRefineInformationPacketNew(pos=%d, result_vnum=%d, cost=%d, prob=%d, type=%d)\n",
; 4081 : 														kRefineInfoPacket.pos,
; 4082 : 														kRefineInfoPacket.refine_table.result_vnum,
; 4083 : 														rkRefineTable.cost,
; 4084 : 														rkRefineTable.prob,
; 4085 : 														kRefineInfoPacket.type);
; 4086 : #endif
; 4087 : 
; 4088 : 	return true;
; 4089 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN4@RecvRefine:

; 4061 : 		return false;
; 4062 : 
; 4063 : 	TRefineTable & rkRefineTable = kRefineInfoPacket.refine_table;
; 4064 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 4065 : 		"OpenRefineDialog", 
; 4066 : 		Py_BuildValue("(iiiii)", 
; 4067 : 			kRefineInfoPacket.pos, 
; 4068 : 			kRefineInfoPacket.refine_table.result_vnum, 
; 4069 : 			rkRefineTable.cost, 
; 4070 : 			rkRefineTable.prob, 
; 4071 : 			kRefineInfoPacket.type)
; 4072 : 		);

  00031	0f b6 45 c1	 movzx	 eax, BYTE PTR _kRefineInfoPacket$[ebp+1]
  00035	53		 push	 ebx
  00036	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__Py_BuildValue
  0003c	56		 push	 esi
  0003d	50		 push	 eax
  0003e	ff 75 d0	 push	 DWORD PTR _kRefineInfoPacket$[ebp+16]
  00041	0f b6 45 c2	 movzx	 eax, BYTE PTR _kRefineInfoPacket$[ebp+2]
  00045	ff 75 cc	 push	 DWORD PTR _kRefineInfoPacket$[ebp+12]
  00048	ff 75 c7	 push	 DWORD PTR _kRefineInfoPacket$[ebp+7]
  0004b	50		 push	 eax
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_07FANHMMCA@?$CIiiiii?$CJ?$AA@
  00051	ff d3		 call	 ebx
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CHHJLMHC@OpenRefineDialog?$AA@
  00059	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  0005f	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00064	83 c4 24	 add	 esp, 36			; 00000024H

; 4073 : 
; 4074 : 	for (int i = 0; i < rkRefineTable.material_count; ++i)

  00067	33 f6		 xor	 esi, esi
  00069	80 7d cb 00	 cmp	 BYTE PTR _kRefineInfoPacket$[ebp+11], 0
  0006d	76 2d		 jbe	 SHORT $LN1@RecvRefine
  0006f	90		 npad	 1
$LL3@RecvRefine:

; 4075 : 	{
; 4076 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "AppendMaterialToRefineDialog", Py_BuildValue("(ii)", rkRefineTable.materials[i].vnum, rkRefineTable.materials[i].count));

  00070	ff 74 f5 d8	 push	 DWORD PTR _kRefineInfoPacket$[ebp+esi*8+24]
  00074	ff 74 f5 d4	 push	 DWORD PTR _kRefineInfoPacket$[ebp+esi*8+20]
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  0007d	ff d3		 call	 ebx
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KLPAAKFJ@AppendMaterialToRefineDialog?$AA@
  00085	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  0008b	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00090	0f b6 45 cb	 movzx	 eax, BYTE PTR _kRefineInfoPacket$[ebp+11]
  00094	46		 inc	 esi
  00095	83 c4 18	 add	 esp, 24			; 00000018H
  00098	3b f0		 cmp	 esi, eax
  0009a	7c d4		 jl	 SHORT $LL3@RecvRefine
$LN1@RecvRefine:

; 4077 : 	}
; 4078 : 
; 4079 : #ifdef _DEBUG
; 4080 : 	Tracef(" >> RecvRefineInformationPacketNew(pos=%d, result_vnum=%d, cost=%d, prob=%d, type=%d)\n",
; 4081 : 														kRefineInfoPacket.pos,
; 4082 : 														kRefineInfoPacket.refine_table.result_vnum,
; 4083 : 														rkRefineTable.cost,
; 4084 : 														rkRefineTable.prob,
; 4085 : 														kRefineInfoPacket.type);
; 4086 : #endif
; 4087 : 
; 4088 : 	return true;
; 4089 : }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	b0 01		 mov	 al, 1
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	33 cd		 xor	 ecx, ebp
  000a5	5f		 pop	 edi
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?RecvRefineInformationPacketNew@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvRefineInformationPacketNew
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvNPCList@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kNPCPosition$ = -48					; size = 5
_NPCPosition$1 = -40					; size = 34
__$ArrayPad$ = -4					; size = 4
?RecvNPCList@CPythonNetworkStream@@IAE_NXZ PROC		; CPythonNetworkStream::RecvNPCList, COMDAT
; _this$ = ecx

; 4092 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 4093 : 	TPacketGCNPCPosition kNPCPosition;
; 4094 : 	if (!Recv(sizeof(kNPCPosition), &kNPCPosition))

  00011	8d 45 d0	 lea	 eax, DWORD PTR _kNPCPosition$[ebp]
  00014	8b f9		 mov	 edi, ecx
  00016	50		 push	 eax
  00017	6a 05		 push	 5
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN5@RecvNPCLis
  00022	5f		 pop	 edi

; 4111 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN5@RecvNPCLis:

; 4095 : 		return false;
; 4096 : 
; 4097 : 	assert(int(kNPCPosition.size)-sizeof(kNPCPosition) == kNPCPosition.count*sizeof(TNPCPosition) && "HEADER_GC_NPC_POSITION");
; 4098 : 
; 4099 : 	CPythonMiniMap::Instance().ClearAtlasMarkInfo();

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ?ClearAtlasMarkInfo@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ClearAtlasMarkInfo

; 4100 : 
; 4101 : 	for (int i = 0; i < kNPCPosition.count; ++i)

  0003d	33 c0		 xor	 eax, eax
  0003f	33 f6		 xor	 esi, esi
  00041	66 3b 45 d3	 cmp	 ax, WORD PTR _kNPCPosition$[ebp+3]
  00045	73 32		 jae	 SHORT $LN2@RecvNPCLis
$LL4@RecvNPCLis:

; 4102 : 	{
; 4103 : 		TNPCPosition NPCPosition;
; 4104 : 		if (!Recv(sizeof(TNPCPosition), &NPCPosition))

  00047	8d 45 d8	 lea	 eax, DWORD PTR _NPCPosition$1[ebp]
  0004a	8b cf		 mov	 ecx, edi
  0004c	50		 push	 eax
  0004d	6a 22		 push	 34			; 00000022H
  0004f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00054	84 c0		 test	 al, al
  00056	74 33		 je	 SHORT $LN13@RecvNPCLis

; 4105 : 			return false;
; 4106 : 
; 4107 : 		CPythonMiniMap::Instance().RegisterAtlasMark(NPCPosition.bType, NPCPosition.name, NPCPosition.x, NPCPosition.y);

  00058	ff 75 f6	 push	 DWORD PTR _NPCPosition$1[ebp+30]
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00061	8d 45 d9	 lea	 eax, DWORD PTR _NPCPosition$1[ebp+1]
  00064	ff 75 f2	 push	 DWORD PTR _NPCPosition$1[ebp+26]
  00067	50		 push	 eax
  00068	ff 75 d8	 push	 DWORD PTR _NPCPosition$1[ebp]
  0006b	e8 00 00 00 00	 call	 ?RegisterAtlasMark@CPythonMiniMap@@QAEXEPBDJJ@Z ; CPythonMiniMap::RegisterAtlasMark
  00070	0f b7 45 d3	 movzx	 eax, WORD PTR _kNPCPosition$[ebp+3]
  00074	46		 inc	 esi
  00075	3b f0		 cmp	 esi, eax
  00077	7c ce		 jl	 SHORT $LL4@RecvNPCLis
$LN2@RecvNPCLis:
  00079	5e		 pop	 esi

; 4108 : 	}
; 4109 : 
; 4110 : 	return true;

  0007a	b0 01		 mov	 al, 1
  0007c	5f		 pop	 edi

; 4111 : }

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00080	33 cd		 xor	 ecx, ebp
  00082	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN13@RecvNPCLis:
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	32 c0		 xor	 al, al
  00090	5e		 pop	 esi
  00091	33 cd		 xor	 ecx, ebp
  00093	5f		 pop	 edi
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?RecvNPCList@CPythonNetworkStream@@IAE_NXZ ENDP		; CPythonNetworkStream::RecvNPCList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_filename$ = -144					; size = 24
$T2 = -120						; size = 24
_kVersionPacket$3 = -96					; size = 67
_kVersionPacket$4 = -96					; size = 67
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::SendClientVersionPacket, COMDAT
; _this$ = ecx

; 4143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 80 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+148], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 98 00
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+164]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00042	c7 44 24 28 0f
	00 00 00	 mov	 DWORD PTR _filename$[esp+184], 15 ; 0000000fH

; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0004a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _filename$[esp+180], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00052	c6 44 24 14 00	 mov	 BYTE PTR _filename$[esp+164], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4146 : 	GetExcutedFileName(filename);

  00057	8d 44 24 14	 lea	 eax, DWORD PTR _filename$[esp+164]
  0005b	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+172], 0
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?GetExcutedFileName@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetExcutedFileName

; 4147 : 
; 4148 : 	filename = CFileNameHelper::NoPath(filename);

  0006c	8d 44 24 18	 lea	 eax, DWORD PTR _filename$[esp+168]
  00070	50		 push	 eax
  00071	8d 44 24 34	 lea	 eax, DWORD PTR $T2[esp+172]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?NoPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::NoPath
  0007b	8b f8		 mov	 edi, eax
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 903  : 		if (this != &_Right)

  00080	8d 44 24 14	 lea	 eax, DWORD PTR _filename$[esp+164]
  00084	3b c7		 cmp	 eax, edi
  00086	74 32		 je	 SHORT $LN47@SendClient

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00088	83 7c 24 28 10	 cmp	 DWORD PTR _filename$[esp+184], 16 ; 00000010H
  0008d	72 0c		 jb	 SHORT $LN71@SendClient
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0008f	ff 74 24 14	 push	 DWORD PTR _filename$[esp+164]
  00093	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00098	83 c4 04	 add	 esp, 4
$LN71@SendClient:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  0009b	57		 push	 edi
  0009c	8d 4c 24 18	 lea	 ecx, DWORD PTR _filename$[esp+168]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000a0	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR _filename$[esp+188], 15 ; 0000000fH

; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000a8	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _filename$[esp+184], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000b0	c6 44 24 18 00	 mov	 BYTE PTR _filename$[esp+168], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  000b5	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN47@SendClient:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000ba	83 7c 24 40 10	 cmp	 DWORD PTR $T2[esp+184], 16 ; 00000010H
  000bf	72 0c		 jb	 SHORT $LN181@SendClient
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000c1	ff 74 24 2c	 push	 DWORD PTR $T2[esp+164]
  000c5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ca	83 c4 04	 add	 esp, 4
$LN181@SendClient:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4149 : 	CFileNameHelper::ChangeDosPath(filename);

  000cd	8d 44 24 14	 lea	 eax, DWORD PTR _filename$[esp+164]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?ChangeDosPath@CFileNameHelper@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CFileNameHelper::ChangeDosPath
  000d7	83 c4 04	 add	 esp, 4

; 4150 : 
; 4151 : 	if (LocaleService_IsEUROPE() && false == LocaleService_IsYMIR())

  000da	e8 00 00 00 00	 call	 ?LocaleService_IsEUROPE@@YA_NXZ ; LocaleService_IsEUROPE
  000df	84 c0		 test	 al, al
  000e1	74 32		 je	 SHORT $LN4@SendClient
  000e3	e8 00 00 00 00	 call	 ?LocaleService_IsYMIR@@YA_NXZ ; LocaleService_IsYMIR
  000e8	84 c0		 test	 al, al
  000ea	75 29		 jne	 SHORT $LN4@SendClient
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000ec	83 7c 24 28 10	 cmp	 DWORD PTR _filename$[esp+184], 16 ; 00000010H
  000f1	8d 44 24 14	 lea	 eax, DWORD PTR _filename$[esp+164]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4155 : 		strncpy(kVersionPacket.filename, filename.c_str(), sizeof(kVersionPacket.filename)-1);

  000f5	6a 20		 push	 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000f7	0f 43 44 24 18	 cmovae	 eax, DWORD PTR _filename$[esp+168]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4155 : 		strncpy(kVersionPacket.filename, filename.c_str(), sizeof(kVersionPacket.filename)-1);

  000fc	50		 push	 eax
  000fd	8d 44 24 4d	 lea	 eax, DWORD PTR _kVersionPacket$4[esp+173]
  00101	c6 44 24 4c f1	 mov	 BYTE PTR _kVersionPacket$4[esp+172], 241 ; 000000f1H
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _strncpy

; 4156 : 		strncpy(kVersionPacket.timestamp, "1215955205", sizeof(kVersionPacket.timestamp)-1); // # python time.time 

  0010c	6a 20		 push	 32			; 00000020H
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DJAIFHCH@1215955205?$AA@

; 4157 : 		//strncpy(kVersionPacket.timestamp, __TIMESTAMP__, sizeof(kVersionPacket.timestamp)-1); // old_string_ver
; 4158 : 		//strncpy(kVersionPacket.timestamp, "1218055205", sizeof(kVersionPacket.timestamp)-1); // new_future
; 4159 : 		//strncpy(kVersionPacket.timestamp, "1214055205", sizeof(kVersionPacket.timestamp)-1); // old_past
; 4160 : 
; 4161 : 		if (!Send(sizeof(kVersionPacket), &kVersionPacket))
; 4162 : 			Tracef("SendClientReportPacket Error");
; 4163 : 	}
; 4164 : 	else

  00113	eb 27		 jmp	 SHORT $LN244@SendClient
$LN4@SendClient:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00115	83 7c 24 28 10	 cmp	 DWORD PTR _filename$[esp+184], 16 ; 00000010H
  0011a	8d 44 24 14	 lea	 eax, DWORD PTR _filename$[esp+164]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4168 : 		strncpy(kVersionPacket.filename, filename.c_str(), sizeof(kVersionPacket.filename)-1);

  0011e	6a 20		 push	 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00120	0f 43 44 24 18	 cmovae	 eax, DWORD PTR _filename$[esp+168]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4168 : 		strncpy(kVersionPacket.filename, filename.c_str(), sizeof(kVersionPacket.filename)-1);

  00125	50		 push	 eax
  00126	8d 44 24 4d	 lea	 eax, DWORD PTR _kVersionPacket$3[esp+173]
  0012a	c6 44 24 4c fd	 mov	 BYTE PTR _kVersionPacket$3[esp+172], 253 ; 000000fdH
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _strncpy

; 4169 : 		strncpy(kVersionPacket.timestamp, __TIMESTAMP__, sizeof(kVersionPacket.timestamp)-1);

  00135	6a 20		 push	 32			; 00000020H
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@FBHNPCOP@Fri?5Sep?527?521?356?350?52013?$AA@
$LN244@SendClient:
  0013c	8d 44 24 7a	 lea	 eax, DWORD PTR _kVersionPacket$3[esp+218]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _strncpy
  00146	83 c4 18	 add	 esp, 24			; 00000018H

; 4170 : 
; 4171 : 		if (!Send(sizeof(kVersionPacket), &kVersionPacket))

  00149	8d 44 24 44	 lea	 eax, DWORD PTR _kVersionPacket$3[esp+164]
  0014d	8b ce		 mov	 ecx, esi
  0014f	50		 push	 eax
  00150	6a 43		 push	 67			; 00000043H
  00152	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00157	84 c0		 test	 al, al
  00159	75 0d		 jne	 SHORT $LN1@SendClient

; 4172 : 			Tracef("SendClientReportPacket Error");

  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PKCCDLMA@SendClientReportPacket?5Error?$AA@
  00160	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00165	83 c4 04	 add	 esp, 4
$LN1@SendClient:

; 4174 : 	return SendSequence();

  00168	8b ce		 mov	 ecx, esi
  0016a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0016f	83 7c 24 28 10	 cmp	 DWORD PTR _filename$[esp+184], 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4174 : 	return SendSequence();

  00174	8a d8		 mov	 bl, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00176	72 0c		 jb	 SHORT $LN241@SendClient
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00178	ff 74 24 14	 push	 DWORD PTR _filename$[esp+164]
  0017c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00181	83 c4 04	 add	 esp, 4
$LN241@SendClient:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4174 : 	return SendSequence();

  00184	8a c3		 mov	 al, bl

; 4175 : }

  00186	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+164]
  0018d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00194	59		 pop	 ecx
  00195	5f		 pop	 edi
  00196	5e		 pop	 esi
  00197	5b		 pop	 ebx
  00198	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+148]
  0019f	33 cc		 xor	 ecx, esp
  001a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a6	8b e5		 mov	 esp, ebp
  001a8	5d		 pop	 ebp
  001a9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ$0:
  00000	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _filename$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 82 6c ff ff
	ff		 lea	 eax, DWORD PTR [edx-148]
  00015	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	83 c0 0c	 add	 eax, 12			; 0000000cH
  00025	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::SendClientVersionPacket
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvAffectAddPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kAffectAdd$ = -28					; size = 22
__$ArrayPad$ = -4					; size = 4
?RecvAffectAddPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvAffectAddPacket, COMDAT
; _this$ = ecx

; 4178 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 4179 : 	TPacketGCAffectAdd kAffectAdd;
; 4180 : 	if (!Recv(sizeof(kAffectAdd), &kAffectAdd))

  00011	8d 45 e4	 lea	 eax, DWORD PTR _kAffectAdd$[ebp]
  00014	8b f9		 mov	 edi, ecx
  00016	50		 push	 eax
  00017	6a 16		 push	 22			; 00000016H
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN2@RecvAffect
  00022	5f		 pop	 edi

; 4190 : 
; 4191 : 	return true;
; 4192 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN2@RecvAffect:

; 4181 : 		return false;
; 4182 : 
; 4183 : 	TPacketAffectElement & rkElement = kAffectAdd.elem;
; 4184 : 	if (rkElement.bPointIdxApplyOn == POINT_ENERGY)

  00031	8a 45 e9	 mov	 al, BYTE PTR _kAffectAdd$[ebp+5]
  00034	3c 80		 cmp	 al, 128			; 00000080H
  00036	75 2d		 jne	 SHORT $LN1@RecvAffect

; 4186 : 		CPythonPlayer::instance().SetStatus (POINT_ENERGY_END_TIME, CPythonApplication::Instance().GetServerTimeStamp() + rkElement.lDuration);

  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  0003e	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 38   : 		return (*ms_singleton);

  0003f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4186 : 		CPythonPlayer::instance().SetStatus (POINT_ENERGY_END_TIME, CPythonApplication::Instance().GetServerTimeStamp() + rkElement.lDuration);

  00045	e8 00 00 00 00	 call	 ?GetServerTimeStamp@CPythonApplication@@QAEJXZ ; CPythonApplication::GetServerTimeStamp
  0004a	03 45 f2	 add	 eax, DWORD PTR _kAffectAdd$[ebp+14]
  0004d	8b ce		 mov	 ecx, esi
  0004f	50		 push	 eax
  00050	68 81 00 00 00	 push	 129			; 00000081H
  00055	e8 00 00 00 00	 call	 ?SetStatus@CPythonPlayer@@QAEXKJ@Z ; CPythonPlayer::SetStatus

; 4187 : 		__RefreshStatus();

  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?__RefreshStatus@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__RefreshStatus
  00061	8a 45 e9	 mov	 al, BYTE PTR _kAffectAdd$[ebp+5]
  00064	5e		 pop	 esi
$LN1@RecvAffect:

; 4188 : 	}
; 4189 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_AddAffect", Py_BuildValue("(iiii)", rkElement.dwType, rkElement.bPointIdxApplyOn, rkElement.lApplyValue, rkElement.lDuration));

  00065	ff 75 f2	 push	 DWORD PTR _kAffectAdd$[ebp+14]
  00068	0f b6 c0	 movzx	 eax, al
  0006b	ff 75 ea	 push	 DWORD PTR _kAffectAdd$[ebp+6]
  0006e	50		 push	 eax
  0006f	ff 75 e5	 push	 DWORD PTR _kAffectAdd$[ebp+1]
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_06GAHGMLBJ@?$CIiiii?$CJ?$AA@
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DEMCFMHM@BINARY_NEW_AddAffect?$AA@
  00083	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00089	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 4190 : 
; 4191 : 	return true;
; 4192 : }

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	83 c4 20	 add	 esp, 32			; 00000020H
  00094	33 cd		 xor	 ecx, ebp
  00096	b0 01		 mov	 al, 1
  00098	5f		 pop	 edi
  00099	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?RecvAffectAddPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvAffectAddPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvAffectRemovePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kAffectRemove$ = -8					; size = 6
?RecvAffectRemovePacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvAffectRemovePacket, COMDAT
; _this$ = ecx

; 4195 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4196 : 	TPacketGCAffectRemove kAffectRemove;
; 4197 : 	if (!Recv(sizeof(kAffectRemove), &kAffectRemove))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _kAffectRemove$[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	6a 06		 push	 6
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00014	84 c0		 test	 al, al
  00016	75 05		 jne	 SHORT $LN1@RecvAffect
  00018	5e		 pop	 esi

; 4203 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN1@RecvAffect:

; 4198 : 		return false;
; 4199 : 
; 4200 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_NEW_RemoveAffect", Py_BuildValue("(ii)", kAffectRemove.dwType, kAffectRemove.bApplyOn));

  0001d	0f b6 45 fd	 movzx	 eax, BYTE PTR _kAffectRemove$[ebp+5]
  00021	50		 push	 eax
  00022	ff 75 f9	 push	 DWORD PTR _kAffectRemove$[ebp+1]
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00030	50		 push	 eax
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NIFEGIKP@BINARY_NEW_RemoveAffect?$AA@
  00036	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  0003c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00041	83 c4 18	 add	 esp, 24			; 00000018H

; 4201 : 
; 4202 : 	return true;

  00044	b0 01		 mov	 al, 1
  00046	5e		 pop	 esi

; 4203 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?RecvAffectRemovePacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvAffectRemovePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvChannelPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kChannelPacket$ = -4					; size = 2
?RecvChannelPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvChannelPacket, COMDAT
; _this$ = ecx

; 4206 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4207 : 	TPacketGCChannel kChannelPacket;
; 4208 : 	if (!Recv(sizeof(kChannelPacket), &kChannelPacket))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _kChannelPacket$[ebp]
  00007	50		 push	 eax
  00008	6a 02		 push	 2
  0000a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0000f	84 c0		 test	 al, al
  00011	0f 95 c0	 setne	 al

; 4209 : 		return false;
; 4210 : 
; 4211 : 	//Tracef(" >> CPythonNetworkStream::RecvChannelPacket(channel=%d)\n", kChannelPacket.channel);
; 4212 : 
; 4213 : 	return true;
; 4214 : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?RecvChannelPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvChannelPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvViewEquipPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -436					; size = 4
tv437 = -432						; size = 4
_kViewEquipPacket$ = -428				; size = 423
__$ArrayPad$ = -4					; size = 4
?RecvViewEquipPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvViewEquipPacket, COMDAT
; _this$ = ecx

; 4217 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 01 00
	00		 sub	 esp, 436		; 000001b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 4218 : 	TPacketGCViewEquip kViewEquipPacket;
; 4219 : 	if (!Recv(sizeof(kViewEquipPacket), &kViewEquipPacket))

  00014	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _kViewEquipPacket$[ebp]
  0001a	8b f1		 mov	 esi, ecx
  0001c	50		 push	 eax
  0001d	68 a7 01 00 00	 push	 423			; 000001a7H
  00022	89 b5 4c fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00028	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0002d	84 c0		 test	 al, al
  0002f	75 0f		 jne	 SHORT $LN10@RecvViewEq
  00031	5e		 pop	 esi

; 4234 : 	}
; 4235 : 
; 4236 : 	return true;
; 4237 : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN10@RecvViewEq:
  00040	53		 push	 ebx
  00041	57		 push	 edi

; 4220 : 		return false;
; 4221 : 
; 4222 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OpenEquipmentDialog", Py_BuildValue("(i)", kViewEquipPacket.dwVID));

  00042	ff b5 55 fe ff
	ff		 push	 DWORD PTR _kViewEquipPacket$[ebp+1]
  00048	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Py_BuildValue
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00053	ff d7		 call	 edi
  00055	50		 push	 eax
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@OLAMAMAK@OpenEquipmentDialog?$AA@
  0005b	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00061	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00066	8d 8d 5d fe ff
	ff		 lea	 ecx, DWORD PTR _kViewEquipPacket$[ebp+9]
  0006c	83 c4 14	 add	 esp, 20			; 00000014H

; 4223 : 
; 4224 : 	for (int i = 0; i < WEAR_MAX_NUM; ++i)

  0006f	33 db		 xor	 ebx, ebx
  00071	89 8d 50 fe ff
	ff		 mov	 DWORD PTR tv437[ebp], ecx
$LL9@RecvViewEq:

; 4225 : 	{
; 4226 : 		TEquipmentItemSet & rItemSet = kViewEquipPacket.equips[i];
; 4227 : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogItem", Py_BuildValue("(iiii)", kViewEquipPacket.dwVID, i, rItemSet.vnum, rItemSet.count));

  00077	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0007a	50		 push	 eax
  0007b	ff 71 fc	 push	 DWORD PTR [ecx-4]
  0007e	53		 push	 ebx
  0007f	ff b5 55 fe ff
	ff		 push	 DWORD PTR _kViewEquipPacket$[ebp+1]
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_06GAHGMLBJ@?$CIiiii?$CJ?$AA@
  0008a	ff d7		 call	 edi
  0008c	50		 push	 eax
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DIEBEMHE@SetEquipmentDialogItem?$AA@
  00092	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00098	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0009d	8b bd 50 fe ff
	ff		 mov	 edi, DWORD PTR tv437[ebp]
  000a3	83 c4 20	 add	 esp, 32			; 00000020H

; 4228 : 
; 4229 : 		for (int j = 0; j < ITEM_SOCKET_SLOT_MAX_NUM; ++j)

  000a6	33 f6		 xor	 esi, esi
  000a8	47		 inc	 edi
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL6@RecvViewEq:

; 4230 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogSocket", Py_BuildValue("(iiii)", kViewEquipPacket.dwVID, i, j, rItemSet.alSockets[j]));

  000b0	ff 37		 push	 DWORD PTR [edi]
  000b2	56		 push	 esi
  000b3	53		 push	 ebx
  000b4	ff b5 55 fe ff
	ff		 push	 DWORD PTR _kViewEquipPacket$[ebp+1]
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_06GAHGMLBJ@?$CIiiii?$CJ?$AA@
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000c5	50		 push	 eax
  000c6	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBOCKHJF@SetEquipmentDialogSocket?$AA@
  000d1	ff b0 90 01 00
	00		 push	 DWORD PTR [eax+400]
  000d7	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000dc	46		 inc	 esi
  000dd	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  000e0	83 c4 20	 add	 esp, 32			; 00000020H
  000e3	83 fe 03	 cmp	 esi, 3
  000e6	7c c8		 jl	 SHORT $LL6@RecvViewEq

; 4231 : 
; 4232 : 		for (int k = 0; k < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++k)

  000e8	8b bd 50 fe ff
	ff		 mov	 edi, DWORD PTR tv437[ebp]
  000ee	33 f6		 xor	 esi, esi
  000f0	83 c7 0d	 add	 edi, 13			; 0000000dH
$LL3@RecvViewEq:

; 4233 : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "SetEquipmentDialogAttr", Py_BuildValue("(iiiii)", kViewEquipPacket.dwVID, i, k, rItemSet.aAttr[k].bType, rItemSet.aAttr[k].sValue));

  000f3	0f bf 47 01	 movsx	 eax, WORD PTR [edi+1]
  000f7	50		 push	 eax
  000f8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000fb	50		 push	 eax
  000fc	56		 push	 esi
  000fd	53		 push	 ebx
  000fe	ff b5 55 fe ff
	ff		 push	 DWORD PTR _kViewEquipPacket$[ebp+1]
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_07FANHMMCA@?$CIiiiii?$CJ?$AA@
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0010f	50		 push	 eax
  00110	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NIIPMAGM@SetEquipmentDialogAttr?$AA@
  0011b	ff b0 90 01 00
	00		 push	 DWORD PTR [eax+400]
  00121	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00126	46		 inc	 esi
  00127	8d 7f 03	 lea	 edi, DWORD PTR [edi+3]
  0012a	83 c4 24	 add	 esp, 36			; 00000024H
  0012d	83 fe 07	 cmp	 esi, 7
  00130	7c c1		 jl	 SHORT $LL3@RecvViewEq

; 4223 : 
; 4224 : 	for (int i = 0; i < WEAR_MAX_NUM; ++i)

  00132	8b 8d 50 fe ff
	ff		 mov	 ecx, DWORD PTR tv437[ebp]
  00138	43		 inc	 ebx
  00139	8b b5 4c fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  0013f	83 c1 26	 add	 ecx, 38			; 00000026H
  00142	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Py_BuildValue
  00148	89 8d 50 fe ff
	ff		 mov	 DWORD PTR tv437[ebp], ecx
  0014e	83 fb 0b	 cmp	 ebx, 11			; 0000000bH
  00151	0f 8c 20 ff ff
	ff		 jl	 $LL9@RecvViewEq

; 4234 : 	}
; 4235 : 
; 4236 : 	return true;
; 4237 : }

  00157	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015a	b0 01		 mov	 al, 1
  0015c	5f		 pop	 edi
  0015d	5b		 pop	 ebx
  0015e	33 cd		 xor	 ecx, ebp
  00160	5e		 pop	 esi
  00161	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
?RecvViewEquipPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvViewEquipPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_rkMiniMap$1$ = -68					; size = 4
_kVec_dwGuildID$ = -64					; size = 12
_kLandList$ = -52					; size = 3
_rkBG$1$ = -48						; size = 4
_this$GSCopy$1$ = -44					; size = 4
_kElement$2 = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvLandPacket, COMDAT
; _this$ = ecx

; 4240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b c1		 mov	 eax, ecx
  0002d	89 45 d4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax

; 4241 : 	TPacketGCLandList kLandList;
; 4242 : 	if (!Recv(sizeof(kLandList), &kLandList))

  00030	8d 4d cc	 lea	 ecx, DWORD PTR _kLandList$[ebp]
  00033	51		 push	 ecx
  00034	6a 03		 push	 3
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0003d	84 c0		 test	 al, al
  0003f	0f 84 e1 00 00
	00		 je	 $LN9@RecvLandPa
$LN8@RecvLandPa:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00045	33 ff		 xor	 edi, edi
  00047	89 7d c0	 mov	 DWORD PTR _kVec_dwGuildID$[ebp], edi

; 483  : 		_Mylast = pointer();

  0004a	89 7d c4	 mov	 DWORD PTR _kVec_dwGuildID$[ebp+4], edi

; 484  : 		_Myend = pointer();

  0004d	89 7d c8	 mov	 DWORD PTR _kVec_dwGuildID$[ebp+8], edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4245 : 	std::vector<DWORD> kVec_dwGuildID;

  00050	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi

; 4246 : 
; 4247 : 	CPythonMiniMap & rkMiniMap = CPythonMiniMap::Instance();
; 4248 : 	CPythonBackground & rkBG = CPythonBackground::Instance();
; 4249 : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0005e	83 c1 04	 add	 ecx, 4
  00061	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00067	89 45 d0	 mov	 DWORD PTR _rkBG$1$[ebp], eax
  0006a	89 75 bc	 mov	 DWORD PTR _rkMiniMap$1$[ebp], esi
  0006d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006f	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 4250 : 
; 4251 : 	rkMiniMap.ClearGuildArea();

  00075	8b ce		 mov	 ecx, esi
  00077	8b d8		 mov	 ebx, eax
  00079	e8 00 00 00 00	 call	 ?ClearGuildArea@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ClearGuildArea

; 4252 : 	rkBG.ClearGuildArea();

  0007e	8b 4d d0	 mov	 ecx, DWORD PTR _rkBG$1$[ebp]
  00081	e8 00 00 00 00	 call	 ?ClearGuildArea@CPythonBackground@@QAEXXZ ; CPythonBackground::ClearGuildArea

; 4253 : 
; 4254 : 	int iPacketSize = (kLandList.size - sizeof(TPacketGCLandList));

  00086	0f b7 75 cd	 movzx	 esi, WORD PTR _kLandList$[ebp+1]
  0008a	83 ee 03	 sub	 esi, 3

; 4255 : 	for (; iPacketSize > 0; iPacketSize-=sizeof(TLandPacketElement))

  0008d	85 f6		 test	 esi, esi
  0008f	7e 78		 jle	 SHORT $LN5@RecvLandPa
  00091	8b 7d d4	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
$LL7@RecvLandPa:

; 4256 : 	{
; 4257 : 		TLandPacketElement kElement;
; 4258 : 		if (!Recv(sizeof(TLandPacketElement), &kElement))

  00094	8d 45 d8	 lea	 eax, DWORD PTR _kElement$2[ebp]
  00097	8b cf		 mov	 ecx, edi
  00099	50		 push	 eax
  0009a	6a 18		 push	 24			; 00000018H
  0009c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  000a1	84 c0		 test	 al, al
  000a3	0f 84 99 00 00
	00		 je	 $LN41@RecvLandPa

; 4259 : 			return false;
; 4260 : 
; 4261 : 		rkMiniMap.RegisterGuildArea(kElement.dwID,
; 4262 : 									kElement.dwGuildID,
; 4263 : 									kElement.x,
; 4264 : 									kElement.y,
; 4265 : 									kElement.width,
; 4266 : 									kElement.height);

  000a9	ff 75 e8	 push	 DWORD PTR _kElement$2[ebp+16]
  000ac	ff 75 e4	 push	 DWORD PTR _kElement$2[ebp+12]
  000af	ff 75 e0	 push	 DWORD PTR _kElement$2[ebp+8]
  000b2	ff 75 dc	 push	 DWORD PTR _kElement$2[ebp+4]
  000b5	ff 75 ec	 push	 DWORD PTR _kElement$2[ebp+20]
  000b8	51		 push	 ecx
  000b9	8b 4d bc	 mov	 ecx, DWORD PTR _rkMiniMap$1$[ebp]
  000bc	e8 00 00 00 00	 call	 ?RegisterGuildArea@CPythonMiniMap@@QAEXKKJJJJ@Z ; CPythonMiniMap::RegisterGuildArea

; 4267 : 
; 4268 : 		if (pMainInstance)

  000c1	85 db		 test	 ebx, ebx
  000c3	74 28		 je	 SHORT $LN45@RecvLandPa

; 4269 : 		if (kElement.dwGuildID == pMainInstance->GetGuildID())

  000c5	8b cb		 mov	 ecx, ebx
  000c7	e8 00 00 00 00	 call	 ?GetGuildID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetGuildID
  000cc	39 45 ec	 cmp	 DWORD PTR _kElement$2[ebp+20], eax
  000cf	75 1c		 jne	 SHORT $LN45@RecvLandPa

; 4270 : 		{
; 4271 : 			rkBG.RegisterGuildArea(kElement.x,
; 4272 : 								   kElement.y,
; 4273 : 								   kElement.x+kElement.width,
; 4274 : 								   kElement.y+kElement.height);

  000d1	8b 55 e0	 mov	 edx, DWORD PTR _kElement$2[ebp+8]
  000d4	8b 45 e8	 mov	 eax, DWORD PTR _kElement$2[ebp+16]
  000d7	8b 4d dc	 mov	 ecx, DWORD PTR _kElement$2[ebp+4]
  000da	03 c2		 add	 eax, edx
  000dc	50		 push	 eax
  000dd	8b 45 e4	 mov	 eax, DWORD PTR _kElement$2[ebp+12]
  000e0	03 c1		 add	 eax, ecx
  000e2	50		 push	 eax
  000e3	52		 push	 edx
  000e4	51		 push	 ecx
  000e5	8b 4d d0	 mov	 ecx, DWORD PTR _rkBG$1$[ebp]
  000e8	e8 00 00 00 00	 call	 ?RegisterGuildArea@CPythonBackground@@QAEXHHHH@Z ; CPythonBackground::RegisterGuildArea
$LN45@RecvLandPa:

; 4275 : 		}
; 4276 : 
; 4277 : 		if (0 != kElement.dwGuildID)

  000ed	83 7d ec 00	 cmp	 DWORD PTR _kElement$2[ebp+20], 0
  000f1	74 0c		 je	 SHORT $LN6@RecvLandPa

; 4278 : 			kVec_dwGuildID.push_back(kElement.dwGuildID);

  000f3	8d 45 ec	 lea	 eax, DWORD PTR _kElement$2[ebp+20]
  000f6	50		 push	 eax
  000f7	8d 4d c0	 lea	 ecx, DWORD PTR _kVec_dwGuildID$[ebp]
  000fa	e8 00 00 00 00	 call	 ?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
$LN6@RecvLandPa:

; 4255 : 	for (; iPacketSize > 0; iPacketSize-=sizeof(TLandPacketElement))

  000ff	83 ee 18	 sub	 esi, 24			; 00000018H
  00102	85 f6		 test	 esi, esi
  00104	7f 8e		 jg	 SHORT $LL7@RecvLandPa

; 4256 : 	{
; 4257 : 		TLandPacketElement kElement;
; 4258 : 		if (!Recv(sizeof(TLandPacketElement), &kElement))

  00106	8b 7d c0	 mov	 edi, DWORD PTR _kVec_dwGuildID$[ebp]
$LN5@RecvLandPa:

; 4279 : 	}
; 4280 : 
; 4281 : 	__DownloadSymbol(kVec_dwGuildID);

  00109	8b 4d d4	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0010c	8d 45 c0	 lea	 eax, DWORD PTR _kVec_dwGuildID$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?__DownloadSymbol@CPythonNetworkStream@@IAEXABV?$vector@KV?$allocator@K@std@@@std@@@Z ; CPythonNetworkStream::__DownloadSymbol

; 4283 : 	return true;

  00115	b3 01		 mov	 bl, 1
$LN12@RecvLandPa:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00117	85 ff		 test	 edi, edi
  00119	74 09		 je	 SHORT $LN29@RecvLandPa
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0011b	57		 push	 edi
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$LN29@RecvLandPa:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4283 : 	return true;

  00124	8a c3		 mov	 al, bl
$LN9@RecvLandPa:

; 4284 : }

  00126	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00129	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00130	59		 pop	 ecx
  00131	5f		 pop	 edi
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx
  00134	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00137	33 cd		 xor	 ecx, ebp
  00139	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN41@RecvLandPa:

; 4256 : 	{
; 4257 : 		TLandPacketElement kElement;
; 4258 : 		if (!Recv(sizeof(TLandPacketElement), &kElement))

  00142	8b 7d c0	 mov	 edi, DWORD PTR _kVec_dwGuildID$[ebp]
  00145	32 db		 xor	 bl, bl
  00147	eb ce		 jmp	 SHORT $LN12@RecvLandPa
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _kVec_dwGuildID$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__ehhandler$?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvLandPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvLandPacket
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvTargetCreatePacketNew@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kTargetCreate$ = -48					; size = 43
__$ArrayPad$ = -4					; size = 4
?RecvTargetCreatePacketNew@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvTargetCreatePacketNew, COMDAT
; _this$ = ecx

; 4307 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 4308 : 	TPacketGCTargetCreateNew kTargetCreate;
; 4309 : 	if (!Recv(sizeof(kTargetCreate), &kTargetCreate))

  00012	8d 45 d0	 lea	 eax, DWORD PTR _kTargetCreate$[ebp]
  00015	8b f1		 mov	 esi, ecx
  00017	50		 push	 eax
  00018	6a 2b		 push	 43			; 0000002bH
  0001a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001f	84 c0		 test	 al, al
  00021	75 10		 jne	 SHORT $LN3@RecvTarget

; 4332 : 	return true;
; 4333 : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	33 cd		 xor	 ecx, ebp
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN3@RecvTarget:

; 4310 : 		return false;
; 4311 : 
; 4312 : 	CPythonMiniMap & rkpyMiniMap = CPythonMiniMap::Instance();
; 4313 : 	CPythonBackground & rkpyBG = CPythonBackground::Instance();
; 4314 : 	if (CREATE_TARGET_TYPE_LOCATION == kTargetCreate.byType)

  00033	80 7d fa 01	 cmp	 BYTE PTR _kTargetCreate$[ebp+42], 1

; 4315 : 	{
; 4316 : 		rkpyMiniMap.CreateTarget(kTargetCreate.lID, kTargetCreate.szTargetName);

  00037	8d 45 d5	 lea	 eax, DWORD PTR _kTargetCreate$[ebp+5]
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00040	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00046	75 0b		 jne	 SHORT $LN2@RecvTarget
  00048	50		 push	 eax
  00049	ff 75 d1	 push	 DWORD PTR _kTargetCreate$[ebp+1]
  0004c	e8 00 00 00 00	 call	 ?CreateTarget@CPythonMiniMap@@QAEXHPBD@Z ; CPythonMiniMap::CreateTarget

; 4317 : 	}
; 4318 : 	else

  00051	eb 19		 jmp	 SHORT $LN1@RecvTarget
$LN2@RecvTarget:

; 4319 : 	{
; 4320 : 		rkpyMiniMap.CreateTarget(kTargetCreate.lID, kTargetCreate.szTargetName, kTargetCreate.dwVID);

  00053	ff 75 f6	 push	 DWORD PTR _kTargetCreate$[ebp+38]
  00056	50		 push	 eax
  00057	ff 75 d1	 push	 DWORD PTR _kTargetCreate$[ebp+1]
  0005a	e8 00 00 00 00	 call	 ?CreateTarget@CPythonMiniMap@@QAEXHPBDK@Z ; CPythonMiniMap::CreateTarget

; 4321 : 		rkpyBG.CreateTargetEffect(kTargetCreate.lID, kTargetCreate.dwVID);

  0005f	ff 75 f6	 push	 DWORD PTR _kTargetCreate$[ebp+38]
  00062	8b cf		 mov	 ecx, edi
  00064	ff 75 d1	 push	 DWORD PTR _kTargetCreate$[ebp+1]
  00067	e8 00 00 00 00	 call	 ?CreateTargetEffect@CPythonBackground@@QAEXKK@Z ; CPythonBackground::CreateTargetEffect
$LN1@RecvTarget:

; 4322 : 	}
; 4323 : 
; 4324 : //#ifdef _DEBUG
; 4325 : //	char szBuf[256+1];
; 4326 : //	_snprintf(szBuf, sizeof(szBuf), "    [%d:%s:%d]", kTargetCreate.lID, kTargetCreate.szTargetName, kTargetCreate.dwVID);
; 4327 : //	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
; 4328 : //	Tracef(" >> RecvTargetCreatePacketNew %d : %d/%d\n", kTargetCreate.lID, kTargetCreate.byType, kTargetCreate.dwVID);
; 4329 : //#endif
; 4330 : 
; 4331 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_OpenAtlasWindow", Py_BuildValue("()"));

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00077	83 c4 04	 add	 esp, 4
  0007a	50		 push	 eax
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NJGJICND@BINARY_OpenAtlasWindow?$AA@
  00080	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00086	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 4332 : 	return true;
; 4333 : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00091	33 cd		 xor	 ecx, ebp
  00093	b0 01		 mov	 al, 1
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?RecvTargetCreatePacketNew@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvTargetCreatePacketNew
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvTargetUpdatePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kTargetUpdate$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
?RecvTargetUpdatePacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvTargetUpdatePacket, COMDAT
; _this$ = ecx

; 4336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4337 : 	TPacketGCTargetUpdate kTargetUpdate;
; 4338 : 	if (!Recv(sizeof(kTargetUpdate), &kTargetUpdate))

  00010	8d 45 ec	 lea	 eax, DWORD PTR _kTargetUpdate$[ebp]
  00013	50		 push	 eax
  00014	6a 0d		 push	 13			; 0000000dH
  00016	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001b	84 c0		 test	 al, al
  0001d	75 0e		 jne	 SHORT $LN1@RecvTarget

; 4346 : 
; 4347 : //#ifdef _DEBUG
; 4348 : //	char szBuf[256+1];
; 4349 : //	_snprintf(szBuf, sizeof(szBuf), "    [%d:%d/%d]", kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
; 4350 : //	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
; 4351 : //	Tracef(" >> RecvTargetUpdatePacket %d : %d, %d\n", kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
; 4352 : //#endif
; 4353 : 
; 4354 : 	return true;
; 4355 : }

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00022	33 cd		 xor	 ecx, ebp
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN1@RecvTarget:

; 4339 : 		return false;
; 4340 : 
; 4341 : 	CPythonMiniMap & rkpyMiniMap = CPythonMiniMap::Instance();
; 4342 : 	rkpyMiniMap.UpdateTarget(kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);

  0002d	ff 75 f5	 push	 DWORD PTR _kTargetUpdate$[ebp+9]
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00036	ff 75 f1	 push	 DWORD PTR _kTargetUpdate$[ebp+5]
  00039	ff 75 ed	 push	 DWORD PTR _kTargetUpdate$[ebp+1]
  0003c	e8 00 00 00 00	 call	 ?UpdateTarget@CPythonMiniMap@@QAEXHHH@Z ; CPythonMiniMap::UpdateTarget

; 4343 : 
; 4344 : 	CPythonBackground & rkpyBG = CPythonBackground::Instance();
; 4345 : 	rkpyBG.CreateTargetEffect(kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);

  00041	ff 75 f5	 push	 DWORD PTR _kTargetUpdate$[ebp+9]
  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0004a	ff 75 f1	 push	 DWORD PTR _kTargetUpdate$[ebp+5]
  0004d	ff 75 ed	 push	 DWORD PTR _kTargetUpdate$[ebp+1]
  00050	e8 00 00 00 00	 call	 ?CreateTargetEffect@CPythonBackground@@QAEXKJJ@Z ; CPythonBackground::CreateTargetEffect

; 4346 : 
; 4347 : //#ifdef _DEBUG
; 4348 : //	char szBuf[256+1];
; 4349 : //	_snprintf(szBuf, sizeof(szBuf), "    [%d:%d/%d]", kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
; 4350 : //	CPythonChat::Instance().AppendChat(CHAT_TYPE_NOTICE, szBuf);
; 4351 : //	Tracef(" >> RecvTargetUpdatePacket %d : %d, %d\n", kTargetUpdate.lID, kTargetUpdate.lX, kTargetUpdate.lY);
; 4352 : //#endif
; 4353 : 
; 4354 : 	return true;
; 4355 : }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	b0 01		 mov	 al, 1
  0005a	33 cd		 xor	 ecx, ebp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?RecvTargetUpdatePacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvTargetUpdatePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvTargetDeletePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kTargetDelete$ = -8					; size = 5
?RecvTargetDeletePacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvTargetDeletePacket, COMDAT
; _this$ = ecx

; 4358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4359 : 	TPacketGCTargetDelete kTargetDelete;
; 4360 : 	if (!Recv(sizeof(kTargetDelete), &kTargetDelete))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _kTargetDelete$[ebp]
  00009	50		 push	 eax
  0000a	6a 05		 push	 5
  0000c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00011	84 c0		 test	 al, al
  00013	75 04		 jne	 SHORT $LN1@RecvTarget

; 4374 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN1@RecvTarget:

; 4361 : 		return false;
; 4362 : 
; 4363 : 	CPythonMiniMap & rkpyMiniMap = CPythonMiniMap::Instance();
; 4364 : 	rkpyMiniMap.DeleteTarget(kTargetDelete.lID);

  00019	ff 75 f9	 push	 DWORD PTR _kTargetDelete$[ebp+1]
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00022	e8 00 00 00 00	 call	 ?DeleteTarget@CPythonMiniMap@@QAEXH@Z ; CPythonMiniMap::DeleteTarget

; 4365 : 
; 4366 : 	CPythonBackground & rkpyBG = CPythonBackground::Instance();
; 4367 : 	rkpyBG.DeleteTargetEffect(kTargetDelete.lID);

  00027	ff 75 f9	 push	 DWORD PTR _kTargetDelete$[ebp+1]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?DeleteTargetEffect@CPythonBackground@@QAEXK@Z ; CPythonBackground::DeleteTargetEffect

; 4368 : 
; 4369 : //#ifdef _DEBUG
; 4370 : //	Tracef(" >> RecvTargetDeletePacket %d\n", kTargetDelete.lID);
; 4371 : //#endif
; 4372 : 
; 4373 : 	return true;

  00035	b0 01		 mov	 al, 1

; 4374 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?RecvTargetDeletePacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvTargetDeletePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvLoverInfoPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_kLoverInfo$ = -32					; size = 27
__$ArrayPad$ = -4					; size = 4
?RecvLoverInfoPacket@CPythonNetworkStream@@QAE_NXZ PROC	; CPythonNetworkStream::RecvLoverInfoPacket, COMDAT
; _this$ = ecx

; 4377 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 4378 : 	TPacketGCLoverInfo kLoverInfo;
; 4379 : 	if (!Recv(sizeof(kLoverInfo), &kLoverInfo))

  00011	8d 45 e0	 lea	 eax, DWORD PTR _kLoverInfo$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 1b		 push	 27			; 0000001bH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN1@RecvLoverI
  00022	5e		 pop	 esi

; 4383 : #ifdef _DEBUG
; 4384 : 	Tracef("RECV LOVER INFO : %s, %d\n", kLoverInfo.szName, kLoverInfo.byLovePoint);
; 4385 : #endif
; 4386 : 	return true;
; 4387 : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN1@RecvLoverI:

; 4380 : 		return false;
; 4381 : 
; 4382 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_LoverInfo", Py_BuildValue("(si)", kLoverInfo.szName, kLoverInfo.byLovePoint));

  00031	0f b6 45 fa	 movzx	 eax, BYTE PTR _kLoverInfo$[ebp+26]
  00035	50		 push	 eax
  00036	8d 45 e1	 lea	 eax, DWORD PTR _kLoverInfo$[ebp+1]
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_04LCKGAMBB@?$CIsi?$CJ?$AA@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EGDBDJKJ@BINARY_LoverInfo?$AA@
  0004b	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00051	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 4383 : #ifdef _DEBUG
; 4384 : 	Tracef("RECV LOVER INFO : %s, %d\n", kLoverInfo.szName, kLoverInfo.byLovePoint);
; 4385 : #endif
; 4386 : 	return true;
; 4387 : }

  00056	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00059	83 c4 18	 add	 esp, 24			; 00000018H
  0005c	33 cd		 xor	 ecx, ebp
  0005e	b0 01		 mov	 al, 1
  00060	5e		 pop	 esi
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?RecvLoverInfoPacket@CPythonNetworkStream@@QAE_NXZ ENDP	; CPythonNetworkStream::RecvLoverInfoPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvLovePointUpdatePacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_kLovePointUpdate$ = -4					; size = 2
?RecvLovePointUpdatePacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::RecvLovePointUpdatePacket, COMDAT
; _this$ = ecx

; 4390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 4391 : 	TPacketGCLovePointUpdate kLovePointUpdate;
; 4392 : 	if (!Recv(sizeof(kLovePointUpdate), &kLovePointUpdate))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _kLovePointUpdate$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 02		 push	 2
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 05		 jne	 SHORT $LN1@RecvLovePo
  00016	5e		 pop	 esi

; 4400 : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN1@RecvLovePo:

; 4393 : 		return false;
; 4394 : 
; 4395 : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_UpdateLovePoint", Py_BuildValue("(i)", kLovePointUpdate.byLovePoint));

  0001b	0f b6 45 fd	 movzx	 eax, BYTE PTR _kLovePointUpdate$[ebp+1]
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KEGDJEJM@BINARY_UpdateLovePoint?$AA@
  00031	ff b6 90 01 00
	00		 push	 DWORD PTR [esi+400]
  00037	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0003c	83 c4 14	 add	 esp, 20			; 00000014H

; 4396 : #ifdef _DEBUG
; 4397 : 	Tracef("RECV LOVE POINT UPDATE : %d\n", kLovePointUpdate.byLovePoint);
; 4398 : #endif
; 4399 : 	return true;

  0003f	b0 01		 mov	 al, 1
  00041	5e		 pop	 esi

; 4400 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?RecvLovePointUpdatePacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::RecvLovePointUpdatePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?RecvDigMotionPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_kDigMotion$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?RecvDigMotionPacket@CPythonNetworkStream@@QAE_NXZ PROC	; CPythonNetworkStream::RecvDigMotionPacket, COMDAT
; _this$ = ecx

; 4403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4404 : 	TPacketGCDigMotion kDigMotion;
; 4405 : 	if (!Recv(sizeof(kDigMotion), &kDigMotion))

  00010	8d 45 f0	 lea	 eax, DWORD PTR _kDigMotion$[ebp]
  00013	50		 push	 eax
  00014	6a 0a		 push	 10			; 0000000aH
  00016	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001b	84 c0		 test	 al, al
  0001d	75 0e		 jne	 SHORT $LN6@RecvDigMot

; 4423 : 
; 4424 : 	return true;
; 4425 : }

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00022	33 cd		 xor	 ecx, ebp
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN6@RecvDigMot:
  0002d	56		 push	 esi

; 4406 : 		return false;
; 4407 : 
; 4408 : #ifdef _DEBUG
; 4409 : 	Tracef(" Dig Motion [%d/%d]\n", kDigMotion.vid, kDigMotion.count);
; 4410 : #endif
; 4411 : 
; 4412 : 	IAbstractCharacterManager& rkChrMgr=IAbstractCharacterManager::GetSingleton();

  0002e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton

; 4413 : 	CInstanceBase * pkInstMain = rkChrMgr.GetInstancePtr(kDigMotion.vid);

  00034	8b ce		 mov	 ecx, esi
  00036	57		 push	 edi
  00037	ff 75 f1	 push	 DWORD PTR _kDigMotion$[ebp+1]
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	ff 50 08	 call	 DWORD PTR [eax+8]

; 4414 : 	CInstanceBase * pkInstTarget = rkChrMgr.GetInstancePtr(kDigMotion.target_vid);

  0003f	8b 16		 mov	 edx, DWORD PTR [esi]
  00041	8b ce		 mov	 ecx, esi
  00043	ff 75 f5	 push	 DWORD PTR _kDigMotion$[ebp+5]
  00046	8b f8		 mov	 edi, eax
  00048	ff 52 08	 call	 DWORD PTR [edx+8]

; 4415 : 	if (NULL == pkInstMain)

  0004b	85 ff		 test	 edi, edi
  0004d	74 39		 je	 SHORT $LN1@RecvDigMot

; 4416 : 		return true;
; 4417 : 
; 4418 : 	if (pkInstTarget)

  0004f	85 c0		 test	 eax, eax
  00051	74 08		 je	 SHORT $LN4@RecvDigMot

; 4419 : 		pkInstMain->NEW_LookAtDestInstance(*pkInstTarget);

  00053	50		 push	 eax
  00054	8b cf		 mov	 ecx, edi
  00056	e8 00 00 00 00	 call	 ?NEW_LookAtDestInstance@CInstanceBase@@QAEXAAV1@@Z ; CInstanceBase::NEW_LookAtDestInstance
$LN4@RecvDigMot:

; 4420 : 
; 4421 : 	for (int i = 0; i < kDigMotion.count; ++i)

  0005b	33 f6		 xor	 esi, esi
  0005d	80 7d f9 00	 cmp	 BYTE PTR _kDigMotion$[ebp+9], 0
  00061	76 25		 jbe	 SHORT $LN1@RecvDigMot
$LL3@RecvDigMot:

; 4422 : 		pkInstMain->PushOnceMotion(CRaceMotionData::NAME_DIG);

  00063	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  0006b	8b cf		 mov	 ecx, edi
  0006d	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  00075	68 45 01 00 00	 push	 325			; 00000145H
  0007a	e8 00 00 00 00	 call	 ?PushOnceMotion@CInstanceBase@@QAEXGMM@Z ; CInstanceBase::PushOnceMotion
  0007f	0f b6 45 f9	 movzx	 eax, BYTE PTR _kDigMotion$[ebp+9]
  00083	46		 inc	 esi
  00084	3b f0		 cmp	 esi, eax
  00086	7c db		 jl	 SHORT $LL3@RecvDigMot
$LN1@RecvDigMot:

; 4423 : 
; 4424 : 	return true;
; 4425 : }

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	b0 01		 mov	 al, 1
  0008d	5f		 pop	 edi
  0008e	33 cd		 xor	 ecx, ebp
  00090	5e		 pop	 esi
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?RecvDigMotionPacket@CPythonNetworkStream@@QAE_NXZ ENDP	; CPythonNetworkStream::RecvDigMotionPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp
;	COMDAT ?SendDragonSoulRefinePacket@CPythonNetworkStream@@QAE_NEPAUSItemPos@@@Z
_TEXT	SEGMENT
_pk$ = -52						; size = 47
__$ArrayPad$ = -4					; size = 4
_bRefineType$ = 8					; size = 1
_pos$ = 12						; size = 4
?SendDragonSoulRefinePacket@CPythonNetworkStream@@QAE_NEPAUSItemPos@@@Z PROC ; CPythonNetworkStream::SendDragonSoulRefinePacket, COMDAT
; _this$ = ecx

; 4430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h

; 2792 : 	{}

  00013	8d 45 ce	 lea	 eax, DWORD PTR _pk$[ebp+2]
  00016	56		 push	 esi
  00017	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4430 : {

  00018	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h

; 2792 : 	{}

  0001a	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  0001f	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
$LL7@SendDragon:
  00024	49		 dec	 ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00025	c6 00 01	 mov	 BYTE PTR [eax], 1

; 187  : 		cell = WORD_MAX;

  00028	66 89 78 01	 mov	 WORD PTR [eax+1], di
  0002c	8d 40 03	 lea	 eax, DWORD PTR [eax+3]
  0002f	79 f3		 jns	 SHORT $LL7@SendDragon
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasegame.cpp

; 4434 : 	memcpy (pk.ItemGrid, pos, sizeof (TItemPos) * DS_REFINE_WINDOW_MAX_NUM);

  00031	f3 0f 6f 02	 movdqu	 xmm0, XMMWORD PTR [edx]
  00035	8b 45 08	 mov	 eax, DWORD PTR _bRefineType$[ebp]

; 4435 : 	if (!Send(sizeof (pk), &pk))

  00038	8b ce		 mov	 ecx, esi
  0003a	88 45 cd	 mov	 BYTE PTR _pk$[ebp+1], al
  0003d	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00040	89 45 f6	 mov	 DWORD PTR _pk$[ebp+42], eax
  00043	8a 42 2c	 mov	 al, BYTE PTR [edx+44]
  00046	f3 0f 7f 45 ce	 movdqu	 XMMWORD PTR _pk$[ebp+2], xmm0
  0004b	88 45 fa	 mov	 BYTE PTR _pk$[ebp+46], al
  0004e	8d 45 cc	 lea	 eax, DWORD PTR _pk$[ebp]
  00051	f3 0f 6f 42 10	 movdqu	 xmm0, XMMWORD PTR [edx+16]
  00056	50		 push	 eax
  00057	6a 2f		 push	 47			; 0000002fH
  00059	f3 0f 7f 45 de	 movdqu	 XMMWORD PTR _pk$[ebp+18], xmm0
  0005e	c6 45 cc cd	 mov	 BYTE PTR _pk$[ebp], 205	; 000000cdH
  00062	f3 0f 7e 42 20	 movq	 xmm0, QWORD PTR [edx+32]
  00067	66 0f d6 45 ee	 movq	 QWORD PTR _pk$[ebp+34], xmm0
  0006c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send

; 4436 : 	{
; 4437 : 		return false;
; 4438 : 	}
; 4439 : 	return true;
; 4440 : }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	84 c0		 test	 al, al
  00076	5f		 pop	 edi
  00077	0f 95 c0	 setne	 al
  0007a	33 cd		 xor	 ecx, ebp
  0007c	5e		 pop	 esi
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
?SendDragonSoulRefinePacket@CPythonNetworkStream@@QAE_NEPAUSItemPos@@@Z ENDP ; CPythonNetworkStream::SendDragonSoulRefinePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?front@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?front@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::front, COMDAT
; _this$ = ecx

; 1405 : 		{	// return first element of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1406 : 		return (*begin());

  00006	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?begin@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
  0000f	8b d0		 mov	 edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	85 c0		 test	 eax, eax
  00015	75 11		 jne	 SHORT $LN9@front
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1406 : 		return (*begin());

  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001d	49		 dec	 ecx
  0001e	23 4a 08	 and	 ecx, DWORD PTR [edx+8]

; 1406 : 		return (*begin());

  00021	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1407 : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN9@front:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00028	8b 00		 mov	 eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0002a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1406 : 		return (*begin());

  0002d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00030	49		 dec	 ecx
  00031	23 4a 08	 and	 ecx, DWORD PTR [edx+8]

; 1406 : 		return (*begin());

  00034	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1407 : 		}

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?front@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_front, COMDAT
; _this$ = ecx

; 1434 : 		{	// erase element at beginning

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00004	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000a	4a		 dec	 edx
  0000b	23 56 0c	 and	 edx, DWORD PTR [esi+12]

; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  0000e	8b 3c 90	 mov	 edi, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00011	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00015	72 0a		 jb	 SHORT $LN38@pop_front
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00017	ff 37		 push	 DWORD PTR [edi]
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	83 c4 04	 add	 esp, 4
$LN38@pop_front:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00021	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00028	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0002f	c6 07 00	 mov	 BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1454 : 		if (--this->_Mysize == 0)

  00032	ff 4e 10	 dec	 DWORD PTR [esi+16]
  00035	75 0a		 jne	 SHORT $LN2@pop_front

; 1455 : 			this->_Myoff = 0;

  00037	5f		 pop	 edi
  00038	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0003f	5e		 pop	 esi

; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}

  00040	c3		 ret	 0
$LN2@pop_front:

; 1456 : 		else
; 1457 : 			++this->_Myoff;

  00041	ff 46 0c	 inc	 DWORD PTR [esi+12]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}

  00046	c3		 ret	 0
?pop_front@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?instance@?$CSingleton@VCPythonPlayer@@@@SAAAVCPythonPlayer@@XZ
_TEXT	SEGMENT
?instance@?$CSingleton@VCPythonPlayer@@@@SAAAVCPythonPlayer@@XZ PROC ; CSingleton<CPythonPlayer>::instance, COMDAT

; 37   : 		assert(ms_singleton);
; 38   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 39   : 	}

  00005	c3		 ret	 0
?instance@?$CSingleton@VCPythonPlayer@@@@SAAAVCPythonPlayer@@XZ ENDP ; CSingleton<CPythonPlayer>::instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonShop@@@@SAAAVCPythonShop@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonShop@@@@SAAAVCPythonShop@@XZ PROC ; CSingleton<CPythonShop>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonShop@@@@SAAAVCPythonShop@@XZ ENDP ; CSingleton<CPythonShop>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?instance@?$CSingleton@VCPythonShop@@@@SAAAVCPythonShop@@XZ
_TEXT	SEGMENT
?instance@?$CSingleton@VCPythonShop@@@@SAAAVCPythonShop@@XZ PROC ; CSingleton<CPythonShop>::instance, COMDAT

; 37   : 		assert(ms_singleton);
; 38   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton

; 39   : 	}

  00005	c3		 ret	 0
?instance@?$CSingleton@VCPythonShop@@@@SAAAVCPythonShop@@XZ ENDP ; CSingleton<CPythonShop>::instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonQuest@@@@SAAAVCPythonQuest@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonQuest@@@@SAAAVCPythonQuest@@XZ PROC ; CSingleton<CPythonQuest>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonQuest@@@@0PAVCPythonQuest@@A ; CSingleton<CPythonQuest>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonQuest@@@@SAAAVCPythonQuest@@XZ ENDP ; CSingleton<CPythonQuest>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z PROC ; std::vector<char,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1100 : 		{	// determine new length, padding as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1101 : 		if (_Newsize < size())

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]

; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000d	8b ca		 mov	 ecx, edx
  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	2b c8		 sub	 ecx, eax

; 1101 : 		if (_Newsize < size())

  00013	3b cf		 cmp	 ecx, edi
  00015	77 25		 ja	 SHORT $LN36@resize

; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)

  00017	73 28		 jae	 SHORT $LN2@resize

; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());

  00019	2b c2		 sub	 eax, edx
  0001b	8b ce		 mov	 ecx, esi
  0001d	03 c7		 add	 eax, edi
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reserve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2639 : 	_CSTD memset(_Dest, _Val, _Count);

  00025	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	2b c1		 sub	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1109 : 				_Alval);

  0002c	03 c7		 add	 eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2639 : 	_CSTD memset(_Dest, _Val, _Count);

  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1114 : 			this->_Mylast += _Newsize - size();

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2639 : 	_CSTD memset(_Dest, _Val, _Count);

  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@resize:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1114 : 			this->_Mylast += _Newsize - size();

  0003c	03 c7		 add	 eax, edi
  0003e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN2@resize:
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi

; 1115 : 			}
; 1116 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z PROC	; std::vector<char,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	03 45 08	 add	 eax, DWORD PTR __Pos$[ebp]

; 1210 : 		}

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ENDP	; std::vector<char,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ PROC	; std::vector<char,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ENDP	; std::vector<char,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1149 : 		}

  00016	c3		 ret	 0
?size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEABUSShopItemTable@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEABUSShopItemTable@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEABUSShopItemTable@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 0d	 add	 DWORD PTR [ecx], 13	; 0000000dH

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator<, COMDAT
; _this$ = ecx

; 214  : 		{	// test if this < _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	1b c0		 sbb	 eax, eax
  0000c	f7 d8		 neg	 eax

; 217  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::operator<
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?begin@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 1250 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 114  : 		{	// construct orphaned iterator

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1251 : 		return (iterator(this->_Myoff, this));

  00006	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 171  : 			_Myproxy = _Parent_proxy;

  00009	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 114  : 		{	// construct orphaned iterator

  0000b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 171  : 			_Myproxy = _Parent_proxy;

  00012	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 305  : 		_Myoff = _Off;

  00014	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1252 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?begin@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
__Count$1$ = -12					; size = 4
__Myptr$1$ = -8						; size = 4
__Myboff$1$ = -4					; size = 4
__Ptr$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Growmap, COMDAT
; _this$ = ecx

; 1772 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 1773 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1774 : 			"The _Xlen() test should always be performed.");
; 1775 : 
; 1776 : 		typedef typename _Alpty::pointer _Blockptr;
; 1777 : 		_Alpty _Almap(this->_Getal());
; 1778 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000c	56		 push	 esi
  0000d	be 01 00 00 00	 mov	 esi, 1
  00012	89 5d f0	 mov	 DWORD PTR _this$1$[ebp], ebx
  00015	57		 push	 edi
  00016	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00019	85 d2		 test	 edx, edx
  0001b	0f 45 f2	 cmovne	 esi, edx
  0001e	8b ff		 npad	 2
$LL7@Growmap:

; 1779 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

  00020	8b c6		 mov	 eax, esi
  00022	2b c2		 sub	 eax, edx
  00024	3b c1		 cmp	 eax, ecx
  00026	72 05		 jb	 SHORT $LN5@Growmap
  00028	83 fe 08	 cmp	 esi, 8
  0002b	73 13		 jae	 SHORT $LN6@Growmap
$LN5@Growmap:

; 1780 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1781 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

  0002d	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH
  00032	2b c6		 sub	 eax, esi
  00034	3b c6		 cmp	 eax, esi
  00036	0f 82 35 01 00
	00		 jb	 $LN151@Growmap

; 1782 : 				_Xlen();	// result too long
; 1783 : 			_Newsize *= 2;

  0003c	03 f6		 add	 esi, esi

; 1784 : 			}

  0003e	eb e0		 jmp	 SHORT $LL7@Growmap
$LN6@Growmap:

; 1785 : 		_Count = _Newsize - this->_Mapsize;
; 1786 : 
; 1787 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

  00040	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00043	2b f2		 sub	 esi, edx
  00045	89 7d fc	 mov	 DWORD PTR __Myboff$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  00048	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Ptr$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1788 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

  0004f	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00052	85 c0		 test	 eax, eax
  00054	74 22		 je	 SHORT $LN32@Growmap

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00056	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0005b	0f 87 0b 01 00
	00		 ja	 $LN168@Growmap
  00061	c1 e0 02	 shl	 eax, 2
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 08	 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00070	85 c0		 test	 eax, eax
  00072	0f 84 f4 00 00
	00		 je	 $LN168@Growmap
$LN32@Growmap:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1793 : 			_Myptr, _Almap);	// copy initial to end

  00078	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0007b	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0007e	c1 e0 02	 shl	 eax, 2
  00081	8d 14 b9	 lea	 edx, DWORD PTR [ecx+edi*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00084	2b c2		 sub	 eax, edx
  00086	03 c1		 add	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1789 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  0008b	c1 f8 02	 sar	 eax, 2

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0008e	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1789 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  00095	8b 45 08	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00098	57		 push	 edi
  00099	52		 push	 edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1789 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  0009a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1798 : 				_Myptr, _Almap);	// copy rest of old

  000a3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1794 : 		if (_Myboff <= _Count)

  000ac	8b 7d fc	 mov	 edi, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000af	89 55 f8	 mov	 DWORD PTR __Myptr$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1794 : 		if (_Myboff <= _Count)

  000b2	3b fe		 cmp	 edi, esi
  000b4	77 45		 ja	 SHORT $LN3@Growmap
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000b6	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1800 : 				_Almap);	// clear suffix of new

  000bd	8b d6		 mov	 edx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000bf	c1 f8 02	 sar	 eax, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1800 : 				_Almap);	// clear suffix of new

  000c2	2b d7		 sub	 edx, edi
  000c4	89 55 f4	 mov	 DWORD PTR __Count$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000c7	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*4]
  000ce	53		 push	 ebx
  000cf	51		 push	 ecx
  000d0	ff 75 f8	 push	 DWORD PTR __Myptr$1$[ebp]
  000d3	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  000d8	8b 4d f4	 mov	 ecx, DWORD PTR __Count$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  000e1	85 c9		 test	 ecx, ecx
  000e3	74 09		 je	 SHORT $LN81@Growmap
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1798 : 				_Myptr, _Almap);	// copy rest of old

  000e5	33 c0		 xor	 eax, eax
  000e7	8b fa		 mov	 edi, edx
  000e9	f3 ab		 rep stosd
  000eb	8b 7d fc	 mov	 edi, DWORD PTR __Myboff$1$[ebp]
$LN81@Growmap:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

  000ee	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  000f1	85 ff		 test	 edi, edi
  000f3	74 55		 je	 SHORT $LN139@Growmap
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

  000f5	8b cf		 mov	 ecx, edi
  000f7	8b fb		 mov	 edi, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1804 : 		else

  000f9	eb 4b		 jmp	 SHORT $LN167@Growmap
$LN3@Growmap:

; 1808 : 				_Myptr, _Almap);	// copy more old

  000fb	8d 3c b5 00 00
	00 00		 lea	 edi, DWORD PTR [esi*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00102	8b c7		 mov	 eax, edi
  00104	83 e0 fc	 and	 eax, -4			; fffffffcH
  00107	50		 push	 eax
  00108	51		 push	 ecx
  00109	52		 push	 edx
  0010a	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1811 : 				_Newmap, _Almap);	// copy rest of old

  0010f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00112	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00115	8b 7d fc	 mov	 edi, DWORD PTR __Myboff$1$[ebp]
  00118	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  0011f	2b d1		 sub	 edx, ecx
  00121	03 d0		 add	 edx, eax
  00123	c1 fa 02	 sar	 edx, 2

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00126	8d 1c 95 00 00
	00 00		 lea	 ebx, DWORD PTR [edx*4]
  0012d	53		 push	 ebx
  0012e	51		 push	 ecx
  0012f	ff 75 08	 push	 DWORD PTR __Ptr$1$[ebp]
  00132	e8 00 00 00 00	 call	 _memmove
  00137	83 c4 18	 add	 esp, 24			; 00000018H
  0013a	8d 3c 03	 lea	 edi, DWORD PTR [ebx+eax]
  0013d	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00140	85 f6		 test	 esi, esi
  00142	74 06		 je	 SHORT $LN139@Growmap
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1808 : 				_Myptr, _Almap);	// copy more old

  00144	8b ce		 mov	 ecx, esi
$LN167@Growmap:
  00146	33 c0		 xor	 eax, eax
  00148	f3 ab		 rep stosd
$LN139@Growmap:

; 1812 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1813 : 				_Almap);	// clear rest to initial block
; 1814 : 			}
; 1815 : 
; 1816 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1817 : 			_Almap);
; 1818 : 		if (this->_Map != _Mapptr())

  0014a	8b 7d f0	 mov	 edi, DWORD PTR _this$1$[ebp]
  0014d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00150	85 c0		 test	 eax, eax
  00152	74 09		 je	 SHORT $LN144@Growmap
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0015a	83 c4 04	 add	 esp, 4
$LN144@Growmap:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1823 : 		this->_Mapsize += _Count;

  0015d	01 77 08	 add	 DWORD PTR [edi+8], esi
  00160	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx

; 1824 : 		}

  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 04 00	 ret	 4
$LN168@Growmap:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  0016c	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN170@Growmap:
$LN151@Growmap:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1763 : 		_Xlength_error("deque<T> too long");

  00171	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00176	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN171@Growmap:
$LN166@Growmap:
  0017b	cc		 int	 3
?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC	; std::vector<char,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1149 : 		}

  00005	c3		 ret	 0
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP	; std::vector<char,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z PROC ; std::vector<char,std::allocator<char> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1495 : 		{	// erase _Count elements at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	29 41 04	 sub	 DWORD PTR [ecx+4], eax

; 1504 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Pop_back_n@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z PROC ; std::vector<char,std::allocator<char> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00012	3b c7		 cmp	 eax, edi
  00014	73 44		 jae	 SHORT $LN2@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00016	53		 push	 ebx
  00017	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00019	8b c3		 mov	 eax, ebx
  0001b	2b c6		 sub	 eax, esi
  0001d	48		 dec	 eax
  0001e	3b c7		 cmp	 eax, edi
  00020	72 3e		 jb	 SHORT $LN43@Reserve

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00022	2b f3		 sub	 esi, ebx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00024	2b d3		 sub	 edx, ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00026	03 f7		 add	 esi, edi

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00028	83 c8 ff	 or	 eax, -1
  0002b	8b fa		 mov	 edi, edx
  0002d	d1 ef		 shr	 edi, 1
  0002f	2b c7		 sub	 eax, edi
  00031	5b		 pop	 ebx
  00032	3b c2		 cmp	 eax, edx
  00034	73 12		 jae	 SHORT $LN27@Reserve
  00036	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00038	3b d6		 cmp	 edx, esi
  0003a	5f		 pop	 edi
  0003b	0f 42 d6	 cmovb	 edx, esi
  0003e	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0003f	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  00042	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00043	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reallocate
$LN27@Reserve:

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00048	03 d7		 add	 edx, edi

; 1576 : 		if (_Capacity < _Count)

  0004a	3b d6		 cmp	 edx, esi
  0004c	5f		 pop	 edi
  0004d	0f 42 d6	 cmovb	 edx, esi
  00050	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00051	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  00054	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00055	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ; std::vector<char,std::allocator<char> >::_Reallocate
$LN2@Reserve:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00065	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  0006a	cc		 int	 3
?_Reserve@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ PROC	; std::vector<char,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ENDP	; std::vector<char,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$dead$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*, COMDAT
; _this$ = ecx

; 602  : 		{	// return designated object

  00000	8b d1		 mov	 edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]
  00004	85 c0		 test	 eax, eax
  00006	75 0e		 jne	 SHORT $LN7@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00008	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 603  : 		return ((reference)**(_Mybase *)this);

  0000b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000e	49		 dec	 ecx
  0000f	23 4a 08	 and	 ecx, DWORD PTR [edx+8]

; 603  : 		return ((reference)**(_Mybase *)this);

  00012	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 604  : 		}

  00015	c3		 ret	 0
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00016	8b 00		 mov	 eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 603  : 		return ((reference)**(_Mybase *)this);

  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001e	49		 dec	 ecx
  0001f	23 4a 08	 and	 ecx, DWORD PTR [edx+8]

; 603  : 		return ((reference)**(_Mybase *)this);

  00022	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 604  : 		}

  00025	c3		 ret	 0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 1357 : 		return (this->_Getal().max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1358 : 		}

  00005	c3		 ret	 0
?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT
; _this$ = ecx

; 1763 : 		_Xlength_error("deque<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 1016 : 		}

  00006	c3		 ret	 0
?_Unused_capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	83 c8 ff	 or	 eax, -1

; 1154 : 		}

  00003	c3		 ret	 0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@DV?$allocator@D@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@DV?$allocator@D@std@@@std@@IBEII@Z PROC ; std::vector<char,std::allocator<char> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	83 c8 ff	 or	 eax, -1

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00009	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0000b	8b ca		 mov	 ecx, edx
  0000d	d1 e9		 shr	 ecx, 1
  0000f	2b c1		 sub	 eax, ecx
  00011	3b c2		 cmp	 eax, edx
  00013	73 0f		 jae	 SHORT $LN4@Grow_to
  00015	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00017	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001a	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  0001e	8b c2		 mov	 eax, edx

; 1579 : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00024	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  00026	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00029	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  0002d	8b c2		 mov	 eax, edx

; 1579 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Grow_to@?$vector@DV?$allocator@D@std@@@std@@IBEII@Z ENDP ; std::vector<char,std::allocator<char> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z PROC ; std::vector<char,std::allocator<char> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00009	33 f6		 xor	 esi, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b d9		 mov	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 ff		 test	 edi, edi
  0000f	74 14		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	83 ff ff	 cmp	 edi, -1
  00014	77 50		 ja	 SHORT $LN61@Reallocate
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b f0		 mov	 esi, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 f6		 test	 esi, esi
  00023	74 41		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00025	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00027	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002a	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00039	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0003c	2b c8		 sub	 ecx, eax
  0003e	89 4d 08	 mov	 DWORD PTR __Size$1$[ebp], ecx

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00041	85 c0		 test	 eax, eax
  00043	74 0c		 je	 SHORT $LN56@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  0004e	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  00051	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00054	89 33		 mov	 DWORD PTR [ebx], esi
  00056	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00059	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00061	5b		 pop	 ebx

; 1609 : 		}

  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
$LN61@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00066	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0006b	cc		 int	 3
?_Reallocate@?$vector@DV?$allocator@D@std@@@std@@IAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ PROC	; std::vector<char,std::allocator<char> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@IBEXXZ ENDP	; std::vector<char,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 585  : 		{	// construct with offset _Off in *_Pdeque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 149  : 		if (_Parent == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdeque$[ebp]

; 114  : 		{	// construct orphaned iterator

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 149  : 		if (_Parent == 0)

  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $LN13@Deque_iter

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@Deque_iter:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 305  : 		_Myoff = _Off;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0001e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 586  : 		}

  00021	8b c1		 mov	 eax, ecx
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		{	// return designated object

  00000	8b d1		 mov	 edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]
  00004	85 c0		 test	 eax, eax
  00006	75 0e		 jne	 SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00008	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  0000b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000e	49		 dec	 ecx
  0000f	23 4a 08	 and	 ecx, DWORD PTR [edx+8]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  00012	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 345  : 		}

  00015	c3		 ret	 0
$LN5@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00016	8b 00		 mov	 eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001e	49		 dec	 ecx
  0001f	23 4a 08	 and	 ecx, DWORD PTR [edx+8]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  00022	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 345  : 		}

  00025	c3		 ret	 0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1011 : 		}

  00005	c3		 ret	 0
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 302  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 149  : 		if (_Parent == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdeque$[ebp]

; 114  : 		{	// construct orphaned iterator

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 149  : 		if (_Parent == 0)

  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $LN11@Deque_cons

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 305  : 		_Myoff = _Off;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0001e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 306  : 		}

  00021	8b c1		 mov	 eax, ecx
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Setcont, COMDAT
; _this$ = ecx

; 530  : 		{	// set container pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 149  : 		if (_Parent == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 04		 je	 SHORT $LN3@Setcont

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Setcont:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 532  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<char *,unsigned int,std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __First$ = ecx
; __Count$ = edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2639 : 	_CSTD memset(_Dest, _Val, _Count);

  00000	52		 push	 edx
  00001	6a 00		 push	 0
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _memset
  00009	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 693  : 	}

  0000c	c3		 ret	 0
??$_Uninitialized_default_fill_n@PADIU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<char *,unsigned int,std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN11@Uninitiali
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN11@Uninitiali:

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 693  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z PROC ; std::vector<char,std::allocator<char> >::_Umove<char *>, COMDAT
; _this$dead$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000a	2b f0		 sub	 esi, eax

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 _memmove
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	03 c6		 add	 eax, esi
  0001b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ENDP ; std::vector<char,std::allocator<char> >::_Umove<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z PROC ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAD@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Val_type@PAD@std@@YAPADPAD@Z PROC			; std::_Val_type<char *>, COMDAT
; ___formal$dead$ = ecx

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAD@std@@YAPADPAD@Z ENDP			; std::_Val_type<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z PROC ; std::_Ptr_cat<char,char>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@DD@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAD0@Z ENDP ; std::_Ptr_cat<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<char,unsigned int,char>, COMDAT
; __First$ = ecx
; __Count$ = edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2639 : 	_CSTD memset(_Dest, _Val, _Count);

  00000	52		 push	 edx
  00001	6a 00		 push	 0
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _memset
  00009	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 683  : 	}

  0000c	c3		 ret	 0
??$_Uninit_def_fill_n@DID@std@@YAXPADIAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<char,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z PROC ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z ENDP ; std::_Unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@@std@@YAAAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAPAV10@PAPAV10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@@std@@YAAAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAPAV10@PAPAV10@@Z PROC ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@@std@@YAAAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAPAV10@PAPAV10@@Z ENDP ; std::_Rechecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z PROC ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z ENDP ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN5@Uninit_def
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN5@Uninit_def:

; 683  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXPAD0AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninitialized_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f2		 mov	 esi, edx

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00006	2b f1		 sub	 esi, ecx

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00008	56		 push	 esi
  00009	51		 push	 ecx
  0000a	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  0000d	e8 00 00 00 00	 call	 _memmove
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	03 c6		 add	 eax, esi
  00017	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Uninitialized_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninitialized_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 407  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z PROC ; std::_Fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	85 d2		 test	 edx, edx
  0000b	74 0f		 je	 SHORT $LN1@Fill_n
  0000d	56		 push	 esi
  0000e	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
$LL3@Fill_n:

; 2633 : 		*_Dest = _Val;

  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	89 08		 mov	 DWORD PTR [eax], ecx
  00015	83 c0 04	 add	 eax, 4
  00018	4a		 dec	 edx
  00019	75 f6		 jne	 SHORT $LL3@Fill_n
  0001b	5e		 pop	 esi
$LN1@Fill_n:

; 2634 : 	return (_Dest);
; 2635 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z ENDP ; std::_Fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAD@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAD@std@@YAPADPAD@Z PROC			; std::_Unchecked<char *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAD@std@@YAPADPAD@Z ENDP			; std::_Unchecked<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z PROC ; std::_Uninit_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f2		 mov	 esi, edx

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00006	2b f1		 sub	 esi, ecx

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00008	56		 push	 esi
  00009	51		 push	 ecx
  0000a	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  0000d	e8 00 00 00 00	 call	 _memmove
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	03 c6		 add	 eax, esi
  00017	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Uninit_move@PADPADU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@@Z ENDP ; std::_Uninit_move<char *,char *,std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z
_TEXT	SEGMENT
??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z PROC	; std::_Rechecked<char *,char *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 289  : 	_Dest = _Src;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 290  : 	return (_Dest);

  00002	8b c1		 mov	 eax, ecx

; 291  : 	}

  00004	c3		 ret	 0
??$_Rechecked@PADPAD@std@@YAAAPADAAPADPAD@Z ENDP	; std::_Rechecked<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$dead$ = 16					; size = 4
___formal$ = 20						; size = 1
??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<char,char,char>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f2		 mov	 esi, edx

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00006	2b f1		 sub	 esi, ecx

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00008	56		 push	 esi
  00009	51		 push	 ecx
  0000a	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  0000d	e8 00 00 00 00	 call	 _memmove
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	03 c6		 add	 eax, esi
  00017	5e		 pop	 esi

; 475  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Uninit_move@DDD@std@@YAPADPAD00AAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<char,char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Fill_n@std@@YAPADPADID@Z
_TEXT	SEGMENT
__Val$dead$ = 8						; size = 1
?_Fill_n@std@@YAPADPADID@Z PROC				; std::_Fill_n, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 2638 : 	{	// copy char _Val _Count times through [_Dest, ...)

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b fa		 mov	 edi, edx
  00004	8b f1		 mov	 esi, ecx

; 2639 : 	_CSTD memset(_Dest, _Val, _Count);

  00006	57		 push	 edi
  00007	6a 00		 push	 0
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _memset
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2640 : 	return (_Dest + _Count);

  00012	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi

; 2641 : 	}

  00017	c3		 ret	 0
?_Fill_n@std@@YAPADPADID@Z ENDP				; std::_Fill_n
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::at, COMDAT
; _this$ = ecx

; 1668 : 		{	// subscript mutable sequence with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1669 : 		if (this->_Mysize <= _Off)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	76 0e		 jbe	 SHORT $LN14@at

; 513  : 			: this->_Bx._Buf);

  0000b	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000f	72 02		 jb	 SHORT $LN10@at
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN10@at:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1671 : 		return (this->_Myptr()[_Off]);

  00013	03 c1		 add	 eax, ecx

; 1672 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN14@at:

; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0001e	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN16@at:
$LN13@at:
  00023	cc		 int	 3
?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::at
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
;	COMDAT ?ChangeDosPath@CFileNameHelper@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?ChangeDosPath@CFileNameHelper@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CFileNameHelper::ChangeDosPath, COMDAT

; 95   : 	static void ChangeDosPath(string& str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1749 : 		return (this->_Mysize);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 98   : 		for (size_t i = 0; i < nLength; ++i)

  00006	33 c0		 xor	 eax, eax
  00008	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1749 : 		return (this->_Mysize);

  00009	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 98   : 		for (size_t i = 0; i < nLength; ++i)

  0000c	85 ff		 test	 edi, edi
  0000e	74 2f		 je	 SHORT $LN2@ChangeDosP
  00010	56		 push	 esi
$LL4@ChangeDosP:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1669 : 		if (this->_Mysize <= _Off)

  00011	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00014	76 2c		 jbe	 SHORT $LN41@ChangeDosP

; 513  : 			: this->_Bx._Buf);

  00016	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00019	83 fa 10	 cmp	 edx, 16			; 00000010H
  0001c	72 04		 jb	 SHORT $LN17@ChangeDosP
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0001e	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00020	eb 02		 jmp	 SHORT $LN18@ChangeDosP
$LN17@ChangeDosP:
  00022	8b f1		 mov	 esi, ecx
$LN18@ChangeDosP:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 100  : 			if (str.at(i) == '/')

  00024	80 3c 06 2f	 cmp	 BYTE PTR [esi+eax], 47	; 0000002fH
  00028	75 0f		 jne	 SHORT $LN3@ChangeDosP
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H
  0002d	72 04		 jb	 SHORT $LN30@ChangeDosP
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00031	eb 02		 jmp	 SHORT $LN31@ChangeDosP
$LN30@ChangeDosP:
  00033	8b d1		 mov	 edx, ecx
$LN31@ChangeDosP:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 101  : 				str.at(i) = '\\';

  00035	c6 04 02 5c	 mov	 BYTE PTR [edx+eax], 92	; 0000005cH
$LN3@ChangeDosP:

; 98   : 		for (size_t i = 0; i < nLength; ++i)

  00039	40		 inc	 eax
  0003a	3b c7		 cmp	 eax, edi
  0003c	72 d3		 jb	 SHORT $LL4@ChangeDosP
  0003e	5e		 pop	 esi
$LN2@ChangeDosP:
  0003f	5f		 pop	 edi

; 103  : 	}

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN41@ChangeDosP:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2295 : 		_Xout_of_range("invalid string position");

  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00047	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN42@ChangeDosP:
$LN40@ChangeDosP:
  0004c	cc		 int	 3
?ChangeDosPath@CFileNameHelper@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CFileNameHelper::ChangeDosPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h
;	COMDAT ?NoPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
_TEXT	SEGMENT
$T1 = -1036						; size = 4
___$ReturnUdt$GSCopy$1$ = -1032				; size = 4
_szPath$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_str$ = 12						; size = 4
?NoPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z PROC ; CFileNameHelper::NoPath, COMDAT

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1749 : 		return (this->_Mysize);

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _str$[ebp]
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	53		 push	 ebx
  0001a	89 85 f8 fb ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  00020	8b 59 10	 mov	 ebx, DWORD PTR [ecx+16]
  00023	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 230  : 	szPath[0] = '\0';

  0002d	c6 85 fc fb ff
	ff 00		 mov	 BYTE PTR _szPath$[ebp], 0

; 231  : 
; 232  : 	size_t nLength = str.length();
; 233  : 
; 234  : 	if (nLength > 0)

  00034	85 db		 test	 ebx, ebx
  00036	0f 84 95 00 00
	00		 je	 $LN7@NoPath
  0003c	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0003d	8b 79 14	 mov	 edi, DWORD PTR [ecx+20]
  00040	83 ff 10	 cmp	 edi, 16			; 00000010H
  00043	72 04		 jb	 SHORT $LN26@NoPath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00045	8b 11		 mov	 edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00047	eb 02		 jmp	 SHORT $LN27@NoPath
$LN26@NoPath:
  00049	8b d1		 mov	 edx, ecx
$LN27@NoPath:
  0004b	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 236  : 		strcpy(szPath, str.c_str());

  0004c	8d b5 fc fb ff
	ff		 lea	 esi, DWORD PTR _szPath$[ebp]
$LL15@NoPath:
  00052	8a 02		 mov	 al, BYTE PTR [edx]
  00054	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00057	88 06		 mov	 BYTE PTR [esi], al
  00059	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0005c	84 c0		 test	 al, al
  0005e	75 f2		 jne	 SHORT $LL15@NoPath

; 237  : 
; 238  : 		for (size_t i = nLength - 1; i > 0; i--)

  00060	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00063	85 c0		 test	 eax, eax
  00065	74 68		 je	 SHORT $LN114@NoPath
$LL9@NoPath:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00067	83 ff 10	 cmp	 edi, 16			; 00000010H
  0006a	72 04		 jb	 SHORT $LN34@NoPath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0006e	eb 02		 jmp	 SHORT $LN35@NoPath
$LN34@NoPath:
  00070	8b d1		 mov	 edx, ecx
$LN35@NoPath:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 240  : 			if (str[i] == '/' || str[i] == '\\')

  00072	80 3c 02 2f	 cmp	 BYTE PTR [edx+eax], 47	; 0000002fH
  00076	74 1a		 je	 SHORT $LN5@NoPath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00078	83 ff 10	 cmp	 edi, 16			; 00000010H
  0007b	72 04		 jb	 SHORT $LN42@NoPath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0007f	eb 02		 jmp	 SHORT $LN43@NoPath
$LN42@NoPath:
  00081	8b d1		 mov	 edx, ecx
$LN43@NoPath:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 240  : 			if (str[i] == '/' || str[i] == '\\')

  00083	80 3c 02 5c	 cmp	 BYTE PTR [edx+eax], 92	; 0000005cH
  00087	74 09		 je	 SHORT $LN5@NoPath

; 246  : 				break;
; 247  : 			}
; 248  : 
; 249  : 			if (0 == i)

  00089	85 c0		 test	 eax, eax
  0008b	74 42		 je	 SHORT $LN114@NoPath

; 237  : 
; 238  : 		for (size_t i = nLength - 1; i > 0; i--)

  0008d	48		 dec	 eax
  0008e	75 d7		 jne	 SHORT $LL9@NoPath

; 246  : 				break;
; 247  : 			}
; 248  : 
; 249  : 			if (0 == i)

  00090	eb 3d		 jmp	 SHORT $LN114@NoPath
$LN5@NoPath:

; 243  : 				for (size_t j = i + 1; j < nLength; j++, k++)

  00092	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00095	33 f6		 xor	 esi, esi
  00097	3b d3		 cmp	 edx, ebx
  00099	73 2c		 jae	 SHORT $LN111@NoPath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0009b	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 243  : 				for (size_t j = i + 1; j < nLength; j++, k++)

  0009e	8d 9d fc fb ff
	ff		 lea	 ebx, DWORD PTR _szPath$[ebp]
  000a4	2b da		 sub	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000a6	2b f2		 sub	 esi, edx
$LL4@NoPath:
  000a8	83 ff 10	 cmp	 edi, 16			; 00000010H
  000ab	72 04		 jb	 SHORT $LN50@NoPath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000ad	8b 01		 mov	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000af	eb 02		 jmp	 SHORT $LN51@NoPath
$LN50@NoPath:
  000b1	8b c1		 mov	 eax, ecx
$LN51@NoPath:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 244  : 					szPath[k] = str[j];

  000b3	8a 04 10	 mov	 al, BYTE PTR [eax+edx]
  000b6	88 04 13	 mov	 BYTE PTR [ebx+edx], al
  000b9	42		 inc	 edx
  000ba	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000bd	72 e9		 jb	 SHORT $LL4@NoPath

; 245  : 				szPath[k] = '\0';

  000bf	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  000c5	73 62		 jae	 SHORT $LN116@NoPath
$LN111@NoPath:
  000c7	c6 84 35 fc fb
	ff ff 00	 mov	 BYTE PTR _szPath$[ebp+esi], 0
$LN114@NoPath:
  000cf	5e		 pop	 esi
  000d0	5f		 pop	 edi
$LN7@NoPath:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000d1	8b 9d f8 fb ff
	ff		 mov	 ebx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  000d7	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH

; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000de	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000e5	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 523  : 			: _CSTD strlen(_First));

  000e8	80 bd fc fb ff
	ff 00		 cmp	 BYTE PTR _szPath$[ebp], 0
  000ef	75 04		 jne	 SHORT $LN96@NoPath
  000f1	33 c9		 xor	 ecx, ecx
  000f3	eb 14		 jmp	 SHORT $LN97@NoPath
$LN96@NoPath:
  000f5	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _szPath$[ebp]
  000fb	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000fe	8b ff		 npad	 2
$LL112@NoPath:
  00100	8a 01		 mov	 al, BYTE PTR [ecx]
  00102	41		 inc	 ecx
  00103	84 c0		 test	 al, al
  00105	75 f9		 jne	 SHORT $LL112@NoPath
  00107	2b ca		 sub	 ecx, edx
$LN97@NoPath:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00109	51		 push	 ecx
  0010a	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szPath$[ebp]
  00110	8b cb		 mov	 ecx, ebx
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\filename.h

; 255  : }

  00118	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011b	8b c3		 mov	 eax, ebx
  0011d	33 cd		 xor	 ecx, ebp
  0011f	5b		 pop	 ebx
  00120	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
$LN116@NoPath:

; 245  : 				szPath[k] = '\0';

  00129	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN118@NoPath:
$LN115@NoPath:
  0012e	cc		 int	 3
?NoPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ENDP ; CFileNameHelper::NoPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv882 = -4						; size = 4
__Newsize$1$ = -4					; size = 4
tv905 = 8						; size = 4
tv901 = 8						; size = 4
tv897 = 8						; size = 4
__Off$ = 8						; size = 4
tv909 = 12						; size = 4
tv903 = 12						; size = 4
tv900 = 12						; size = 4
__N0$ = 12						; size = 4
tv896 = 16						; size = 4
tv893 = 16						; size = 4
tv891 = 16						; size = 4
tv889 = 16						; size = 4
__Right$ = 16						; size = 4
__Roff$ = 20						; size = 4
tv908 = 24						; size = 4
__Nm$1$ = 24						; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Off$[ebp]
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	3b cf		 cmp	 ecx, edi
  00010	0f 82 2c 03 00
	00		 jb	 $LN13@replace
  00016	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00019	53		 push	 ebx
  0001a	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  0001d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00020	3b c3		 cmp	 eax, ebx
  00022	0f 82 1a 03 00
	00		 jb	 $LN13@replace

; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)

  00028	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0002b	2b cf		 sub	 ecx, edi
  0002d	3b ca		 cmp	 ecx, edx
  0002f	0f 42 d1	 cmovb	 edx, ecx

; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;

  00032	2b c3		 sub	 eax, ebx

; 1390 : 		if (_Num < _Count)

  00034	8b 5d 18	 mov	 ebx, DWORD PTR __Count$[ebp]
  00037	3b c3		 cmp	 eax, ebx
  00039	89 55 0c	 mov	 DWORD PTR __N0$[ebp], edx
  0003c	0f 42 d8	 cmovb	 ebx, eax

; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)

  0003f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00042	2b c2		 sub	 eax, edx
  00044	89 45 fc	 mov	 DWORD PTR tv882[ebp], eax
  00047	83 c8 ff	 or	 eax, -1
  0004a	2b c3		 sub	 eax, ebx
  0004c	3b 45 fc	 cmp	 eax, DWORD PTR tv882[ebp]
  0004f	0f 86 e3 02 00
	00		 jbe	 $LN215@replace

; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;

  00055	8b 45 fc	 mov	 eax, DWORD PTR tv882[ebp]
  00058	2b ca		 sub	 ecx, edx
  0005a	03 c3		 add	 eax, ebx
  0005c	89 4d 18	 mov	 DWORD PTR __Nm$1$[ebp], ecx
  0005f	89 45 fc	 mov	 DWORD PTR __Newsize$1$[ebp], eax

; 1397 : 		if (this->_Mysize < _Newsize)

  00062	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  00065	73 10		 jae	 SHORT $LN9@replace

; 1398 : 			_Grow(_Newsize);

  00067	6a 00		 push	 0
  00069	50		 push	 eax
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00071	8b 4d 18	 mov	 ecx, DWORD PTR __Nm$1$[ebp]
  00074	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
$LN9@replace:

; 1399 : 
; 1400 : 		if (this != &_Right)

  00077	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  0007a	3b f0		 cmp	 esi, eax
  0007c	74 75		 je	 SHORT $LN8@replace

; 513  : 			: this->_Bx._Buf);

  0007e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00082	72 0a		 jb	 SHORT $LN28@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00084	8b 3e		 mov	 edi, DWORD PTR [esi]
  00086	89 7d 0c	 mov	 DWORD PTR tv909[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00089	8b 7d 08	 mov	 edi, DWORD PTR __Off$[ebp]
  0008c	eb 03		 jmp	 SHORT $LN29@replace
$LN28@replace:
  0008e	89 75 0c	 mov	 DWORD PTR tv909[ebp], esi
$LN29@replace:
  00091	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00095	72 0a		 jb	 SHORT $LN34@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00097	8b 3e		 mov	 edi, DWORD PTR [esi]
  00099	89 7d 18	 mov	 DWORD PTR tv908[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0009c	8b 7d 08	 mov	 edi, DWORD PTR __Off$[ebp]
  0009f	eb 03		 jmp	 SHORT $LN35@replace
$LN34@replace:
  000a1	89 75 18	 mov	 DWORD PTR tv908[ebp], esi
$LN35@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000a4	85 c9		 test	 ecx, ecx
  000a6	74 1c		 je	 SHORT $LN41@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole

  000a8	8b 45 0c	 mov	 eax, DWORD PTR tv909[ebp]
  000ab	03 c7		 add	 eax, edi
  000ad	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000af	51		 push	 ecx
  000b0	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole

  000b1	8b 45 18	 mov	 eax, DWORD PTR tv908[ebp]
  000b4	03 c7		 add	 eax, edi
  000b6	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _memmove
  000be	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000c4	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000c8	72 02		 jb	 SHORT $LN44@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
$LN44@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000cc	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d0	72 04		 jb	 SHORT $LN50@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000d2	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000d4	eb 02		 jmp	 SHORT $LN51@replace
$LN50@replace:
  000d6	8b ce		 mov	 ecx, esi
$LN51@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000d8	85 db		 test	 ebx, ebx
  000da	0f 84 2d 02 00
	00		 je	 $LN201@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole

  000e0	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e3	53		 push	 ebx
  000e4	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole

  000e5	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _memcpy

; 531  : 		}

  000ee	e9 17 02 00 00	 jmp	 $LN213@replace
$LN8@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1407 : 		else if (_Count <= _N0)

  000f3	3b da		 cmp	 ebx, edx
  000f5	77 73		 ja	 SHORT $LN6@replace

; 513  : 			: this->_Bx._Buf);

  000f7	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000fa	83 f8 10	 cmp	 eax, 16			; 00000010H
  000fd	72 07		 jb	 SHORT $LN60@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000ff	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00101	89 4d 08	 mov	 DWORD PTR tv905[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00104	eb 03		 jmp	 SHORT $LN61@replace
$LN60@replace:
  00106	89 75 08	 mov	 DWORD PTR tv905[ebp], esi
$LN61@replace:
  00109	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010c	72 04		 jb	 SHORT $LN66@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0010e	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00110	eb 02		 jmp	 SHORT $LN67@replace
$LN66@replace:
  00112	8b ce		 mov	 ecx, esi
$LN67@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00114	85 db		 test	 ebx, ebx
  00116	74 17		 je	 SHORT $LN73@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole

  00118	8b 45 08	 mov	 eax, DWORD PTR tv905[ebp]
  0011b	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0011e	53		 push	 ebx
  0011f	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole

  00120	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _memmove
  00129	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0012c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN73@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0012f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00132	83 f8 10	 cmp	 eax, 16			; 00000010H
  00135	72 07		 jb	 SHORT $LN76@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00137	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00139	89 4d 0c	 mov	 DWORD PTR tv903[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0013c	eb 03		 jmp	 SHORT $LN77@replace
$LN76@replace:
  0013e	89 75 0c	 mov	 DWORD PTR tv903[ebp], esi
$LN77@replace:
  00141	83 f8 10	 cmp	 eax, 16			; 00000010H
  00144	72 04		 jb	 SHORT $LN82@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00146	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00148	eb 02		 jmp	 SHORT $LN83@replace
$LN82@replace:
  0014a	8b ce		 mov	 ecx, esi
$LN83@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0014c	8b 45 18	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  0014f	85 c0		 test	 eax, eax
  00151	0f 84 b6 01 00
	00		 je	 $LN201@replace
  00157	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  00158	8b 45 0c	 mov	 eax, DWORD PTR tv903[ebp]
  0015b	03 c7		 add	 eax, edi
  0015d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0015f	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  00160	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00163	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 554  : 		}

  00165	e9 9a 01 00 00	 jmp	 $LN214@replace
$LN6@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1414 : 		else if (_Roff <= _Off)

  0016a	39 7d 14	 cmp	 DWORD PTR __Roff$[ebp], edi
  0016d	77 71		 ja	 SHORT $LN4@replace

; 513  : 			: this->_Bx._Buf);

  0016f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00172	83 f8 10	 cmp	 eax, 16			; 00000010H
  00175	72 0a		 jb	 SHORT $LN92@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00177	8b 16		 mov	 edx, DWORD PTR [esi]
  00179	89 55 08	 mov	 DWORD PTR tv901[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0017c	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0017f	eb 03		 jmp	 SHORT $LN93@replace
$LN92@replace:
  00181	89 75 08	 mov	 DWORD PTR tv901[ebp], esi
$LN93@replace:
  00184	83 f8 10	 cmp	 eax, 16			; 00000010H
  00187	72 07		 jb	 SHORT $LN98@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00189	8b 06		 mov	 eax, DWORD PTR [esi]
  0018b	89 45 0c	 mov	 DWORD PTR tv900[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0018e	eb 03		 jmp	 SHORT $LN99@replace
$LN98@replace:
  00190	89 75 0c	 mov	 DWORD PTR tv900[ebp], esi
$LN99@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00193	85 c9		 test	 ecx, ecx
  00195	74 19		 je	 SHORT $LN105@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  00197	8b 45 08	 mov	 eax, DWORD PTR tv901[ebp]
  0019a	03 c7		 add	 eax, edi
  0019c	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0019e	51		 push	 ecx
  0019f	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  001a0	8b 45 0c	 mov	 eax, DWORD PTR tv900[ebp]
  001a3	03 c7		 add	 eax, edi
  001a5	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _memmove
  001ad	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN105@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  001b0	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001b3	83 f8 10	 cmp	 eax, 16			; 00000010H
  001b6	72 04		 jb	 SHORT $LN108@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  001b8	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  001ba	eb 02		 jmp	 SHORT $LN109@replace
$LN108@replace:
  001bc	8b d6		 mov	 edx, esi
$LN109@replace:
  001be	83 f8 10	 cmp	 eax, 16			; 00000010H
  001c1	72 04		 jb	 SHORT $LN114@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  001c3	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  001c5	eb 02		 jmp	 SHORT $LN115@replace
$LN114@replace:
  001c7	8b ce		 mov	 ecx, esi
$LN115@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  001c9	85 db		 test	 ebx, ebx
  001cb	0f 84 3c 01 00
	00		 je	 $LN201@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole

  001d1	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  001d4	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  001d6	53		 push	 ebx
  001d7	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole

  001d8	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 554  : 		}

  001db	e9 24 01 00 00	 jmp	 $LN214@replace
$LN4@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1421 : 		else if (_Off + _N0 <= _Roff)

  001e0	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  001e3	3b 45 14	 cmp	 eax, DWORD PTR __Roff$[ebp]

; 513  : 			: this->_Bx._Buf);

  001e6	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 1421 : 		else if (_Off + _N0 <= _Roff)

  001e9	77 73		 ja	 SHORT $LN2@replace

; 513  : 			: this->_Bx._Buf);

  001eb	83 f8 10	 cmp	 eax, 16			; 00000010H
  001ee	72 0a		 jb	 SHORT $LN124@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  001f0	8b 16		 mov	 edx, DWORD PTR [esi]
  001f2	89 55 08	 mov	 DWORD PTR tv897[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  001f5	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  001f8	eb 03		 jmp	 SHORT $LN125@replace
$LN124@replace:
  001fa	89 75 08	 mov	 DWORD PTR tv897[ebp], esi
$LN125@replace:
  001fd	83 f8 10	 cmp	 eax, 16			; 00000010H
  00200	72 07		 jb	 SHORT $LN130@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00202	8b 06		 mov	 eax, DWORD PTR [esi]
  00204	89 45 10	 mov	 DWORD PTR tv896[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00207	eb 03		 jmp	 SHORT $LN131@replace
$LN130@replace:
  00209	89 75 10	 mov	 DWORD PTR tv896[ebp], esi
$LN131@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0020c	85 c9		 test	 ecx, ecx
  0020e	74 1c		 je	 SHORT $LN137@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  00210	8b 45 08	 mov	 eax, DWORD PTR tv897[ebp]
  00213	03 c7		 add	 eax, edi
  00215	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00217	51		 push	 ecx
  00218	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  00219	8b 45 10	 mov	 eax, DWORD PTR tv896[ebp]
  0021c	03 c7		 add	 eax, edi
  0021e	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00220	50		 push	 eax
  00221	e8 00 00 00 00	 call	 _memmove
  00226	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00229	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN137@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0022c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0022f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00232	72 04		 jb	 SHORT $LN140@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00234	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00236	eb 02		 jmp	 SHORT $LN141@replace
$LN140@replace:
  00238	8b c6		 mov	 eax, esi
$LN141@replace:
  0023a	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0023d	72 04		 jb	 SHORT $LN146@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0023f	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00241	eb 02		 jmp	 SHORT $LN147@replace
$LN146@replace:
  00243	8b ce		 mov	 ecx, esi
$LN147@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00245	85 db		 test	 ebx, ebx
  00247	0f 84 c0 00 00
	00		 je	 $LN201@replace
  0024d	2b c2		 sub	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1427 : 				_Count);	// fill hole

  0024f	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  00252	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00254	53		 push	 ebx
  00255	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1427 : 				_Count);	// fill hole

  00256	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 1428 : 			}
; 1429 : 		else

  00259	e9 a6 00 00 00	 jmp	 $LN214@replace
$LN2@replace:

; 513  : 			: this->_Bx._Buf);

  0025e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00261	72 07		 jb	 SHORT $LN156@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00263	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00265	89 4d 10	 mov	 DWORD PTR tv893[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00268	eb 03		 jmp	 SHORT $LN157@replace
$LN156@replace:
  0026a	89 75 10	 mov	 DWORD PTR tv893[ebp], esi
$LN157@replace:
  0026d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00270	72 04		 jb	 SHORT $LN162@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00272	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00274	eb 02		 jmp	 SHORT $LN163@replace
$LN162@replace:
  00276	8b ce		 mov	 ecx, esi
$LN163@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00278	85 d2		 test	 edx, edx
  0027a	74 17		 je	 SHORT $LN169@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole

  0027c	8b 45 10	 mov	 eax, DWORD PTR tv893[ebp]
  0027f	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00282	52		 push	 edx
  00283	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole

  00284	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00287	50		 push	 eax
  00288	e8 00 00 00 00	 call	 _memmove
  0028d	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00290	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN169@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00293	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00296	83 f8 10	 cmp	 eax, 16			; 00000010H
  00299	72 07		 jb	 SHORT $LN172@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0029b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0029d	89 4d 10	 mov	 DWORD PTR tv891[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  002a0	eb 03		 jmp	 SHORT $LN173@replace
$LN172@replace:
  002a2	89 75 10	 mov	 DWORD PTR tv891[ebp], esi
$LN173@replace:
  002a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  002a8	72 04		 jb	 SHORT $LN178@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  002aa	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  002ac	eb 02		 jmp	 SHORT $LN179@replace
$LN178@replace:
  002ae	8b ce		 mov	 ecx, esi
$LN179@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  002b0	8b 45 18	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  002b3	85 c0		 test	 eax, eax
  002b5	74 17		 je	 SHORT $LN185@replace
  002b7	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  002b8	8b 45 10	 mov	 eax, DWORD PTR tv891[ebp]
  002bb	03 c7		 add	 eax, edi
  002bd	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  002bf	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  002c0	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  002c3	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 _memmove
  002cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN185@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  002ce	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  002d1	83 f8 10	 cmp	 eax, 16			; 00000010H
  002d4	72 07		 jb	 SHORT $LN188@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  002d6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002d8	89 4d 10	 mov	 DWORD PTR tv889[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  002db	eb 03		 jmp	 SHORT $LN189@replace
$LN188@replace:
  002dd	89 75 10	 mov	 DWORD PTR tv889[ebp], esi
$LN189@replace:
  002e0	83 f8 10	 cmp	 eax, 16			; 00000010H
  002e3	72 04		 jb	 SHORT $LN194@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  002e5	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  002e7	eb 02		 jmp	 SHORT $LN195@replace
$LN194@replace:
  002e9	8b d6		 mov	 edx, esi
$LN195@replace:

; 1437 : 				_Count - _N0);	// fill rest of new hole

  002eb	8b 4d 0c	 mov	 ecx, DWORD PTR __N0$[ebp]
  002ee	8b c3		 mov	 eax, ebx
  002f0	2b c1		 sub	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  002f2	74 19		 je	 SHORT $LN201@replace
  002f4	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1437 : 				_Count - _N0);	// fill rest of new hole

  002f5	8b 45 10	 mov	 eax, DWORD PTR tv889[ebp]
  002f8	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002fb	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  002fd	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1437 : 				_Count - _N0);	// fill rest of new hole

  002fe	8b c7		 mov	 eax, edi
  00300	03 c2		 add	 eax, edx
  00302	03 c1		 add	 eax, ecx
$LN214@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00304	50		 push	 eax
  00305	e8 00 00 00 00	 call	 _memmove
$LN213@replace:
  0030a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN201@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0030d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00311	8b 4d fc	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00314	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00317	5b		 pop	 ebx

; 513  : 			: this->_Bx._Buf);

  00318	72 10		 jb	 SHORT $LN206@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0031a	8b 06		 mov	 eax, DWORD PTR [esi]
  0031c	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0031d	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1441 : 		return (*this);

  00321	8b c6		 mov	 eax, esi
  00323	5e		 pop	 esi

; 1442 : 		}

  00324	8b e5		 mov	 esp, ebp
  00326	5d		 pop	 ebp
  00327	c2 14 00	 ret	 20			; 00000014H
$LN206@replace:

; 513  : 			: this->_Bx._Buf);

  0032a	8b c6		 mov	 eax, esi
  0032c	5f		 pop	 edi
  0032d	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0032e	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1442 : 		}

  00332	8b e5		 mov	 esp, ebp
  00334	5d		 pop	 ebp
  00335	c2 14 00	 ret	 20			; 00000014H
$LN215@replace:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

  00338	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0033d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN217@replace:
$LN13@replace:

; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

  00342	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00347	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN218@replace:
$LN212@replace:
  0034c	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT	SEGMENT
__Num$1$ = -4						; size = 4
__Off$ = 8						; size = 4
tv404 = 12						; size = 4
tv402 = 12						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Nm$1$ = 20						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi

; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  0000b	85 d2		 test	 edx, edx
  0000d	74 4d		 je	 SHORT $LN8@replace

; 513  : 			: this->_Bx._Buf);

  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00015	72 04		 jb	 SHORT $LN18@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00019	eb 02		 jmp	 SHORT $LN19@replace
$LN18@replace:
  0001b	8b c6		 mov	 eax, esi
$LN19@replace:

; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  0001d	3b d0		 cmp	 edx, eax
  0001f	72 3b		 jb	 SHORT $LN8@replace

; 513  : 			: this->_Bx._Buf);

  00021	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00024	72 04		 jb	 SHORT $LN24@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00026	8b 3e		 mov	 edi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00028	eb 02		 jmp	 SHORT $LN25@replace
$LN24@replace:
  0002a	8b fe		 mov	 edi, esi
$LN25@replace:

; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	03 c7		 add	 eax, edi
  00031	3b c2		 cmp	 eax, edx
  00033	76 27		 jbe	 SHORT $LN8@replace

; 513  : 			: this->_Bx._Buf);

  00035	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00038	72 04		 jb	 SHORT $LN30@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0003c	eb 02		 jmp	 SHORT $LN31@replace
$LN30@replace:
  0003e	8b c6		 mov	 eax, esi
$LN31@replace:

; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully

  00040	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  00043	2b d0		 sub	 edx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	52		 push	 edx
  00048	56		 push	 esi
  00049	ff 75 0c	 push	 DWORD PTR __N0$[ebp]
  0004c	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0004f	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 1479 : 		}

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 10 00	 ret	 16			; 00000010H
$LN8@replace:

; 1456 : 		if (this->_Mysize < _Off)

  0005c	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0005f	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00062	3b d0		 cmp	 edx, eax
  00064	0f 82 00 01 00
	00		 jb	 $LN83@replace

; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)

  0006a	8b 7d 0c	 mov	 edi, DWORD PTR __N0$[ebp]
  0006d	8b ca		 mov	 ecx, edx
  0006f	2b c8		 sub	 ecx, eax
  00071	3b cf		 cmp	 ecx, edi
  00073	53		 push	 ebx

; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)

  00074	8b 5d 14	 mov	 ebx, DWORD PTR __Count$[ebp]
  00077	0f 42 f9	 cmovb	 edi, ecx
  0007a	83 c8 ff	 or	 eax, -1
  0007d	2b d7		 sub	 edx, edi
  0007f	2b c3		 sub	 eax, ebx
  00081	3b c2		 cmp	 eax, edx
  00083	0f 86 eb 00 00
	00		 jbe	 $LN85@replace

; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;

  00089	2b cf		 sub	 ecx, edi
  0008b	89 4d 14	 mov	 DWORD PTR __Nm$1$[ebp], ecx

; 1463 : 
; 1464 : 		if (_Count < _N0)

  0008e	3b df		 cmp	 ebx, edi
  00090	73 3b		 jae	 SHORT $LN54@replace

; 513  : 			: this->_Bx._Buf);

  00092	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00095	83 f8 10	 cmp	 eax, 16			; 00000010H
  00098	72 07		 jb	 SHORT $LN41@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0009a	8b 16		 mov	 edx, DWORD PTR [esi]
  0009c	89 55 0c	 mov	 DWORD PTR tv404[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0009f	eb 03		 jmp	 SHORT $LN42@replace
$LN41@replace:
  000a1	89 75 0c	 mov	 DWORD PTR tv404[ebp], esi
$LN42@replace:
  000a4	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a7	72 04		 jb	 SHORT $LN47@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000a9	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000ab	eb 02		 jmp	 SHORT $LN48@replace
$LN47@replace:
  000ad	8b d6		 mov	 edx, esi
$LN48@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000af	85 c9		 test	 ecx, ecx
  000b1	74 1a		 je	 SHORT $LN54@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1467 : 				_Nm);	// smaller hole, move tail up

  000b3	8b 45 0c	 mov	 eax, DWORD PTR tv404[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000b6	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1467 : 				_Nm);	// smaller hole, move tail up

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  000ba	03 c1		 add	 eax, ecx
  000bc	03 c7		 add	 eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000be	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1467 : 				_Nm);	// smaller hole, move tail up

  000bf	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000c2	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _memmove
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))

  000cd	85 db		 test	 ebx, ebx
  000cf	75 08		 jne	 SHORT $LN2@replace
  000d1	85 ff		 test	 edi, edi
  000d3	0f 84 86 00 00
	00		 je	 $LN3@replace
$LN2@replace:
  000d9	8b c3		 mov	 eax, ebx
  000db	8b ce		 mov	 ecx, esi
  000dd	2b c7		 sub	 eax, edi
  000df	03 46 10	 add	 eax, DWORD PTR [esi+16]
  000e2	6a 00		 push	 0
  000e4	50		 push	 eax
  000e5	89 45 fc	 mov	 DWORD PTR __Num$1$[ebp], eax
  000e8	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  000ed	84 c0		 test	 al, al
  000ef	74 6e		 je	 SHORT $LN3@replace

; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)

  000f1	3b fb		 cmp	 edi, ebx
  000f3	73 3e		 jae	 SHORT $LN70@replace

; 513  : 			: this->_Bx._Buf);

  000f5	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000f8	83 f8 10	 cmp	 eax, 16			; 00000010H
  000fb	72 07		 jb	 SHORT $LN57@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000fd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ff	89 4d 0c	 mov	 DWORD PTR tv402[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00102	eb 03		 jmp	 SHORT $LN58@replace
$LN57@replace:
  00104	89 75 0c	 mov	 DWORD PTR tv402[ebp], esi
$LN58@replace:
  00107	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010a	72 04		 jb	 SHORT $LN63@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0010c	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0010e	eb 02		 jmp	 SHORT $LN64@replace
$LN63@replace:
  00110	8b d6		 mov	 edx, esi
$LN64@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00112	8b 45 14	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00115	85 c0		 test	 eax, eax
  00117	74 1a		 je	 SHORT $LN70@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  00119	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0011c	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  0011d	8b 45 0c	 mov	 eax, DWORD PTR tv402[ebp]
  00120	03 c1		 add	 eax, ecx
  00122	03 c7		 add	 eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00124	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down

  00125	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00128	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memmove
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN70@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00133	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00137	72 04		 jb	 SHORT $LN73@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00139	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0013b	eb 02		 jmp	 SHORT $LN74@replace
$LN73@replace:
  0013d	8b ce		 mov	 ecx, esi
$LN74@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0013f	85 db		 test	 ebx, ebx
  00141	74 12		 je	 SHORT $LN80@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00143	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00146	53		 push	 ebx
  00147	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  0014a	03 c1		 add	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _memcpy
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN80@replace:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1476 : 			_Eos(_Num);

  00155	ff 75 fc	 push	 DWORD PTR __Num$1$[ebp]
  00158	8b ce		 mov	 ecx, esi
  0015a	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@replace:

; 1477 : 			}
; 1478 : 		return (*this);

  0015f	5b		 pop	 ebx
  00160	5f		 pop	 edi
  00161	8b c6		 mov	 eax, esi
  00163	5e		 pop	 esi

; 1479 : 		}

  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c2 10 00	 ret	 16			; 00000010H
$LN83@replace:

; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0016f	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN86@replace:
$LN85@replace:

; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00179	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN87@replace:
$LN82@replace:
  0017e	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 393  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 394  : 		return ((_Mybase)*this - _Right);
; 395  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 202  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 205  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z
_TEXT	SEGMENT
__P2$ = 8						; size = 4
__P1$ = 12						; size = 4
?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Pdif, COMDAT

; 2266 : 		{	// compute safe iterator difference

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);

  00003	8b 45 08	 mov	 eax, DWORD PTR __P2$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN3@Pdif

; 2268 : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN3@Pdif:

; 204  : 		return (this->_Ptr - _Right._Ptr);

  0000c	2b 45 0c	 sub	 eax, DWORD PTR __P1$[ebp]

; 2268 : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Pdif
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 55 14	 mov	 edx, DWORD PTR __Last2$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __First2$[ebp]
  0000a	57		 push	 edi

; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  0000b	8b f9		 mov	 edi, ecx

; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);

  0000d	3b f2		 cmp	 esi, edx

; 1590 : 		if (_First2 == _Last2)

  0000f	75 44		 jne	 SHORT $LN2@replace

; 513  : 			: this->_Bx._Buf);

  00011	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00015	72 04		 jb	 SHORT $LN13@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00017	8b 17		 mov	 edx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00019	eb 02		 jmp	 SHORT $LN14@replace
$LN13@replace:
  0001b	8b d7		 mov	 edx, edi
$LN14@replace:

; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	85 c9		 test	 ecx, ecx
  00025	75 04		 jne	 SHORT $LN25@replace
  00027	33 c9		 xor	 ecx, ecx
  00029	eb 02		 jmp	 SHORT $LN26@replace
$LN25@replace:

; 204  : 		return (this->_Ptr - _Right._Ptr);

  0002b	2b c8		 sub	 ecx, eax
$LN26@replace:

; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);

  0002d	85 c0		 test	 eax, eax
  0002f	75 11		 jne	 SHORT $LN33@replace

; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));

  00031	51		 push	 ecx
  00032	50		 push	 eax
  00033	8b cf		 mov	 ecx, edi
  00035	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1595 : 		return (*this);

  0003a	8b c7		 mov	 eax, edi
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1596 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 10 00	 ret	 16			; 00000010H
$LN33@replace:

; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));

  00042	51		 push	 ecx

; 204  : 		return (this->_Ptr - _Right._Ptr);

  00043	2b c2		 sub	 eax, edx

; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));

  00045	8b cf		 mov	 ecx, edi
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1595 : 		return (*this);

  0004d	8b c7		 mov	 eax, edi
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 1596 : 		}

  00051	5d		 pop	 ebp
  00052	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 513  : 			: this->_Bx._Buf);

  00055	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00059	53		 push	 ebx
  0005a	72 04		 jb	 SHORT $LN43@replace
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0005c	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0005e	eb 02		 jmp	 SHORT $LN44@replace
$LN43@replace:
  00060	8b df		 mov	 ebx, edi
$LN44@replace:

; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);

  00062	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00065	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00068	85 c9		 test	 ecx, ecx
  0006a	75 04		 jne	 SHORT $LN65@replace
  0006c	33 c9		 xor	 ecx, ecx
  0006e	eb 02		 jmp	 SHORT $LN66@replace
$LN65@replace:

; 204  : 		return (this->_Ptr - _Right._Ptr);

  00070	2b c8		 sub	 ecx, eax
$LN66@replace:

; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);

  00072	85 c0		 test	 eax, eax
  00074	74 02		 je	 SHORT $LN74@replace
$LN73@replace:

; 204  : 		return (this->_Ptr - _Right._Ptr);

  00076	2b c3		 sub	 eax, ebx
$LN74@replace:
  00078	2b d6		 sub	 edx, esi

; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);

  0007a	52		 push	 edx
  0007b	56		 push	 esi
  0007c	51		 push	 ecx
  0007d	50		 push	 eax
  0007e	8b cf		 mov	 ecx, edi
  00080	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00085	5b		 pop	 ebx

; 1595 : 		return (*this);

  00086	8b c7		 mov	 eax, edi
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi

; 1596 : 		}

  0008a	5d		 pop	 ebp
  0008b	c2 10 00	 ret	 16			; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 513  : 			: this->_Bx._Buf);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 04		 jb	 SHORT $LN7@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  0000b	eb 02		 jmp	 SHORT $LN8@assign
$LN7@assign:
  0000d	8b d1		 mov	 edx, ecx
$LN8@assign:

; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));

  0000f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00012	03 c2		 add	 eax, edx

; 513  : 			: this->_Bx._Buf);

  00014	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00018	72 13		 jb	 SHORT $LN21@assign

; 1190 : 		return (replace(begin(), end(), _First, _Last));

  0001a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1190 : 		return (replace(begin(), end(), _First, _Last));

  0001f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00022	50		 push	 eax
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1191 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN21@assign:

; 1190 : 		return (replace(begin(), end(), _First, _Last));

  0002d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]

; 513  : 			: this->_Bx._Buf);

  00030	8b d1		 mov	 edx, ecx

; 1190 : 		return (replace(begin(), end(), _First, _Last));

  00032	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1191 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 902  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 903  : 		if (this != &_Right)

  00006	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00009	74 2b		 je	 SHORT $LN115@operator

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0000b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000f	72 0a		 jb	 SHORT $LN25@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00011	ff 36		 push	 DWORD PTR [esi]
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN25@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  0001b	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0001e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00025	8b ce		 mov	 ecx, esi

; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00027	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0002e	c6 06 00	 mov	 BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  00031	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN115@operator:

; 915  : 			}
; 916  : 		return (*this);

  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi

; 917  : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	e9 00 00 00 00	 jmp	 _strchr
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
END
