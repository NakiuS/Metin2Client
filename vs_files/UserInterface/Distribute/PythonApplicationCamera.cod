; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonApplicationCamera.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BE@DMOOAJEE@CenterPos?5?$CFf?5?$CFf?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@PHEEAALI@CameraSetting?5?$CFf?5?$CFf?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@KBBGALHE@CmrPos?5?$CFf?5?$CFf?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0EK@OFJKBEAJ@Line?5?$CCx?$DL?$CFd?$HMy?$DL?$CFd?$HMz?$DL?$CFd?$HMdistance?$DL?$CFd@ ; `string'
PUBLIC	??_C@_09BKJKIBFC@centerpos?$AA@			; `string'
PUBLIC	??_C@_0O@GKCMOHOF@camerasetting?$AA@		; `string'
PUBLIC	??_C@_06MDBDNPGG@cmrpos?$AA@			; `string'
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; `string'
EXTRN	_atof:PROC
EXTRN	?GetTokenVector3@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXVECTOR3@@@Z:PROC ; CTextFileLoader::GetTokenVector3
EXTRN	?GetTokenVector@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z:PROC ; CTextFileLoader::GetTokenVector
EXTRN	?Load@CTextFileLoader@@QAE_NPBD@Z:PROC		; CTextFileLoader::Load
EXTRN	?SetTop@CTextFileLoader@@QAEXXZ:PROC		; CTextFileLoader::SetTop
EXTRN	??0CTextFileLoader@@QAE@XZ:PROC			; CTextFileLoader::CTextFileLoader
EXTRN	??1CTextFileLoader@@UAE@XZ:PROC			; CTextFileLoader::~CTextFileLoader
EXTRN	__imp__SetFileAttributesA@8:PROC
EXTRN	?GetCurrentCameraNum@CCameraManager@@QAEEXZ:PROC ; CCameraManager::GetCurrentCameraNum
EXTRN	?SetCurrentCamera@CCameraManager@@QAEXE@Z:PROC	; CCameraManager::SetCurrentCamera
EXTRN	?IsLock@CCamera@@QAE_NXZ:PROC			; CCamera::IsLock
EXTRN	__imp__GetKeyState@4:PROC
EXTRN	?SetDirection@CSoundManager@@QAEXMMMMMM@Z:PROC	; CSoundManager::SetDirection
EXTRN	?Update@CSoundManager@@QAEXXZ:PROC		; CSoundManager::Update
EXTRN	?IsDraging@CCamera@@QAE_NXZ:PROC		; CCamera::IsDraging
EXTRN	?SetPosition@CSoundManager@@QAEXMMM@Z:PROC	; CSoundManager::SetPosition
EXTRN	?Pitch@CCamera@@QAEXM@Z:PROC			; CCamera::Pitch
EXTRN	?Zoom@CCamera@@QAEXM@Z:PROC			; CCamera::Zoom
EXTRN	?GetTargetHeight@CCamera@@QAEMXZ:PROC		; CCamera::GetTargetHeight
EXTRN	?Roll@CCamera@@QAEXM@Z:PROC			; CCamera::Roll
EXTRN	?Lock@CCamera@@QAEXXZ:PROC			; CCamera::Lock
EXTRN	?MoveFront@CCamera@@QAEXM@Z:PROC		; CCamera::MoveFront
EXTRN	?MoveAlongCross@CCamera@@QAEXM@Z:PROC		; CCamera::MoveAlongCross
EXTRN	?SetPositionCamera@CGraphicBase@@QAEXMMMMMM@Z:PROC ; CGraphicBase::SetPositionCamera
EXTRN	?MoveVertical@CCamera@@QAEXM@Z:PROC		; CCamera::MoveVertical
EXTRN	?Unlock@CCamera@@QAEXXZ:PROC			; CCamera::Unlock
EXTRN	?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ:PROC		; PrintfTabs
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ DB 'invalid v'
	DB	'ector<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDBDNPGG@cmrpos?$AA@
CONST	SEGMENT
??_C@_06MDBDNPGG@cmrpos?$AA@ DB 'cmrpos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKCMOHOF@camerasetting?$AA@
CONST	SEGMENT
??_C@_0O@GKCMOHOF@camerasetting?$AA@ DB 'camerasetting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BKJKIBFC@centerpos?$AA@
CONST	SEGMENT
??_C@_09BKJKIBFC@centerpos?$AA@ DB 'centerpos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@OFJKBEAJ@Line?5?$CCx?$DL?$CFd?$HMy?$DL?$CFd?$HMz?$DL?$CFd?$HMdistance?$DL?$CFd@
CONST	SEGMENT
??_C@_0EK@OFJKBEAJ@Line?5?$CCx?$DL?$CFd?$HMy?$DL?$CFd?$HMz?$DL?$CFd?$HMdistance?$DL?$CFd@ DB 'L'
	DB	'ine "x;%d|y;%d|z;%d|distance;%d|pitch;%d|rot;%d|up;%d|view;%d'
	DB	'|cross;%d"', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KBBGALHE@CmrPos?5?$CFf?5?$CFf?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BB@KBBGALHE@CmrPos?5?$CFf?5?$CFf?5?$CFf?6?$AA@ DB 'CmrPos %f %f %f'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PHEEAALI@CameraSetting?5?$CFf?5?$CFf?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BI@PHEEAALI@CameraSetting?5?$CFf?5?$CFf?5?$CFf?6?$AA@ DB 'CameraSe'
	DB	'tting %f %f %f', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DMOOAJEE@CenterPos?5?$CFf?5?$CFf?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BE@DMOOAJEE@CenterPos?5?$CFf?5?$CFf?5?$CFf?6?$AA@ DB 'CenterPos %f'
	DB	' %f %f', 0aH, 00H				; `string'
PUBLIC	?_Xran@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xran
PUBLIC	?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
PUBLIC	?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z ; CPythonApplication::LoadCameraSetting
PUBLIC	?SaveCameraSetting@CPythonApplication@@QAEXPBD@Z ; CPythonApplication::SaveCameraSetting
PUBLIC	?GetCameraSetting@CPythonApplication@@QAEXPAUSCameraSetting@IAbstractApplication@@@Z ; CPythonApplication::GetCameraSetting
PUBLIC	?SetCameraSetting@CPythonApplication@@QAEXABUSCameraSetting@IAbstractApplication@@@Z ; CPythonApplication::SetCameraSetting
PUBLIC	?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
PUBLIC	?GetPitch@CPythonApplication@@QAEMXZ		; CPythonApplication::GetPitch
PUBLIC	?GetRotation@CPythonApplication@@QAEMXZ		; CPythonApplication::GetRotation
PUBLIC	?MovieResetCamera@CPythonApplication@@QAEXXZ	; CPythonApplication::MovieResetCamera
PUBLIC	?MovieZoomCamera@CPythonApplication@@QAEXH@Z	; CPythonApplication::MovieZoomCamera
PUBLIC	?MoviePitchCamera@CPythonApplication@@QAEXH@Z	; CPythonApplication::MoviePitchCamera
PUBLIC	?MovieRotateCamera@CPythonApplication@@QAEXH@Z	; CPythonApplication::MovieRotateCamera
PUBLIC	?ZoomCamera@CPythonApplication@@QAEXH@Z		; CPythonApplication::ZoomCamera
PUBLIC	?PitchCamera@CPythonApplication@@QAEXH@Z	; CPythonApplication::PitchCamera
PUBLIC	?RotateCamera@CPythonApplication@@QAEXH@Z	; CPythonApplication::RotateCamera
PUBLIC	?GetCamera@CPythonApplication@@QAEXPAM000@Z	; CPythonApplication::GetCamera
PUBLIC	?SetCamera@CPythonApplication@@QAEXMMMM@Z	; CPythonApplication::SetCamera
PUBLIC	?SetUpDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetUpDirCameraSpeed
PUBLIC	?SetCrossDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetCrossDirCameraSpeed
PUBLIC	?SetViewDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetViewDirCameraSpeed
PUBLIC	?BlendValueByLinear@@YAMMMMM@Z			; BlendValueByLinear
PUBLIC	?GetRoll@CCamera@@QBEMXZ			; CCamera::GetRoll
PUBLIC	?GetPitch@CCamera@@QBEMXZ			; CCamera::GetPitch
PUBLIC	?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ		; CCamera::GetView
PUBLIC	?GetUp@CCamera@@QBEABUD3DXVECTOR3@@XZ		; CCamera::GetUp
PUBLIC	?__UpdateCamera@CPythonApplication@@IAEXXZ	; CPythonApplication::__UpdateCamera
PUBLIC	?SetEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@@Z ; CPythonApplication::SetEventCamera
PUBLIC	?BlendEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@M@Z ; CPythonApplication::BlendEventCamera
PUBLIC	?SetDefaultCamera@CPythonApplication@@UAEXXZ	; CPythonApplication::SetDefaultCamera
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z$3
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?SetDefaultCamera@CPythonApplication@@UAEXXZ
_TEXT	SEGMENT
?SetDefaultCamera@CPythonApplication@@UAEXXZ PROC	; CPythonApplication::SetDefaultCamera, COMDAT
; _this$ = ecx

; 296  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 297  : 	m_iCameraMode = CAMERA_MODE_NORMAL;

  00003	c7 86 cc ff 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+131020], 0

; 298  : 	m_fBlendCameraStartTime = 0.0f;

  0000d	c7 86 d0 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+131024], 0

; 299  : 	m_fBlendCameraBlendTime = 0.0f;

  00017	c7 86 d4 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+131028], 0

; 300  : 
; 301  : 	/////
; 302  : 
; 303  : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00027	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 304  : 	if (pCamera)

  0002c	85 c0		 test	 eax, eax
  0002e	74 07		 je	 SHORT $LN2@SetDefault

; 305  : 		pCamera->Unlock();

  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 ?Unlock@CCamera@@QAEXXZ	; CCamera::Unlock
$LN2@SetDefault:

; 306  : 
; 307  : 	if (CCameraManager::DEFAULT_PERSPECTIVE_CAMERA != CCameraManager::Instance().GetCurrentCameraNum())

  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0003d	e8 00 00 00 00	 call	 ?GetCurrentCameraNum@CCameraManager@@QAEEXZ ; CCameraManager::GetCurrentCameraNum
  00042	3c 01		 cmp	 al, 1
  00044	74 1c		 je	 SHORT $LN1@SetDefault

; 308  : 	{
; 309  : 		CCameraManager::Instance().SetCurrentCamera(CCameraManager::DEFAULT_PERSPECTIVE_CAMERA);

  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0004c	6a 01		 push	 1
  0004e	e8 00 00 00 00	 call	 ?SetCurrentCamera@CCameraManager@@QAEXE@Z ; CCameraManager::SetCurrentCamera

; 310  : 		SetCameraSetting(m_DefaultCameraSetting);

  00053	8d 86 84 ff 01
	00		 lea	 eax, DWORD PTR [esi+130948]
  00059	50		 push	 eax
  0005a	8d 4e e0	 lea	 ecx, DWORD PTR [esi-32]
  0005d	e8 00 00 00 00	 call	 ?SetCameraSetting@CPythonApplication@@QAEXABUSCameraSetting@IAbstractApplication@@@Z ; CPythonApplication::SetCameraSetting
$LN1@SetDefault:
  00062	5e		 pop	 esi

; 311  : 	}
; 312  : }

  00063	c3		 ret	 0
?SetDefaultCamera@CPythonApplication@@UAEXXZ ENDP	; CPythonApplication::SetDefaultCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?BlendEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@M@Z
_TEXT	SEGMENT
_c_rCameraSetting$ = 8					; size = 4
_fBlendTime$ = 12					; size = 4
?BlendEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@M@Z PROC ; CPythonApplication::BlendEventCamera, COMDAT
; _this$ = ecx

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 285  : 	m_iCameraMode = CAMERA_MODE_BLEND;

  00006	c7 86 cc ff 01
	00 02 00 00 00	 mov	 DWORD PTR [esi+131020], 2

; 286  : 	m_fBlendCameraStartTime = CTimer::Instance().GetCurrentSecond();

  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00016	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond

; 287  : 	m_fBlendCameraBlendTime = fBlendTime;
; 288  : 	m_kEndBlendCameraSetting = c_rCameraSetting;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _c_rCameraSetting$[ebp]
  0001e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fBlendTime$[ebp]
  00023	d9 9e d0 ff 01
	00		 fstp	 DWORD PTR [esi+131024]
  00029	f3 0f 11 86 d4
	ff 01 00	 movss	 DWORD PTR [esi+131028], xmm0
  00031	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00035	f3 0f 7f 86 d8
	ff 01 00	 movdqu	 XMMWORD PTR [esi+131032], xmm0
  0003d	f3 0f 6f 40 10	 movdqu	 xmm0, XMMWORD PTR [eax+16]
  00042	f3 0f 7f 86 e8
	ff 01 00	 movdqu	 XMMWORD PTR [esi+131048], xmm0
  0004a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0004d	89 86 f8 ff 01
	00		 mov	 DWORD PTR [esi+131064], eax

; 289  : 
; 290  : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00059	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  0005e	5e		 pop	 esi

; 291  : 	if (pCamera)

  0005f	85 c0		 test	 eax, eax
  00061	74 07		 je	 SHORT $LN1@BlendEvent

; 292  : 		pCamera->Lock();

  00063	8b c8		 mov	 ecx, eax
  00065	e8 00 00 00 00	 call	 ?Lock@CCamera@@QAEXXZ	; CCamera::Lock
$LN1@BlendEvent:

; 293  : }

  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
?BlendEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@M@Z ENDP ; CPythonApplication::BlendEventCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?SetEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@@Z
_TEXT	SEGMENT
_c_rCameraSetting$ = 8					; size = 4
?SetEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@@Z PROC ; CPythonApplication::SetEventCamera, COMDAT
; _this$ = ecx

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 266  : 	if (CCameraManager::DEFAULT_PERSPECTIVE_CAMERA == CCameraManager::Instance().GetCurrentCameraNum())

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0000c	e8 00 00 00 00	 call	 ?GetCurrentCameraNum@CCameraManager@@QAEEXZ ; CCameraManager::GetCurrentCameraNum
  00011	3c 01		 cmp	 al, 1
  00013	75 0f		 jne	 SHORT $LN2@SetEventCa

; 267  : 	{
; 268  : 		GetCameraSetting(&m_DefaultCameraSetting);

  00015	8d 87 84 ff 01
	00		 lea	 eax, DWORD PTR [edi+130948]
  0001b	50		 push	 eax
  0001c	8d 4f e0	 lea	 ecx, DWORD PTR [edi-32]
  0001f	e8 00 00 00 00	 call	 ?GetCameraSetting@CPythonApplication@@QAEXPAUSCameraSetting@IAbstractApplication@@@Z ; CPythonApplication::GetCameraSetting
$LN2@SetEventCa:

; 269  : 	}
; 270  : 
; 271  : 	/////
; 272  : 
; 273  : 	CCameraManager::Instance().SetCurrentCamera(EVENT_CAMERA_NUMBER);

  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0002a	6a 65		 push	 101			; 00000065H
  0002c	e8 00 00 00 00	 call	 ?SetCurrentCamera@CCameraManager@@QAEXE@Z ; CCameraManager::SetCurrentCamera

; 274  : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00037	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 275  : 	if (!pCamera)

  0003c	85 c0		 test	 eax, eax
  0003e	74 3a		 je	 SHORT $LN3@SetEventCa

; 276  : 		return;
; 277  : 
; 278  : 	SetCameraSetting(c_rCameraSetting);

  00040	56		 push	 esi
  00041	8b 75 08	 mov	 esi, DWORD PTR _c_rCameraSetting$[ebp]
  00044	8d 4f e0	 lea	 ecx, DWORD PTR [edi-32]
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ?SetCameraSetting@CPythonApplication@@QAEXABUSCameraSetting@IAbstractApplication@@@Z ; CPythonApplication::SetCameraSetting

; 279  : 	m_kEventCameraSetting = c_rCameraSetting;

  0004d	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]
  00051	f3 0f 7f 87 a8
	ff 01 00	 movdqu	 XMMWORD PTR [edi+130984], xmm0
  00059	f3 0f 6f 46 10	 movdqu	 xmm0, XMMWORD PTR [esi+16]
  0005e	f3 0f 7f 87 b8
	ff 01 00	 movdqu	 XMMWORD PTR [edi+131000], xmm0
  00066	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00069	89 87 c8 ff 01
	00		 mov	 DWORD PTR [edi+131016], eax

; 280  : 	m_iCameraMode = CAMERA_MODE_STAND;

  0006f	c7 87 cc ff 01
	00 01 00 00 00	 mov	 DWORD PTR [edi+131020], 1
  00079	5e		 pop	 esi
$LN3@SetEventCa:
  0007a	5f		 pop	 edi

; 281  : }

  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
?SetEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@@Z ENDP ; CPythonApplication::SetEventCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?__UpdateCamera@CPythonApplication@@IAEXXZ
_TEXT	SEGMENT
_fCrossDir$1$ = -36					; size = 4
_fRotation$1 = -36					; size = 4
_fRotation$2 = -36					; size = 4
_fViewDir$1$ = -32					; size = 4
_fPitch$3 = -32						; size = 4
_fPitch$4 = -32						; size = 4
_fUpDir$1$ = -28					; size = 4
_fDistance$5 = -28					; size = 4
_fDistance$6 = -28					; size = 4
_fxCenter$1$ = -24					; size = 4
_fHeight$7 = -24					; size = 4
_fHeight$8 = -24					; size = 4
_fyCenter$1$ = -20					; size = 4
_fzCenter$1$ = -16					; size = 4
_fDistance$1$ = -12					; size = 4
_fPitch$1$ = -8						; size = 4
_fRotation$1$ = -4					; size = 4
_fcurTime$9 = -4					; size = 4
?__UpdateCamera@CPythonApplication@@IAEXXZ PROC		; CPythonApplication::__UpdateCamera, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 17   : 	//////////////////////
; 18   : 	// Camera Setting
; 19   : 	CCamera * pMainCamera = CCameraManager::Instance().GetCurrentCamera();

  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00010	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  00015	8b d8		 mov	 ebx, eax

; 20   : 	if (!pMainCamera)

  00017	85 db		 test	 ebx, ebx
  00019	0f 84 83 04 00
	00		 je	 $LN17@UpdateCame

; 21   : 		return;
; 22   : 
; 23   : 	if (CAMERA_MODE_BLEND == m_iCameraMode)

  0001f	8b 87 ec ff 01
	00		 mov	 eax, DWORD PTR [edi+131052]
  00025	83 f8 02	 cmp	 eax, 2
  00028	0f 85 c0 01 00
	00		 jne	 $LN15@UpdateCame

; 24   : 	{
; 25   : 		float fcurTime = CTimer::Instance().GetCurrentSecond();

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00034	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond

; 26   : 		float fElapsedTime = fcurTime - m_fBlendCameraStartTime;
; 27   : 
; 28   : 		float fxCenter = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.v3CenterPosition.x, m_kEndBlendCameraSetting.v3CenterPosition.x);

  00039	f3 0f 10 8f f4
	ff 01 00	 movss	 xmm1, DWORD PTR [edi+131060]
  00041	f3 0f 10 9f f8
	ff 01 00	 movss	 xmm3, DWORD PTR [edi+131064]
  00049	f3 0f 10 97 c8
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131016]
  00051	d9 5d fc	 fstp	 DWORD PTR _fcurTime$9[ebp]
  00054	f3 0f 10 65 fc	 movss	 xmm4, DWORD PTR _fcurTime$9[ebp]
  00059	f3 0f 5c a7 f0
	ff 01 00	 subss	 xmm4, DWORD PTR [edi+131056]
  00061	0f 28 c4	 movaps	 xmm0, xmm4
  00064	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 29   : 		float fyCenter = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.v3CenterPosition.y, m_kEndBlendCameraSetting.v3CenterPosition.y);

  00069	f3 0f 10 9f fc
	ff 01 00	 movss	 xmm3, DWORD PTR [edi+131068]
  00071	f3 0f 10 97 cc
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131020]
  00079	f3 0f 11 45 e8	 movss	 DWORD PTR _fxCenter$1$[ebp], xmm0
  0007e	0f 28 c4	 movaps	 xmm0, xmm4
  00081	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 30   : 		float fzCenter = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.v3CenterPosition.z, m_kEndBlendCameraSetting.v3CenterPosition.z);

  00086	f3 0f 10 9f 00
	00 02 00	 movss	 xmm3, DWORD PTR [edi+131072]
  0008e	f3 0f 10 97 d0
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131024]
  00096	f3 0f 11 45 ec	 movss	 DWORD PTR _fyCenter$1$[ebp], xmm0
  0009b	0f 28 c4	 movaps	 xmm0, xmm4
  0009e	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 31   : 
; 32   : 		float fDistance = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.fZoom, m_kEndBlendCameraSetting.fZoom);

  000a3	f3 0f 10 9f 18
	00 02 00	 movss	 xmm3, DWORD PTR [edi+131096]
  000ab	f3 0f 10 97 e8
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131048]
  000b3	f3 0f 11 45 f0	 movss	 DWORD PTR _fzCenter$1$[ebp], xmm0
  000b8	0f 28 c4	 movaps	 xmm0, xmm4
  000bb	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 33   : 		float fPitch = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.fPitch, m_kEndBlendCameraSetting.fPitch);

  000c0	f3 0f 10 9f 14
	00 02 00	 movss	 xmm3, DWORD PTR [edi+131092]
  000c8	f3 0f 10 97 e4
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131044]
  000d0	f3 0f 11 45 f4	 movss	 DWORD PTR _fDistance$1$[ebp], xmm0
  000d5	0f 28 c4	 movaps	 xmm0, xmm4
  000d8	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 34   : 		float fRotation = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.fRotation, m_kEndBlendCameraSetting.fRotation);

  000dd	f3 0f 10 9f 10
	00 02 00	 movss	 xmm3, DWORD PTR [edi+131088]
  000e5	f3 0f 10 97 e0
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131040]
  000ed	f3 0f 11 45 f8	 movss	 DWORD PTR _fPitch$1$[ebp], xmm0
  000f2	0f 28 c4	 movaps	 xmm0, xmm4
  000f5	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 35   : 
; 36   : 		float fUpDir = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.kCmrPos.m_fUpDir, m_kEndBlendCameraSetting.kCmrPos.m_fUpDir);

  000fa	f3 0f 10 9f 04
	00 02 00	 movss	 xmm3, DWORD PTR [edi+131076]
  00102	f3 0f 10 97 d4
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131028]
  0010a	f3 0f 11 45 fc	 movss	 DWORD PTR _fRotation$1$[ebp], xmm0
  0010f	0f 28 c4	 movaps	 xmm0, xmm4
  00112	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 37   : 		float fViewDir = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.kCmrPos.m_fViewDir, m_kEndBlendCameraSetting.kCmrPos.m_fViewDir);

  00117	f3 0f 10 9f 08
	00 02 00	 movss	 xmm3, DWORD PTR [edi+131080]
  0011f	f3 0f 10 97 d8
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131032]
  00127	f3 0f 11 45 e4	 movss	 DWORD PTR _fUpDir$1$[ebp], xmm0
  0012c	0f 28 c4	 movaps	 xmm0, xmm4
  0012f	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 38   : 		float fCrossDir = BlendValueByLinear(fElapsedTime, m_fBlendCameraBlendTime, m_kEventCameraSetting.kCmrPos.m_fCrossDir, m_kEndBlendCameraSetting.kCmrPos.m_fCrossDir);

  00134	f3 0f 10 9f 0c
	00 02 00	 movss	 xmm3, DWORD PTR [edi+131084]
  0013c	f3 0f 10 97 dc
	ff 01 00	 movss	 xmm2, DWORD PTR [edi+131036]
  00144	f3 0f 11 45 e0	 movss	 DWORD PTR _fViewDir$1$[ebp], xmm0
  00149	0f 28 c4	 movaps	 xmm0, xmm4
  0014c	e8 00 00 00 00	 call	 ?BlendValueByLinear@@YAMMMMM@Z ; BlendValueByLinear

; 39   : 
; 40   : 		// Temporary. Have to fix that this work in camera class. - [levites]
; 41   : 		pMainCamera->Unlock();

  00151	8b cb		 mov	 ecx, ebx
  00153	f3 0f 11 45 dc	 movss	 DWORD PTR _fCrossDir$1$[ebp], xmm0
  00158	e8 00 00 00 00	 call	 ?Unlock@CCamera@@QAEXXZ	; CCamera::Unlock

; 42   : 		m_pyGraphic.SetPositionCamera(fxCenter, fyCenter, fzCenter, fDistance, fPitch, fRotation);

  0015d	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fRotation$1$[ebp]
  00162	8d 8f 9c 07 00
	00		 lea	 ecx, DWORD PTR [edi+1948]
  00168	83 ec 18	 sub	 esp, 24			; 00000018H
  0016b	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  00171	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fPitch$1$[ebp]
  00176	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  0017c	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fDistance$1$[ebp]
  00181	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00187	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fzCenter$1$[ebp]
  0018c	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00192	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fyCenter$1$[ebp]
  00197	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0019d	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fxCenter$1$[ebp]
  001a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a7	e8 00 00 00 00	 call	 ?SetPositionCamera@CGraphicBase@@QAEXMMMMMM@Z ; CGraphicBase::SetPositionCamera

; 43   : 		pMainCamera->MoveVertical(fUpDir);

  001ac	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fUpDir$1$[ebp]
  001b1	51		 push	 ecx
  001b2	8b cb		 mov	 ecx, ebx
  001b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b9	e8 00 00 00 00	 call	 ?MoveVertical@CCamera@@QAEXM@Z ; CCamera::MoveVertical

; 44   : 		pMainCamera->MoveFront(fViewDir);

  001be	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fViewDir$1$[ebp]
  001c3	51		 push	 ecx
  001c4	8b cb		 mov	 ecx, ebx
  001c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001cb	e8 00 00 00 00	 call	 ?MoveFront@CCamera@@QAEXM@Z ; CCamera::MoveFront

; 45   : 		pMainCamera->MoveAlongCross(fCrossDir);

  001d0	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fCrossDir$1$[ebp]
  001d5	51		 push	 ecx
  001d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001db	8b cb		 mov	 ecx, ebx
  001dd	e8 00 00 00 00	 call	 ?MoveAlongCross@CCamera@@QAEXM@Z ; CCamera::MoveAlongCross

; 46   : 		pMainCamera->Lock();

  001e2	8b cb		 mov	 ecx, ebx
  001e4	e8 00 00 00 00	 call	 ?Lock@CCamera@@QAEXXZ	; CCamera::Lock
  001e9	e9 df 00 00 00	 jmp	 $LN11@UpdateCame
$LN15@UpdateCame:

; 47   : 	}
; 48   : 	else if (CAMERA_MODE_STAND == m_iCameraMode)

  001ee	83 f8 01	 cmp	 eax, 1
  001f1	75 64		 jne	 SHORT $LN13@UpdateCame

; 49   : 	{
; 50   : 		float fDistance, fPitch, fRotation, fHeight;
; 51   : 		GetCamera(&fDistance, &fPitch, &fRotation, &fHeight);

  001f3	8d 45 e8	 lea	 eax, DWORD PTR _fHeight$8[ebp]
  001f6	50		 push	 eax
  001f7	8d 45 dc	 lea	 eax, DWORD PTR _fRotation$2[ebp]
  001fa	50		 push	 eax
  001fb	8d 45 e0	 lea	 eax, DWORD PTR _fPitch$4[ebp]
  001fe	50		 push	 eax
  001ff	8d 45 e4	 lea	 eax, DWORD PTR _fDistance$6[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ?GetCamera@CPythonApplication@@QAEXPAM000@Z ; CPythonApplication::GetCamera

; 52   : 		m_pyGraphic.SetPositionCamera(m_kEventCameraSetting.v3CenterPosition.x,
; 53   : 									  m_kEventCameraSetting.v3CenterPosition.y,
; 54   : 									  m_kEventCameraSetting.v3CenterPosition.z + pMainCamera->GetTargetHeight(),
; 55   : 									  fDistance, fPitch, fRotation);

  00208	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fRotation$2[ebp]
  0020d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00210	8b cb		 mov	 ecx, ebx
  00212	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00218	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fPitch$4[ebp]
  0021d	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00223	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fDistance$6[ebp]
  00228	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022d	e8 00 00 00 00	 call	 ?GetTargetHeight@CCamera@@QAEMXZ ; CCamera::GetTargetHeight
  00232	d8 87 d0 ff 01
	00		 fadd	 DWORD PTR [edi+131024]
  00238	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0023b	f3 0f 10 87 cc
	ff 01 00	 movss	 xmm0, DWORD PTR [edi+131020]
  00243	d9 5c 24 08	 fstp	 DWORD PTR [esp+8]
  00247	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0024d	f3 0f 10 87 c8
	ff 01 00	 movss	 xmm0, DWORD PTR [edi+131016]
  00255	eb 66		 jmp	 SHORT $LN27@UpdateCame
$LN13@UpdateCame:

; 56   : 	}
; 57   : 	else if (CAMERA_MODE_NORMAL == m_iCameraMode)

  00257	85 c0		 test	 eax, eax
  00259	75 72		 jne	 SHORT $LN11@UpdateCame

; 58   : 	{
; 59   : 		float fDistance, fPitch, fRotation, fHeight;
; 60   : 		GetCamera(&fDistance, &fPitch, &fRotation, &fHeight);

  0025b	8d 45 e8	 lea	 eax, DWORD PTR _fHeight$7[ebp]
  0025e	50		 push	 eax
  0025f	8d 45 dc	 lea	 eax, DWORD PTR _fRotation$1[ebp]
  00262	50		 push	 eax
  00263	8d 45 e0	 lea	 eax, DWORD PTR _fPitch$3[ebp]
  00266	50		 push	 eax
  00267	8d 45 e4	 lea	 eax, DWORD PTR _fDistance$5[ebp]
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 ?GetCamera@CPythonApplication@@QAEXPAM000@Z ; CPythonApplication::GetCamera

; 61   : 		m_pyGraphic.SetPositionCamera(m_v3CenterPosition.x, m_v3CenterPosition.y, m_v3CenterPosition.z + pMainCamera->GetTargetHeight(), fDistance, fPitch, fRotation);

  00270	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fRotation$1[ebp]
  00275	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00278	8b cb		 mov	 ecx, ebx
  0027a	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00280	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fPitch$3[ebp]
  00285	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0028b	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fDistance$5[ebp]
  00290	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00295	e8 00 00 00 00	 call	 ?GetTargetHeight@CCamera@@QAEMXZ ; CCamera::GetTargetHeight
  0029a	d8 87 6c ff 01
	00		 fadd	 DWORD PTR [edi+130924]
  002a0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002a3	f3 0f 10 87 68
	ff 01 00	 movss	 xmm0, DWORD PTR [edi+130920]
  002ab	d9 5c 24 08	 fstp	 DWORD PTR [esp+8]
  002af	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002b5	f3 0f 10 87 64
	ff 01 00	 movss	 xmm0, DWORD PTR [edi+130916]
$LN27@UpdateCame:
  002bd	8d 8f 9c 07 00
	00		 lea	 ecx, DWORD PTR [edi+1948]
  002c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c8	e8 00 00 00 00	 call	 ?SetPositionCamera@CGraphicBase@@QAEXMMMMMM@Z ; CGraphicBase::SetPositionCamera
$LN11@UpdateCame:

; 62   : 	}
; 63   : 
; 64   : 	if (0.0f != m_fRotationSpeed)

  002cd	f3 0f 10 8f 1c
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131100]
  002d5	0f 57 c0	 xorps	 xmm0, xmm0
  002d8	0f 2e c1	 ucomiss xmm0, xmm1
  002db	9f		 lahf
  002dc	f6 c4 44	 test	 ah, 68			; 00000044H
  002df	7b 10		 jnp	 SHORT $LN10@UpdateCame

; 65   : 		pMainCamera->Roll(m_fRotationSpeed);

  002e1	51		 push	 ecx
  002e2	8b cb		 mov	 ecx, ebx
  002e4	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  002e9	e8 00 00 00 00	 call	 ?Roll@CCamera@@QAEXM@Z	; CCamera::Roll
  002ee	0f 57 c0	 xorps	 xmm0, xmm0
$LN10@UpdateCame:

; 66   : 	if (0.0f != m_fPitchSpeed)

  002f1	f3 0f 10 8f 20
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131104]
  002f9	0f 2e c1	 ucomiss xmm0, xmm1
  002fc	9f		 lahf
  002fd	f6 c4 44	 test	 ah, 68			; 00000044H
  00300	7b 10		 jnp	 SHORT $LN9@UpdateCame

; 67   : 		pMainCamera->Pitch(m_fPitchSpeed);

  00302	51		 push	 ecx
  00303	8b cb		 mov	 ecx, ebx
  00305	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0030a	e8 00 00 00 00	 call	 ?Pitch@CCamera@@QAEXM@Z	; CCamera::Pitch
  0030f	0f 57 c0	 xorps	 xmm0, xmm0
$LN9@UpdateCame:

; 68   : 	if (0.0f != m_fZoomSpeed)

  00312	f3 0f 10 8f 24
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131108]
  0031a	0f 2e c1	 ucomiss xmm0, xmm1
  0031d	9f		 lahf
  0031e	f6 c4 44	 test	 ah, 68			; 00000044H
  00321	7b 10		 jnp	 SHORT $LN8@UpdateCame

; 69   : 		pMainCamera->Zoom(m_fZoomSpeed);

  00323	51		 push	 ecx
  00324	8b cb		 mov	 ecx, ebx
  00326	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0032b	e8 00 00 00 00	 call	 ?Zoom@CCamera@@QAEXM@Z	; CCamera::Zoom
  00330	0f 57 c0	 xorps	 xmm0, xmm0
$LN8@UpdateCame:

; 70   : 
; 71   : 	if (0.0f !=m_kCmrSpd.m_fViewDir)

  00333	f3 0f 10 8f 44
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131140]
  0033b	0f 2e c1	 ucomiss xmm0, xmm1
  0033e	9f		 lahf
  0033f	f6 c4 44	 test	 ah, 68			; 00000044H
  00342	7b 10		 jnp	 SHORT $LN7@UpdateCame

; 72   : 		m_kCmrPos.m_fViewDir+=m_kCmrSpd.m_fViewDir;

  00344	f3 0f 58 8f 38
	00 02 00	 addss	 xmm1, DWORD PTR [edi+131128]
  0034c	f3 0f 11 8f 38
	00 02 00	 movss	 DWORD PTR [edi+131128], xmm1
$LN7@UpdateCame:

; 73   : 	if (0.0f !=m_kCmrSpd.m_fCrossDir)

  00354	f3 0f 10 8f 48
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131144]
  0035c	0f 2e c1	 ucomiss xmm0, xmm1
  0035f	9f		 lahf
  00360	f6 c4 44	 test	 ah, 68			; 00000044H
  00363	7b 10		 jnp	 SHORT $LN6@UpdateCame

; 74   : 		m_kCmrPos.m_fCrossDir+=m_kCmrSpd.m_fCrossDir;

  00365	f3 0f 58 8f 3c
	00 02 00	 addss	 xmm1, DWORD PTR [edi+131132]
  0036d	f3 0f 11 8f 3c
	00 02 00	 movss	 DWORD PTR [edi+131132], xmm1
$LN6@UpdateCame:

; 75   : 	if (0.0f !=m_kCmrSpd.m_fUpDir)

  00375	f3 0f 10 8f 40
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131136]
  0037d	0f 2e c1	 ucomiss xmm0, xmm1
  00380	9f		 lahf
  00381	f6 c4 44	 test	 ah, 68			; 00000044H
  00384	7b 10		 jnp	 SHORT $LN5@UpdateCame

; 76   : 		m_kCmrPos.m_fUpDir+=m_kCmrSpd.m_fUpDir;

  00386	f3 0f 58 8f 34
	00 02 00	 addss	 xmm1, DWORD PTR [edi+131124]
  0038e	f3 0f 11 8f 34
	00 02 00	 movss	 DWORD PTR [edi+131124], xmm1
$LN5@UpdateCame:

; 77   : 
; 78   : 	if (0.0f != m_kCmrPos.m_fViewDir)

  00396	f3 0f 10 8f 38
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131128]
  0039e	0f 2e c1	 ucomiss xmm0, xmm1
  003a1	9f		 lahf
  003a2	f6 c4 44	 test	 ah, 68			; 00000044H
  003a5	7b 10		 jnp	 SHORT $LN4@UpdateCame

; 79   : 		pMainCamera->MoveFront(m_kCmrPos.m_fViewDir);

  003a7	51		 push	 ecx
  003a8	8b cb		 mov	 ecx, ebx
  003aa	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  003af	e8 00 00 00 00	 call	 ?MoveFront@CCamera@@QAEXM@Z ; CCamera::MoveFront
  003b4	0f 57 c0	 xorps	 xmm0, xmm0
$LN4@UpdateCame:

; 80   : 	if (0.0f != m_kCmrPos.m_fCrossDir)

  003b7	f3 0f 10 8f 3c
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131132]
  003bf	0f 2e c1	 ucomiss xmm0, xmm1
  003c2	9f		 lahf
  003c3	f6 c4 44	 test	 ah, 68			; 00000044H
  003c6	7b 10		 jnp	 SHORT $LN3@UpdateCame

; 81   : 		pMainCamera->MoveAlongCross(m_kCmrPos.m_fCrossDir);

  003c8	51		 push	 ecx
  003c9	8b cb		 mov	 ecx, ebx
  003cb	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  003d0	e8 00 00 00 00	 call	 ?MoveAlongCross@CCamera@@QAEXM@Z ; CCamera::MoveAlongCross
  003d5	0f 57 c0	 xorps	 xmm0, xmm0
$LN3@UpdateCame:

; 82   : 	if (0.0f != m_kCmrPos.m_fUpDir)

  003d8	f3 0f 10 8f 34
	00 02 00	 movss	 xmm1, DWORD PTR [edi+131124]
  003e0	0f 2e c1	 ucomiss xmm0, xmm1
  003e3	9f		 lahf
  003e4	f6 c4 44	 test	 ah, 68			; 00000044H
  003e7	7b 0d		 jnp	 SHORT $LN2@UpdateCame

; 83   : 		pMainCamera->MoveVertical(m_kCmrPos.m_fUpDir);

  003e9	51		 push	 ecx
  003ea	8b cb		 mov	 ecx, ebx
  003ec	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  003f1	e8 00 00 00 00	 call	 ?MoveVertical@CCamera@@QAEXM@Z ; CCamera::MoveVertical
$LN2@UpdateCame:

; 84   : 
; 85   : 	//////////////////////
; 86   : 
; 87   : 	if (pMainCamera->IsDraging())

  003f6	8b cb		 mov	 ecx, ebx
  003f8	e8 00 00 00 00	 call	 ?IsDraging@CCamera@@QAE_NXZ ; CCamera::IsDraging
  003fd	84 c0		 test	 al, al
  003ff	74 0e		 je	 SHORT $LN1@UpdateCame

; 88   : 		SkipRenderBuffering(3000);

  00401	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00404	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00407	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  0040c	ff 50 10	 call	 DWORD PTR [eax+16]
$LN1@UpdateCame:

; 89   : 
; 90   : 	//////////////////////
; 91   : 	// Sound Setting
; 92   : 	const D3DXVECTOR3 & c_rv3CameraDirection = pMainCamera->GetView();
; 93   : 	const D3DXVECTOR3 & c_rv3CameraUp = pMainCamera->GetUp();
; 94   : 	m_SoundManager.SetPosition(m_v3CenterPosition.x, m_v3CenterPosition.y, m_v3CenterPosition.z);	// Listener - 캐릭터 위치

  0040f	f3 0f 10 87 6c
	ff 01 00	 movss	 xmm0, DWORD PTR [edi+130924]
  00417	8d 8f e8 00 00
	00		 lea	 ecx, DWORD PTR [edi+232]
  0041d	56		 push	 esi
  0041e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00421	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00427	f3 0f 10 87 68
	ff 01 00	 movss	 xmm0, DWORD PTR [edi+130920]
  0042f	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00435	f3 0f 10 87 64
	ff 01 00	 movss	 xmm0, DWORD PTR [edi+130916]
  0043d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00442	e8 00 00 00 00	 call	 ?SetPosition@CSoundManager@@QAEXMMM@Z ; CSoundManager::SetPosition

; 95   : 	m_SoundManager.SetDirection(c_rv3CameraDirection.x, c_rv3CameraDirection.y, c_rv3CameraDirection.z, c_rv3CameraUp.x, c_rv3CameraUp.y, c_rv3CameraUp.z);

  00447	f3 0f 10 43 50	 movss	 xmm0, DWORD PTR [ebx+80]
  0044c	8d 8f e8 00 00
	00		 lea	 ecx, DWORD PTR [edi+232]
  00452	83 ec 18	 sub	 esp, 24			; 00000018H
  00455	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  0045b	f3 0f 10 43 4c	 movss	 xmm0, DWORD PTR [ebx+76]
  00460	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  00466	f3 0f 10 43 48	 movss	 xmm0, DWORD PTR [ebx+72]
  0046b	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00471	f3 0f 10 43 5c	 movss	 xmm0, DWORD PTR [ebx+92]
  00476	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0047c	f3 0f 10 43 58	 movss	 xmm0, DWORD PTR [ebx+88]
  00481	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00487	f3 0f 10 43 54	 movss	 xmm0, DWORD PTR [ebx+84]
  0048c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00491	e8 00 00 00 00	 call	 ?SetDirection@CSoundManager@@QAEXMMMMMM@Z ; CSoundManager::SetDirection

; 96   : 	m_SoundManager.Update();

  00496	8d 8f e8 00 00
	00		 lea	 ecx, DWORD PTR [edi+232]
  0049c	e8 00 00 00 00	 call	 ?Update@CSoundManager@@QAEXXZ ; CSoundManager::Update
  004a1	5e		 pop	 esi
$LN17@UpdateCame:
  004a2	5f		 pop	 edi
  004a3	5b		 pop	 ebx

; 97   : 	//////////////////////
; 98   : }

  004a4	8b e5		 mov	 esp, ebp
  004a6	5d		 pop	 ebp
  004a7	c3		 ret	 0
?__UpdateCamera@CPythonApplication@@IAEXXZ ENDP		; CPythonApplication::__UpdateCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\camera.h
;	COMDAT ?GetUp@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetUp@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetUp, COMDAT
; _this$ = ecx

; 170  : 		const D3DXVECTOR3 & GetUp() const		{ return m_v3Up; }

  00000	8d 41 48	 lea	 eax, DWORD PTR [ecx+72]
  00003	c3		 ret	 0
?GetUp@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\camera.h
;	COMDAT ?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetView, COMDAT
; _this$ = ecx

; 171  : 		const D3DXVECTOR3 & GetView() const		{ return m_v3View; }

  00000	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  00003	c3		 ret	 0
?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetView
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\camera.h
;	COMDAT ?GetPitch@CCamera@@QBEMXZ
_TEXT	SEGMENT
?GetPitch@CCamera@@QBEMXZ PROC				; CCamera::GetPitch, COMDAT
; _this$ = ecx

; 184  : 		float GetPitch() const { return m_fPitch; }

  00000	f3 0f 10 81 2c
	01 00 00	 movss	 xmm0, DWORD PTR [ecx+300]
  00008	c3		 ret	 0
?GetPitch@CCamera@@QBEMXZ ENDP				; CCamera::GetPitch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\camera.h
;	COMDAT ?GetRoll@CCamera@@QBEMXZ
_TEXT	SEGMENT
?GetRoll@CCamera@@QBEMXZ PROC				; CCamera::GetRoll, COMDAT
; _this$ = ecx

; 185  : 		float GetRoll() const { return m_fRoll; }

  00000	f3 0f 10 81 30
	01 00 00	 movss	 xmm0, DWORD PTR [ecx+304]
  00008	c3		 ret	 0
?GetRoll@CCamera@@QBEMXZ ENDP				; CCamera::GetRoll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?BlendValueByLinear@@YAMMMMM@Z
_TEXT	SEGMENT
?BlendValueByLinear@@YAMMMMM@Z PROC			; BlendValueByLinear, COMDAT
; _fElapsedTime$ = xmm0s
; _fDuration$ = xmm1s
; _fBeginValue$ = xmm2s
; _fEndValue$ = xmm3s

; 9    : 	if (fElapsedTime >= fDuration)

  00000	0f 2f c1	 comiss	 xmm0, xmm1
  00003	72 04		 jb	 SHORT $LN1@BlendValue

; 10   : 		return fEndValue;

  00005	0f 28 c3	 movaps	 xmm0, xmm3

; 13   : }

  00008	c3		 ret	 0
$LN1@BlendValue:

; 11   : 
; 12   : 	return (fEndValue - fBeginValue) * (fElapsedTime / fDuration) + fBeginValue;

  00009	f3 0f 5e c1	 divss	 xmm0, xmm1
  0000d	f3 0f 5c da	 subss	 xmm3, xmm2
  00011	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00015	f3 0f 58 c2	 addss	 xmm0, xmm2

; 13   : }

  00019	c3		 ret	 0
?BlendValueByLinear@@YAMMMMM@Z ENDP			; BlendValueByLinear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?SetViewDirCameraSpeed@CPythonApplication@@QAEXM@Z
_TEXT	SEGMENT
_fSpeed$1$ = -4						; size = 4
?SetViewDirCameraSpeed@CPythonApplication@@QAEXM@Z PROC	; CPythonApplication::SetViewDirCameraSpeed, COMDAT
; _this$ = ecx
; _fSpeed$ = xmm1s

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	f3 0f 11 4d fc	 movss	 DWORD PTR _fSpeed$1$[ebp], xmm1
  0000a	8b f1		 mov	 esi, ecx

; 102  : 	if (IsLockCurrentCamera())

  0000c	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  00011	84 c0		 test	 al, al
  00013	75 0d		 jne	 SHORT $LN2@SetViewDir

; 103  : 		return;
; 104  : 
; 105  : 	m_kCmrSpd.m_fViewDir=fSpeed;

  00015	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fSpeed$1$[ebp]
  0001a	f3 0f 11 86 44
	00 02 00	 movss	 DWORD PTR [esi+131140], xmm0
$LN2@SetViewDir:
  00022	5e		 pop	 esi

; 106  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?SetViewDirCameraSpeed@CPythonApplication@@QAEXM@Z ENDP	; CPythonApplication::SetViewDirCameraSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?SetCrossDirCameraSpeed@CPythonApplication@@QAEXM@Z
_TEXT	SEGMENT
_fSpeed$1$ = -4						; size = 4
?SetCrossDirCameraSpeed@CPythonApplication@@QAEXM@Z PROC ; CPythonApplication::SetCrossDirCameraSpeed, COMDAT
; _this$ = ecx
; _fSpeed$ = xmm1s

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	f3 0f 11 4d fc	 movss	 DWORD PTR _fSpeed$1$[ebp], xmm1
  0000a	8b f1		 mov	 esi, ecx

; 110  : 	if (IsLockCurrentCamera())

  0000c	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  00011	84 c0		 test	 al, al
  00013	75 0d		 jne	 SHORT $LN2@SetCrossDi

; 111  : 		return;
; 112  : 
; 113  : 	m_kCmrSpd.m_fCrossDir=fSpeed;

  00015	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fSpeed$1$[ebp]
  0001a	f3 0f 11 86 48
	00 02 00	 movss	 DWORD PTR [esi+131144], xmm0
$LN2@SetCrossDi:
  00022	5e		 pop	 esi

; 114  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?SetCrossDirCameraSpeed@CPythonApplication@@QAEXM@Z ENDP ; CPythonApplication::SetCrossDirCameraSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?SetUpDirCameraSpeed@CPythonApplication@@QAEXM@Z
_TEXT	SEGMENT
_fSpeed$1$ = -4						; size = 4
?SetUpDirCameraSpeed@CPythonApplication@@QAEXM@Z PROC	; CPythonApplication::SetUpDirCameraSpeed, COMDAT
; _this$ = ecx
; _fSpeed$ = xmm1s

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	f3 0f 11 4d fc	 movss	 DWORD PTR _fSpeed$1$[ebp], xmm1
  0000a	8b f1		 mov	 esi, ecx

; 118  : 	if (IsLockCurrentCamera())

  0000c	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  00011	84 c0		 test	 al, al
  00013	75 0d		 jne	 SHORT $LN2@SetUpDirCa

; 119  : 		return;
; 120  : 
; 121  : 	m_kCmrSpd.m_fUpDir=fSpeed;

  00015	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fSpeed$1$[ebp]
  0001a	f3 0f 11 86 40
	00 02 00	 movss	 DWORD PTR [esi+131136], xmm0
$LN2@SetUpDirCa:
  00022	5e		 pop	 esi

; 122  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?SetUpDirCameraSpeed@CPythonApplication@@QAEXM@Z ENDP	; CPythonApplication::SetUpDirCameraSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?SetCamera@CPythonApplication@@QAEXMMMM@Z
_TEXT	SEGMENT
_v3Target$ = -24					; size = 12
_Distance$1$ = -12					; size = 4
_Pitch$1$ = -8						; size = 4
_Rotation$1$ = -4					; size = 4
_fDestinationHeight$ = 8				; size = 4
?SetCamera@CPythonApplication@@QAEXMMMM@Z PROC		; CPythonApplication::SetCamera, COMDAT
; _this$ = ecx
; _Distance$ = xmm1s
; _Pitch$ = xmm2s
; _Rotation$ = xmm3s

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	f3 0f 11 5d fc	 movss	 DWORD PTR _Rotation$1$[ebp], xmm3
  0000c	8b f1		 mov	 esi, ecx
  0000e	f3 0f 11 55 f8	 movss	 DWORD PTR _Pitch$1$[ebp], xmm2
  00013	f3 0f 11 4d f4	 movss	 DWORD PTR _Distance$1$[ebp], xmm1

; 126  : 	if (IsLockCurrentCamera())

  00018	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  0001d	84 c0		 test	 al, al
  0001f	0f 85 93 00 00
	00		 jne	 $LN1@SetCamera

; 127  : 		return;
; 128  : 
; 129  : 	CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0002b	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 130  : 	if (!pCurrentCamera)

  00030	85 c0		 test	 eax, eax
  00032	0f 84 80 00 00
	00		 je	 $LN1@SetCamera

; 131  : 		return;
; 132  : 
; 133  : 	D3DXVECTOR3 v3Target = pCurrentCamera->GetTarget();

  00038	f3 0f 7e 40 3c	 movq	 xmm0, QWORD PTR [eax+60]

; 134  : 	m_pyGraphic.SetPositionCamera(v3Target.x, v3Target.y, v3Target.z, Distance, Pitch, Rotation);

  0003d	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  00043	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00046	83 ec 18	 sub	 esp, 24			; 00000018H
  00049	66 0f d6 45 e8	 movq	 QWORD PTR _v3Target$[ebp], xmm0
  0004e	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _Rotation$1$[ebp]
  00053	89 45 f0	 mov	 DWORD PTR _v3Target$[ebp+8], eax
  00056	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  0005c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _Pitch$1$[ebp]
  00061	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  00067	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _Distance$1$[ebp]
  0006c	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00072	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3Target$[ebp+8]
  00077	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0007d	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v3Target$[ebp+4]
  00082	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00088	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _v3Target$[ebp]
  0008d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00092	e8 00 00 00 00	 call	 ?SetPositionCamera@CGraphicBase@@QAEXMMMMMM@Z ; CGraphicBase::SetPositionCamera

; 135  : 
; 136  : 	CCamera * pMainCamera = CCameraManager::Instance().GetCurrentCamera();

  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0009d	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 137  : 	if (pMainCamera)

  000a2	85 c0		 test	 eax, eax
  000a4	74 12		 je	 SHORT $LN1@SetCamera

; 138  : 		pMainCamera->SetTargetHeight(fDestinationHeight);

  000a6	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fDestinationHeight$[ebp]
  000ab	51		 push	 ecx
  000ac	8b c8		 mov	 ecx, eax
  000ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b3	e8 00 00 00 00	 call	 ?SetTargetHeight@CCamera@@QAEXM@Z ; CCamera::SetTargetHeight
$LN1@SetCamera:
  000b8	5e		 pop	 esi

; 139  : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
?SetCamera@CPythonApplication@@QAEXMMMM@Z ENDP		; CPythonApplication::SetCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?GetCamera@CPythonApplication@@QAEXPAM000@Z
_TEXT	SEGMENT
_Distance$ = 8						; size = 4
_Pitch$ = 12						; size = 4
_Rotation$ = 16						; size = 4
_DestinationHeight$ = 20				; size = 4
?GetCamera@CPythonApplication@@QAEXPAM000@Z PROC	; CPythonApplication::GetCamera, COMDAT
; _this$dead$ = ecx

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  : 	CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00009	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 144  : 	*Distance			= pCurrentCamera->GetDistance();

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _Distance$[ebp]
  00011	8b 90 34 01 00
	00		 mov	 edx, DWORD PTR [eax+308]
  00017	89 11		 mov	 DWORD PTR [ecx], edx

; 145  : 	*Pitch				= pCurrentCamera->GetPitch();

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _Pitch$[ebp]
  0001c	8b 90 2c 01 00
	00		 mov	 edx, DWORD PTR [eax+300]
  00022	89 11		 mov	 DWORD PTR [ecx], edx

; 146  : 	*Rotation			= pCurrentCamera->GetRoll();

  00024	8b 4d 10	 mov	 ecx, DWORD PTR _Rotation$[ebp]
  00027	8b 90 30 01 00
	00		 mov	 edx, DWORD PTR [eax+304]
  0002d	89 11		 mov	 DWORD PTR [ecx], edx

; 147  : 	*DestinationHeight	= pCurrentCamera->GetTarget().z;

  0002f	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00032	8b 45 14	 mov	 eax, DWORD PTR _DestinationHeight$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 148  : }

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
?GetCamera@CPythonApplication@@QAEXPAM000@Z ENDP	; CPythonApplication::GetCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?RotateCamera@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_iDirection$ = 8					; size = 4
?RotateCamera@CPythonApplication@@QAEXH@Z PROC		; CPythonApplication::RotateCamera, COMDAT
; _this$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 152  : 	if (IsLockCurrentCamera())

  00006	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  0000b	84 c0		 test	 al, al
  0000d	75 18		 jne	 SHORT $LN2@RotateCame

; 153  : 		return;
; 154  : 
; 155  : 	float fDegree = m_fCameraRotateSpeed * float(iDirection);

  0000f	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iDirection$[ebp]
  00014	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00017	f3 0f 59 86 28
	00 02 00	 mulss	 xmm0, DWORD PTR [esi+131112]

; 156  : 	m_fRotationSpeed = fDegree;

  0001f	f3 0f 11 86 1c
	00 02 00	 movss	 DWORD PTR [esi+131100], xmm0
$LN2@RotateCame:
  00027	5e		 pop	 esi

; 157  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?RotateCamera@CPythonApplication@@QAEXH@Z ENDP		; CPythonApplication::RotateCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?PitchCamera@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_iDirection$ = 8					; size = 4
?PitchCamera@CPythonApplication@@QAEXH@Z PROC		; CPythonApplication::PitchCamera, COMDAT
; _this$ = ecx

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 161  : 	if (IsLockCurrentCamera())

  00006	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  0000b	84 c0		 test	 al, al
  0000d	75 18		 jne	 SHORT $LN2@PitchCamer

; 162  : 		return;
; 163  : 
; 164  : 	float fDegree = m_fCameraPitchSpeed * float(iDirection);

  0000f	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iDirection$[ebp]
  00014	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00017	f3 0f 59 86 2c
	00 02 00	 mulss	 xmm0, DWORD PTR [esi+131116]

; 165  : 	m_fPitchSpeed = fDegree;

  0001f	f3 0f 11 86 20
	00 02 00	 movss	 DWORD PTR [esi+131104], xmm0
$LN2@PitchCamer:
  00027	5e		 pop	 esi

; 166  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?PitchCamera@CPythonApplication@@QAEXH@Z ENDP		; CPythonApplication::PitchCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?ZoomCamera@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_iDirection$ = 8					; size = 4
?ZoomCamera@CPythonApplication@@QAEXH@Z PROC		; CPythonApplication::ZoomCamera, COMDAT
; _this$ = ecx

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 170  : 	if (IsLockCurrentCamera())

  00006	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  0000b	84 c0		 test	 al, al
  0000d	75 20		 jne	 SHORT $LN2@ZoomCamera

; 171  : 		return;
; 172  : 
; 173  : 	float fRatio = 1.0f + m_fCameraZoomSpeed * float(iDirection);

  0000f	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iDirection$[ebp]
  00014	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00017	f3 0f 59 86 30
	00 02 00	 mulss	 xmm0, DWORD PTR [esi+131120]
  0001f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000

; 174  : 	m_fZoomSpeed = fRatio;

  00027	f3 0f 11 86 24
	00 02 00	 movss	 DWORD PTR [esi+131108], xmm0
$LN2@ZoomCamera:
  0002f	5e		 pop	 esi

; 175  : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?ZoomCamera@CPythonApplication@@QAEXH@Z ENDP		; CPythonApplication::ZoomCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?MovieRotateCamera@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_fDegree$1$ = 8						; size = 4
_iDirection$ = 8					; size = 4
?MovieRotateCamera@CPythonApplication@@QAEXH@Z PROC	; CPythonApplication::MovieRotateCamera, COMDAT
; _this$ = ecx

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 179  : 	if (IsLockCurrentCamera())

  00006	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  0000b	84 c0		 test	 al, al
  0000d	75 53		 jne	 SHORT $LN4@MovieRotat

; 180  : 		return;
; 181  : 
; 182  : 	float fDegree = m_fCameraRotateSpeed * float(iDirection);
; 183  : 	if (m_isSpecialCameraMode)

  0000f	83 be 4c 00 02
	00 00		 cmp	 DWORD PTR [esi+131148], 0
  00016	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iDirection$[ebp]
  0001b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0001e	f3 0f 59 86 28
	00 02 00	 mulss	 xmm0, DWORD PTR [esi+131112]
  00026	f3 0f 11 45 08	 movss	 DWORD PTR _fDegree$1$[ebp], xmm0
  0002b	74 2d		 je	 SHORT $LN1@MovieRotat

; 184  : 	{
; 185  : 		if (GetKeyState(VK_SCROLL) & 1)

  0002d	68 91 00 00 00	 push	 145			; 00000091H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  00038	a8 01		 test	 al, 1
  0003a	74 19		 je	 SHORT $LN6@MovieRotat

; 186  : 		{
; 187  : 			SetCrossDirCameraSpeed(-fDegree * 6.0f);

  0003c	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fDegree$1$[ebp]
  00041	8b ce		 mov	 ecx, esi
  00043	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@c0c00000
  0004b	e8 00 00 00 00	 call	 ?SetCrossDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetCrossDirCameraSpeed
  00050	5e		 pop	 esi

; 192  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN6@MovieRotat:
  00055	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fDegree$1$[ebp]
$LN1@MovieRotat:

; 188  : 			return;
; 189  : 		}
; 190  : 	}
; 191  : 	m_fRotationSpeed = fDegree;

  0005a	f3 0f 11 86 1c
	00 02 00	 movss	 DWORD PTR [esi+131100], xmm0
$LN4@MovieRotat:
  00062	5e		 pop	 esi

; 192  : }

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?MovieRotateCamera@CPythonApplication@@QAEXH@Z ENDP	; CPythonApplication::MovieRotateCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?MoviePitchCamera@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_fDegree$1$ = 8						; size = 4
_iDirection$ = 8					; size = 4
?MoviePitchCamera@CPythonApplication@@QAEXH@Z PROC	; CPythonApplication::MoviePitchCamera, COMDAT
; _this$ = ecx

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 196  : 	if (IsLockCurrentCamera())

  00006	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  0000b	84 c0		 test	 al, al
  0000d	75 53		 jne	 SHORT $LN4@MoviePitch

; 197  : 		return;
; 198  : 
; 199  : 	float fDegree = m_fCameraPitchSpeed * float(iDirection);
; 200  : 	if (m_isSpecialCameraMode)

  0000f	83 be 4c 00 02
	00 00		 cmp	 DWORD PTR [esi+131148], 0
  00016	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iDirection$[ebp]
  0001b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0001e	f3 0f 59 86 2c
	00 02 00	 mulss	 xmm0, DWORD PTR [esi+131116]
  00026	f3 0f 11 45 08	 movss	 DWORD PTR _fDegree$1$[ebp], xmm0
  0002b	74 2d		 je	 SHORT $LN1@MoviePitch

; 201  : 	{
; 202  : 		if (GetKeyState(VK_SCROLL) & 1)

  0002d	68 91 00 00 00	 push	 145			; 00000091H
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  00038	a8 01		 test	 al, 1
  0003a	74 19		 je	 SHORT $LN6@MoviePitch

; 203  : 		{
; 204  : 			SetViewDirCameraSpeed(-fDegree * 6.0f);

  0003c	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fDegree$1$[ebp]
  00041	8b ce		 mov	 ecx, esi
  00043	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@c0c00000
  0004b	e8 00 00 00 00	 call	 ?SetViewDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetViewDirCameraSpeed
  00050	5e		 pop	 esi

; 209  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN6@MoviePitch:
  00055	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fDegree$1$[ebp]
$LN1@MoviePitch:

; 205  : 			return;
; 206  : 		}
; 207  : 	}
; 208  : 	m_fPitchSpeed = fDegree;

  0005a	f3 0f 11 86 20
	00 02 00	 movss	 DWORD PTR [esi+131104], xmm0
$LN4@MoviePitch:
  00062	5e		 pop	 esi

; 209  : }

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?MoviePitchCamera@CPythonApplication@@QAEXH@Z ENDP	; CPythonApplication::MoviePitchCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?MovieZoomCamera@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_fRatio$1$ = 8						; size = 4
_iDirection$ = 8					; size = 4
?MovieZoomCamera@CPythonApplication@@QAEXH@Z PROC	; CPythonApplication::MovieZoomCamera, COMDAT
; _this$ = ecx

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 213  : 	if (IsLockCurrentCamera())

  00006	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  0000b	84 c0		 test	 al, al
  0000d	75 66		 jne	 SHORT $LN4@MovieZoomC

; 214  : 		return;
; 215  : 
; 216  : 	float fRatio = 1.0f + m_fCameraZoomSpeed * float(iDirection);
; 217  : 	if (m_isSpecialCameraMode)

  0000f	83 be 4c 00 02
	00 00		 cmp	 DWORD PTR [esi+131148], 0
  00016	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _iDirection$[ebp]
  0001b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0001e	f3 0f 59 86 30
	00 02 00	 mulss	 xmm0, DWORD PTR [esi+131120]
  00026	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0002e	f3 0f 11 45 08	 movss	 DWORD PTR _fRatio$1$[ebp], xmm0
  00033	74 38		 je	 SHORT $LN1@MovieZoomC

; 218  : 	{
; 219  : 		if (GetKeyState(VK_SCROLL) & 1)

  00035	68 91 00 00 00	 push	 145			; 00000091H
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  00040	a8 01		 test	 al, 1
  00042	74 24		 je	 SHORT $LN6@MovieZoomC

; 220  : 		{
; 221  : 			SetUpDirCameraSpeed((1.0f - fRatio) * 200.0f);

  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004c	8b ce		 mov	 ecx, esi
  0004e	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _fRatio$1$[ebp]
  00053	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@43480000
  0005b	0f 28 c8	 movaps	 xmm1, xmm0
  0005e	e8 00 00 00 00	 call	 ?SetUpDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetUpDirCameraSpeed
  00063	5e		 pop	 esi

; 226  : }

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN6@MovieZoomC:
  00068	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fRatio$1$[ebp]
$LN1@MovieZoomC:

; 222  : 			return;
; 223  : 		}
; 224  : 	}
; 225  : 	m_fZoomSpeed = fRatio;

  0006d	f3 0f 11 86 24
	00 02 00	 movss	 DWORD PTR [esi+131108], xmm0
$LN4@MovieZoomC:
  00075	5e		 pop	 esi

; 226  : }

  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
?MovieZoomCamera@CPythonApplication@@QAEXH@Z ENDP	; CPythonApplication::MovieZoomCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?MovieResetCamera@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
?MovieResetCamera@CPythonApplication@@QAEXXZ PROC	; CPythonApplication::MovieResetCamera, COMDAT
; _this$ = ecx

; 229  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 230  : 	if (IsLockCurrentCamera())

  00003	e8 00 00 00 00	 call	 ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsLockCurrentCamera
  00008	84 c0		 test	 al, al
  0000a	75 45		 jne	 SHORT $LN1@MovieReset

; 231  : 		return;
; 232  : 
; 233  : 	if (m_isSpecialCameraMode)

  0000c	83 be 4c 00 02
	00 00		 cmp	 DWORD PTR [esi+131148], 0
  00013	74 3c		 je	 SHORT $LN1@MovieReset

; 234  : 	{
; 235  : 		SetCrossDirCameraSpeed(0.0f);

  00015	0f 57 c9	 xorps	 xmm1, xmm1
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?SetCrossDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetCrossDirCameraSpeed
  0001f	0f 57 c9	 xorps	 xmm1, xmm1

; 236  : 		SetViewDirCameraSpeed(0.0f);

  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?SetViewDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetViewDirCameraSpeed
  00029	0f 57 c9	 xorps	 xmm1, xmm1

; 237  : 		SetUpDirCameraSpeed(0.0f);

  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?SetUpDirCameraSpeed@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetUpDirCameraSpeed

; 238  : 
; 239  : 		m_kCmrPos.m_fViewDir = 0;

  00033	c7 86 38 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131128], 0

; 240  : 		m_kCmrPos.m_fCrossDir = 0;

  0003d	c7 86 3c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131132], 0

; 241  : 		m_kCmrPos.m_fUpDir = 0;

  00047	c7 86 34 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131124], 0
$LN1@MovieReset:
  00051	5e		 pop	 esi

; 242  : 	}
; 243  : }

  00052	c3		 ret	 0
?MovieResetCamera@CPythonApplication@@QAEXXZ ENDP	; CPythonApplication::MovieResetCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?GetRotation@CPythonApplication@@QAEMXZ
_TEXT	SEGMENT
?GetRotation@CPythonApplication@@QAEMXZ PROC		; CPythonApplication::GetRotation, COMDAT
; _this$dead$ = ecx

; 247  : 	return CCameraManager::Instance().GetCurrentCamera()->GetRoll();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  0000b	f3 0f 10 80 30
	01 00 00	 movss	 xmm0, DWORD PTR [eax+304]

; 248  : }

  00013	c3		 ret	 0
?GetRotation@CPythonApplication@@QAEMXZ ENDP		; CPythonApplication::GetRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?GetPitch@CPythonApplication@@QAEMXZ
_TEXT	SEGMENT
?GetPitch@CPythonApplication@@QAEMXZ PROC		; CPythonApplication::GetPitch, COMDAT
; _this$dead$ = ecx

; 252  : 	return CCameraManager::Instance().GetCurrentCamera()->GetPitch();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  0000b	f3 0f 10 80 2c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+300]

; 253  : }

  00013	c3		 ret	 0
?GetPitch@CPythonApplication@@QAEMXZ ENDP		; CPythonApplication::GetPitch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ
_TEXT	SEGMENT
?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ PROC	; CPythonApplication::IsLockCurrentCamera, COMDAT
; _this$dead$ = ecx

; 257  : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 258  : 	if (!pCamera)

  0000b	85 c0		 test	 eax, eax
  0000d	75 03		 jne	 SHORT $LN1@IsLockCurr

; 259  : 		return false;

  0000f	32 c0		 xor	 al, al

; 262  : }

  00011	c3		 ret	 0
$LN1@IsLockCurr:

; 260  : 
; 261  : 	return pCamera->IsLock();

  00012	8b c8		 mov	 ecx, eax
  00014	e9 00 00 00 00	 jmp	 ?IsLock@CCamera@@QAE_NXZ ; CCamera::IsLock
?IsLockCurrentCamera@CPythonApplication@@QAE_NXZ ENDP	; CPythonApplication::IsLockCurrentCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?SetCameraSetting@CPythonApplication@@QAEXABUSCameraSetting@IAbstractApplication@@@Z
_TEXT	SEGMENT
_c_rCameraSetting$ = 8					; size = 4
?SetCameraSetting@CPythonApplication@@QAEXABUSCameraSetting@IAbstractApplication@@@Z PROC ; CPythonApplication::SetCameraSetting, COMDAT
; _this$ = ecx

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 316  : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  00012	8b f8		 mov	 edi, eax

; 317  : 	if (!pCamera)

  00014	85 ff		 test	 edi, edi
  00016	0f 84 07 01 00
	00		 je	 $LN5@SetCameraS

; 318  : 		return;
; 319  : 
; 320  : 	m_pyGraphic.SetPositionCamera(	c_rCameraSetting.v3CenterPosition.x,
; 321  : 									c_rCameraSetting.v3CenterPosition.y,
; 322  : 									c_rCameraSetting.v3CenterPosition.z,
; 323  : 									c_rCameraSetting.fZoom,
; 324  : 									c_rCameraSetting.fPitch,
; 325  : 									c_rCameraSetting.fRotation);

  0001c	53		 push	 ebx
  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _c_rCameraSetting$[ebp]
  00020	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  00026	83 ec 18	 sub	 esp, 24			; 00000018H
  00029	f3 0f 10 43 18	 movss	 xmm0, DWORD PTR [ebx+24]
  0002e	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  00034	f3 0f 10 43 1c	 movss	 xmm0, DWORD PTR [ebx+28]
  00039	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  0003f	f3 0f 10 43 20	 movss	 xmm0, DWORD PTR [ebx+32]
  00044	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  0004a	f3 0f 10 43 08	 movss	 xmm0, DWORD PTR [ebx+8]
  0004f	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00055	f3 0f 10 43 04	 movss	 xmm0, DWORD PTR [ebx+4]
  0005a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00060	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
  00064	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00069	e8 00 00 00 00	 call	 ?SetPositionCamera@CGraphicBase@@QAEXMMMMMM@Z ; CGraphicBase::SetPositionCamera

; 326  : 
; 327  : 	if (0.0f != c_rCameraSetting.kCmrPos.m_fViewDir)

  0006e	f3 0f 10 4b 10	 movss	 xmm1, DWORD PTR [ebx+16]
  00073	0f 57 c0	 xorps	 xmm0, xmm0
  00076	0f 2e c1	 ucomiss xmm0, xmm1
  00079	9f		 lahf
  0007a	f6 c4 44	 test	 ah, 68			; 00000044H
  0007d	7b 0d		 jnp	 SHORT $LN3@SetCameraS

; 328  : 		pCamera->MoveFront(c_rCameraSetting.kCmrPos.m_fViewDir);

  0007f	51		 push	 ecx
  00080	8b cf		 mov	 ecx, edi
  00082	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00087	e8 00 00 00 00	 call	 ?MoveFront@CCamera@@QAEXM@Z ; CCamera::MoveFront
$LN3@SetCameraS:

; 329  : 	if (0.0f != c_rCameraSetting.kCmrPos.m_fCrossDir)

  0008c	f3 0f 10 43 14	 movss	 xmm0, DWORD PTR [ebx+20]
  00091	0f 57 c9	 xorps	 xmm1, xmm1
  00094	0f 2e c8	 ucomiss xmm1, xmm0
  00097	9f		 lahf
  00098	f6 c4 44	 test	 ah, 68			; 00000044H
  0009b	7b 10		 jnp	 SHORT $LN2@SetCameraS

; 330  : 		pCamera->MoveAlongCross(c_rCameraSetting.kCmrPos.m_fCrossDir);

  0009d	51		 push	 ecx
  0009e	8b cf		 mov	 ecx, edi
  000a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a5	e8 00 00 00 00	 call	 ?MoveAlongCross@CCamera@@QAEXM@Z ; CCamera::MoveAlongCross
  000aa	0f 57 c9	 xorps	 xmm1, xmm1
$LN2@SetCameraS:

; 331  : 	if (0.0f != c_rCameraSetting.kCmrPos.m_fUpDir)

  000ad	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR [ebx+12]
  000b2	0f 2e c8	 ucomiss xmm1, xmm0
  000b5	5b		 pop	 ebx
  000b6	9f		 lahf
  000b7	f6 c4 44	 test	 ah, 68			; 00000044H
  000ba	7b 0d		 jnp	 SHORT $LN1@SetCameraS

; 332  : 		pCamera->MoveVertical(c_rCameraSetting.kCmrPos.m_fUpDir);

  000bc	51		 push	 ecx
  000bd	8b cf		 mov	 ecx, edi
  000bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c4	e8 00 00 00 00	 call	 ?MoveVertical@CCamera@@QAEXM@Z ; CCamera::MoveVertical
$LN1@SetCameraS:

; 333  : 
; 334  : 	m_kCmrPos.m_fUpDir = 0.0f;

  000c9	c7 86 34 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131124], 0

; 335  : 	m_kCmrPos.m_fViewDir = 0.0f;

  000d3	c7 86 38 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131128], 0

; 336  : 	m_kCmrPos.m_fCrossDir = 0.0f;

  000dd	c7 86 3c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131132], 0

; 337  : 	m_kCmrSpd.m_fUpDir = 0.0f;

  000e7	c7 86 40 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131136], 0

; 338  : 	m_kCmrSpd.m_fViewDir = 0.0f;

  000f1	c7 86 44 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131140], 0

; 339  : 	m_kCmrSpd.m_fCrossDir = 0.0f;

  000fb	c7 86 48 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131144], 0

; 340  : 	m_fZoomSpeed = 0.0f;

  00105	c7 86 24 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131108], 0

; 341  : 	m_fPitchSpeed = 0.0f;

  0010f	c7 86 20 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131104], 0

; 342  : 	m_fRotationSpeed = 0.0f;

  00119	c7 86 1c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131100], 0
$LN5@SetCameraS:
  00123	5f		 pop	 edi
  00124	5e		 pop	 esi

; 343  : }

  00125	5d		 pop	 ebp
  00126	c2 04 00	 ret	 4
?SetCameraSetting@CPythonApplication@@QAEXABUSCameraSetting@IAbstractApplication@@@Z ENDP ; CPythonApplication::SetCameraSetting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?GetCameraSetting@CPythonApplication@@QAEXPAUSCameraSetting@IAbstractApplication@@@Z
_TEXT	SEGMENT
_fHeight$ = 8						; size = 4
_pCameraSetting$ = 8					; size = 4
?GetCameraSetting@CPythonApplication@@QAEXPAUSCameraSetting@IAbstractApplication@@@Z PROC ; CPythonApplication::GetCameraSetting, COMDAT
; _this$ = ecx

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 347  : 	pCameraSetting->v3CenterPosition = m_v3CenterPosition;

  00003	f3 0f 7e 81 64
	ff 01 00	 movq	 xmm0, QWORD PTR [ecx+130916]
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _pCameraSetting$[ebp]
  0000f	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00013	8b 81 6c ff 01
	00		 mov	 eax, DWORD PTR [ecx+130924]
  00019	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 348  : 	pCameraSetting->kCmrPos = m_kCmrPos;

  0001c	f3 0f 7e 81 34
	00 02 00	 movq	 xmm0, QWORD PTR [ecx+131124]
  00024	66 0f d6 46 0c	 movq	 QWORD PTR [esi+12], xmm0
  00029	8b 81 3c 00 02
	00		 mov	 eax, DWORD PTR [ecx+131132]
  0002f	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 349  : 
; 350  : 	if (CCameraManager::Instance().GetCurrentCamera())

  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00038	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  0003d	85 c0		 test	 eax, eax
  0003f	74 18		 je	 SHORT $LN1@GetCameraS

; 351  : 		pCameraSetting->v3CenterPosition.z += CCameraManager::Instance().GetCurrentCamera()->GetTargetHeight();

  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00047	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 ?GetTargetHeight@CCamera@@QAEMXZ ; CCamera::GetTargetHeight
  00053	d8 46 08	 fadd	 DWORD PTR [esi+8]
  00056	d9 5e 08	 fstp	 DWORD PTR [esi+8]
$LN1@GetCameraS:

; 352  : 
; 353  : 	float fHeight;
; 354  : 	GetCamera(&pCameraSetting->fZoom, &pCameraSetting->fPitch, &pCameraSetting->fRotation, &fHeight);

  00059	8d 45 08	 lea	 eax, DWORD PTR _fHeight$[ebp]
  0005c	50		 push	 eax
  0005d	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00060	50		 push	 eax
  00061	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00064	50		 push	 eax
  00065	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?GetCamera@CPythonApplication@@QAEXPAM000@Z ; CPythonApplication::GetCamera
  0006e	5e		 pop	 esi

; 355  : }

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?GetCameraSetting@CPythonApplication@@QAEXPAUSCameraSetting@IAbstractApplication@@@Z ENDP ; CPythonApplication::GetCameraSetting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?SaveCameraSetting@CPythonApplication@@QAEXPBD@Z
_TEXT	SEGMENT
_CameraSetting$ = -36					; size = 36
_c_szFileName$ = 8					; size = 4
?SaveCameraSetting@CPythonApplication@@QAEXPBD@Z PROC	; CPythonApplication::SaveCameraSetting, COMDAT
; _this$ = ecx

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00009	57		 push	 edi
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 28   : 								fZoom(0.0f) {}

  0000d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _CameraSetting$[esp+96], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 360  : 	GetCameraSetting(&CameraSetting);

  00015	8d 44 24 1c	 lea	 eax, DWORD PTR _CameraSetting$[esp+64]
  00019	50		 push	 eax
  0001a	0f 11 44 24 20	 movups	 XMMWORD PTR _CameraSetting$[esp+68], xmm0
  0001f	0f 11 44 24 30	 movups	 XMMWORD PTR _CameraSetting$[esp+84], xmm0
  00024	e8 00 00 00 00	 call	 ?GetCameraSetting@CPythonApplication@@QAEXPAUSCameraSetting@IAbstractApplication@@@Z ; CPythonApplication::GetCameraSetting

; 361  : 
; 362  : 	FILE * File = fopen(c_szFileName, "w");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0002e	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00031	e8 00 00 00 00	 call	 _fopen
  00036	83 c4 08	 add	 esp, 8
  00039	8b f8		 mov	 edi, eax

; 363  : 	SetFileAttributes(c_szFileName, FILE_ATTRIBUTE_NORMAL);

  0003b	68 80 00 00 00	 push	 128			; 00000080H
  00040	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileAttributesA@8
  00049	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+72]

; 364  : 
; 365  : 	PrintfTabs(File, 0, "CenterPos %f %f %f\n", CameraSetting.v3CenterPosition.x, CameraSetting.v3CenterPosition.y, CameraSetting.v3CenterPosition.z);

  0004f	83 ec 18	 sub	 esp, 24			; 00000018H
  00052	0f 5a c0	 cvtps2pd xmm0, xmm0
  00055	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  0005b	f3 0f 10 44 24
	38		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+92]
  00061	0f 5a c0	 cvtps2pd xmm0, xmm0
  00064	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  0006a	f3 0f 10 44 24
	34		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+88]
  00070	0f 5a c0	 cvtps2pd xmm0, xmm0
  00073	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DMOOAJEE@CenterPos?5?$CFf?5?$CFf?5?$CFf?6?$AA@
  0007d	6a 00		 push	 0
  0007f	57		 push	 edi
  00080	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  00085	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+124]

; 366  : 	PrintfTabs(File, 0, "CameraSetting %f %f %f\n", CameraSetting.fZoom, CameraSetting.fPitch, CameraSetting.fRotation);

  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00091	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  00097	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+116]
  0009d	0f 5a c0	 cvtps2pd xmm0, xmm0
  000a0	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  000a6	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+120]
  000ac	0f 5a c0	 cvtps2pd xmm0, xmm0
  000af	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@PHEEAALI@CameraSetting?5?$CFf?5?$CFf?5?$CFf?6?$AA@
  000b9	6a 00		 push	 0
  000bb	57		 push	 edi
  000bc	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  000c1	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+120]

; 367  : 	PrintfTabs(File, 0, "CmrPos %f %f %f\n", CameraSetting.kCmrPos.m_fUpDir, CameraSetting.kCmrPos.m_fViewDir, CameraSetting.kCmrPos.m_fCrossDir);

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	0f 5a c0	 cvtps2pd xmm0, xmm0
  000cd	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  000d3	f3 0f 10 44 24
	44		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+104]
  000d9	0f 5a c0	 cvtps2pd xmm0, xmm0
  000dc	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  000e2	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR _CameraSetting$[esp+100]
  000e8	0f 5a c0	 cvtps2pd xmm0, xmm0
  000eb	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KBBGALHE@CmrPos?5?$CFf?5?$CFf?5?$CFf?6?$AA@
  000f5	6a 00		 push	 0
  000f7	57		 push	 edi
  000f8	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 368  : 	PrintfTabs(File, 0, "Line \"x;%d|y;%d|z;%d|distance;%d|pitch;%d|rot;%d|up;%d|view;%d|cross;%d\"\n",
; 369  : 												int(CameraSetting.v3CenterPosition.x),
; 370  : 												int(CameraSetting.v3CenterPosition.y),
; 371  : 												int(CameraSetting.v3CenterPosition.z),
; 372  : 												int(CameraSetting.fZoom),
; 373  : 												int(CameraSetting.fPitch),
; 374  : 												int(CameraSetting.fRotation),
; 375  : 												int(CameraSetting.kCmrPos.m_fUpDir),
; 376  : 												int(CameraSetting.kCmrPos.m_fViewDir),
; 377  : 												int(CameraSetting.kCmrPos.m_fCrossDir));

  000fd	f3 0f 2c 44 24
	54		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+120]
  00103	50		 push	 eax
  00104	f3 0f 2c 44 24
	54		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+120]
  0010a	50		 push	 eax
  0010b	f3 0f 2c 44 24
	54		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+120]
  00111	50		 push	 eax
  00112	f3 0f 2c 44 24
	64		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+136]
  00118	50		 push	 eax
  00119	f3 0f 2c 44 24
	6c		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+144]
  0011f	50		 push	 eax
  00120	f3 0f 2c 44 24
	74		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+152]
  00126	50		 push	 eax
  00127	f3 0f 2c 44 24
	60		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+132]
  0012d	50		 push	 eax
  0012e	f3 0f 2c 44 24
	60		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+132]
  00134	50		 push	 eax
  00135	f3 0f 2c 44 24
	60		 cvttss2si eax, DWORD PTR _CameraSetting$[esp+132]
  0013b	50		 push	 eax
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OFJKBEAJ@Line?5?$CCx?$DL?$CFd?$HMy?$DL?$CFd?$HMz?$DL?$CFd?$HMdistance?$DL?$CFd@
  00141	6a 00		 push	 0
  00143	57		 push	 edi
  00144	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  00149	83 c4 54	 add	 esp, 84			; 00000054H

; 378  : 
; 379  : 	fclose(File);

  0014c	57		 push	 edi
  0014d	e8 00 00 00 00	 call	 _fclose
  00152	83 c4 04	 add	 esp, 4

; 380  : }

  00155	5f		 pop	 edi
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c2 04 00	 ret	 4
?SaveCameraSetting@CPythonApplication@@QAEXPBD@Z ENDP	; CPythonApplication::SaveCameraSetting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp
;	COMDAT ?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z
_TEXT	SEGMENT
_pCmrPos$ = -208					; size = 4
_pCameraSetting$ = -204					; size = 4
_CameraSetting$2 = -200					; size = 36
$T3 = -200						; size = 24
$T4 = -200						; size = 24
$T5 = -200						; size = 24
_v3CenterPosition$ = -164				; size = 12
_TextFileLoader$ = -152					; size = 128
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z PROC	; CPythonApplication::LoadCameraSetting, COMDAT
; _this$ = ecx

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 c0 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+212], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 d8 00
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+228]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	8b f9		 mov	 edi, ecx
  00042	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]

; 384  : 	CTextFileLoader TextFileLoader;

  00045	8d 4c 24 4c	 lea	 ecx, DWORD PTR _TextFileLoader$[esp+228]
  00049	e8 00 00 00 00	 call	 ??0CTextFileLoader@@QAE@XZ ; CTextFileLoader::CTextFileLoader

; 385  : 	if (!TextFileLoader.Load(c_szFileName))

  0004e	56		 push	 esi
  0004f	8d 4c 24 50	 lea	 ecx, DWORD PTR _TextFileLoader$[esp+232]
  00053	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+240], 0
  0005e	e8 00 00 00 00	 call	 ?Load@CTextFileLoader@@QAE_NPBD@Z ; CTextFileLoader::Load
  00063	84 c0		 test	 al, al
  00065	0f 84 3f 02 00
	00		 je	 $LN1@LoadCamera

; 386  : 		return false;
; 387  : 
; 388  : 	TextFileLoader.SetTop();

  0006b	8d 4c 24 4c	 lea	 ecx, DWORD PTR _TextFileLoader$[esp+228]
  0006f	e8 00 00 00 00	 call	 ?SetTop@CTextFileLoader@@QAEXXZ ; CTextFileLoader::SetTop
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00074	6a 09		 push	 9
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_09BKJKIBFC@centerpos?$AA@
  0007b	8d 4c 24 24	 lea	 ecx, DWORD PTR $T5[esp+236]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0007f	c7 44 24 38 0f
	00 00 00	 mov	 DWORD PTR $T5[esp+256], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00087	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR $T5[esp+252], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0008f	c6 44 24 24 00	 mov	 BYTE PTR $T5[esp+236], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00094	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 393  : 	if (TextFileLoader.GetTokenVector3("centerpos", &v3CenterPosition))

  00099	8d 44 24 40	 lea	 eax, DWORD PTR _v3CenterPosition$[esp+228]
  0009d	c6 84 24 e0 00
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+236], 1
  000a5	50		 push	 eax
  000a6	8d 44 24 20	 lea	 eax, DWORD PTR $T5[esp+232]
  000aa	50		 push	 eax
  000ab	8d 4c 24 54	 lea	 ecx, DWORD PTR _TextFileLoader$[esp+236]
  000af	e8 00 00 00 00	 call	 ?GetTokenVector3@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXVECTOR3@@@Z ; CTextFileLoader::GetTokenVector3
  000b4	c6 84 24 e0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+236], 0
  000bc	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000be	83 7c 24 30 10	 cmp	 DWORD PTR $T5[esp+248], 16 ; 00000010H
  000c3	72 0c		 jb	 SHORT $LN81@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000c5	ff 74 24 1c	 push	 DWORD PTR $T5[esp+228]
  000c9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ce	83 c4 04	 add	 esp, 4
$LN81@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 393  : 	if (TextFileLoader.GetTokenVector3("centerpos", &v3CenterPosition))

  000d1	85 f6		 test	 esi, esi
  000d3	0f 84 d1 01 00
	00		 je	 $LN1@LoadCamera

; 394  : 	if (TextFileLoader.GetTokenVector("camerasetting", &pCameraSetting))

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKCMOHOF@camerasetting?$AA@
  000de	8d 4c 24 20	 lea	 ecx, DWORD PTR $T4[esp+232]
  000e2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000e7	8d 44 24 18	 lea	 eax, DWORD PTR _pCameraSetting$[esp+228]
  000eb	c6 84 24 e0 00
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+236], 2
  000f3	50		 push	 eax
  000f4	8d 44 24 20	 lea	 eax, DWORD PTR $T4[esp+232]
  000f8	50		 push	 eax
  000f9	8d 4c 24 54	 lea	 ecx, DWORD PTR _TextFileLoader$[esp+236]
  000fd	e8 00 00 00 00	 call	 ?GetTokenVector@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; CTextFileLoader::GetTokenVector
  00102	c6 84 24 e0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+236], 0
  0010a	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0010c	83 7c 24 30 10	 cmp	 DWORD PTR $T4[esp+248], 16 ; 00000010H
  00111	72 0c		 jb	 SHORT $LN113@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00113	ff 74 24 1c	 push	 DWORD PTR $T4[esp+228]
  00117	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011c	83 c4 04	 add	 esp, 4
$LN113@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 394  : 	if (TextFileLoader.GetTokenVector("camerasetting", &pCameraSetting))

  0011f	85 f6		 test	 esi, esi
  00121	0f 84 83 01 00
	00		 je	 $LN1@LoadCamera

; 395  : 	if (TextFileLoader.GetTokenVector("cmrpos", &pCmrPos))

  00127	68 00 00 00 00	 push	 OFFSET ??_C@_06MDBDNPGG@cmrpos?$AA@
  0012c	8d 4c 24 20	 lea	 ecx, DWORD PTR $T3[esp+232]
  00130	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00135	8d 44 24 14	 lea	 eax, DWORD PTR _pCmrPos$[esp+228]
  00139	c6 84 24 e0 00
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+236], 3
  00141	50		 push	 eax
  00142	8d 44 24 20	 lea	 eax, DWORD PTR $T3[esp+232]
  00146	50		 push	 eax
  00147	8d 4c 24 54	 lea	 ecx, DWORD PTR _TextFileLoader$[esp+236]
  0014b	e8 00 00 00 00	 call	 ?GetTokenVector@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; CTextFileLoader::GetTokenVector
  00150	c6 84 24 e0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+236], 0
  00158	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0015a	83 7c 24 30 10	 cmp	 DWORD PTR $T3[esp+248], 16 ; 00000010H
  0015f	72 0c		 jb	 SHORT $LN145@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00161	ff 74 24 1c	 push	 DWORD PTR $T3[esp+228]
  00165	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0016a	83 c4 04	 add	 esp, 4
$LN145@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 395  : 	if (TextFileLoader.GetTokenVector("cmrpos", &pCmrPos))

  0016d	85 f6		 test	 esi, esi
  0016f	0f 84 35 01 00
	00		 je	 $LN1@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00175	8b 44 24 18	 mov	 eax, DWORD PTR _pCameraSetting$[esp+228]
  00179	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0017c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0017e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00183	f7 e9		 imul	 ecx
  00185	c1 fa 02	 sar	 edx, 2
  00188	8b ca		 mov	 ecx, edx
  0018a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0018d	03 ca		 add	 ecx, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 396  : 	if (3 == pCameraSetting->size())

  0018f	83 f9 03	 cmp	 ecx, 3
  00192	0f 85 12 01 00
	00		 jne	 $LN1@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00198	8b 4c 24 14	 mov	 ecx, DWORD PTR _pCmrPos$[esp+228]
  0019c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  001a1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001a4	2b 11		 sub	 edx, DWORD PTR [ecx]
  001a6	f7 ea		 imul	 edx
  001a8	c1 fa 02	 sar	 edx, 2
  001ab	8b c2		 mov	 eax, edx
  001ad	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001b0	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 397  : 	if (3 == pCmrPos->size())

  001b2	83 f8 03	 cmp	 eax, 3
  001b5	0f 85 ef 00 00
	00		 jne	 $LN1@LoadCamera

; 398  : 	{
; 399  : 		SCameraSetting CameraSetting;

  001bb	8d 4c 24 1c	 lea	 ecx, DWORD PTR _CameraSetting$2[esp+228]
  001bf	e8 00 00 00 00	 call	 ??0SCameraSetting@IAbstractApplication@@QAE@XZ ; IAbstractApplication::SCameraSetting::SCameraSetting

; 400  : 		CameraSetting.v3CenterPosition = v3CenterPosition;

  001c4	f3 0f 7e 44 24
	40		 movq	 xmm0, QWORD PTR _v3CenterPosition$[esp+228]
  001ca	8b 44 24 48	 mov	 eax, DWORD PTR _v3CenterPosition$[esp+236]

; 402  : 		CameraSetting.fZoom					= atof(pCameraSetting->at(0).c_str());

  001ce	8b 4c 24 18	 mov	 ecx, DWORD PTR _pCameraSetting$[esp+228]
  001d2	6a 00		 push	 0
  001d4	66 0f d6 44 24
	20		 movq	 QWORD PTR _CameraSetting$2[esp+232], xmm0
  001da	89 44 24 28	 mov	 DWORD PTR _CameraSetting$2[esp+240], eax
  001de	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  001e3	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  001e7	72 02		 jb	 SHORT $LN165@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  001e9	8b 00		 mov	 eax, DWORD PTR [eax]
$LN165@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 402  : 		CameraSetting.fZoom					= atof(pCameraSetting->at(0).c_str());

  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _atof

; 403  : 		CameraSetting.fPitch				= atof(pCameraSetting->at(1).c_str());

  001f1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pCameraSetting$[esp+232]
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 5c 24 3c	 fstp	 DWORD PTR _CameraSetting$2[esp+260]
  001fc	6a 01		 push	 1
  001fe	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00203	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00207	72 02		 jb	 SHORT $LN173@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00209	8b 00		 mov	 eax, DWORD PTR [eax]
$LN173@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 403  : 		CameraSetting.fPitch				= atof(pCameraSetting->at(1).c_str());

  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 _atof

; 404  : 		CameraSetting.fRotation				= atof(pCameraSetting->at(2).c_str());

  00211	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pCameraSetting$[esp+232]
  00215	83 c4 04	 add	 esp, 4
  00218	d9 5c 24 38	 fstp	 DWORD PTR _CameraSetting$2[esp+256]
  0021c	6a 02		 push	 2
  0021e	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00223	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00227	72 02		 jb	 SHORT $LN181@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00229	8b 00		 mov	 eax, DWORD PTR [eax]
$LN181@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 404  : 		CameraSetting.fRotation				= atof(pCameraSetting->at(2).c_str());

  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 _atof

; 406  : 		CameraSetting.kCmrPos.m_fUpDir		= atof(pCmrPos->at(0).c_str());

  00231	8b 4c 24 18	 mov	 ecx, DWORD PTR _pCmrPos$[esp+232]
  00235	83 c4 04	 add	 esp, 4
  00238	d9 5c 24 34	 fstp	 DWORD PTR _CameraSetting$2[esp+252]
  0023c	6a 00		 push	 0
  0023e	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00243	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00247	72 02		 jb	 SHORT $LN189@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00249	8b 00		 mov	 eax, DWORD PTR [eax]
$LN189@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 406  : 		CameraSetting.kCmrPos.m_fUpDir		= atof(pCmrPos->at(0).c_str());

  0024b	50		 push	 eax
  0024c	e8 00 00 00 00	 call	 _atof

; 407  : 		CameraSetting.kCmrPos.m_fViewDir	= atof(pCmrPos->at(1).c_str());

  00251	8b 4c 24 18	 mov	 ecx, DWORD PTR _pCmrPos$[esp+232]
  00255	83 c4 04	 add	 esp, 4
  00258	d9 5c 24 28	 fstp	 DWORD PTR _CameraSetting$2[esp+240]
  0025c	6a 01		 push	 1
  0025e	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00263	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00267	72 02		 jb	 SHORT $LN197@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00269	8b 00		 mov	 eax, DWORD PTR [eax]
$LN197@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 407  : 		CameraSetting.kCmrPos.m_fViewDir	= atof(pCmrPos->at(1).c_str());

  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 _atof

; 408  : 		CameraSetting.kCmrPos.m_fCrossDir	= atof(pCmrPos->at(2).c_str());

  00271	8b 4c 24 18	 mov	 ecx, DWORD PTR _pCmrPos$[esp+232]
  00275	83 c4 04	 add	 esp, 4
  00278	d9 5c 24 2c	 fstp	 DWORD PTR _CameraSetting$2[esp+244]
  0027c	6a 02		 push	 2
  0027e	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00283	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00287	72 02		 jb	 SHORT $LN205@LoadCamera
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00289	8b 00		 mov	 eax, DWORD PTR [eax]
$LN205@LoadCamera:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplicationcamera.cpp

; 408  : 		CameraSetting.kCmrPos.m_fCrossDir	= atof(pCmrPos->at(2).c_str());

  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 _atof

; 409  : 
; 410  : 		SetEventCamera(CameraSetting);

  00291	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00294	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00297	83 c4 04	 add	 esp, 4
  0029a	8d 54 24 1c	 lea	 edx, DWORD PTR _CameraSetting$2[esp+228]
  0029e	d9 5c 24 30	 fstp	 DWORD PTR _CameraSetting$2[esp+248]
  002a2	52		 push	 edx
  002a3	ff 50 1c	 call	 DWORD PTR [eax+28]

; 411  : 		return true;

  002a6	b3 01		 mov	 bl, 1
  002a8	eb 02		 jmp	 SHORT $LN14@LoadCamera
$LN1@LoadCamera:

; 412  : 	}
; 413  : 
; 414  : 	return false;

  002aa	32 db		 xor	 bl, bl
$LN14@LoadCamera:
  002ac	8d 4c 24 4c	 lea	 ecx, DWORD PTR _TextFileLoader$[esp+228]
  002b0	c7 84 24 e0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+236], -1
  002bb	e8 00 00 00 00	 call	 ??1CTextFileLoader@@UAE@XZ ; CTextFileLoader::~CTextFileLoader
  002c0	8a c3		 mov	 al, bl

; 415  : }

  002c2	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+228]
  002c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002d0	59		 pop	 ecx
  002d1	5f		 pop	 edi
  002d2	5e		 pop	 esi
  002d3	5b		 pop	 ebx
  002d4	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+212]
  002db	33 cc		 xor	 ecx, esp
  002dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e2	8b e5		 mov	 esp, ebp
  002e4	5d		 pop	 ebp
  002e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z$0:
  00000	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CTextFileLoader@@UAE@XZ ; CTextFileLoader::~CTextFileLoader
__unwindfunclet$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z$1:
  0000b	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z$2:
  00016	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z$3:
  00021	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 82 2c ff ff
	ff		 lea	 eax, DWORD PTR [edx-212]
  00036	8b 8a 28 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-216]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	83 c0 0c	 add	 eax, 12			; 0000000cH
  00046	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00049	33 c8		 xor	 ecx, eax
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z
  00055	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z ENDP	; CPythonApplication::LoadCameraSetting
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at, COMDAT
; _this$ = ecx

; 1174 : 		{	// subscript mutable sequence with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00004	8b 31		 mov	 esi, DWORD PTR [ecx]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000e	2b ce		 sub	 ecx, esi
  00010	f7 e9		 imul	 ecx

; 1175 : 		if (size() <= _Pos)

  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00015	c1 fa 02	 sar	 edx, 2
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx

; 1175 : 		if (size() <= _Pos)

  0001f	3b c1		 cmp	 eax, ecx
  00021	76 0b		 jbe	 SHORT $LN10@at

; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));

  00023	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00026	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
  00029	5e		 pop	 esi

; 1178 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN10@at:

; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");
; 1755 : 		}
; 1756 : 
; 1757 : 	__declspec(noreturn) void _Xran() const
; 1758 : 		{	// report an out_of_range error
; 1759 : 		_Xout_of_range("invalid vector<T> subscript");

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  00033	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN12@at:
$LN9@at:
  00038	cc		 int	 3
?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xran@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xran@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xran, COMDAT
; _this$ = ecx

; 1759 : 		_Xout_of_range("invalid vector<T> subscript");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xran
_TEXT	ENDS
END
