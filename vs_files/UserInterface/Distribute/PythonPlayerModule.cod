; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonPlayerModule.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EA@OHLDKNFC@playerSetAttackKeyState?$CIisPresse@ ; `string'
PUBLIC	??_C@_0DF@ILFGGFEI@CPythonPlayer?3?3RegisterEffect?$CIeE@ ; `string'
PUBLIC	??_C@_0EK@IDBGKDBN@playerSetSingleDIKKeyState?$CIeDIK?0@ ; `string'
PUBLIC	??_C@_0EJ@BNKMOLIP@playerSetSingleDIKKeyState?$CIeDIK?0@ ; `string'
PUBLIC	??_C@_01HHGOMJKL@l?$AA@				; `string'
PUBLIC	??_C@_02HPEDFNFO@ff?$AA@			; `string'
PUBLIC	??_C@_0BK@MGKBEPOF@?5?$HMh?$HMr?$FL?$CFs?$FN?$HMcfff1e6c0?$HMH?$CFs?$HMh?$AA@ ; `string'
PUBLIC	??_C@_0BK@MCOKCAKI@?5?$HMh?$HMr?$FL?$CFs?$FN?$HMcffffc700?$HMH?$CFs?$HMh?$AA@ ; `string'
PUBLIC	??_C@_0BF@IBGKLIMC@can?8t?5find?5item?5data?$AA@ ; `string'
PUBLIC	??_C@_0BF@BGKCJNBK@Can?8t?5find?5item?5data?$AA@ ; `string'
PUBLIC	??_C@_04GPDILEAH@biii?$AA@			; `string'
PUBLIC	??_C@_07EFJJEBFG@iiiiiii?$AA@			; `string'
PUBLIC	??_C@_0BC@CILJOCG@SetAutoPotionInfo?$AA@	; `string'
PUBLIC	??_C@_0BC@CHIABFDI@GetAutoPotionInfo?$AA@	; `string'
PUBLIC	??_C@_0O@MNPFFDEJ@SetGameWindow?$AA@		; `string'
PUBLIC	??_C@_0O@MAEJALBO@PickCloseItem?$AA@		; `string'
PUBLIC	??_C@_0N@LEJNPCGM@SetMouseFunc?$AA@		; `string'
PUBLIC	??_C@_0O@HDELDAFI@SetMouseState?$AA@		; `string'
PUBLIC	??_C@_0BK@JBJLNCBH@SetMouseMiddleButtonState?$AA@ ; `string'
PUBLIC	??_C@_0N@MACDDOCA@GetMouseFunc?$AA@		; `string'
PUBLIC	??_C@_0BG@GHIKDJGB@GetMainCharacterIndex?$AA@	; `string'
PUBLIC	??_C@_0BG@JCNMOACA@SetMainCharacterIndex?$AA@	; `string'
PUBLIC	??_C@_0BJ@GIKFEPMH@GetMainCharacterPosition?$AA@ ; `string'
PUBLIC	??_C@_0BF@OMDPKDFM@GetMainCharacterName?$AA@	; `string'
PUBLIC	??_C@_0BC@FLPEGJDD@CanAttackInstance?$AA@	; `string'
PUBLIC	??_C@_0BF@GALHNOAL@IsMainCharacterIndex?$AA@	; `string'
PUBLIC	??_C@_0O@ECCODAC@IsPVPInstance?$AA@		; `string'
PUBLIC	??_C@_0BA@ODCBPOEF@IsActingEmotion?$AA@		; `string'
PUBLIC	??_C@_0BE@FOIPHJLO@IsChallengeInstance?$AA@	; `string'
PUBLIC	??_C@_0N@CBEDFALN@IsSameEmpire?$AA@		; `string'
PUBLIC	??_C@_0BE@HJOMPGKI@IsCantFightInstance?$AA@	; `string'
PUBLIC	??_C@_0BC@IKOEAPGC@IsRevengeInstance?$AA@	; `string'
PUBLIC	??_C@_0N@IKPCBCPA@IsInSafeArea?$AA@		; `string'
PUBLIC	??_C@_0BF@DABJOKIF@GetCharacterDistance?$AA@	; `string'
PUBLIC	??_C@_0P@LDENHACE@IsObserverMode?$AA@		; `string'
PUBLIC	??_C@_0BA@GFJLKENO@IsMountingHorse?$AA@		; `string'
PUBLIC	??_C@_0L@CPMIOCIM@ShowPlayer?$AA@		; `string'
PUBLIC	??_C@_0L@JEBGMNAH@ActEmotion?$AA@		; `string'
PUBLIC	??_C@_0M@GOCDIKPN@ComboAttack?$AA@		; `string'
PUBLIC	??_C@_0L@PBBGGCLG@HidePlayer?$AA@		; `string'
PUBLIC	??_C@_0BC@DAIEHFBH@SetAttackKeyState?$AA@	; `string'
PUBLIC	??_C@_0BL@IEKDAKHC@SetAutoCameraRotationSpeed?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HGLJKHIH@EndKeyWalkingImmediately?$AA@ ; `string'
PUBLIC	??_C@_0BF@PNJNANBI@SetSingleDIKKeyState?$AA@	; `string'
PUBLIC	??_C@_0BA@JEOKFDLP@EndMouseWalking?$AA@		; `string'
PUBLIC	??_C@_0BC@NCHFPCDM@StartMouseWalking?$AA@	; `string'
PUBLIC	??_C@_0BD@DPHLFGPP@SetQuickCameraMode?$AA@	; `string'
PUBLIC	??_C@_0BE@MCFGJOPA@ResetCameraRotation?$AA@	; `string'
PUBLIC	??_C@_0BC@HNJMANI@GetSkillSlotIndex?$AA@	; `string'
PUBLIC	??_C@_08HIFGFOGG@SetSkill?$AA@			; `string'
PUBLIC	??_C@_0CD@EFGGIKHI@GetSkillCurrentEfficientPercenta@ ; `string'
PUBLIC	??_C@_0O@IIOIANPE@GetSkillGrade?$AA@		; `string'
PUBLIC	??_C@_0P@IGNHDBHH@ClickSkillSlot?$AA@		; `string'
PUBLIC	??_C@_0CA@JHGONPGM@GetSkillNextEfficientPercentage?$AA@ ; `string'
PUBLIC	??_C@_0P@MJOJKOJJ@ClearSkillDict?$AA@		; `string'
PUBLIC	??_C@_0BN@BPJDEKED@ChangeCurrentSkillNumberOnly?$AA@ ; `string'
PUBLIC	??_C@_0N@DMCGDNGF@GetItemFlags?$AA@		; `string'
PUBLIC	??_C@_0N@GABOCBEH@GetItemIndex?$AA@		; `string'
PUBLIC	??_C@_0BD@DBLILMFK@GetItemCountByVnum?$AA@	; `string'
PUBLIC	??_C@_0N@LEKALLIG@GetItemCount?$AA@		; `string'
PUBLIC	??_C@_0BB@GOKPPDHH@GetItemAttribute?$AA@	; `string'
PUBLIC	??_C@_0BD@JBOBKHIE@GetItemMetinSocket?$AA@	; `string'
PUBLIC	??_C@_0BE@DBIFLBAC@SendClickItemPacket?$AA@	; `string'
PUBLIC	??_C@_08MHJANHDM@MoveItem?$AA@			; `string'
PUBLIC	??_C@_0M@DJDCIBLO@GetPlayTime?$AA@		; `string'
PUBLIC	??_C@_06FHLNIOPB@GetJob?$AA@			; `string'
PUBLIC	??_C@_0BA@FOPKKJJD@IsSkillCoolTime?$AA@		; `string'
PUBLIC	??_C@_0M@DGCMFHDN@SetPlayTime?$AA@		; `string'
PUBLIC	??_C@_0O@IAPCJJAC@IsSkillActive?$AA@		; `string'
PUBLIC	??_C@_0BB@CNGGKNGL@GetSkillCoolTime?$AA@	; `string'
PUBLIC	??_C@_0BI@JIGEMOFF@AffectIndexToSkillIndex?$AA@	; `string'
PUBLIC	??_C@_0O@HHBOBCLE@UseGuildSkill?$AA@		; `string'
PUBLIC	??_C@_09MKFEIFJE@GetStatus?$AA@			; `string'
PUBLIC	??_C@_06MDIKDJMD@GetEXP?$AA@			; `string'
PUBLIC	??_C@_06NMFKJLLH@GetElk?$AA@			; `string'
PUBLIC	??_C@_09OEBBKEAG@SetStatus?$AA@			; `string'
PUBLIC	??_C@_0BB@LANDCIKG@GetAlignmentData?$AA@	; `string'
PUBLIC	??_C@_08OAJFGNBC@GetMoney?$AA@			; `string'
PUBLIC	??_C@_0CA@JMFCJJPL@RequestAddToEmptyLocalQuickSlot?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DNLGAMEO@RequestAddLocalQuickSlot?$AA@ ; `string'
PUBLIC	??_C@_0CL@IEMBKGLN@RequestMoveGlobalQuickSlotToLoca@ ; `string'
PUBLIC	??_C@_0BN@NACLJDMA@RequestDeleteGlobalQuickSlot?$AA@ ; `string'
PUBLIC	??_C@_0CK@GNGKFIDB@LocalQuickSlotIndexToGlobalQuick@ ; `string'
PUBLIC	??_C@_0BJ@IBBGPDPH@RequestUseLocalQuickSlot?$AA@ ; `string'
PUBLIC	??_C@_0N@KPHBLMNM@SetQuickPage?$AA@		; `string'
PUBLIC	??_C@_0N@NLMPHAJA@GetQuickPage?$AA@		; `string'
PUBLIC	??_C@_0BD@ECGPDHPA@GetGlobalQuickSlot?$AA@	; `string'
PUBLIC	??_C@_0BC@LNKMMBDG@GetLocalQuickSlot?$AA@	; `string'
PUBLIC	??_C@_06NOPKEHAK@isItem?$AA@			; `string'
PUBLIC	??_C@_0BH@JNCIKJMC@RemoveQuickSlotByValue?$AA@	; `string'
PUBLIC	??_C@_0BC@DDCIGDKO@IsDSEquipmentSlot?$AA@	; `string'
PUBLIC	??_C@_0BA@EMKHGGAL@IsEquipmentSlot?$AA@		; `string'
PUBLIC	??_C@_0P@LAJFBPPH@IsValuableItem?$AA@		; `string'
PUBLIC	??_C@_0O@KCAGNEAI@IsCostumeSlot?$AA@		; `string'
PUBLIC	??_C@_0N@DGHEMMKN@GetItemGrade?$AA@		; `string'
PUBLIC	??_C@_0BC@DCFDMADN@IsOpenPrivateShop?$AA@	; `string'
PUBLIC	??_C@_09GHIBIBHI@CanDetach?$AA@			; `string'
PUBLIC	??_C@_09BGNCJJP@CanRefine?$AA@			; `string'
PUBLIC	??_C@_0P@BLOGPKFO@CanAttachMetin?$AA@		; `string'
PUBLIC	??_C@_09FHINBOHC@CanUnlock?$AA@			; `string'
PUBLIC	??_C@_0M@DPCEEMCG@ClearTarget?$AA@		; `string'
PUBLIC	??_C@_0BE@ELNKJPMC@IsRefineGradeScroll?$AA@	; `string'
PUBLIC	??_C@_0BC@HAEJEFBP@OpenCharacterMenu?$AA@	; `string'
PUBLIC	??_C@_09EECGCJDE@SetTarget?$AA@			; `string'
PUBLIC	??_C@_0BD@HGKJMFNK@IsPartyLeaderByPID?$AA@	; `string'
PUBLIC	??_C@_0O@BPMJGNAC@IsPartyLeader?$AA@		; `string'
PUBLIC	??_C@_0BE@HKIJMBKK@GetPartyMemberState?$AA@	; `string'
PUBLIC	??_C@_0BL@EPAFEFHI@GetPartyMemberHPPercentage?$AA@ ; `string'
PUBLIC	??_C@_09DMPBEJCG@ExitParty?$AA@			; `string'
PUBLIC	??_C@_0BG@EEFAFMJC@GetPartyMemberAffects?$AA@	; `string'
PUBLIC	??_C@_0BF@CLGCEOLO@HasMobilePhoneNumber?$AA@	; `string'
PUBLIC	??_C@_09IMMFEEHK@GetPKMode?$AA@			; `string'
PUBLIC	??_C@_0BE@FELKHKJF@GetEmotionIconImage?$AA@	; `string'
PUBLIC	??_C@_0BE@PMDABIKP@RegisterEmotionIcon?$AA@	; `string'
PUBLIC	??_C@_0P@ILOOLMDH@ToggleCoolTime?$AA@		; `string'
PUBLIC	??_C@_0BJ@CFCMHNHB@SetWeaponAttackBonusFlag?$AA@ ; `string'
PUBLIC	??_C@_0N@MEKPPHGC@GetTargetVID?$AA@		; `string'
PUBLIC	??_C@_0BB@DJKKOCLB@ToggleLevelLimit?$AA@	; `string'
PUBLIC	??_C@_0BD@GLMLJBGM@SetItemMetinSocket?$AA@	; `string'
PUBLIC	??_C@_0M@CHNGAPIB@SetItemData?$AA@		; `string'
PUBLIC	??_C@_0N@MABOHHMK@SetItemCount?$AA@		; `string'
PUBLIC	??_C@_0BB@KPGENMF@SetItemAttribute?$AA@		; `string'
PUBLIC	??_C@_0BE@IOMKCPHN@SlotTypeToInvenType?$AA@	; `string'
PUBLIC	??_C@_0M@DGFCHEAA@GetItemLink?$AA@		; `string'
PUBLIC	??_C@_06BALNJMNP@player?$AA@			; `string'
PUBLIC	??_C@_0BF@PLGNHJMH@SendDragonSoulRefine?$AA@	; `string'
PUBLIC	??_C@_05FHIHOFEA@VOICE?$AA@			; `string'
PUBLIC	??_C@_05GCEPFMCO@LEVEL?$AA@			; `string'
PUBLIC	??_C@_08CHGDMADF@NEXT_EXP?$AA@			; `string'
PUBLIC	??_C@_03KKGFKKLA@EXP?$AA@			; `string'
PUBLIC	??_C@_06NMHEPHCD@MAX_HP?$AA@			; `string'
PUBLIC	??_C@_02MEIMKHMB@HP?$AA@			; `string'
PUBLIC	??_C@_06MMAHLLLC@MAX_SP?$AA@			; `string'
PUBLIC	??_C@_02NEPPOLFA@SP?$AA@			; `string'
PUBLIC	??_C@_0M@CHCGLEDD@MAX_STAMINA?$AA@		; `string'
PUBLIC	??_C@_07IHPDJFBP@STAMINA?$AA@			; `string'
PUBLIC	??_C@_02LAJDCOFE@ST?$AA@			; `string'
PUBLIC	??_C@_03BIHMGKIG@ELK?$AA@			; `string'
PUBLIC	??_C@_02FEPNEKN@DX?$AA@				; `string'
PUBLIC	??_C@_02KAOAGCMF@HT?$AA@			; `string'
PUBLIC	??_C@_09DIGJAPIG@ATT_POWER?$AA@			; `string'
PUBLIC	??_C@_02NMFFPMLH@IQ?$AA@			; `string'
PUBLIC	??_C@_07OPGIINPB@ATT_MAX?$AA@			; `string'
PUBLIC	??_C@_07PNODGJJO@ATT_MIN?$AA@			; `string'
PUBLIC	??_C@_0O@JAPECJBK@MAX_MAGIC_WEP?$AA@		; `string'
PUBLIC	??_C@_0O@CJNCLCGL@MIN_MAGIC_WEP?$AA@		; `string'
PUBLIC	??_C@_09FOFLCGDC@ATT_BONUS?$AA@			; `string'
PUBLIC	??_C@_09LKMFFHLI@ATT_SPEED?$AA@			; `string'
PUBLIC	??_C@_0N@KGGLAJKM@MOVING_SPEED?$AA@		; `string'
PUBLIC	??_C@_0L@IPHIKIMB@EVADE_RATE?$AA@		; `string'
PUBLIC	??_C@_09DNFHINBC@DEF_BONUS?$AA@			; `string'
PUBLIC	??_C@_09KMPFCDFE@DEF_GRADE?$AA@			; `string'
PUBLIC	??_C@_07PEONMKMN@MAG_ATT?$AA@			; `string'
PUBLIC	??_C@_0O@IOLIEEIE@CASTING_SPEED?$AA@		; `string'
PUBLIC	??_C@_0N@JIFCAIPA@EMPIRE_POINT?$AA@		; `string'
PUBLIC	??_C@_07KGCDIDGL@MAG_DEF?$AA@			; `string'
PUBLIC	??_C@_0O@DGEPJFAK@SKILL_PASSIVE?$AA@		; `string'
PUBLIC	??_C@_04KNIOFKKL@STAT?$AA@			; `string'
PUBLIC	??_C@_0N@DNBJLBPA@SKILL_ACTIVE?$AA@		; `string'
PUBLIC	??_C@_0O@JLNOPGFK@SKILL_SUPPORT?$AA@		; `string'
PUBLIC	??_C@_08CKIIBBI@PLAYTIME?$AA@			; `string'
PUBLIC	??_C@_0M@HAFIBGFL@SKILL_HORSE?$AA@		; `string'
PUBLIC	??_C@_0M@CLAIAEPM@HP_RECOVERY?$AA@		; `string'
PUBLIC	??_C@_0N@KHDDEEFG@BOW_DISTANCE?$AA@		; `string'
PUBLIC	??_C@_0P@GAAMLPFK@ATTACKER_BONUS?$AA@		; `string'
PUBLIC	??_C@_0M@FGICENAO@SP_RECOVERY?$AA@		; `string'
PUBLIC	??_C@_0BD@CPEECKKP@POINT_CRITICAL_PCT?$AA@	; `string'
PUBLIC	??_C@_07MEMMKJPK@MAX_NUM?$AA@			; `string'
PUBLIC	??_C@_0BE@FDGMKOPN@POINT_MALL_ATTBONUS?$AA@	; `string'
PUBLIC	??_C@_0BE@BGNEFMNJ@POINT_PENETRATE_PCT?$AA@	; `string'
PUBLIC	??_C@_0BE@KNGAMOKN@POINT_MALL_EXPBONUS?$AA@	; `string'
PUBLIC	??_C@_0BE@FJKLFHOA@POINT_MALL_DEFBONUS?$AA@	; `string'
PUBLIC	??_C@_0BF@LPKHMJJF@POINT_MALL_GOLDBONUS?$AA@	; `string'
PUBLIC	??_C@_0BF@FCMHLHC@POINT_MALL_ITEMBONUS?$AA@	; `string'
PUBLIC	??_C@_0BB@IHDKAICM@POINT_MAX_SP_PCT?$AA@	; `string'
PUBLIC	??_C@_0BB@OCODMABI@POINT_MAX_HP_PCT?$AA@	; `string'
PUBLIC	??_C@_0BO@GNDIKOOF@POINT_NORMAL_HIT_DAMAGE_BONUS?$AA@ ; `string'
PUBLIC	??_C@_0BJ@PGEFOCDG@POINT_SKILL_DAMAGE_BONUS?$AA@ ; `string'
PUBLIC	??_C@_0BO@CEPNAEGB@POINT_NORMAL_HIT_DEFEND_BONUS?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LPIAEILC@POINT_SKILL_DEFEND_BONUS?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LFKCHGEO@POINT_PC_BANG_DROP_BONUS?$AA@ ; `string'
PUBLIC	??_C@_0BI@BAKJJELL@POINT_PC_BANG_EXP_BONUS?$AA@	; `string'
PUBLIC	??_C@_0BA@PIHNCBED@ENERGY_END_TIME?$AA@		; `string'
PUBLIC	??_C@_06KOEJHMAL@ENERGY?$AA@			; `string'
PUBLIC	??_C@_0BD@HIHOAICI@SKILL_GRADE_MASTER?$AA@	; `string'
PUBLIC	??_C@_0BD@LAKFNFGD@SKILL_GRADE_NORMAL?$AA@	; `string'
PUBLIC	??_C@_0BL@DCIPLDCA@SKILL_GRADE_PERFECT_MASTER?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CFOEIGCN@SKILL_GRADE_GRAND_MASTER?$AA@ ; `string'
PUBLIC	??_C@_0BB@HCMEALJK@CATEGORY_PASSIVE?$AA@	; `string'
PUBLIC	??_C@_0BA@LCKKFCJM@CATEGORY_ACTIVE?$AA@		; `string'
PUBLIC	??_C@_0BF@NFIFHHOM@INVENTORY_PAGE_COUNT?$AA@	; `string'
PUBLIC	??_C@_0BE@CEBDMLGH@INVENTORY_PAGE_SIZE?$AA@	; `string'
PUBLIC	??_C@_0BF@HJEBPPMM@EQUIPMENT_SLOT_START?$AA@	; `string'
PUBLIC	??_C@_0BF@LCFAAJPA@INVENTORY_SLOT_COUNT?$AA@	; `string'
PUBLIC	??_C@_09NLFDBCDH@MBF_SKILL?$AA@			; `string'
PUBLIC	??_C@_0BF@MADFLPAE@EQUIPMENT_PAGE_COUNT?$AA@	; `string'
PUBLIC	??_C@_0L@JHBFAMB@MBF_CAMERA?$AA@		; `string'
PUBLIC	??_C@_0L@MIGMJBKJ@MBF_ATTACK?$AA@		; `string'
PUBLIC	??_C@_08BLLANCB@MBF_MOVE?$AA@			; `string'
PUBLIC	??_C@_09FAENJFL@MBF_SMART?$AA@			; `string'
PUBLIC	??_C@_09JEJKPPEO@MBS_PRESS?$AA@			; `string'
PUBLIC	??_C@_08CIEGLDP@MBF_AUTO?$AA@			; `string'
PUBLIC	??_C@_09DBJMODBC@MBT_RIGHT?$AA@			; `string'
PUBLIC	??_C@_09BKODCCAJ@MBS_CLICK?$AA@			; `string'
PUBLIC	??_C@_0P@JBDPGPGM@SLOT_TYPE_NONE?$AA@		; `string'
PUBLIC	??_C@_08OMNIMJHC@MBT_LEFT?$AA@			; `string'
PUBLIC	??_C@_0BA@MAJHKGKG@SLOT_TYPE_SKILL?$AA@		; `string'
PUBLIC	??_C@_0BE@BNOEBHPE@SLOT_TYPE_INVENTORY?$AA@	; `string'
PUBLIC	??_C@_0BJ@DBNHPJKE@SLOT_TYPE_EXCHANGE_OWNER?$AA@ ; `string'
PUBLIC	??_C@_0P@KCOPIIMF@SLOT_TYPE_SHOP?$AA@		; `string'
PUBLIC	??_C@_0BF@CPPFMLHN@SLOT_TYPE_QUICK_SLOT?$AA@	; `string'
PUBLIC	??_C@_0BK@KJHLAGBH@SLOT_TYPE_EXCHANGE_TARGET?$AA@ ; `string'
PUBLIC	??_C@_0BH@MJAEADNE@SLOT_TYPE_PRIVATE_SHOP?$AA@	; `string'
PUBLIC	??_C@_0BC@HGKFDIFN@SLOT_TYPE_SAFEBOX?$AA@	; `string'
PUBLIC	??_C@_0BC@LKMHLHKJ@SLOT_TYPE_EMOTION?$AA@	; `string'
PUBLIC	??_C@_0P@OEAGANKI@SLOT_TYPE_MALL?$AA@		; `string'
PUBLIC	??_C@_0BA@NKAFFIGF@RESERVED_WINDOW?$AA@		; `string'
PUBLIC	??_C@_0CA@FHKIPOOP@SLOT_TYPE_DRAGON_SOUL_INVENTORY?$AA@ ; `string'
PUBLIC	??_C@_09GJGOMHMK@EQUIPMENT?$AA@			; `string'
PUBLIC	??_C@_09NCAHJFFG@INVENTORY?$AA@			; `string'
PUBLIC	??_C@_04JPFKNPOP@MALL?$AA@			; `string'
PUBLIC	??_C@_07NCKDBJCB@SAFEBOX?$AA@			; `string'
PUBLIC	??_C@_06GKBINIEJ@GROUND?$AA@			; `string'
PUBLIC	??_C@_0BG@FHEDCCNN@DRAGON_SOUL_INVENTORY?$AA@	; `string'
PUBLIC	??_C@_0BB@IOEKBHAE@SKILL_SLOT_COUNT?$AA@	; `string'
PUBLIC	??_C@_0L@HFAEBHHD@ITEM_MONEY?$AA@		; `string'
PUBLIC	??_C@_0BH@FCKCIMBH@METIN_SOCKET_TYPE_NONE?$AA@	; `string'
PUBLIC	??_C@_0M@CHLINENA@EFFECT_PICK?$AA@		; `string'
PUBLIC	??_C@_0BH@EFCNALEJ@METIN_SOCKET_TYPE_GOLD?$AA@	; `string'
PUBLIC	??_C@_0BJ@PHGNNMMA@METIN_SOCKET_TYPE_SILVER?$AA@ ; `string'
PUBLIC	??_C@_0BH@BPEONNLD@ATTRIBUTE_SLOT_MAX_NUM?$AA@	; `string'
PUBLIC	??_C@_0BF@HOKBLOCN@METIN_SOCKET_MAX_NUM?$AA@	; `string'
PUBLIC	??_C@_09FFJEIDJG@REFINE_OK?$AA@			; `string'
PUBLIC	??_C@_0M@FNDEJPGN@REFINE_CANT?$AA@		; `string'
PUBLIC	??_C@_0BN@FMBLMMOD@REFINE_NEED_MORE_GOOD_SCROLL?$AA@ ; `string'
PUBLIC	??_C@_0CA@CPLGFHBD@REFINE_ALREADY_MAX_SOCKET_COUNT?$AA@ ; `string'
PUBLIC	??_C@_0BL@EILCCEPE@REFINE_NOT_NEXT_GRADE_ITEM?$AA@ ; `string'
PUBLIC	??_C@_0BN@JPDLJDPD@REFINE_CANT_MAKE_SOCKET_ITEM?$AA@ ; `string'
PUBLIC	??_C@_0BH@OENPPLJB@REFINE_CANT_REFINE_ROD?$AA@	; `string'
PUBLIC	??_C@_0CG@LFLLDFCE@REFINE_CANT_REFINE_METIN_TO_EQUI@ ; `string'
PUBLIC	??_C@_0BA@HOJAFGB@ATTACH_METIN_OK?$AA@		; `string'
PUBLIC	??_C@_0BC@CBCJMHP@ATTACH_METIN_CANT?$AA@	; `string'
PUBLIC	??_C@_0CB@MAILDNNI@ATTACH_METIN_NO_MATCHABLE_SOCKET@ ; `string'
PUBLIC	??_C@_0CA@OFAKGLFM@ATTACH_METIN_NOT_MATCHABLE_ITEM?$AA@ ; `string'
PUBLIC	??_C@_0CG@BCIFDNEM@ATTACH_METIN_CANT_ATTACH_TO_EQUI@ ; `string'
PUBLIC	??_C@_0CD@JNOPKOFJ@ATTACH_METIN_NOT_EXIST_GOLD_SOCK@ ; `string'
PUBLIC	??_C@_0BA@IACJJMNA@DETACH_METIN_OK?$AA@		; `string'
PUBLIC	??_C@_0BC@HGBPKPKG@DETACH_METIN_CANT?$AA@	; `string'
PUBLIC	??_C@_0BD@ECFFHEOH@PARTY_STATE_LEADER?$AA@	; `string'
PUBLIC	??_C@_0BD@PNFBHDHD@PARTY_STATE_NORMAL?$AA@	; `string'
PUBLIC	??_C@_0BD@FHMGGDNP@PARTY_STATE_TANKER?$AA@	; `string'
PUBLIC	??_C@_0BF@DOKPPLCL@PARTY_STATE_ATTACKER?$AA@	; `string'
PUBLIC	??_C@_0BJ@EIPCPJKC@PARTY_STATE_SKILL_MASTER?$AA@ ; `string'
PUBLIC	??_C@_0BD@JJFBJLK@PARTY_STATE_BUFFER?$AA@	; `string'
PUBLIC	??_C@_0BF@PAKJEMH@PARTY_STATE_DEFENDER?$AA@	; `string'
PUBLIC	??_C@_0BG@LCNEBE@PARTY_STATE_BERSERKER?$AA@	; `string'
PUBLIC	??_C@_0BE@MNBFKLPI@SKILL_INDEX_TONGSOL?$AA@	; `string'
PUBLIC	??_C@_0BE@KCLJFDCO@PARTY_STATE_MAX_NUM?$AA@	; `string'
PUBLIC	??_C@_0BD@KFCAJBFG@SKILL_INDEX_MINING?$AA@	; `string'
PUBLIC	??_C@_0BE@HANBCKAH@SKILL_INDEX_FISHING?$AA@	; `string'
PUBLIC	??_C@_0BC@HACNAMIK@SKILL_INDEX_COMBO?$AA@	; `string'
PUBLIC	??_C@_0BD@IBJDJMEL@SKILL_INDEX_MAKING?$AA@	; `string'
PUBLIC	??_C@_0BG@EEJDAHGJ@SKILL_INDEX_LANGUAGE2?$AA@	; `string'
PUBLIC	??_C@_0BG@GPLOFEKK@SKILL_INDEX_LANGUAGE1?$AA@	; `string'
PUBLIC	??_C@_0BG@DMEIDEKO@SKILL_INDEX_POLYMORPH?$AA@	; `string'
PUBLIC	??_C@_0BG@FNIIDGCI@SKILL_INDEX_LANGUAGE3?$AA@	; `string'
PUBLIC	??_C@_0BD@POBHIINM@SKILL_INDEX_SUMMON?$AA@	; `string'
PUBLIC	??_C@_0BD@HOAGGFNA@SKILL_INDEX_RIDING?$AA@	; `string'
PUBLIC	??_C@_0BA@HNNGLCOB@PK_MODE_REVENGE?$AA@		; `string'
PUBLIC	??_C@_0O@BIPAMBIG@PK_MODE_PEACE?$AA@		; `string'
PUBLIC	??_C@_0BA@GHACPGHA@PK_MODE_PROTECT?$AA@		; `string'
PUBLIC	??_C@_0N@DCANEGJG@PK_MODE_FREE?$AA@		; `string'
PUBLIC	??_C@_0BA@OLCDKGDA@PK_MODE_MAX_NUM?$AA@		; `string'
PUBLIC	??_C@_0O@LBDADKLE@PK_MODE_GUILD?$AA@		; `string'
PUBLIC	??_C@_0M@KFDBGBIL@BLOCK_PARTY?$AA@		; `string'
PUBLIC	??_C@_0P@CDMGAFPE@BLOCK_EXCHANGE?$AA@		; `string'
PUBLIC	??_C@_0O@CFHKOIIK@BLOCK_WHISPER?$AA@		; `string'
PUBLIC	??_C@_0M@EEMDCMKA@BLOCK_GUILD?$AA@		; `string'
PUBLIC	??_C@_0BE@NDGMABKO@BLOCK_PARTY_REQUEST?$AA@	; `string'
PUBLIC	??_C@_0N@IJGKBLJF@BLOCK_FRIEND?$AA@		; `string'
PUBLIC	??_C@_0BO@CBJBDFJC@PARTY_EXP_DISTRIBUTION_PARITY?$AA@ ; `string'
PUBLIC	??_C@_0BL@OELLICOI@PARTY_EXP_NON_DISTRIBUTION?$AA@ ; `string'
PUBLIC	??_C@_0BB@MCMBOGFC@EMOTION_CHEERS_1?$AA@	; `string'
PUBLIC	??_C@_0N@GFLIEIGE@EMOTION_CLAP?$AA@		; `string'
PUBLIC	??_C@_0BA@CLHGMEE@EMOTION_DANCE_1?$AA@		; `string'
PUBLIC	??_C@_0BB@OJOMLFJB@EMOTION_CHEERS_2?$AA@	; `string'
PUBLIC	??_C@_0BA@DAIBAOMG@EMOTION_DANCE_3?$AA@		; `string'
PUBLIC	??_C@_0BA@CJJKDPIH@EMOTION_DANCE_2?$AA@		; `string'
PUBLIC	??_C@_0BA@GGNLKJEA@EMOTION_DANCE_5?$AA@		; `string'
PUBLIC	??_C@_0BA@HPMAJIAB@EMOTION_DANCE_4?$AA@		; `string'
PUBLIC	??_C@_0BH@FIIEKKHF@EMOTION_CONGRATULATION?$AA@	; `string'
PUBLIC	??_C@_0BA@ENPGPKID@EMOTION_DANCE_6?$AA@		; `string'
PUBLIC	??_C@_0O@DACEICMN@EMOTION_ANGRY?$AA@		; `string'
PUBLIC	??_C@_0BA@JPGNEMIB@EMOTION_FORGIVE?$AA@		; `string'
PUBLIC	??_C@_0M@EGEMMDCF@EMOTION_SAD?$AA@		; `string'
PUBLIC	??_C@_0BD@FLNIBF@EMOTION_ATTRACTIVE?$AA@	; `string'
PUBLIC	??_C@_0BA@MENCJFPL@EMOTION_CHEERUP?$AA@		; `string'
PUBLIC	??_C@_0M@LGPBJELG@EMOTION_SHY?$AA@		; `string'
PUBLIC	??_C@_0M@JOKPJKCG@EMOTION_JOY?$AA@		; `string'
PUBLIC	??_C@_0P@JAJBGKKI@EMOTION_BANTER?$AA@		; `string'
PUBLIC	??_C@_0BE@KCAKKBPE@EMOTION_FRENCH_KISS?$AA@	; `string'
PUBLIC	??_C@_0N@FGJJNHEK@EMOTION_KISS?$AA@		; `string'
PUBLIC	??_C@_0BE@LLABJENL@AUTO_POTION_TYPE_HP?$AA@	; `string'
PUBLIC	??_C@_0N@FFINPOG@EMOTION_SLAP?$AA@		; `string'
PUBLIC	??_C@_0BG@FEPFCIIM@DRAGON_SOUL_PAGE_SIZE?$AA@	; `string'
PUBLIC	??_C@_0BE@KLHCNIEK@AUTO_POTION_TYPE_SP?$AA@	; `string'
PUBLIC	??_C@_0BH@IFPINEOD@DRAGON_SOUL_SLOT_COUNT?$AA@	; `string'
PUBLIC	??_C@_0BH@OCCNKKPP@DRAGON_SOUL_PAGE_COUNT?$AA@	; `string'
PUBLIC	??_C@_0CB@GAHKEECK@DRAGON_SOUL_EQUIPMENT_PAGE_COUNT@ ; `string'
PUBLIC	??_C@_0CB@NJAOAEOC@DRAGON_SOUL_EQUIPMENT_SLOT_START@ ; `string'
PUBLIC	??_C@_0BJ@MMGGGOHJ@DRAGON_SOUL_REFINE_CLOSE?$AA@ ; `string'
PUBLIC	??_C@_0CB@OIFHBJMG@DRAGON_SOUL_EQUIPMENT_FIRST_SIZE@ ; `string'
PUBLIC	??_C@_0BN@PCPINHKH@DS_SUB_HEADER_DO_IMPROVEMENT?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JKFAJIJN@DS_SUB_HEADER_DO_UPGRADE?$AA@ ; `string'
PUBLIC	??_C@_0BI@NHBOLMGK@DS_SUB_HEADER_DO_REFINE?$AA@	; `string'
PUBLIC	?c_iSkillIndex_Riding@@3KB			; c_iSkillIndex_Riding
PUBLIC	?c_iSkillIndex_Summon@@3KB			; c_iSkillIndex_Summon
PUBLIC	?c_iSkillIndex_Combo@@3KB			; c_iSkillIndex_Combo
PUBLIC	?c_iSkillIndex_Fishing@@3KB			; c_iSkillIndex_Fishing
EXTRN	__imp__PyDict_Next:PROC
EXTRN	__imp__PyDict_Size:PROC
EXTRN	?PyTuple_GetLong@@YA_NPAU_object@@HPAJ@Z:PROC	; PyTuple_GetLong
EXTRN	?GetWearFlags@CItemData@@QBEKXZ:PROC		; CItemData::GetWearFlags
EXTRN	?HasNextGrade@CItemData@@QBEHXZ:PROC		; CItemData::HasNextGrade
EXTRN	?Hide@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Hide
;	COMDAT ?s_methods@?1??initPlayer@@YAXXZ@4PAUPyMethodDef@@A
_DATA	SEGMENT
?s_methods@?1??initPlayer@@YAXXZ@4PAUPyMethodDef@@A DD FLAT:??_C@_0BC@CHIABFDI@GetAutoPotionInfo?$AA@ ; `initPlayer'::`2'::s_methods
	DD	FLAT:?playerGetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@CILJOCG@SetAutoPotionInfo?$AA@
	DD	FLAT:?playerSetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@MAEJALBO@PickCloseItem?$AA@
	DD	FLAT:?playerPickCloseItem@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@MNPFFDEJ@SetGameWindow?$AA@
	DD	FLAT:?playerSetGameWindow@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@HDADHLLI@RegisterEffect?$AA@
	DD	FLAT:?playerRegisterEffect@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@EGCDGLCF@RegisterCacheEffect?$AA@
	DD	FLAT:?playerRegisterCacheEffect@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@HDELDAFI@SetMouseState?$AA@
	DD	FLAT:?playerSetMouseState@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@LEJNPCGM@SetMouseFunc?$AA@
	DD	FLAT:?playerSetMouseFunc@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@MACDDOCA@GetMouseFunc?$AA@
	DD	FLAT:?playerGetMouseFunc@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BK@JBJLNCBH@SetMouseMiddleButtonState?$AA@
	DD	FLAT:?playerSetMouseMiddleButtonState@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BG@JCNMOACA@SetMainCharacterIndex?$AA@
	DD	FLAT:?playerSetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BG@GHIKDJGB@GetMainCharacterIndex?$AA@
	DD	FLAT:?playerGetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@OMDPKDFM@GetMainCharacterName?$AA@
	DD	FLAT:?playerGetMainCharacterName@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BJ@GIKFEPMH@GetMainCharacterPosition?$AA@
	DD	FLAT:?playerGetMainCharacterPosition@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@GALHNOAL@IsMainCharacterIndex?$AA@
	DD	FLAT:?playerIsMainCharacterIndex@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@FLPEGJDD@CanAttackInstance?$AA@
	DD	FLAT:?playerCanAttackInstance@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@ODCBPOEF@IsActingEmotion?$AA@
	DD	FLAT:?playerIsActingEmotion@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@ECCODAC@IsPVPInstance?$AA@
	DD	FLAT:?playerIsPVPInstance@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@CBEDFALN@IsSameEmpire?$AA@
	DD	FLAT:?playerIsSameEmpire@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@FOIPHJLO@IsChallengeInstance?$AA@
	DD	FLAT:?playerIsChallengeInstance@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@IKOEAPGC@IsRevengeInstance?$AA@
	DD	FLAT:?playerIsRevengeInstance@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@HJOMPGKI@IsCantFightInstance?$AA@
	DD	FLAT:?playerIsCantFightInstance@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@DABJOKIF@GetCharacterDistance?$AA@
	DD	FLAT:?playerGetCharacterDistance@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@IKPCBCPA@IsInSafeArea?$AA@
	DD	FLAT:?playerIsInSafeArea@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@GFJLKENO@IsMountingHorse?$AA@
	DD	FLAT:?playerIsMountingHorse@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@LDENHACE@IsObserverMode?$AA@
	DD	FLAT:?playerIsObserverMode@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@JEBGMNAH@ActEmotion?$AA@
	DD	FLAT:?playerActEmotion@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@CPMIOCIM@ShowPlayer?$AA@
	DD	FLAT:?playerShowPlayer@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@PBBGGCLG@HidePlayer?$AA@
	DD	FLAT:?playerHidePlayer@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@GOCDIKPN@ComboAttack?$AA@
	DD	FLAT:?playerComboAttack@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BL@IEKDAKHC@SetAutoCameraRotationSpeed?$AA@
	DD	FLAT:?playerSetAutoCameraRotationSpeed@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@DAIEHFBH@SetAttackKeyState?$AA@
	DD	FLAT:?playerSetAttackKeyState@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@PNJNANBI@SetSingleDIKKeyState?$AA@
	DD	FLAT:?playerSetSingleDIKKeyState@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BJ@HGLJKHIH@EndKeyWalkingImmediately?$AA@
	DD	FLAT:?playerEndKeyWalkingImmediately@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@NCHFPCDM@StartMouseWalking?$AA@
	DD	FLAT:?playerStartMouseWalking@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@JEOKFDLP@EndMouseWalking?$AA@
	DD	FLAT:?playerEndMouseWalking@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@MCFGJOPA@ResetCameraRotation?$AA@
	DD	FLAT:?playerResetCameraRotation@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@DPHLFGPP@SetQuickCameraMode?$AA@
	DD	FLAT:?playerSetQuickCameraMode@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_08HIFGFOGG@SetSkill?$AA@
	DD	FLAT:?playerSetSkill@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@NOICOABO@GetSkillIndex?$AA@
	DD	FLAT:?playerGetSkillIndex@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@HNJMANI@GetSkillSlotIndex?$AA@
	DD	FLAT:?playerGetSkillSlotIndex@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@IIOIANPE@GetSkillGrade?$AA@
	DD	FLAT:?playerGetSkillGrade@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@CNCBAIPN@GetSkillLevel?$AA@
	DD	FLAT:?playerGetSkillLevel@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0CD@EFGGIKHI@GetSkillCurrentEfficientPercenta@
	DD	FLAT:?playerGetSkillCurrentEfficientPercentage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0CA@JHGONPGM@GetSkillNextEfficientPercentage?$AA@
	DD	FLAT:?playerGetSkillNextEfficientPercentage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@IGNHDBHH@ClickSkillSlot?$AA@
	DD	FLAT:?playerClickSkillSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BN@BPJDEKED@ChangeCurrentSkillNumberOnly?$AA@
	DD	FLAT:?playerChangeCurrentSkillNumberOnly@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@MJOJKOJJ@ClearSkillDict?$AA@
	DD	FLAT:?playerClearSkillDict@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@GABOCBEH@GetItemIndex?$AA@
	DD	FLAT:?playerGetItemIndex@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@DMCGDNGF@GetItemFlags?$AA@
	DD	FLAT:?playerGetItemFlags@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@LEKALLIG@GetItemCount?$AA@
	DD	FLAT:?playerGetItemCount@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@DBLILMFK@GetItemCountByVnum?$AA@
	DD	FLAT:?playerGetItemCountByVnum@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@JBOBKHIE@GetItemMetinSocket?$AA@
	DD	FLAT:?playerGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@GOKPPDHH@GetItemAttribute?$AA@
	DD	FLAT:?playerGetItemAttribute@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@OKNBBEMG@GetISellItemPrice?$AA@
	DD	FLAT:?playerGetISellItemPrice@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_08MHJANHDM@MoveItem?$AA@
	DD	FLAT:?playerMoveItem@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@DBIFLBAC@SendClickItemPacket?$AA@
	DD	FLAT:?playerSendClickItemPacket@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07MMGEHGCI@GetName?$AA@
	DD	FLAT:?playerGetName@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06FHLNIOPB@GetJob?$AA@
	DD	FLAT:?playerGetJob@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07GDOKCBKB@GetRace?$AA@
	DD	FLAT:?playerGetRace@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@DJDCIBLO@GetPlayTime?$AA@
	DD	FLAT:?playerGetPlayTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@DGCMFHDN@SetPlayTime?$AA@
	DD	FLAT:?playerSetPlayTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@FOPKKJJD@IsSkillCoolTime?$AA@
	DD	FLAT:?playerIsSkillCoolTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@CNGGKNGL@GetSkillCoolTime?$AA@
	DD	FLAT:?playerGetSkillCoolTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@IAPCJJAC@IsSkillActive?$AA@
	DD	FLAT:?playerIsSkillActive@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@HHBOBCLE@UseGuildSkill?$AA@
	DD	FLAT:?playerUseGuildSkill@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@JIGEMOFF@AffectIndexToSkillIndex?$AA@
	DD	FLAT:?playerAffectIndexToSkillIndex@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06MDIKDJMD@GetEXP?$AA@
	DD	FLAT:?playerGetEXP@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09MKFEIFJE@GetStatus?$AA@
	DD	FLAT:?playerGetStatus@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09OEBBKEAG@SetStatus?$AA@
	DD	FLAT:?playerSetStatus@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06NMFKJLLH@GetElk?$AA@
	DD	FLAT:?playerGetElk@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_08OAJFGNBC@GetMoney?$AA@
	DD	FLAT:?playerGetElk@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@EAKBLDCO@GetGuildID?$AA@
	DD	FLAT:?playerGetGuildID@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@CECGOPDG@GetGuildName?$AA@
	DD	FLAT:?playerGetGuildName@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@LANDCIKG@GetAlignmentData?$AA@
	DD	FLAT:?playerGetAlignmentData@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BJ@DNLGAMEO@RequestAddLocalQuickSlot?$AA@
	DD	FLAT:?playerRequestAddLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0CA@JMFCJJPL@RequestAddToEmptyLocalQuickSlot?$AA@
	DD	FLAT:?playerRequestAddToEmptyLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BN@NACLJDMA@RequestDeleteGlobalQuickSlot?$AA@
	DD	FLAT:?playerRequestDeleteGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0CL@IEMBKGLN@RequestMoveGlobalQuickSlotToLoca@
	DD	FLAT:?playerRequestMoveGlobalQuickSlotToLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BJ@IBBGPDPH@RequestUseLocalQuickSlot?$AA@
	DD	FLAT:?playerRequestUseLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0CK@GNGKFIDB@LocalQuickSlotIndexToGlobalQuick@
	DD	FLAT:?playerLocalQuickSlotIndexToGlobalQuickSlotIndex@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@NLMPHAJA@GetQuickPage?$AA@
	DD	FLAT:?playerGetQuickPage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@KPHBLMNM@SetQuickPage?$AA@
	DD	FLAT:?playerSetQuickPage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@LNKMMBDG@GetLocalQuickSlot?$AA@
	DD	FLAT:?playerGetLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@ECGPDHPA@GetGlobalQuickSlot?$AA@
	DD	FLAT:?playerGetGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BH@JNCIKJMC@RemoveQuickSlotByValue?$AA@
	DD	FLAT:?playerRemoveQuickSlotByValue@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06NOPKEHAK@isItem?$AA@
	DD	FLAT:?playerisItem@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@EMKHGGAL@IsEquipmentSlot?$AA@
	DD	FLAT:?playerIsEquipmentSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@DDCIGDKO@IsDSEquipmentSlot?$AA@
	DD	FLAT:?playerIsDSEquipmentSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@KCAGNEAI@IsCostumeSlot?$AA@
	DD	FLAT:?playerIsCostumeSlot@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@LAJFBPPH@IsValuableItem?$AA@
	DD	FLAT:?playerIsValuableItem@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@DCFDMADN@IsOpenPrivateShop?$AA@
	DD	FLAT:?playerIsOpenPrivateShop@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@DGHEMMKN@GetItemGrade?$AA@
	DD	FLAT:?playerGetItemGrade@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09BGNCJJP@CanRefine?$AA@
	DD	FLAT:?playerCanRefine@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09GHIBIBHI@CanDetach?$AA@
	DD	FLAT:?playerCanDetach@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09FHINBOHC@CanUnlock?$AA@
	DD	FLAT:?playerCanUnlock@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@BLOGPKFO@CanAttachMetin?$AA@
	DD	FLAT:?playerCanAttachMetin@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@ELNKJPMC@IsRefineGradeScroll?$AA@
	DD	FLAT:?playerIsRefineGradeScroll@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@DPCEEMCG@ClearTarget?$AA@
	DD	FLAT:?playerClearTarget@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09EECGCJDE@SetTarget?$AA@
	DD	FLAT:?playerSetTarget@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@HAEJEFBP@OpenCharacterMenu?$AA@
	DD	FLAT:?playerOpenCharacterMenu@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06LMAGPFNF@Update?$AA@
	DD	FLAT:?playerUpdate@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06EPLDPNDB@Render?$AA@
	DD	FLAT:?playerRender@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_05MDNHABIA@Clear?$AA@
	DD	FLAT:?playerClear@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@FJCFNEGL@IsPartyMember?$AA@
	DD	FLAT:?playerIsPartyMember@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@BPMJGNAC@IsPartyLeader?$AA@
	DD	FLAT:?playerIsPartyLeader@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@HGKJMFNK@IsPartyLeaderByPID?$AA@
	DD	FLAT:?playerIsPartyLeaderByPID@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BL@EPAFEFHI@GetPartyMemberHPPercentage?$AA@
	DD	FLAT:?playerGetPartyMemberHPPercentage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@HKIJMBKK@GetPartyMemberState?$AA@
	DD	FLAT:?playerGetPartyMemberState@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BG@EEFAFMJC@GetPartyMemberAffects?$AA@
	DD	FLAT:?playerGetPartyMemberAffects@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@DGCJFOHN@RemovePartyMember?$AA@
	DD	FLAT:?playerRemovePartyMember@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09DMPBEJCG@ExitParty?$AA@
	DD	FLAT:?playerExitParty@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09IMMFEEHK@GetPKMode?$AA@
	DD	FLAT:?playerGetPKMode@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@CLGCEOLO@HasMobilePhoneNumber?$AA@
	DD	FLAT:?playerHasMobilePhoneNumber@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@PMDABIKP@RegisterEmotionIcon?$AA@
	DD	FLAT:?playerRegisterEmotionIcon@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@FELKHKJF@GetEmotionIconImage?$AA@
	DD	FLAT:?playerGetEmotionIconImage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BJ@CFCMHNHB@SetWeaponAttackBonusFlag?$AA@
	DD	FLAT:?playerSetWeaponAttackBonusFlag@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@ILOOLMDH@ToggleCoolTime?$AA@
	DD	FLAT:?playerToggleCoolTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@DJKKOCLB@ToggleLevelLimit?$AA@
	DD	FLAT:?playerToggleLevelLimit@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@MEKPPHGC@GetTargetVID?$AA@
	DD	FLAT:?playerGetTargetVID@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@CHNGAPIB@SetItemData?$AA@
	DD	FLAT:?playerSetItemData@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@GLMLJBGM@SetItemMetinSocket?$AA@
	DD	FLAT:?playerSetItemMetinSocket@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@KPGENMF@SetItemAttribute?$AA@
	DD	FLAT:?playerSetItemAttribute@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@MABOHHMK@SetItemCount?$AA@
	DD	FLAT:?playerSetItemCount@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@DGFCHEAA@GetItemLink?$AA@
	DD	FLAT:?playerGetItemLink@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@IOMKCPHN@SlotTypeToInvenType?$AA@
	DD	FLAT:?playerSlotTypeToInvenType@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@PLGNHJMH@SendDragonSoulRefine?$AA@
	DD	FLAT:?playerSendDragonSoulRefine@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
;	COMDAT ??_C@_0BI@NHBOLMGK@DS_SUB_HEADER_DO_REFINE?$AA@
CONST	SEGMENT
??_C@_0BI@NHBOLMGK@DS_SUB_HEADER_DO_REFINE?$AA@ DB 'DS_SUB_HEADER_DO_REFI'
	DB	'NE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JKFAJIJN@DS_SUB_HEADER_DO_UPGRADE?$AA@
CONST	SEGMENT
??_C@_0BJ@JKFAJIJN@DS_SUB_HEADER_DO_UPGRADE?$AA@ DB 'DS_SUB_HEADER_DO_UPG'
	DB	'RADE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PCPINHKH@DS_SUB_HEADER_DO_IMPROVEMENT?$AA@
CONST	SEGMENT
??_C@_0BN@PCPINHKH@DS_SUB_HEADER_DO_IMPROVEMENT?$AA@ DB 'DS_SUB_HEADER_DO'
	DB	'_IMPROVEMENT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OIFHBJMG@DRAGON_SOUL_EQUIPMENT_FIRST_SIZE@
CONST	SEGMENT
??_C@_0CB@OIFHBJMG@DRAGON_SOUL_EQUIPMENT_FIRST_SIZE@ DB 'DRAGON_SOUL_EQUI'
	DB	'PMENT_FIRST_SIZE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMGGGOHJ@DRAGON_SOUL_REFINE_CLOSE?$AA@
CONST	SEGMENT
??_C@_0BJ@MMGGGOHJ@DRAGON_SOUL_REFINE_CLOSE?$AA@ DB 'DRAGON_SOUL_REFINE_C'
	DB	'LOSE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NJAOAEOC@DRAGON_SOUL_EQUIPMENT_SLOT_START@
CONST	SEGMENT
??_C@_0CB@NJAOAEOC@DRAGON_SOUL_EQUIPMENT_SLOT_START@ DB 'DRAGON_SOUL_EQUI'
	DB	'PMENT_SLOT_START', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GAHKEECK@DRAGON_SOUL_EQUIPMENT_PAGE_COUNT@
CONST	SEGMENT
??_C@_0CB@GAHKEECK@DRAGON_SOUL_EQUIPMENT_PAGE_COUNT@ DB 'DRAGON_SOUL_EQUI'
	DB	'PMENT_PAGE_COUNT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OCCNKKPP@DRAGON_SOUL_PAGE_COUNT?$AA@
CONST	SEGMENT
??_C@_0BH@OCCNKKPP@DRAGON_SOUL_PAGE_COUNT?$AA@ DB 'DRAGON_SOUL_PAGE_COUNT'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IFPINEOD@DRAGON_SOUL_SLOT_COUNT?$AA@
CONST	SEGMENT
??_C@_0BH@IFPINEOD@DRAGON_SOUL_SLOT_COUNT?$AA@ DB 'DRAGON_SOUL_SLOT_COUNT'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KLHCNIEK@AUTO_POTION_TYPE_SP?$AA@
CONST	SEGMENT
??_C@_0BE@KLHCNIEK@AUTO_POTION_TYPE_SP?$AA@ DB 'AUTO_POTION_TYPE_SP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FEPFCIIM@DRAGON_SOUL_PAGE_SIZE?$AA@
CONST	SEGMENT
??_C@_0BG@FEPFCIIM@DRAGON_SOUL_PAGE_SIZE?$AA@ DB 'DRAGON_SOUL_PAGE_SIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFINPOG@EMOTION_SLAP?$AA@
CONST	SEGMENT
??_C@_0N@FFINPOG@EMOTION_SLAP?$AA@ DB 'EMOTION_SLAP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LLABJENL@AUTO_POTION_TYPE_HP?$AA@
CONST	SEGMENT
??_C@_0BE@LLABJENL@AUTO_POTION_TYPE_HP?$AA@ DB 'AUTO_POTION_TYPE_HP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FGJJNHEK@EMOTION_KISS?$AA@
CONST	SEGMENT
??_C@_0N@FGJJNHEK@EMOTION_KISS?$AA@ DB 'EMOTION_KISS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KCAKKBPE@EMOTION_FRENCH_KISS?$AA@
CONST	SEGMENT
??_C@_0BE@KCAKKBPE@EMOTION_FRENCH_KISS?$AA@ DB 'EMOTION_FRENCH_KISS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JAJBGKKI@EMOTION_BANTER?$AA@
CONST	SEGMENT
??_C@_0P@JAJBGKKI@EMOTION_BANTER?$AA@ DB 'EMOTION_BANTER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JOKPJKCG@EMOTION_JOY?$AA@
CONST	SEGMENT
??_C@_0M@JOKPJKCG@EMOTION_JOY?$AA@ DB 'EMOTION_JOY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LGPBJELG@EMOTION_SHY?$AA@
CONST	SEGMENT
??_C@_0M@LGPBJELG@EMOTION_SHY?$AA@ DB 'EMOTION_SHY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MENCJFPL@EMOTION_CHEERUP?$AA@
CONST	SEGMENT
??_C@_0BA@MENCJFPL@EMOTION_CHEERUP?$AA@ DB 'EMOTION_CHEERUP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FLNIBF@EMOTION_ATTRACTIVE?$AA@
CONST	SEGMENT
??_C@_0BD@FLNIBF@EMOTION_ATTRACTIVE?$AA@ DB 'EMOTION_ATTRACTIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EGEMMDCF@EMOTION_SAD?$AA@
CONST	SEGMENT
??_C@_0M@EGEMMDCF@EMOTION_SAD?$AA@ DB 'EMOTION_SAD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JPGNEMIB@EMOTION_FORGIVE?$AA@
CONST	SEGMENT
??_C@_0BA@JPGNEMIB@EMOTION_FORGIVE?$AA@ DB 'EMOTION_FORGIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DACEICMN@EMOTION_ANGRY?$AA@
CONST	SEGMENT
??_C@_0O@DACEICMN@EMOTION_ANGRY?$AA@ DB 'EMOTION_ANGRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENPGPKID@EMOTION_DANCE_6?$AA@
CONST	SEGMENT
??_C@_0BA@ENPGPKID@EMOTION_DANCE_6?$AA@ DB 'EMOTION_DANCE_6', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FIIEKKHF@EMOTION_CONGRATULATION?$AA@
CONST	SEGMENT
??_C@_0BH@FIIEKKHF@EMOTION_CONGRATULATION?$AA@ DB 'EMOTION_CONGRATULATION'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPMAJIAB@EMOTION_DANCE_4?$AA@
CONST	SEGMENT
??_C@_0BA@HPMAJIAB@EMOTION_DANCE_4?$AA@ DB 'EMOTION_DANCE_4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGNLKJEA@EMOTION_DANCE_5?$AA@
CONST	SEGMENT
??_C@_0BA@GGNLKJEA@EMOTION_DANCE_5?$AA@ DB 'EMOTION_DANCE_5', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CJJKDPIH@EMOTION_DANCE_2?$AA@
CONST	SEGMENT
??_C@_0BA@CJJKDPIH@EMOTION_DANCE_2?$AA@ DB 'EMOTION_DANCE_2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DAIBAOMG@EMOTION_DANCE_3?$AA@
CONST	SEGMENT
??_C@_0BA@DAIBAOMG@EMOTION_DANCE_3?$AA@ DB 'EMOTION_DANCE_3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OJOMLFJB@EMOTION_CHEERS_2?$AA@
CONST	SEGMENT
??_C@_0BB@OJOMLFJB@EMOTION_CHEERS_2?$AA@ DB 'EMOTION_CHEERS_2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLHGMEE@EMOTION_DANCE_1?$AA@
CONST	SEGMENT
??_C@_0BA@CLHGMEE@EMOTION_DANCE_1?$AA@ DB 'EMOTION_DANCE_1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GFLIEIGE@EMOTION_CLAP?$AA@
CONST	SEGMENT
??_C@_0N@GFLIEIGE@EMOTION_CLAP?$AA@ DB 'EMOTION_CLAP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MCMBOGFC@EMOTION_CHEERS_1?$AA@
CONST	SEGMENT
??_C@_0BB@MCMBOGFC@EMOTION_CHEERS_1?$AA@ DB 'EMOTION_CHEERS_1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OELLICOI@PARTY_EXP_NON_DISTRIBUTION?$AA@
CONST	SEGMENT
??_C@_0BL@OELLICOI@PARTY_EXP_NON_DISTRIBUTION?$AA@ DB 'PARTY_EXP_NON_DIST'
	DB	'RIBUTION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CBJBDFJC@PARTY_EXP_DISTRIBUTION_PARITY?$AA@
CONST	SEGMENT
??_C@_0BO@CBJBDFJC@PARTY_EXP_DISTRIBUTION_PARITY?$AA@ DB 'PARTY_EXP_DISTR'
	DB	'IBUTION_PARITY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IJGKBLJF@BLOCK_FRIEND?$AA@
CONST	SEGMENT
??_C@_0N@IJGKBLJF@BLOCK_FRIEND?$AA@ DB 'BLOCK_FRIEND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NDGMABKO@BLOCK_PARTY_REQUEST?$AA@
CONST	SEGMENT
??_C@_0BE@NDGMABKO@BLOCK_PARTY_REQUEST?$AA@ DB 'BLOCK_PARTY_REQUEST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEMDCMKA@BLOCK_GUILD?$AA@
CONST	SEGMENT
??_C@_0M@EEMDCMKA@BLOCK_GUILD?$AA@ DB 'BLOCK_GUILD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFHKOIIK@BLOCK_WHISPER?$AA@
CONST	SEGMENT
??_C@_0O@CFHKOIIK@BLOCK_WHISPER?$AA@ DB 'BLOCK_WHISPER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CDMGAFPE@BLOCK_EXCHANGE?$AA@
CONST	SEGMENT
??_C@_0P@CDMGAFPE@BLOCK_EXCHANGE?$AA@ DB 'BLOCK_EXCHANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFDBGBIL@BLOCK_PARTY?$AA@
CONST	SEGMENT
??_C@_0M@KFDBGBIL@BLOCK_PARTY?$AA@ DB 'BLOCK_PARTY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LBDADKLE@PK_MODE_GUILD?$AA@
CONST	SEGMENT
??_C@_0O@LBDADKLE@PK_MODE_GUILD?$AA@ DB 'PK_MODE_GUILD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OLCDKGDA@PK_MODE_MAX_NUM?$AA@
CONST	SEGMENT
??_C@_0BA@OLCDKGDA@PK_MODE_MAX_NUM?$AA@ DB 'PK_MODE_MAX_NUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCANEGJG@PK_MODE_FREE?$AA@
CONST	SEGMENT
??_C@_0N@DCANEGJG@PK_MODE_FREE?$AA@ DB 'PK_MODE_FREE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GHACPGHA@PK_MODE_PROTECT?$AA@
CONST	SEGMENT
??_C@_0BA@GHACPGHA@PK_MODE_PROTECT?$AA@ DB 'PK_MODE_PROTECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BIPAMBIG@PK_MODE_PEACE?$AA@
CONST	SEGMENT
??_C@_0O@BIPAMBIG@PK_MODE_PEACE?$AA@ DB 'PK_MODE_PEACE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HNNGLCOB@PK_MODE_REVENGE?$AA@
CONST	SEGMENT
??_C@_0BA@HNNGLCOB@PK_MODE_REVENGE?$AA@ DB 'PK_MODE_REVENGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HOAGGFNA@SKILL_INDEX_RIDING?$AA@
CONST	SEGMENT
??_C@_0BD@HOAGGFNA@SKILL_INDEX_RIDING?$AA@ DB 'SKILL_INDEX_RIDING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@POBHIINM@SKILL_INDEX_SUMMON?$AA@
CONST	SEGMENT
??_C@_0BD@POBHIINM@SKILL_INDEX_SUMMON?$AA@ DB 'SKILL_INDEX_SUMMON', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FNIIDGCI@SKILL_INDEX_LANGUAGE3?$AA@
CONST	SEGMENT
??_C@_0BG@FNIIDGCI@SKILL_INDEX_LANGUAGE3?$AA@ DB 'SKILL_INDEX_LANGUAGE3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DMEIDEKO@SKILL_INDEX_POLYMORPH?$AA@
CONST	SEGMENT
??_C@_0BG@DMEIDEKO@SKILL_INDEX_POLYMORPH?$AA@ DB 'SKILL_INDEX_POLYMORPH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GPLOFEKK@SKILL_INDEX_LANGUAGE1?$AA@
CONST	SEGMENT
??_C@_0BG@GPLOFEKK@SKILL_INDEX_LANGUAGE1?$AA@ DB 'SKILL_INDEX_LANGUAGE1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EEJDAHGJ@SKILL_INDEX_LANGUAGE2?$AA@
CONST	SEGMENT
??_C@_0BG@EEJDAHGJ@SKILL_INDEX_LANGUAGE2?$AA@ DB 'SKILL_INDEX_LANGUAGE2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IBJDJMEL@SKILL_INDEX_MAKING?$AA@
CONST	SEGMENT
??_C@_0BD@IBJDJMEL@SKILL_INDEX_MAKING?$AA@ DB 'SKILL_INDEX_MAKING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HACNAMIK@SKILL_INDEX_COMBO?$AA@
CONST	SEGMENT
??_C@_0BC@HACNAMIK@SKILL_INDEX_COMBO?$AA@ DB 'SKILL_INDEX_COMBO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HANBCKAH@SKILL_INDEX_FISHING?$AA@
CONST	SEGMENT
??_C@_0BE@HANBCKAH@SKILL_INDEX_FISHING?$AA@ DB 'SKILL_INDEX_FISHING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KFCAJBFG@SKILL_INDEX_MINING?$AA@
CONST	SEGMENT
??_C@_0BD@KFCAJBFG@SKILL_INDEX_MINING?$AA@ DB 'SKILL_INDEX_MINING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KCLJFDCO@PARTY_STATE_MAX_NUM?$AA@
CONST	SEGMENT
??_C@_0BE@KCLJFDCO@PARTY_STATE_MAX_NUM?$AA@ DB 'PARTY_STATE_MAX_NUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MNBFKLPI@SKILL_INDEX_TONGSOL?$AA@
CONST	SEGMENT
??_C@_0BE@MNBFKLPI@SKILL_INDEX_TONGSOL?$AA@ DB 'SKILL_INDEX_TONGSOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LCNEBE@PARTY_STATE_BERSERKER?$AA@
CONST	SEGMENT
??_C@_0BG@LCNEBE@PARTY_STATE_BERSERKER?$AA@ DB 'PARTY_STATE_BERSERKER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PAKJEMH@PARTY_STATE_DEFENDER?$AA@
CONST	SEGMENT
??_C@_0BF@PAKJEMH@PARTY_STATE_DEFENDER?$AA@ DB 'PARTY_STATE_DEFENDER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JJFBJLK@PARTY_STATE_BUFFER?$AA@
CONST	SEGMENT
??_C@_0BD@JJFBJLK@PARTY_STATE_BUFFER?$AA@ DB 'PARTY_STATE_BUFFER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EIPCPJKC@PARTY_STATE_SKILL_MASTER?$AA@
CONST	SEGMENT
??_C@_0BJ@EIPCPJKC@PARTY_STATE_SKILL_MASTER?$AA@ DB 'PARTY_STATE_SKILL_MA'
	DB	'STER', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DOKPPLCL@PARTY_STATE_ATTACKER?$AA@
CONST	SEGMENT
??_C@_0BF@DOKPPLCL@PARTY_STATE_ATTACKER?$AA@ DB 'PARTY_STATE_ATTACKER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FHMGGDNP@PARTY_STATE_TANKER?$AA@
CONST	SEGMENT
??_C@_0BD@FHMGGDNP@PARTY_STATE_TANKER?$AA@ DB 'PARTY_STATE_TANKER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNFBHDHD@PARTY_STATE_NORMAL?$AA@
CONST	SEGMENT
??_C@_0BD@PNFBHDHD@PARTY_STATE_NORMAL?$AA@ DB 'PARTY_STATE_NORMAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ECFFHEOH@PARTY_STATE_LEADER?$AA@
CONST	SEGMENT
??_C@_0BD@ECFFHEOH@PARTY_STATE_LEADER?$AA@ DB 'PARTY_STATE_LEADER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HGBPKPKG@DETACH_METIN_CANT?$AA@
CONST	SEGMENT
??_C@_0BC@HGBPKPKG@DETACH_METIN_CANT?$AA@ DB 'DETACH_METIN_CANT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IACJJMNA@DETACH_METIN_OK?$AA@
CONST	SEGMENT
??_C@_0BA@IACJJMNA@DETACH_METIN_OK?$AA@ DB 'DETACH_METIN_OK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JNOPKOFJ@ATTACH_METIN_NOT_EXIST_GOLD_SOCK@
CONST	SEGMENT
??_C@_0CD@JNOPKOFJ@ATTACH_METIN_NOT_EXIST_GOLD_SOCK@ DB 'ATTACH_METIN_NOT'
	DB	'_EXIST_GOLD_SOCKET', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BCIFDNEM@ATTACH_METIN_CANT_ATTACH_TO_EQUI@
CONST	SEGMENT
??_C@_0CG@BCIFDNEM@ATTACH_METIN_CANT_ATTACH_TO_EQUI@ DB 'ATTACH_METIN_CAN'
	DB	'T_ATTACH_TO_EQUIPMENT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OFAKGLFM@ATTACH_METIN_NOT_MATCHABLE_ITEM?$AA@
CONST	SEGMENT
??_C@_0CA@OFAKGLFM@ATTACH_METIN_NOT_MATCHABLE_ITEM?$AA@ DB 'ATTACH_METIN_'
	DB	'NOT_MATCHABLE_ITEM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MAILDNNI@ATTACH_METIN_NO_MATCHABLE_SOCKET@
CONST	SEGMENT
??_C@_0CB@MAILDNNI@ATTACH_METIN_NO_MATCHABLE_SOCKET@ DB 'ATTACH_METIN_NO_'
	DB	'MATCHABLE_SOCKET', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CBCJMHP@ATTACH_METIN_CANT?$AA@
CONST	SEGMENT
??_C@_0BC@CBCJMHP@ATTACH_METIN_CANT?$AA@ DB 'ATTACH_METIN_CANT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HOJAFGB@ATTACH_METIN_OK?$AA@
CONST	SEGMENT
??_C@_0BA@HOJAFGB@ATTACH_METIN_OK?$AA@ DB 'ATTACH_METIN_OK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LFLLDFCE@REFINE_CANT_REFINE_METIN_TO_EQUI@
CONST	SEGMENT
??_C@_0CG@LFLLDFCE@REFINE_CANT_REFINE_METIN_TO_EQUI@ DB 'REFINE_CANT_REFI'
	DB	'NE_METIN_TO_EQUIPMENT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OENPPLJB@REFINE_CANT_REFINE_ROD?$AA@
CONST	SEGMENT
??_C@_0BH@OENPPLJB@REFINE_CANT_REFINE_ROD?$AA@ DB 'REFINE_CANT_REFINE_ROD'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JPDLJDPD@REFINE_CANT_MAKE_SOCKET_ITEM?$AA@
CONST	SEGMENT
??_C@_0BN@JPDLJDPD@REFINE_CANT_MAKE_SOCKET_ITEM?$AA@ DB 'REFINE_CANT_MAKE'
	DB	'_SOCKET_ITEM', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EILCCEPE@REFINE_NOT_NEXT_GRADE_ITEM?$AA@
CONST	SEGMENT
??_C@_0BL@EILCCEPE@REFINE_NOT_NEXT_GRADE_ITEM?$AA@ DB 'REFINE_NOT_NEXT_GR'
	DB	'ADE_ITEM', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CPLGFHBD@REFINE_ALREADY_MAX_SOCKET_COUNT?$AA@
CONST	SEGMENT
??_C@_0CA@CPLGFHBD@REFINE_ALREADY_MAX_SOCKET_COUNT?$AA@ DB 'REFINE_ALREAD'
	DB	'Y_MAX_SOCKET_COUNT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FMBLMMOD@REFINE_NEED_MORE_GOOD_SCROLL?$AA@
CONST	SEGMENT
??_C@_0BN@FMBLMMOD@REFINE_NEED_MORE_GOOD_SCROLL?$AA@ DB 'REFINE_NEED_MORE'
	DB	'_GOOD_SCROLL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNDEJPGN@REFINE_CANT?$AA@
CONST	SEGMENT
??_C@_0M@FNDEJPGN@REFINE_CANT?$AA@ DB 'REFINE_CANT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FFJEIDJG@REFINE_OK?$AA@
CONST	SEGMENT
??_C@_09FFJEIDJG@REFINE_OK?$AA@ DB 'REFINE_OK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOKBLOCN@METIN_SOCKET_MAX_NUM?$AA@
CONST	SEGMENT
??_C@_0BF@HOKBLOCN@METIN_SOCKET_MAX_NUM?$AA@ DB 'METIN_SOCKET_MAX_NUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BPEONNLD@ATTRIBUTE_SLOT_MAX_NUM?$AA@
CONST	SEGMENT
??_C@_0BH@BPEONNLD@ATTRIBUTE_SLOT_MAX_NUM?$AA@ DB 'ATTRIBUTE_SLOT_MAX_NUM'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PHGNNMMA@METIN_SOCKET_TYPE_SILVER?$AA@
CONST	SEGMENT
??_C@_0BJ@PHGNNMMA@METIN_SOCKET_TYPE_SILVER?$AA@ DB 'METIN_SOCKET_TYPE_SI'
	DB	'LVER', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EFCNALEJ@METIN_SOCKET_TYPE_GOLD?$AA@
CONST	SEGMENT
??_C@_0BH@EFCNALEJ@METIN_SOCKET_TYPE_GOLD?$AA@ DB 'METIN_SOCKET_TYPE_GOLD'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CHLINENA@EFFECT_PICK?$AA@
CONST	SEGMENT
??_C@_0M@CHLINENA@EFFECT_PICK?$AA@ DB 'EFFECT_PICK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FCKCIMBH@METIN_SOCKET_TYPE_NONE?$AA@
CONST	SEGMENT
??_C@_0BH@FCKCIMBH@METIN_SOCKET_TYPE_NONE?$AA@ DB 'METIN_SOCKET_TYPE_NONE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HFAEBHHD@ITEM_MONEY?$AA@
CONST	SEGMENT
??_C@_0L@HFAEBHHD@ITEM_MONEY?$AA@ DB 'ITEM_MONEY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IOEKBHAE@SKILL_SLOT_COUNT?$AA@
CONST	SEGMENT
??_C@_0BB@IOEKBHAE@SKILL_SLOT_COUNT?$AA@ DB 'SKILL_SLOT_COUNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FHEDCCNN@DRAGON_SOUL_INVENTORY?$AA@
CONST	SEGMENT
??_C@_0BG@FHEDCCNN@DRAGON_SOUL_INVENTORY?$AA@ DB 'DRAGON_SOUL_INVENTORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKBINIEJ@GROUND?$AA@
CONST	SEGMENT
??_C@_06GKBINIEJ@GROUND?$AA@ DB 'GROUND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCKDBJCB@SAFEBOX?$AA@
CONST	SEGMENT
??_C@_07NCKDBJCB@SAFEBOX?$AA@ DB 'SAFEBOX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JPFKNPOP@MALL?$AA@
CONST	SEGMENT
??_C@_04JPFKNPOP@MALL?$AA@ DB 'MALL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NCAHJFFG@INVENTORY?$AA@
CONST	SEGMENT
??_C@_09NCAHJFFG@INVENTORY?$AA@ DB 'INVENTORY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GJGOMHMK@EQUIPMENT?$AA@
CONST	SEGMENT
??_C@_09GJGOMHMK@EQUIPMENT?$AA@ DB 'EQUIPMENT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FHKIPOOP@SLOT_TYPE_DRAGON_SOUL_INVENTORY?$AA@
CONST	SEGMENT
??_C@_0CA@FHKIPOOP@SLOT_TYPE_DRAGON_SOUL_INVENTORY?$AA@ DB 'SLOT_TYPE_DRA'
	DB	'GON_SOUL_INVENTORY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NKAFFIGF@RESERVED_WINDOW?$AA@
CONST	SEGMENT
??_C@_0BA@NKAFFIGF@RESERVED_WINDOW?$AA@ DB 'RESERVED_WINDOW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OEAGANKI@SLOT_TYPE_MALL?$AA@
CONST	SEGMENT
??_C@_0P@OEAGANKI@SLOT_TYPE_MALL?$AA@ DB 'SLOT_TYPE_MALL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LKMHLHKJ@SLOT_TYPE_EMOTION?$AA@
CONST	SEGMENT
??_C@_0BC@LKMHLHKJ@SLOT_TYPE_EMOTION?$AA@ DB 'SLOT_TYPE_EMOTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HGKFDIFN@SLOT_TYPE_SAFEBOX?$AA@
CONST	SEGMENT
??_C@_0BC@HGKFDIFN@SLOT_TYPE_SAFEBOX?$AA@ DB 'SLOT_TYPE_SAFEBOX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJAEADNE@SLOT_TYPE_PRIVATE_SHOP?$AA@
CONST	SEGMENT
??_C@_0BH@MJAEADNE@SLOT_TYPE_PRIVATE_SHOP?$AA@ DB 'SLOT_TYPE_PRIVATE_SHOP'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KJHLAGBH@SLOT_TYPE_EXCHANGE_TARGET?$AA@
CONST	SEGMENT
??_C@_0BK@KJHLAGBH@SLOT_TYPE_EXCHANGE_TARGET?$AA@ DB 'SLOT_TYPE_EXCHANGE_'
	DB	'TARGET', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CPPFMLHN@SLOT_TYPE_QUICK_SLOT?$AA@
CONST	SEGMENT
??_C@_0BF@CPPFMLHN@SLOT_TYPE_QUICK_SLOT?$AA@ DB 'SLOT_TYPE_QUICK_SLOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCOPIIMF@SLOT_TYPE_SHOP?$AA@
CONST	SEGMENT
??_C@_0P@KCOPIIMF@SLOT_TYPE_SHOP?$AA@ DB 'SLOT_TYPE_SHOP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBNHPJKE@SLOT_TYPE_EXCHANGE_OWNER?$AA@
CONST	SEGMENT
??_C@_0BJ@DBNHPJKE@SLOT_TYPE_EXCHANGE_OWNER?$AA@ DB 'SLOT_TYPE_EXCHANGE_O'
	DB	'WNER', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BNOEBHPE@SLOT_TYPE_INVENTORY?$AA@
CONST	SEGMENT
??_C@_0BE@BNOEBHPE@SLOT_TYPE_INVENTORY?$AA@ DB 'SLOT_TYPE_INVENTORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MAJHKGKG@SLOT_TYPE_SKILL?$AA@
CONST	SEGMENT
??_C@_0BA@MAJHKGKG@SLOT_TYPE_SKILL?$AA@ DB 'SLOT_TYPE_SKILL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OMNIMJHC@MBT_LEFT?$AA@
CONST	SEGMENT
??_C@_08OMNIMJHC@MBT_LEFT?$AA@ DB 'MBT_LEFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JBDPGPGM@SLOT_TYPE_NONE?$AA@
CONST	SEGMENT
??_C@_0P@JBDPGPGM@SLOT_TYPE_NONE?$AA@ DB 'SLOT_TYPE_NONE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BKODCCAJ@MBS_CLICK?$AA@
CONST	SEGMENT
??_C@_09BKODCCAJ@MBS_CLICK?$AA@ DB 'MBS_CLICK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DBJMODBC@MBT_RIGHT?$AA@
CONST	SEGMENT
??_C@_09DBJMODBC@MBT_RIGHT?$AA@ DB 'MBT_RIGHT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIEGLDP@MBF_AUTO?$AA@
CONST	SEGMENT
??_C@_08CIEGLDP@MBF_AUTO?$AA@ DB 'MBF_AUTO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JEJKPPEO@MBS_PRESS?$AA@
CONST	SEGMENT
??_C@_09JEJKPPEO@MBS_PRESS?$AA@ DB 'MBS_PRESS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAENJFL@MBF_SMART?$AA@
CONST	SEGMENT
??_C@_09FAENJFL@MBF_SMART?$AA@ DB 'MBF_SMART', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BLLANCB@MBF_MOVE?$AA@
CONST	SEGMENT
??_C@_08BLLANCB@MBF_MOVE?$AA@ DB 'MBF_MOVE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MIGMJBKJ@MBF_ATTACK?$AA@
CONST	SEGMENT
??_C@_0L@MIGMJBKJ@MBF_ATTACK?$AA@ DB 'MBF_ATTACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JHBFAMB@MBF_CAMERA?$AA@
CONST	SEGMENT
??_C@_0L@JHBFAMB@MBF_CAMERA?$AA@ DB 'MBF_CAMERA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MADFLPAE@EQUIPMENT_PAGE_COUNT?$AA@
CONST	SEGMENT
??_C@_0BF@MADFLPAE@EQUIPMENT_PAGE_COUNT?$AA@ DB 'EQUIPMENT_PAGE_COUNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLFDBCDH@MBF_SKILL?$AA@
CONST	SEGMENT
??_C@_09NLFDBCDH@MBF_SKILL?$AA@ DB 'MBF_SKILL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LCFAAJPA@INVENTORY_SLOT_COUNT?$AA@
CONST	SEGMENT
??_C@_0BF@LCFAAJPA@INVENTORY_SLOT_COUNT?$AA@ DB 'INVENTORY_SLOT_COUNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HJEBPPMM@EQUIPMENT_SLOT_START?$AA@
CONST	SEGMENT
??_C@_0BF@HJEBPPMM@EQUIPMENT_SLOT_START?$AA@ DB 'EQUIPMENT_SLOT_START', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEBDMLGH@INVENTORY_PAGE_SIZE?$AA@
CONST	SEGMENT
??_C@_0BE@CEBDMLGH@INVENTORY_PAGE_SIZE?$AA@ DB 'INVENTORY_PAGE_SIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NFIFHHOM@INVENTORY_PAGE_COUNT?$AA@
CONST	SEGMENT
??_C@_0BF@NFIFHHOM@INVENTORY_PAGE_COUNT?$AA@ DB 'INVENTORY_PAGE_COUNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LCKKFCJM@CATEGORY_ACTIVE?$AA@
CONST	SEGMENT
??_C@_0BA@LCKKFCJM@CATEGORY_ACTIVE?$AA@ DB 'CATEGORY_ACTIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HCMEALJK@CATEGORY_PASSIVE?$AA@
CONST	SEGMENT
??_C@_0BB@HCMEALJK@CATEGORY_PASSIVE?$AA@ DB 'CATEGORY_PASSIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CFOEIGCN@SKILL_GRADE_GRAND_MASTER?$AA@
CONST	SEGMENT
??_C@_0BJ@CFOEIGCN@SKILL_GRADE_GRAND_MASTER?$AA@ DB 'SKILL_GRADE_GRAND_MA'
	DB	'STER', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DCIPLDCA@SKILL_GRADE_PERFECT_MASTER?$AA@
CONST	SEGMENT
??_C@_0BL@DCIPLDCA@SKILL_GRADE_PERFECT_MASTER?$AA@ DB 'SKILL_GRADE_PERFEC'
	DB	'T_MASTER', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAKFNFGD@SKILL_GRADE_NORMAL?$AA@
CONST	SEGMENT
??_C@_0BD@LAKFNFGD@SKILL_GRADE_NORMAL?$AA@ DB 'SKILL_GRADE_NORMAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HIHOAICI@SKILL_GRADE_MASTER?$AA@
CONST	SEGMENT
??_C@_0BD@HIHOAICI@SKILL_GRADE_MASTER?$AA@ DB 'SKILL_GRADE_MASTER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KOEJHMAL@ENERGY?$AA@
CONST	SEGMENT
??_C@_06KOEJHMAL@ENERGY?$AA@ DB 'ENERGY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIHNCBED@ENERGY_END_TIME?$AA@
CONST	SEGMENT
??_C@_0BA@PIHNCBED@ENERGY_END_TIME?$AA@ DB 'ENERGY_END_TIME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BAKJJELL@POINT_PC_BANG_EXP_BONUS?$AA@
CONST	SEGMENT
??_C@_0BI@BAKJJELL@POINT_PC_BANG_EXP_BONUS?$AA@ DB 'POINT_PC_BANG_EXP_BON'
	DB	'US', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFKCHGEO@POINT_PC_BANG_DROP_BONUS?$AA@
CONST	SEGMENT
??_C@_0BJ@LFKCHGEO@POINT_PC_BANG_DROP_BONUS?$AA@ DB 'POINT_PC_BANG_DROP_B'
	DB	'ONUS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LPIAEILC@POINT_SKILL_DEFEND_BONUS?$AA@
CONST	SEGMENT
??_C@_0BJ@LPIAEILC@POINT_SKILL_DEFEND_BONUS?$AA@ DB 'POINT_SKILL_DEFEND_B'
	DB	'ONUS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CEPNAEGB@POINT_NORMAL_HIT_DEFEND_BONUS?$AA@
CONST	SEGMENT
??_C@_0BO@CEPNAEGB@POINT_NORMAL_HIT_DEFEND_BONUS?$AA@ DB 'POINT_NORMAL_HI'
	DB	'T_DEFEND_BONUS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PGEFOCDG@POINT_SKILL_DAMAGE_BONUS?$AA@
CONST	SEGMENT
??_C@_0BJ@PGEFOCDG@POINT_SKILL_DAMAGE_BONUS?$AA@ DB 'POINT_SKILL_DAMAGE_B'
	DB	'ONUS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GNDIKOOF@POINT_NORMAL_HIT_DAMAGE_BONUS?$AA@
CONST	SEGMENT
??_C@_0BO@GNDIKOOF@POINT_NORMAL_HIT_DAMAGE_BONUS?$AA@ DB 'POINT_NORMAL_HI'
	DB	'T_DAMAGE_BONUS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCODMABI@POINT_MAX_HP_PCT?$AA@
CONST	SEGMENT
??_C@_0BB@OCODMABI@POINT_MAX_HP_PCT?$AA@ DB 'POINT_MAX_HP_PCT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IHDKAICM@POINT_MAX_SP_PCT?$AA@
CONST	SEGMENT
??_C@_0BB@IHDKAICM@POINT_MAX_SP_PCT?$AA@ DB 'POINT_MAX_SP_PCT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FCMHLHC@POINT_MALL_ITEMBONUS?$AA@
CONST	SEGMENT
??_C@_0BF@FCMHLHC@POINT_MALL_ITEMBONUS?$AA@ DB 'POINT_MALL_ITEMBONUS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPKHMJJF@POINT_MALL_GOLDBONUS?$AA@
CONST	SEGMENT
??_C@_0BF@LPKHMJJF@POINT_MALL_GOLDBONUS?$AA@ DB 'POINT_MALL_GOLDBONUS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FJKLFHOA@POINT_MALL_DEFBONUS?$AA@
CONST	SEGMENT
??_C@_0BE@FJKLFHOA@POINT_MALL_DEFBONUS?$AA@ DB 'POINT_MALL_DEFBONUS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KNGAMOKN@POINT_MALL_EXPBONUS?$AA@
CONST	SEGMENT
??_C@_0BE@KNGAMOKN@POINT_MALL_EXPBONUS?$AA@ DB 'POINT_MALL_EXPBONUS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BGNEFMNJ@POINT_PENETRATE_PCT?$AA@
CONST	SEGMENT
??_C@_0BE@BGNEFMNJ@POINT_PENETRATE_PCT?$AA@ DB 'POINT_PENETRATE_PCT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FDGMKOPN@POINT_MALL_ATTBONUS?$AA@
CONST	SEGMENT
??_C@_0BE@FDGMKOPN@POINT_MALL_ATTBONUS?$AA@ DB 'POINT_MALL_ATTBONUS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEMMKJPK@MAX_NUM?$AA@
CONST	SEGMENT
??_C@_07MEMMKJPK@MAX_NUM?$AA@ DB 'MAX_NUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPEECKKP@POINT_CRITICAL_PCT?$AA@
CONST	SEGMENT
??_C@_0BD@CPEECKKP@POINT_CRITICAL_PCT?$AA@ DB 'POINT_CRITICAL_PCT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FGICENAO@SP_RECOVERY?$AA@
CONST	SEGMENT
??_C@_0M@FGICENAO@SP_RECOVERY?$AA@ DB 'SP_RECOVERY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAAMLPFK@ATTACKER_BONUS?$AA@
CONST	SEGMENT
??_C@_0P@GAAMLPFK@ATTACKER_BONUS?$AA@ DB 'ATTACKER_BONUS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KHDDEEFG@BOW_DISTANCE?$AA@
CONST	SEGMENT
??_C@_0N@KHDDEEFG@BOW_DISTANCE?$AA@ DB 'BOW_DISTANCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CLAIAEPM@HP_RECOVERY?$AA@
CONST	SEGMENT
??_C@_0M@CLAIAEPM@HP_RECOVERY?$AA@ DB 'HP_RECOVERY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HAFIBGFL@SKILL_HORSE?$AA@
CONST	SEGMENT
??_C@_0M@HAFIBGFL@SKILL_HORSE?$AA@ DB 'SKILL_HORSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CKIIBBI@PLAYTIME?$AA@
CONST	SEGMENT
??_C@_08CKIIBBI@PLAYTIME?$AA@ DB 'PLAYTIME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JLNOPGFK@SKILL_SUPPORT?$AA@
CONST	SEGMENT
??_C@_0O@JLNOPGFK@SKILL_SUPPORT?$AA@ DB 'SKILL_SUPPORT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DNBJLBPA@SKILL_ACTIVE?$AA@
CONST	SEGMENT
??_C@_0N@DNBJLBPA@SKILL_ACTIVE?$AA@ DB 'SKILL_ACTIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNIOFKKL@STAT?$AA@
CONST	SEGMENT
??_C@_04KNIOFKKL@STAT?$AA@ DB 'STAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DGEPJFAK@SKILL_PASSIVE?$AA@
CONST	SEGMENT
??_C@_0O@DGEPJFAK@SKILL_PASSIVE?$AA@ DB 'SKILL_PASSIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGCDIDGL@MAG_DEF?$AA@
CONST	SEGMENT
??_C@_07KGCDIDGL@MAG_DEF?$AA@ DB 'MAG_DEF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JIFCAIPA@EMPIRE_POINT?$AA@
CONST	SEGMENT
??_C@_0N@JIFCAIPA@EMPIRE_POINT?$AA@ DB 'EMPIRE_POINT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IOLIEEIE@CASTING_SPEED?$AA@
CONST	SEGMENT
??_C@_0O@IOLIEEIE@CASTING_SPEED?$AA@ DB 'CASTING_SPEED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PEONMKMN@MAG_ATT?$AA@
CONST	SEGMENT
??_C@_07PEONMKMN@MAG_ATT?$AA@ DB 'MAG_ATT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KMPFCDFE@DEF_GRADE?$AA@
CONST	SEGMENT
??_C@_09KMPFCDFE@DEF_GRADE?$AA@ DB 'DEF_GRADE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DNFHINBC@DEF_BONUS?$AA@
CONST	SEGMENT
??_C@_09DNFHINBC@DEF_BONUS?$AA@ DB 'DEF_BONUS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IPHIKIMB@EVADE_RATE?$AA@
CONST	SEGMENT
??_C@_0L@IPHIKIMB@EVADE_RATE?$AA@ DB 'EVADE_RATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KGGLAJKM@MOVING_SPEED?$AA@
CONST	SEGMENT
??_C@_0N@KGGLAJKM@MOVING_SPEED?$AA@ DB 'MOVING_SPEED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKMFFHLI@ATT_SPEED?$AA@
CONST	SEGMENT
??_C@_09LKMFFHLI@ATT_SPEED?$AA@ DB 'ATT_SPEED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FOFLCGDC@ATT_BONUS?$AA@
CONST	SEGMENT
??_C@_09FOFLCGDC@ATT_BONUS?$AA@ DB 'ATT_BONUS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CJNCLCGL@MIN_MAGIC_WEP?$AA@
CONST	SEGMENT
??_C@_0O@CJNCLCGL@MIN_MAGIC_WEP?$AA@ DB 'MIN_MAGIC_WEP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JAPECJBK@MAX_MAGIC_WEP?$AA@
CONST	SEGMENT
??_C@_0O@JAPECJBK@MAX_MAGIC_WEP?$AA@ DB 'MAX_MAGIC_WEP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PNODGJJO@ATT_MIN?$AA@
CONST	SEGMENT
??_C@_07PNODGJJO@ATT_MIN?$AA@ DB 'ATT_MIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OPGIINPB@ATT_MAX?$AA@
CONST	SEGMENT
??_C@_07OPGIINPB@ATT_MAX?$AA@ DB 'ATT_MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NMFFPMLH@IQ?$AA@
CONST	SEGMENT
??_C@_02NMFFPMLH@IQ?$AA@ DB 'IQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DIGJAPIG@ATT_POWER?$AA@
CONST	SEGMENT
??_C@_09DIGJAPIG@ATT_POWER?$AA@ DB 'ATT_POWER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAGCMF@HT?$AA@
CONST	SEGMENT
??_C@_02KAOAGCMF@HT?$AA@ DB 'HT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FEPNEKN@DX?$AA@
CONST	SEGMENT
??_C@_02FEPNEKN@DX?$AA@ DB 'DX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BIHMGKIG@ELK?$AA@
CONST	SEGMENT
??_C@_03BIHMGKIG@ELK?$AA@ DB 'ELK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LAJDCOFE@ST?$AA@
CONST	SEGMENT
??_C@_02LAJDCOFE@ST?$AA@ DB 'ST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07IHPDJFBP@STAMINA?$AA@
CONST	SEGMENT
??_C@_07IHPDJFBP@STAMINA?$AA@ DB 'STAMINA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CHCGLEDD@MAX_STAMINA?$AA@
CONST	SEGMENT
??_C@_0M@CHCGLEDD@MAX_STAMINA?$AA@ DB 'MAX_STAMINA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEPPOLFA@SP?$AA@
CONST	SEGMENT
??_C@_02NEPPOLFA@SP?$AA@ DB 'SP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MMAHLLLC@MAX_SP?$AA@
CONST	SEGMENT
??_C@_06MMAHLLLC@MAX_SP?$AA@ DB 'MAX_SP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MEIMKHMB@HP?$AA@
CONST	SEGMENT
??_C@_02MEIMKHMB@HP?$AA@ DB 'HP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMHEPHCD@MAX_HP?$AA@
CONST	SEGMENT
??_C@_06NMHEPHCD@MAX_HP?$AA@ DB 'MAX_HP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KKGFKKLA@EXP?$AA@
CONST	SEGMENT
??_C@_03KKGFKKLA@EXP?$AA@ DB 'EXP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHGDMADF@NEXT_EXP?$AA@
CONST	SEGMENT
??_C@_08CHGDMADF@NEXT_EXP?$AA@ DB 'NEXT_EXP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCEPFMCO@LEVEL?$AA@
CONST	SEGMENT
??_C@_05GCEPFMCO@LEVEL?$AA@ DB 'LEVEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHIHOFEA@VOICE?$AA@
CONST	SEGMENT
??_C@_05FHIHOFEA@VOICE?$AA@ DB 'VOICE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PLGNHJMH@SendDragonSoulRefine?$AA@
CONST	SEGMENT
??_C@_0BF@PLGNHJMH@SendDragonSoulRefine?$AA@ DB 'SendDragonSoulRefine', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BALNJMNP@player?$AA@
CONST	SEGMENT
??_C@_06BALNJMNP@player?$AA@ DB 'player', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGFCHEAA@GetItemLink?$AA@
CONST	SEGMENT
??_C@_0M@DGFCHEAA@GetItemLink?$AA@ DB 'GetItemLink', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IOMKCPHN@SlotTypeToInvenType?$AA@
CONST	SEGMENT
??_C@_0BE@IOMKCPHN@SlotTypeToInvenType?$AA@ DB 'SlotTypeToInvenType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KPGENMF@SetItemAttribute?$AA@
CONST	SEGMENT
??_C@_0BB@KPGENMF@SetItemAttribute?$AA@ DB 'SetItemAttribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MABOHHMK@SetItemCount?$AA@
CONST	SEGMENT
??_C@_0N@MABOHHMK@SetItemCount?$AA@ DB 'SetItemCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CHNGAPIB@SetItemData?$AA@
CONST	SEGMENT
??_C@_0M@CHNGAPIB@SetItemData?$AA@ DB 'SetItemData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GLMLJBGM@SetItemMetinSocket?$AA@
CONST	SEGMENT
??_C@_0BD@GLMLJBGM@SetItemMetinSocket?$AA@ DB 'SetItemMetinSocket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DJKKOCLB@ToggleLevelLimit?$AA@
CONST	SEGMENT
??_C@_0BB@DJKKOCLB@ToggleLevelLimit?$AA@ DB 'ToggleLevelLimit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MEKPPHGC@GetTargetVID?$AA@
CONST	SEGMENT
??_C@_0N@MEKPPHGC@GetTargetVID?$AA@ DB 'GetTargetVID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CFCMHNHB@SetWeaponAttackBonusFlag?$AA@
CONST	SEGMENT
??_C@_0BJ@CFCMHNHB@SetWeaponAttackBonusFlag?$AA@ DB 'SetWeaponAttackBonus'
	DB	'Flag', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ILOOLMDH@ToggleCoolTime?$AA@
CONST	SEGMENT
??_C@_0P@ILOOLMDH@ToggleCoolTime?$AA@ DB 'ToggleCoolTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMDABIKP@RegisterEmotionIcon?$AA@
CONST	SEGMENT
??_C@_0BE@PMDABIKP@RegisterEmotionIcon?$AA@ DB 'RegisterEmotionIcon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FELKHKJF@GetEmotionIconImage?$AA@
CONST	SEGMENT
??_C@_0BE@FELKHKJF@GetEmotionIconImage?$AA@ DB 'GetEmotionIconImage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IMMFEEHK@GetPKMode?$AA@
CONST	SEGMENT
??_C@_09IMMFEEHK@GetPKMode?$AA@ DB 'GetPKMode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CLGCEOLO@HasMobilePhoneNumber?$AA@
CONST	SEGMENT
??_C@_0BF@CLGCEOLO@HasMobilePhoneNumber?$AA@ DB 'HasMobilePhoneNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EEFAFMJC@GetPartyMemberAffects?$AA@
CONST	SEGMENT
??_C@_0BG@EEFAFMJC@GetPartyMemberAffects?$AA@ DB 'GetPartyMemberAffects', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DMPBEJCG@ExitParty?$AA@
CONST	SEGMENT
??_C@_09DMPBEJCG@ExitParty?$AA@ DB 'ExitParty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EPAFEFHI@GetPartyMemberHPPercentage?$AA@
CONST	SEGMENT
??_C@_0BL@EPAFEFHI@GetPartyMemberHPPercentage?$AA@ DB 'GetPartyMemberHPPe'
	DB	'rcentage', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HKIJMBKK@GetPartyMemberState?$AA@
CONST	SEGMENT
??_C@_0BE@HKIJMBKK@GetPartyMemberState?$AA@ DB 'GetPartyMemberState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BPMJGNAC@IsPartyLeader?$AA@
CONST	SEGMENT
??_C@_0O@BPMJGNAC@IsPartyLeader?$AA@ DB 'IsPartyLeader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGKJMFNK@IsPartyLeaderByPID?$AA@
CONST	SEGMENT
??_C@_0BD@HGKJMFNK@IsPartyLeaderByPID?$AA@ DB 'IsPartyLeaderByPID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EECGCJDE@SetTarget?$AA@
CONST	SEGMENT
??_C@_09EECGCJDE@SetTarget?$AA@ DB 'SetTarget', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HAEJEFBP@OpenCharacterMenu?$AA@
CONST	SEGMENT
??_C@_0BC@HAEJEFBP@OpenCharacterMenu?$AA@ DB 'OpenCharacterMenu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ELNKJPMC@IsRefineGradeScroll?$AA@
CONST	SEGMENT
??_C@_0BE@ELNKJPMC@IsRefineGradeScroll?$AA@ DB 'IsRefineGradeScroll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DPCEEMCG@ClearTarget?$AA@
CONST	SEGMENT
??_C@_0M@DPCEEMCG@ClearTarget?$AA@ DB 'ClearTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FHINBOHC@CanUnlock?$AA@
CONST	SEGMENT
??_C@_09FHINBOHC@CanUnlock?$AA@ DB 'CanUnlock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BLOGPKFO@CanAttachMetin?$AA@
CONST	SEGMENT
??_C@_0P@BLOGPKFO@CanAttachMetin?$AA@ DB 'CanAttachMetin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGNCJJP@CanRefine?$AA@
CONST	SEGMENT
??_C@_09BGNCJJP@CanRefine?$AA@ DB 'CanRefine', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GHIBIBHI@CanDetach?$AA@
CONST	SEGMENT
??_C@_09GHIBIBHI@CanDetach?$AA@ DB 'CanDetach', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DCFDMADN@IsOpenPrivateShop?$AA@
CONST	SEGMENT
??_C@_0BC@DCFDMADN@IsOpenPrivateShop?$AA@ DB 'IsOpenPrivateShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DGHEMMKN@GetItemGrade?$AA@
CONST	SEGMENT
??_C@_0N@DGHEMMKN@GetItemGrade?$AA@ DB 'GetItemGrade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KCAGNEAI@IsCostumeSlot?$AA@
CONST	SEGMENT
??_C@_0O@KCAGNEAI@IsCostumeSlot?$AA@ DB 'IsCostumeSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LAJFBPPH@IsValuableItem?$AA@
CONST	SEGMENT
??_C@_0P@LAJFBPPH@IsValuableItem?$AA@ DB 'IsValuableItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EMKHGGAL@IsEquipmentSlot?$AA@
CONST	SEGMENT
??_C@_0BA@EMKHGGAL@IsEquipmentSlot?$AA@ DB 'IsEquipmentSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DDCIGDKO@IsDSEquipmentSlot?$AA@
CONST	SEGMENT
??_C@_0BC@DDCIGDKO@IsDSEquipmentSlot?$AA@ DB 'IsDSEquipmentSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JNCIKJMC@RemoveQuickSlotByValue?$AA@
CONST	SEGMENT
??_C@_0BH@JNCIKJMC@RemoveQuickSlotByValue?$AA@ DB 'RemoveQuickSlotByValue'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOPKEHAK@isItem?$AA@
CONST	SEGMENT
??_C@_06NOPKEHAK@isItem?$AA@ DB 'isItem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LNKMMBDG@GetLocalQuickSlot?$AA@
CONST	SEGMENT
??_C@_0BC@LNKMMBDG@GetLocalQuickSlot?$AA@ DB 'GetLocalQuickSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ECGPDHPA@GetGlobalQuickSlot?$AA@
CONST	SEGMENT
??_C@_0BD@ECGPDHPA@GetGlobalQuickSlot?$AA@ DB 'GetGlobalQuickSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NLMPHAJA@GetQuickPage?$AA@
CONST	SEGMENT
??_C@_0N@NLMPHAJA@GetQuickPage?$AA@ DB 'GetQuickPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPHBLMNM@SetQuickPage?$AA@
CONST	SEGMENT
??_C@_0N@KPHBLMNM@SetQuickPage?$AA@ DB 'SetQuickPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IBBGPDPH@RequestUseLocalQuickSlot?$AA@
CONST	SEGMENT
??_C@_0BJ@IBBGPDPH@RequestUseLocalQuickSlot?$AA@ DB 'RequestUseLocalQuick'
	DB	'Slot', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GNGKFIDB@LocalQuickSlotIndexToGlobalQuick@
CONST	SEGMENT
??_C@_0CK@GNGKFIDB@LocalQuickSlotIndexToGlobalQuick@ DB 'LocalQuickSlotIn'
	DB	'dexToGlobalQuickSlotIndex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NACLJDMA@RequestDeleteGlobalQuickSlot?$AA@
CONST	SEGMENT
??_C@_0BN@NACLJDMA@RequestDeleteGlobalQuickSlot?$AA@ DB 'RequestDeleteGlo'
	DB	'balQuickSlot', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IEMBKGLN@RequestMoveGlobalQuickSlotToLoca@
CONST	SEGMENT
??_C@_0CL@IEMBKGLN@RequestMoveGlobalQuickSlotToLoca@ DB 'RequestMoveGloba'
	DB	'lQuickSlotToLocalQuickSlot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DNLGAMEO@RequestAddLocalQuickSlot?$AA@
CONST	SEGMENT
??_C@_0BJ@DNLGAMEO@RequestAddLocalQuickSlot?$AA@ DB 'RequestAddLocalQuick'
	DB	'Slot', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JMFCJJPL@RequestAddToEmptyLocalQuickSlot?$AA@
CONST	SEGMENT
??_C@_0CA@JMFCJJPL@RequestAddToEmptyLocalQuickSlot?$AA@ DB 'RequestAddToE'
	DB	'mptyLocalQuickSlot', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OAJFGNBC@GetMoney?$AA@
CONST	SEGMENT
??_C@_08OAJFGNBC@GetMoney?$AA@ DB 'GetMoney', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LANDCIKG@GetAlignmentData?$AA@
CONST	SEGMENT
??_C@_0BB@LANDCIKG@GetAlignmentData?$AA@ DB 'GetAlignmentData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OEBBKEAG@SetStatus?$AA@
CONST	SEGMENT
??_C@_09OEBBKEAG@SetStatus?$AA@ DB 'SetStatus', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMFKJLLH@GetElk?$AA@
CONST	SEGMENT
??_C@_06NMFKJLLH@GetElk?$AA@ DB 'GetElk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDIKDJMD@GetEXP?$AA@
CONST	SEGMENT
??_C@_06MDIKDJMD@GetEXP?$AA@ DB 'GetEXP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MKFEIFJE@GetStatus?$AA@
CONST	SEGMENT
??_C@_09MKFEIFJE@GetStatus?$AA@ DB 'GetStatus', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HHBOBCLE@UseGuildSkill?$AA@
CONST	SEGMENT
??_C@_0O@HHBOBCLE@UseGuildSkill?$AA@ DB 'UseGuildSkill', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JIGEMOFF@AffectIndexToSkillIndex?$AA@
CONST	SEGMENT
??_C@_0BI@JIGEMOFF@AffectIndexToSkillIndex?$AA@ DB 'AffectIndexToSkillInd'
	DB	'ex', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CNGGKNGL@GetSkillCoolTime?$AA@
CONST	SEGMENT
??_C@_0BB@CNGGKNGL@GetSkillCoolTime?$AA@ DB 'GetSkillCoolTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IAPCJJAC@IsSkillActive?$AA@
CONST	SEGMENT
??_C@_0O@IAPCJJAC@IsSkillActive?$AA@ DB 'IsSkillActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGCMFHDN@SetPlayTime?$AA@
CONST	SEGMENT
??_C@_0M@DGCMFHDN@SetPlayTime?$AA@ DB 'SetPlayTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOPKKJJD@IsSkillCoolTime?$AA@
CONST	SEGMENT
??_C@_0BA@FOPKKJJD@IsSkillCoolTime?$AA@ DB 'IsSkillCoolTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHLNIOPB@GetJob?$AA@
CONST	SEGMENT
??_C@_06FHLNIOPB@GetJob?$AA@ DB 'GetJob', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DJDCIBLO@GetPlayTime?$AA@
CONST	SEGMENT
??_C@_0M@DJDCIBLO@GetPlayTime?$AA@ DB 'GetPlayTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHJANHDM@MoveItem?$AA@
CONST	SEGMENT
??_C@_08MHJANHDM@MoveItem?$AA@ DB 'MoveItem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DBIFLBAC@SendClickItemPacket?$AA@
CONST	SEGMENT
??_C@_0BE@DBIFLBAC@SendClickItemPacket?$AA@ DB 'SendClickItemPacket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JBOBKHIE@GetItemMetinSocket?$AA@
CONST	SEGMENT
??_C@_0BD@JBOBKHIE@GetItemMetinSocket?$AA@ DB 'GetItemMetinSocket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GOKPPDHH@GetItemAttribute?$AA@
CONST	SEGMENT
??_C@_0BB@GOKPPDHH@GetItemAttribute?$AA@ DB 'GetItemAttribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEKALLIG@GetItemCount?$AA@
CONST	SEGMENT
??_C@_0N@LEKALLIG@GetItemCount?$AA@ DB 'GetItemCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBLILMFK@GetItemCountByVnum?$AA@
CONST	SEGMENT
??_C@_0BD@DBLILMFK@GetItemCountByVnum?$AA@ DB 'GetItemCountByVnum', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GABOCBEH@GetItemIndex?$AA@
CONST	SEGMENT
??_C@_0N@GABOCBEH@GetItemIndex?$AA@ DB 'GetItemIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DMCGDNGF@GetItemFlags?$AA@
CONST	SEGMENT
??_C@_0N@DMCGDNGF@GetItemFlags?$AA@ DB 'GetItemFlags', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BPJDEKED@ChangeCurrentSkillNumberOnly?$AA@
CONST	SEGMENT
??_C@_0BN@BPJDEKED@ChangeCurrentSkillNumberOnly?$AA@ DB 'ChangeCurrentSki'
	DB	'llNumberOnly', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MJOJKOJJ@ClearSkillDict?$AA@
CONST	SEGMENT
??_C@_0P@MJOJKOJJ@ClearSkillDict?$AA@ DB 'ClearSkillDict', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JHGONPGM@GetSkillNextEfficientPercentage?$AA@
CONST	SEGMENT
??_C@_0CA@JHGONPGM@GetSkillNextEfficientPercentage?$AA@ DB 'GetSkillNextE'
	DB	'fficientPercentage', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IGNHDBHH@ClickSkillSlot?$AA@
CONST	SEGMENT
??_C@_0P@IGNHDBHH@ClickSkillSlot?$AA@ DB 'ClickSkillSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IIOIANPE@GetSkillGrade?$AA@
CONST	SEGMENT
??_C@_0O@IIOIANPE@GetSkillGrade?$AA@ DB 'GetSkillGrade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EFGGIKHI@GetSkillCurrentEfficientPercenta@
CONST	SEGMENT
??_C@_0CD@EFGGIKHI@GetSkillCurrentEfficientPercenta@ DB 'GetSkillCurrentE'
	DB	'fficientPercentage', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HIFGFOGG@SetSkill?$AA@
CONST	SEGMENT
??_C@_08HIFGFOGG@SetSkill?$AA@ DB 'SetSkill', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HNJMANI@GetSkillSlotIndex?$AA@
CONST	SEGMENT
??_C@_0BC@HNJMANI@GetSkillSlotIndex?$AA@ DB 'GetSkillSlotIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MCFGJOPA@ResetCameraRotation?$AA@
CONST	SEGMENT
??_C@_0BE@MCFGJOPA@ResetCameraRotation?$AA@ DB 'ResetCameraRotation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DPHLFGPP@SetQuickCameraMode?$AA@
CONST	SEGMENT
??_C@_0BD@DPHLFGPP@SetQuickCameraMode?$AA@ DB 'SetQuickCameraMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NCHFPCDM@StartMouseWalking?$AA@
CONST	SEGMENT
??_C@_0BC@NCHFPCDM@StartMouseWalking?$AA@ DB 'StartMouseWalking', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JEOKFDLP@EndMouseWalking?$AA@
CONST	SEGMENT
??_C@_0BA@JEOKFDLP@EndMouseWalking?$AA@ DB 'EndMouseWalking', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PNJNANBI@SetSingleDIKKeyState?$AA@
CONST	SEGMENT
??_C@_0BF@PNJNANBI@SetSingleDIKKeyState?$AA@ DB 'SetSingleDIKKeyState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HGLJKHIH@EndKeyWalkingImmediately?$AA@
CONST	SEGMENT
??_C@_0BJ@HGLJKHIH@EndKeyWalkingImmediately?$AA@ DB 'EndKeyWalkingImmedia'
	DB	'tely', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IEKDAKHC@SetAutoCameraRotationSpeed?$AA@
CONST	SEGMENT
??_C@_0BL@IEKDAKHC@SetAutoCameraRotationSpeed?$AA@ DB 'SetAutoCameraRotat'
	DB	'ionSpeed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DAIEHFBH@SetAttackKeyState?$AA@
CONST	SEGMENT
??_C@_0BC@DAIEHFBH@SetAttackKeyState?$AA@ DB 'SetAttackKeyState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PBBGGCLG@HidePlayer?$AA@
CONST	SEGMENT
??_C@_0L@PBBGGCLG@HidePlayer?$AA@ DB 'HidePlayer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOCDIKPN@ComboAttack?$AA@
CONST	SEGMENT
??_C@_0M@GOCDIKPN@ComboAttack?$AA@ DB 'ComboAttack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JEBGMNAH@ActEmotion?$AA@
CONST	SEGMENT
??_C@_0L@JEBGMNAH@ActEmotion?$AA@ DB 'ActEmotion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CPMIOCIM@ShowPlayer?$AA@
CONST	SEGMENT
??_C@_0L@CPMIOCIM@ShowPlayer?$AA@ DB 'ShowPlayer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GFJLKENO@IsMountingHorse?$AA@
CONST	SEGMENT
??_C@_0BA@GFJLKENO@IsMountingHorse?$AA@ DB 'IsMountingHorse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LDENHACE@IsObserverMode?$AA@
CONST	SEGMENT
??_C@_0P@LDENHACE@IsObserverMode?$AA@ DB 'IsObserverMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DABJOKIF@GetCharacterDistance?$AA@
CONST	SEGMENT
??_C@_0BF@DABJOKIF@GetCharacterDistance?$AA@ DB 'GetCharacterDistance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IKPCBCPA@IsInSafeArea?$AA@
CONST	SEGMENT
??_C@_0N@IKPCBCPA@IsInSafeArea?$AA@ DB 'IsInSafeArea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IKOEAPGC@IsRevengeInstance?$AA@
CONST	SEGMENT
??_C@_0BC@IKOEAPGC@IsRevengeInstance?$AA@ DB 'IsRevengeInstance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HJOMPGKI@IsCantFightInstance?$AA@
CONST	SEGMENT
??_C@_0BE@HJOMPGKI@IsCantFightInstance?$AA@ DB 'IsCantFightInstance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CBEDFALN@IsSameEmpire?$AA@
CONST	SEGMENT
??_C@_0N@CBEDFALN@IsSameEmpire?$AA@ DB 'IsSameEmpire', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FOIPHJLO@IsChallengeInstance?$AA@
CONST	SEGMENT
??_C@_0BE@FOIPHJLO@IsChallengeInstance?$AA@ DB 'IsChallengeInstance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ODCBPOEF@IsActingEmotion?$AA@
CONST	SEGMENT
??_C@_0BA@ODCBPOEF@IsActingEmotion?$AA@ DB 'IsActingEmotion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ECCODAC@IsPVPInstance?$AA@
CONST	SEGMENT
??_C@_0O@ECCODAC@IsPVPInstance?$AA@ DB 'IsPVPInstance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GALHNOAL@IsMainCharacterIndex?$AA@
CONST	SEGMENT
??_C@_0BF@GALHNOAL@IsMainCharacterIndex?$AA@ DB 'IsMainCharacterIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FLPEGJDD@CanAttackInstance?$AA@
CONST	SEGMENT
??_C@_0BC@FLPEGJDD@CanAttackInstance?$AA@ DB 'CanAttackInstance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OMDPKDFM@GetMainCharacterName?$AA@
CONST	SEGMENT
??_C@_0BF@OMDPKDFM@GetMainCharacterName?$AA@ DB 'GetMainCharacterName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GIKFEPMH@GetMainCharacterPosition?$AA@
CONST	SEGMENT
??_C@_0BJ@GIKFEPMH@GetMainCharacterPosition?$AA@ DB 'GetMainCharacterPosi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JCNMOACA@SetMainCharacterIndex?$AA@
CONST	SEGMENT
??_C@_0BG@JCNMOACA@SetMainCharacterIndex?$AA@ DB 'SetMainCharacterIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GHIKDJGB@GetMainCharacterIndex?$AA@
CONST	SEGMENT
??_C@_0BG@GHIKDJGB@GetMainCharacterIndex?$AA@ DB 'GetMainCharacterIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MACDDOCA@GetMouseFunc?$AA@
CONST	SEGMENT
??_C@_0N@MACDDOCA@GetMouseFunc?$AA@ DB 'GetMouseFunc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JBJLNCBH@SetMouseMiddleButtonState?$AA@
CONST	SEGMENT
??_C@_0BK@JBJLNCBH@SetMouseMiddleButtonState?$AA@ DB 'SetMouseMiddleButto'
	DB	'nState', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HDELDAFI@SetMouseState?$AA@
CONST	SEGMENT
??_C@_0O@HDELDAFI@SetMouseState?$AA@ DB 'SetMouseState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEJNPCGM@SetMouseFunc?$AA@
CONST	SEGMENT
??_C@_0N@LEJNPCGM@SetMouseFunc?$AA@ DB 'SetMouseFunc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MAEJALBO@PickCloseItem?$AA@
CONST	SEGMENT
??_C@_0O@MAEJALBO@PickCloseItem?$AA@ DB 'PickCloseItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MNPFFDEJ@SetGameWindow?$AA@
CONST	SEGMENT
??_C@_0O@MNPFFDEJ@SetGameWindow?$AA@ DB 'SetGameWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CHIABFDI@GetAutoPotionInfo?$AA@
CONST	SEGMENT
??_C@_0BC@CHIABFDI@GetAutoPotionInfo?$AA@ DB 'GetAutoPotionInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CILJOCG@SetAutoPotionInfo?$AA@
CONST	SEGMENT
??_C@_0BC@CILJOCG@SetAutoPotionInfo?$AA@ DB 'SetAutoPotionInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFJJEBFG@iiiiiii?$AA@
CONST	SEGMENT
??_C@_07EFJJEBFG@iiiiiii?$AA@ DB 'iiiiiii', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPDILEAH@biii?$AA@
CONST	SEGMENT
??_C@_04GPDILEAH@biii?$AA@ DB 'biii', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BGKCJNBK@Can?8t?5find?5item?5data?$AA@
CONST	SEGMENT
??_C@_0BF@BGKCJNBK@Can?8t?5find?5item?5data?$AA@ DB 'Can''t find item dat'
	DB	'a', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IBGKLIMC@can?8t?5find?5item?5data?$AA@
CONST	SEGMENT
??_C@_0BF@IBGKLIMC@can?8t?5find?5item?5data?$AA@ DB 'can''t find item dat'
	DB	'a', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MCOKCAKI@?5?$HMh?$HMr?$FL?$CFs?$FN?$HMcffffc700?$HMH?$CFs?$HMh?$AA@
CONST	SEGMENT
??_C@_0BK@MCOKCAKI@?5?$HMh?$HMr?$FL?$CFs?$FN?$HMcffffc700?$HMH?$CFs?$HMh?$AA@ DB ' '
	DB	'|h|r[%s]|cffffc700|H%s|h', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MGKBEPOF@?5?$HMh?$HMr?$FL?$CFs?$FN?$HMcfff1e6c0?$HMH?$CFs?$HMh?$AA@
CONST	SEGMENT
??_C@_0BK@MGKBEPOF@?5?$HMh?$HMr?$FL?$CFs?$FN?$HMcfff1e6c0?$HMH?$CFs?$HMh?$AA@ DB ' '
	DB	'|h|r[%s]|cfff1e6c0|H%s|h', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HPEDFNFO@ff?$AA@
CONST	SEGMENT
??_C@_02HPEDFNFO@ff?$AA@ DB 'ff', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HHGOMJKL@l?$AA@
CONST	SEGMENT
??_C@_01HHGOMJKL@l?$AA@ DB 'l', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@BNKMOLIP@playerSetSingleDIKKeyState?$CIeDIK?0@
CONST	SEGMENT
??_C@_0EJ@BNKMOLIP@playerSetSingleDIKKeyState?$CIeDIK?0@ DB 'playerSetSin'
	DB	'gleDIKKeyState(eDIK, isPressed) - There is no first argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@IDBGKDBN@playerSetSingleDIKKeyState?$CIeDIK?0@
CONST	SEGMENT
??_C@_0EK@IDBGKDBN@playerSetSingleDIKKeyState?$CIeDIK?0@ DB 'playerSetSin'
	DB	'gleDIKKeyState(eDIK, isPressed) - There is no second argument'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@ILFGGFEI@CPythonPlayer?3?3RegisterEffect?$CIeE@
CONST	SEGMENT
??_C@_0DF@ILFGGFEI@CPythonPlayer?3?3RegisterEffect?$CIeE@ DB 'CPythonPlay'
	DB	'er::RegisterEffect(eEft=%d, szFileName=%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OHLDKNFC@playerSetAttackKeyState?$CIisPresse@
CONST	SEGMENT
??_C@_0EA@OHLDKNFC@playerSetAttackKeyState?$CIisPresse@ DB 'playerSetAtta'
	DB	'ckKeyState(isPressed) - There is no first argument', 00H ; `string'
?c_iSkillIndex_Riding@@3KB DD 082H			; c_iSkillIndex_Riding
?c_iSkillIndex_Summon@@3KB DD 083H			; c_iSkillIndex_Summon
?c_iSkillIndex_Combo@@3KB DD 07aH			; c_iSkillIndex_Combo
?c_iSkillIndex_Fishing@@3KB DD 07bH			; c_iSkillIndex_Fishing
PUBLIC	??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z	; std::get<0,int const &>
PUBLIC	??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::move<std::tuple<int const &> &>
PUBLIC	??$?0V?$tuple@ABH@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><std::tuple<int const &>,std::tuple<>,0>
PUBLIC	??$forward@PAVCGraphicImage@@@std@@YA$$QAPAVCGraphicImage@@AAPAV1@@Z ; std::forward<CGraphicImage *>
PUBLIC	?_Get_rest@?$tuple@ABH@std@@QAEAAV?$tuple@$$$V@2@XZ ; std::tuple<int const &>::_Get_rest
PUBLIC	??$?0ABH$$$V@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$$V@1@@Z ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><int const &>
PUBLIC	??$?0ABHPAPAX@?$tuple@ABH@std@@QAE@$$QAV01@@Z	; std::tuple<int const &>::tuple<int const &><int const &,void * *>
PUBLIC	??$?0HPAVCGraphicImage@@X@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><int,CGraphicImage *,void>
PUBLIC	??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >
PUBLIC	??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > >
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PAU21@AAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Buynode_if_nil<std::pair<int const ,CGraphicImage *> &>
PUBLIC	??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::max_size
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::destroy<std::pair<int const ,CGraphicImage *> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
PUBLIC	??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > &,bool,void>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool,void>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@YAAAU?$pair@$$CBHPAVCGraphicImage@@@0@AAU10@@Z ; std::forward<std::pair<int const ,CGraphicImage *> &>
PUBLIC	??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator--
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator--
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator--
PUBLIC	?_Freenode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Freenode0
PUBLIC	?_Buynode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode0
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Destroy_if_not_nil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::size
PUBLIC	??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z	; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::pair<int const ,CGraphicImage *> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_hint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::forward<std::tuple<int const &> >
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_nohint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
PUBLIC	??$_Buynode@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::pair<int,CGraphicImage *> >
PUBLIC	??$forward@U?$pair@HPAVCGraphicImage@@@std@@@std@@YA$$QAU?$pair@HPAVCGraphicImage@@@0@AAU10@@Z ; std::forward<std::pair<int,CGraphicImage *> >
PUBLIC	??$?0AAHAAPAVCGraphicImage@@X@?$pair@HPAVCGraphicImage@@@std@@QAE@AAHAAPAVCGraphicImage@@@Z ; std::pair<int,CGraphicImage *>::pair<int,CGraphicImage *><int &,CGraphicImage * &,void>
PUBLIC	??$forward@AAPAVCGraphicImage@@@std@@YAAAPAVCGraphicImage@@AAPAV1@@Z ; std::forward<CGraphicImage * &>
PUBLIC	??0?$tuple@ABH@std@@QAE@ABH@Z			; std::tuple<int const &>::tuple<int const &>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::pair<int const ,CGraphicImage *> >
PUBLIC	??$addressof@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@YAPAU?$pair@$$CBHPAVCGraphicImage@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,CGraphicImage *> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
PUBLIC	??$_Kfn@$$CBHPAVCGraphicImage@@@?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ; std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0>::_Kfn<int const ,CGraphicImage *>
PUBLIC	??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z ; std::forward_as_tuple<int const &>
PUBLIC	??$insert@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::insert<std::pair<int,CGraphicImage *> >
PUBLIC	??$make_pair@AAHAAPAVCGraphicImage@@@std@@YA?AU?$pair@HPAVCGraphicImage@@@0@AAHAAPAVCGraphicImage@@@Z ; std::make_pair<int &,CGraphicImage * &>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::allocate
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator++
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator++
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Min
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Max
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Color
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lrotate
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Erase
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator!=
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator++
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAVCGraphicImage@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator*
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Right
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Parent
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Left
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Isnil
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::deallocate
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Root
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lmost
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::clear
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@SAPAU?$pair@$$CBHPAVCGraphicImage@@@2@AAU32@@Z ; std::pointer_traits<std::pair<int const ,CGraphicImage *> *>::pointer_to
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAVCGraphicImage@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator*
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAU?$pair@$$CBHPAVCGraphicImage@@@2@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Myval
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Freeheadnode
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHPAVCGraphicImage@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Kfn
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lbound
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::begin
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAVCGraphicImage@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator->
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,CGraphicImage *> >::allocator<std::pair<int const ,CGraphicImage *> >
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Getcomp
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Key
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tidy
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::lower_bound
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::~_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::~_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator==
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::find
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::end
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::~_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >
PUBLIC	??A?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAEAAPAVCGraphicImage@@ABH@Z ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::operator[]
PUBLIC	??0?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAE@XZ ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >
PUBLIC	?InstancePtr@?$CSingleton@VCPythonPlayer@@@@SAPAVCPythonPlayer@@XZ ; CSingleton<CPythonPlayer>::InstancePtr
PUBLIC	?initPlayer@@YAXXZ				; initPlayer
PUBLIC	?playerSendDragonSoulRefine@@YAPAU_object@@PAU1@0@Z ; playerSendDragonSoulRefine
PUBLIC	?playerSlotTypeToInvenType@@YAPAU_object@@PAU1@0@Z ; playerSlotTypeToInvenType
PUBLIC	?playerGetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z ; playerGetAutoPotionInfo
PUBLIC	?playerSetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z ; playerSetAutoPotionInfo
PUBLIC	?playerSetItemAttribute@@YAPAU_object@@PAU1@0@Z	; playerSetItemAttribute
PUBLIC	?playerSetItemMetinSocket@@YAPAU_object@@PAU1@0@Z ; playerSetItemMetinSocket
PUBLIC	?playerSetItemData@@YAPAU_object@@PAU1@0@Z	; playerSetItemData
PUBLIC	?playerGetEmotionIconImage@@YAPAU_object@@PAU1@0@Z ; playerGetEmotionIconImage
PUBLIC	?playerRegisterEmotionIcon@@YAPAU_object@@PAU1@0@Z ; playerRegisterEmotionIcon
PUBLIC	?playerGetTargetVID@@YAPAU_object@@PAU1@0@Z	; playerGetTargetVID
PUBLIC	?playerToggleLevelLimit@@YAPAU_object@@PAU1@0@Z	; playerToggleLevelLimit
PUBLIC	?playerToggleCoolTime@@YAPAU_object@@PAU1@0@Z	; playerToggleCoolTime
PUBLIC	?playerSetWeaponAttackBonusFlag@@YAPAU_object@@PAU1@0@Z ; playerSetWeaponAttackBonusFlag
PUBLIC	?playerHasMobilePhoneNumber@@YAPAU_object@@PAU1@0@Z ; playerHasMobilePhoneNumber
PUBLIC	?playerGetPKMode@@YAPAU_object@@PAU1@0@Z	; playerGetPKMode
PUBLIC	?playerExitParty@@YAPAU_object@@PAU1@0@Z	; playerExitParty
PUBLIC	?playerRemovePartyMember@@YAPAU_object@@PAU1@0@Z ; playerRemovePartyMember
PUBLIC	?playerGetPartyMemberAffects@@YAPAU_object@@PAU1@0@Z ; playerGetPartyMemberAffects
PUBLIC	?playerGetPartyMemberState@@YAPAU_object@@PAU1@0@Z ; playerGetPartyMemberState
PUBLIC	?playerGetPartyMemberHPPercentage@@YAPAU_object@@PAU1@0@Z ; playerGetPartyMemberHPPercentage
PUBLIC	?playerIsPartyLeaderByPID@@YAPAU_object@@PAU1@0@Z ; playerIsPartyLeaderByPID
PUBLIC	?playerIsPartyLeader@@YAPAU_object@@PAU1@0@Z	; playerIsPartyLeader
PUBLIC	?playerIsPartyMember@@YAPAU_object@@PAU1@0@Z	; playerIsPartyMember
PUBLIC	?playerOpenCharacterMenu@@YAPAU_object@@PAU1@0@Z ; playerOpenCharacterMenu
PUBLIC	?playerSetTarget@@YAPAU_object@@PAU1@0@Z	; playerSetTarget
PUBLIC	?playerClearTarget@@YAPAU_object@@PAU1@0@Z	; playerClearTarget
PUBLIC	?playerClear@@YAPAU_object@@PAU1@0@Z		; playerClear
PUBLIC	?playerRender@@YAPAU_object@@PAU1@0@Z		; playerRender
PUBLIC	?playerUpdate@@YAPAU_object@@PAU1@0@Z		; playerUpdate
PUBLIC	?playerIsRefineGradeScroll@@YAPAU_object@@PAU1@0@Z ; playerIsRefineGradeScroll
PUBLIC	?playerCanUnlock@@YAPAU_object@@PAU1@0@Z	; playerCanUnlock
PUBLIC	?playerCanDetach@@YAPAU_object@@PAU1@0@Z	; playerCanDetach
PUBLIC	?playerCanAttachMetin@@YAPAU_object@@PAU1@0@Z	; playerCanAttachMetin
PUBLIC	?playerCanRefine@@YAPAU_object@@PAU1@0@Z	; playerCanRefine
PUBLIC	?playerGetItemGrade@@YAPAU_object@@PAU1@0@Z	; playerGetItemGrade
PUBLIC	?GetItemGrade@@YAHPBD@Z				; GetItemGrade
PUBLIC	?playerIsValuableItem@@YAPAU_object@@PAU1@0@Z	; playerIsValuableItem
PUBLIC	?playerIsOpenPrivateShop@@YAPAU_object@@PAU1@0@Z ; playerIsOpenPrivateShop
PUBLIC	?playerIsCostumeSlot@@YAPAU_object@@PAU1@0@Z	; playerIsCostumeSlot
PUBLIC	?playerIsDSEquipmentSlot@@YAPAU_object@@PAU1@0@Z ; playerIsDSEquipmentSlot
PUBLIC	?playerIsEquipmentSlot@@YAPAU_object@@PAU1@0@Z	; playerIsEquipmentSlot
PUBLIC	?playerisItem@@YAPAU_object@@PAU1@0@Z		; playerisItem
PUBLIC	?playerRemoveQuickSlotByValue@@YAPAU_object@@PAU1@0@Z ; playerRemoveQuickSlotByValue
PUBLIC	?playerRequestUseLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ; playerRequestUseLocalQuickSlot
PUBLIC	?playerRequestMoveGlobalQuickSlotToLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ; playerRequestMoveGlobalQuickSlotToLocalQuickSlot
PUBLIC	?playerRequestDeleteGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z ; playerRequestDeleteGlobalQuickSlot
PUBLIC	?playerRequestAddToEmptyLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ; playerRequestAddToEmptyLocalQuickSlot
PUBLIC	?playerRequestAddLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ; playerRequestAddLocalQuickSlot
PUBLIC	?playerGetGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z ; playerGetGlobalQuickSlot
PUBLIC	?playerGetLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ; playerGetLocalQuickSlot
PUBLIC	?playerLocalQuickSlotIndexToGlobalQuickSlotIndex@@YAPAU_object@@PAU1@0@Z ; playerLocalQuickSlotIndexToGlobalQuickSlotIndex
PUBLIC	?playerSetQuickPage@@YAPAU_object@@PAU1@0@Z	; playerSetQuickPage
PUBLIC	?playerGetQuickPage@@YAPAU_object@@PAU1@0@Z	; playerGetQuickPage
PUBLIC	?playerGetISellItemPrice@@YAPAU_object@@PAU1@0@Z ; playerGetISellItemPrice
PUBLIC	?playerGetItemLink@@YAPAU_object@@PAU1@0@Z	; playerGetItemLink
PUBLIC	?playerGetItemAttribute@@YAPAU_object@@PAU1@0@Z	; playerGetItemAttribute
PUBLIC	?playerGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z ; playerGetItemMetinSocket
PUBLIC	?playerGetItemCountByVnum@@YAPAU_object@@PAU1@0@Z ; playerGetItemCountByVnum
PUBLIC	?playerSetItemCount@@YAPAU_object@@PAU1@0@Z	; playerSetItemCount
PUBLIC	?playerGetItemCount@@YAPAU_object@@PAU1@0@Z	; playerGetItemCount
PUBLIC	?playerGetItemFlags@@YAPAU_object@@PAU1@0@Z	; playerGetItemFlags
PUBLIC	?playerGetItemIndex@@YAPAU_object@@PAU1@0@Z	; playerGetItemIndex
PUBLIC	?playerSendClickItemPacket@@YAPAU_object@@PAU1@0@Z ; playerSendClickItemPacket
PUBLIC	?playerMoveItem@@YAPAU_object@@PAU1@0@Z		; playerMoveItem
PUBLIC	?playerClearSkillDict@@YAPAU_object@@PAU1@0@Z	; playerClearSkillDict
PUBLIC	?playerChangeCurrentSkillNumberOnly@@YAPAU_object@@PAU1@0@Z ; playerChangeCurrentSkillNumberOnly
PUBLIC	?playerClickSkillSlot@@YAPAU_object@@PAU1@0@Z	; playerClickSkillSlot
PUBLIC	?playerGetSkillNextEfficientPercentage@@YAPAU_object@@PAU1@0@Z ; playerGetSkillNextEfficientPercentage
PUBLIC	?playerGetSkillCurrentEfficientPercentage@@YAPAU_object@@PAU1@0@Z ; playerGetSkillCurrentEfficientPercentage
PUBLIC	?playerGetSkillLevel@@YAPAU_object@@PAU1@0@Z	; playerGetSkillLevel
PUBLIC	?playerGetSkillGrade@@YAPAU_object@@PAU1@0@Z	; playerGetSkillGrade
PUBLIC	?playerGetSkillSlotIndex@@YAPAU_object@@PAU1@0@Z ; playerGetSkillSlotIndex
PUBLIC	?playerGetSkillIndex@@YAPAU_object@@PAU1@0@Z	; playerGetSkillIndex
PUBLIC	?playerSetSkill@@YAPAU_object@@PAU1@0@Z		; playerSetSkill
PUBLIC	?playerGetAlignmentData@@YAPAU_object@@PAU1@0@Z	; playerGetAlignmentData
PUBLIC	?playerGetGuildName@@YAPAU_object@@PAU1@0@Z	; playerGetGuildName
PUBLIC	?playerGetGuildID@@YAPAU_object@@PAU1@0@Z	; playerGetGuildID
PUBLIC	?playerGetElk@@YAPAU_object@@PAU1@0@Z		; playerGetElk
PUBLIC	?playerSetStatus@@YAPAU_object@@PAU1@0@Z	; playerSetStatus
PUBLIC	?playerGetStatus@@YAPAU_object@@PAU1@0@Z	; playerGetStatus
PUBLIC	?playerGetEXP@@YAPAU_object@@PAU1@0@Z		; playerGetEXP
PUBLIC	?playerAffectIndexToSkillIndex@@YAPAU_object@@PAU1@0@Z ; playerAffectIndexToSkillIndex
PUBLIC	?playerUseGuildSkill@@YAPAU_object@@PAU1@0@Z	; playerUseGuildSkill
PUBLIC	?playerIsSkillActive@@YAPAU_object@@PAU1@0@Z	; playerIsSkillActive
PUBLIC	?playerGetSkillCoolTime@@YAPAU_object@@PAU1@0@Z	; playerGetSkillCoolTime
PUBLIC	?playerIsSkillCoolTime@@YAPAU_object@@PAU1@0@Z	; playerIsSkillCoolTime
PUBLIC	?playerSetPlayTime@@YAPAU_object@@PAU1@0@Z	; playerSetPlayTime
PUBLIC	?playerGetPlayTime@@YAPAU_object@@PAU1@0@Z	; playerGetPlayTime
PUBLIC	?playerGetJob@@YAPAU_object@@PAU1@0@Z		; playerGetJob
PUBLIC	?playerGetRace@@YAPAU_object@@PAU1@0@Z		; playerGetRace
PUBLIC	?playerGetName@@YAPAU_object@@PAU1@0@Z		; playerGetName
PUBLIC	?playerSetMouseMiddleButtonState@@YAPAU_object@@PAU1@0@Z ; playerSetMouseMiddleButtonState
PUBLIC	?playerGetMouseFunc@@YAPAU_object@@PAU1@0@Z	; playerGetMouseFunc
PUBLIC	?playerSetMouseFunc@@YAPAU_object@@PAU1@0@Z	; playerSetMouseFunc
PUBLIC	?playerSetMouseState@@YAPAU_object@@PAU1@0@Z	; playerSetMouseState
PUBLIC	?playerSetAutoCameraRotationSpeed@@YAPAU_object@@PAU1@0@Z ; playerSetAutoCameraRotationSpeed
PUBLIC	?playerResetCameraRotation@@YAPAU_object@@PAU1@0@Z ; playerResetCameraRotation
PUBLIC	?playerEndMouseWalking@@YAPAU_object@@PAU1@0@Z	; playerEndMouseWalking
PUBLIC	?playerStartMouseWalking@@YAPAU_object@@PAU1@0@Z ; playerStartMouseWalking
PUBLIC	?playerEndKeyWalkingImmediately@@YAPAU_object@@PAU1@0@Z ; playerEndKeyWalkingImmediately
PUBLIC	?playerSetSingleDIKKeyState@@YAPAU_object@@PAU1@0@Z ; playerSetSingleDIKKeyState
PUBLIC	?playerSetAttackKeyState@@YAPAU_object@@PAU1@0@Z ; playerSetAttackKeyState
PUBLIC	?playerRegisterCacheEffect@@YAPAU_object@@PAU1@0@Z ; playerRegisterCacheEffect
PUBLIC	?playerRegisterEffect@@YAPAU_object@@PAU1@0@Z	; playerRegisterEffect
PUBLIC	?playerComboAttack@@YAPAU_object@@PAU1@0@Z	; playerComboAttack
PUBLIC	?playerHidePlayer@@YAPAU_object@@PAU1@0@Z	; playerHidePlayer
PUBLIC	?playerShowPlayer@@YAPAU_object@@PAU1@0@Z	; playerShowPlayer
PUBLIC	?playerActEmotion@@YAPAU_object@@PAU1@0@Z	; playerActEmotion
PUBLIC	?playerIsObserverMode@@YAPAU_object@@PAU1@0@Z	; playerIsObserverMode
PUBLIC	?playerIsMountingHorse@@YAPAU_object@@PAU1@0@Z	; playerIsMountingHorse
PUBLIC	?playerIsInSafeArea@@YAPAU_object@@PAU1@0@Z	; playerIsInSafeArea
PUBLIC	?playerGetCharacterDistance@@YAPAU_object@@PAU1@0@Z ; playerGetCharacterDistance
PUBLIC	?playerIsCantFightInstance@@YAPAU_object@@PAU1@0@Z ; playerIsCantFightInstance
PUBLIC	?playerIsRevengeInstance@@YAPAU_object@@PAU1@0@Z ; playerIsRevengeInstance
PUBLIC	?playerIsChallengeInstance@@YAPAU_object@@PAU1@0@Z ; playerIsChallengeInstance
PUBLIC	?playerIsSameEmpire@@YAPAU_object@@PAU1@0@Z	; playerIsSameEmpire
PUBLIC	?playerIsPVPInstance@@YAPAU_object@@PAU1@0@Z	; playerIsPVPInstance
PUBLIC	?playerIsActingEmotion@@YAPAU_object@@PAU1@0@Z	; playerIsActingEmotion
PUBLIC	?playerCanAttackInstance@@YAPAU_object@@PAU1@0@Z ; playerCanAttackInstance
PUBLIC	?playerIsMainCharacterIndex@@YAPAU_object@@PAU1@0@Z ; playerIsMainCharacterIndex
PUBLIC	?playerGetMainCharacterPosition@@YAPAU_object@@PAU1@0@Z ; playerGetMainCharacterPosition
PUBLIC	?playerGetMainCharacterName@@YAPAU_object@@PAU1@0@Z ; playerGetMainCharacterName
PUBLIC	?playerGetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z ; playerGetMainCharacterIndex
PUBLIC	?playerSetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z ; playerSetMainCharacterIndex
PUBLIC	?playerSetQuickCameraMode@@YAPAU_object@@PAU1@0@Z ; playerSetQuickCameraMode
PUBLIC	?playerSetGameWindow@@YAPAU_object@@PAU1@0@Z	; playerSetGameWindow
PUBLIC	?playerPickCloseItem@@YAPAU_object@@PAU1@0@Z	; playerPickCloseItem
PUBLIC	??1?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAE@XZ ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::~map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >
PUBLIC	?GetAutoPotionInfo@CPythonPlayer@@QAEAAUSAutoPotionInfo@1@H@Z ; CPythonPlayer::GetAutoPotionInfo
PUBLIC	?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A ; m_kMap_iEmotionIndex_pkIconImage
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
	ALIGN	8

?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A DQ 01H DUP (?) ; m_kMap_iEmotionIndex_pkIconImage
_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?playerGetGuildName@@YAPAU_object@@PAU1@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?playerGetGuildName@@YAPAU_object@@PAU1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?playerGetGuildName@@YAPAU_object@@PAU1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?playerGetGuildName@@YAPAU_object@@PAU1@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z$2
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z$2
__catchsym$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z$0
_m_kMap_iEmotionIndex_pkIconImage$initializer$ DD FLAT:??__Em_kMap_iEmotionIndex_pkIconImage@@YAXXZ
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
;	COMDAT ?GetAutoPotionInfo@CPythonPlayer@@QAEAAUSAutoPotionInfo@1@H@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?GetAutoPotionInfo@CPythonPlayer@@QAEAAUSAutoPotionInfo@1@H@Z PROC ; CPythonPlayer::GetAutoPotionInfo, COMDAT
; _this$ = ecx

; 427  : 		__inline		SAutoPotionInfo& GetAutoPotionInfo(int type)		{ return m_kAutoPotionInfo[type]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00006	05 a2 10 00 00	 add	 eax, 4258		; 000010a2H
  0000b	c1 e0 04	 shl	 eax, 4
  0000e	03 c1		 add	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?GetAutoPotionInfo@CPythonPlayer@@QAEAAUSAutoPotionInfo@1@H@Z ENDP ; CPythonPlayer::GetAutoPotionInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ??__Em_kMap_iEmotionIndex_pkIconImage@@YAXXZ
text$di	SEGMENT
??__Em_kMap_iEmotionIndex_pkIconImage@@YAXXZ PROC	; `dynamic initializer for 'm_kMap_iEmotionIndex_pkIconImage'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  00000	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 45   : std::map<int, CGraphicImage *> m_kMap_iEmotionIndex_pkIconImage;

  00005	68 00 00 00 00	 push	 OFFSET ??__Fm_kMap_iEmotionIndex_pkIconImage@@YAXXZ ; `dynamic atexit destructor for 'm_kMap_iEmotionIndex_pkIconImage''
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  0000a	a3 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 45   : std::map<int, CGraphicImage *> m_kMap_iEmotionIndex_pkIconImage;

  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Em_kMap_iEmotionIndex_pkIconImage@@YAXXZ ENDP	; `dynamic initializer for 'm_kMap_iEmotionIndex_pkIconImage''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__Fm_kMap_iEmotionIndex_pkIconImage@@YAXXZ
text$yd	SEGMENT
$T1 = -8						; size = 4
$T2 = -1						; size = 1
$T3 = -1						; size = 1
$T4 = -1						; size = 1
$T5 = -1						; size = 1
??__Fm_kMap_iEmotionIndex_pkIconImage@@YAXXZ PROC	; `dynamic atexit destructor for 'm_kMap_iEmotionIndex_pkIconImage'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	50		 push	 eax
  0000d	ff 30		 push	 DWORD PTR [eax]
  0000f	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase

; 778  : 		_Freeheadnode(this->_Myhead);

  00018	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  0001e	8d 4d ff	 lea	 ecx, DWORD PTR $T5[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >

; 779  : 		}
; 780  : 
; 781  : 	void _Change_alloc(const _Alty&)
; 782  : 		{	// replace old allocator
; 783  : 		}
; 784  : 
; 785  : 	void _Swap_alloc(_Myt&)
; 786  : 		{	// swap allocators
; 787  : 		}
; 788  : 
; 789  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 790  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 791  : 		{	// construct allocators from _Al
; 792  : 		this->_Myhead = _Buyheadnode();
; 793  : 		_TRY_BEGIN
; 794  : 		_Alloc_proxy();
; 795  : 		_CATCH_ALL
; 796  : 		_Freeheadnode(this->_Myhead);
; 797  : 		_RERAISE;
; 798  : 		_CATCH_END
; 799  : 		}
; 800  : 
; 801  : 	~_Tree_alloc() _NOEXCEPT
; 802  : 		{	// destroy proxy
; 803  : 		_Freeheadnode(this->_Myhead);
; 804  : 		_Free_proxy();
; 805  : 		}
; 806  : 
; 807  : 	void _Change_alloc(const _Alty&)
; 808  : 		{	// replace old allocator
; 809  : 		}
; 810  : 
; 811  : 	void _Swap_alloc(_Myt&)
; 812  : 		{	// swap allocators
; 813  : 		}
; 814  : 
; 815  : 	void _Alloc_proxy()
; 816  : 		{	// construct proxy from _Alnod
; 817  : 		typename _Alty::template rebind<_Container_proxy>::other
; 818  : 			_Alproxy(_Getal());
; 819  : 		this->_Myproxy = _Alproxy.allocate(1);
; 820  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 821  : 		this->_Myproxy->_Mycont = this;
; 822  : 		}
; 823  : 
; 824  : 	void _Free_proxy()
; 825  : 		{	// destroy proxy
; 826  : 		typename _Alty::template rebind<_Container_proxy>::other
; 827  : 			_Alproxy(_Getal());
; 828  : 		this->_Orphan_all();
; 829  : 		_Alproxy.destroy(this->_Myproxy);
; 830  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 831  : 		this->_Myproxy = 0;
; 832  : 		}
; 833  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 834  : 
; 835  : 	_Nodeptr _Buyheadnode()
; 836  : 		{	// get head node using current allocator
; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 838  : 
; 839  : 		_TRY_BEGIN
; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);
; 848  : 		_RERAISE;
; 849  : 		_CATCH_END
; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;
; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}
; 855  : 
; 856  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 857  : 		{	// free head node using current allocator
; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));

  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  0002c	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0002f	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >

; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  0003a	8d 4d ff	 lea	 ecx, DWORD PTR $T4[ebp]
  0003d	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >

; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));

  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  00048	8d 4d ff	 lea	 ecx, DWORD PTR $T3[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??__Fm_kMap_iEmotionIndex_pkIconImage@@YAXXZ ENDP	; `dynamic atexit destructor for 'm_kMap_iEmotionIndex_pkIconImage''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::~map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >, COMDAT
; _this$dead$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::~map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerPickCloseItem@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerPickCloseItem@@YAPAU_object@@PAU1@0@Z PROC	; playerPickCloseItem, COMDAT

; 115  : 	CPythonPlayer::Instance().PickCloseItem();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?PickCloseItem@CPythonPlayer@@QAEXXZ ; CPythonPlayer::PickCloseItem

; 116  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerPickCloseItem@@YAPAU_object@@PAU1@0@Z ENDP	; playerPickCloseItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetGameWindow@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pyHandle$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetGameWindow@@YAPAU_object@@PAU1@0@Z PROC	; playerSetGameWindow, COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 122  : 	PyObject * pyHandle;
; 123  : 	if (!PyTuple_GetObject(poArgs, 0, &pyHandle))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pyHandle$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z ; PyTuple_GetObject
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 09		 jne	 SHORT $LN1@playerSetG

; 124  : 		return Py_BadArgument();

  00019	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 129  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN1@playerSetG:

; 125  : 
; 126  : 	CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 127  : 	rkPlayer.SetGameWindow(pyHandle);

  00022	ff 75 fc	 push	 DWORD PTR _pyHandle$[ebp]
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002b	e8 00 00 00 00	 call	 ?SetGameWindow@CPythonPlayer@@QAEXPAU_object@@@Z ; CPythonPlayer::SetGameWindow

; 128  : 	return Py_BuildNone();

  00030	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 129  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?playerSetGameWindow@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetGameWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetQuickCameraMode@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nIsEnable$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetQuickCameraMode@@YAPAU_object@@PAU1@0@Z PROC	; playerSetQuickCameraMode, COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 134  : 	int nIsEnable;
; 135  : 	if (!PyTuple_GetInteger(poArgs, 0, &nIsEnable))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _nIsEnable$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 09		 jne	 SHORT $LN1@playerSetQ

; 136  : 		return Py_BadArgument();

  00019	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 142  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN1@playerSetQ:

; 137  : 
; 138  : 	CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 139  : 	rkPlayer.SetQuickCameraMode(nIsEnable ? true : false);	

  00022	83 7d fc 00	 cmp	 DWORD PTR _nIsEnable$[ebp], 0
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002c	0f 95 c0	 setne	 al
  0002f	0f b6 c0	 movzx	 eax, al
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?SetQuickCameraMode@CPythonPlayer@@QAEX_N@Z ; CPythonPlayer::SetQuickCameraMode

; 140  : 
; 141  : 	return Py_BuildNone();

  00038	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 142  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?playerSetQuickCameraMode@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetQuickCameraMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z PROC ; playerSetMainCharacterIndex, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 147  : 	int iVID;
; 148  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerSetM

; 149  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 155  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerSetM:

; 150  : 
; 151  : 	CPythonPlayer::Instance().SetMainCharacterIndex(iVID);

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002d	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  00030	83 c1 04	 add	 ecx, 4
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	ff 50 08	 call	 DWORD PTR [eax+8]

; 152  : 	CPythonCharacterManager::Instance().SetMainInstance(iVID);

  00038	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00041	e8 00 00 00 00	 call	 ?SetMainInstance@CPythonCharacterManager@@QAE_NK@Z ; CPythonCharacterManager::SetMainInstance

; 153  : 
; 154  : 	return Py_BuildNone();

  00046	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 155  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?playerSetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z ENDP ; playerSetMainCharacterIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z PROC ; playerGetMainCharacterIndex, COMDAT

; 160  : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetMainCharacterIndex());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 50 04	 call	 DWORD PTR [eax+4]
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 161  : }

  0001d	c3		 ret	 0
?playerGetMainCharacterIndex@@YAPAU_object@@PAU1@0@Z ENDP ; playerGetMainCharacterIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetMainCharacterName@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetMainCharacterName@@YAPAU_object@@PAU1@0@Z PROC ; playerGetMainCharacterName, COMDAT

; 165  : 	return Py_BuildValue("s", CPythonPlayer::Instance().GetName());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 50 14	 call	 DWORD PTR [eax+20]
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 166  : }

  0001d	c3		 ret	 0
?playerGetMainCharacterName@@YAPAU_object@@PAU1@0@Z ENDP ; playerGetMainCharacterName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetMainCharacterPosition@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_kPPosMainActor$ = -12					; size = 12
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetMainCharacterPosition@@YAPAU_object@@PAU1@0@Z PROC ; playerGetMainCharacterPosition, COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 40	 sub	 esp, 64			; 00000040H

; 170  : 	TPixelPosition kPPosMainActor;
; 171  : 	CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 172  : 	rkPlayer.NEW_GetMainActorPosition(&kPPosMainActor);

  00009	8d 44 24 34	 lea	 eax, DWORD PTR _kPPosMainActor$[esp+64]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?NEW_GetMainActorPosition@CPythonPlayer@@QAEXPAUD3DXVECTOR3@@@Z ; CPythonPlayer::NEW_GetMainActorPosition
  00013	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+72]

; 173  : 	return Py_BuildValue("fff", kPPosMainActor.x, kPPosMainActor.y, kPPosMainActor.z);

  00019	83 ec 18	 sub	 esp, 24			; 00000018H
  0001c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001f	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  00025	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+92]
  0002b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002e	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00034	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+88]
  0003a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0003d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_03LPALPDIP@fff?$AA@
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 174  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?playerGetMainCharacterPosition@@YAPAU_object@@PAU1@0@Z ENDP ; playerGetMainCharacterPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsMainCharacterIndex@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsMainCharacterIndex@@YAPAU_object@@PAU1@0@Z PROC ; playerIsMainCharacterIndex, COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 178  : 	int iVID;
; 179  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerIsMa

; 180  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 183  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerIsMa:

; 181  : 
; 182  : 	return Py_BuildValue("i", CPythonPlayer::Instance().IsMainCharacterIndex(iVID));

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002d	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  00030	83 c1 04	 add	 ecx, 4
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00038	ff d0		 call	 eax
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00049	83 c4 08	 add	 esp, 8

; 183  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?playerIsMainCharacterIndex@@YAPAU_object@@PAU1@0@Z ENDP ; playerIsMainCharacterIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerCanAttackInstance@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerCanAttackInstance@@YAPAU_object@@PAU1@0@Z PROC	; playerCanAttackInstance, COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 187  : 	int iVID;
; 188  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN3@playerCanA

; 189  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 199  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@playerCanA:

; 190  : 
; 191  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002d	83 c1 04	 add	 ecx, 4
  00030	56		 push	 esi
  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 192  : 	CInstanceBase * pTargetInstance = CPythonCharacterManager::Instance().GetInstancePtr(iVID);

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0003f	8b f0		 mov	 esi, eax
  00041	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  00044	83 c1 04	 add	 ecx, 4
  00047	8b 11		 mov	 edx, DWORD PTR [ecx]
  00049	ff 52 08	 call	 DWORD PTR [edx+8]

; 193  : 	if (!pMainInstance)

  0004c	85 f6		 test	 esi, esi
  0004e	75 15		 jne	 SHORT $LN2@playerCanA
$LN12@playerCanA:

; 194  : 		return Py_BuildValue("i", 0);

  00050	6a 00		 push	 0

; 196  : 		return Py_BuildValue("i", 0);
; 197  : 
; 198  : 	return Py_BuildValue("i", pMainInstance->IsAttackableInstance(*pTargetInstance));

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0005d	83 c4 08	 add	 esp, 8
  00060	5e		 pop	 esi

; 199  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN2@playerCanA:

; 195  : 	if (!pTargetInstance)

  00065	85 c0		 test	 eax, eax
  00067	74 e7		 je	 SHORT $LN12@playerCanA

; 196  : 		return Py_BuildValue("i", 0);
; 197  : 
; 198  : 	return Py_BuildValue("i", pMainInstance->IsAttackableInstance(*pTargetInstance));

  00069	50		 push	 eax
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?IsAttackableInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsAttackableInstance
  00071	0f b6 c0	 movzx	 eax, al
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00080	83 c4 08	 add	 esp, 8
  00083	5e		 pop	 esi

; 199  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?playerCanAttackInstance@@YAPAU_object@@PAU1@0@Z ENDP	; playerCanAttackInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsActingEmotion@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsActingEmotion@@YAPAU_object@@PAU1@0@Z PROC	; playerIsActingEmotion, COMDAT

; 203  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 204  : 	if (!pMainInstance)

  00011	85 c0		 test	 eax, eax
  00013	75 10		 jne	 SHORT $LN1@playerIsAc

; 205  : 		return Py_BuildValue("i", 0);

  00015	50		 push	 eax

; 206  : 
; 207  : 	return Py_BuildValue("i", pMainInstance->IsActingEmotion());

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00021	83 c4 08	 add	 esp, 8

; 208  : }

  00024	c3		 ret	 0
$LN1@playerIsAc:

; 206  : 
; 207  : 	return Py_BuildValue("i", pMainInstance->IsActingEmotion());

  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 ?IsActingEmotion@CInstanceBase@@QAEHXZ ; CInstanceBase::IsActingEmotion
  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00038	83 c4 08	 add	 esp, 8

; 208  : }

  0003b	c3		 ret	 0
?playerIsActingEmotion@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsActingEmotion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsPVPInstance@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsPVPInstance@@YAPAU_object@@PAU1@0@Z PROC	; playerIsPVPInstance, COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	int iVID;
; 213  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN3@playerIsPV

; 214  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 224  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@playerIsPV:

; 215  : 
; 216  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002d	83 c1 04	 add	 ecx, 4
  00030	56		 push	 esi
  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 217  : 	CInstanceBase * pTargetInstance = CPythonCharacterManager::Instance().GetInstancePtr(iVID);

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0003f	8b f0		 mov	 esi, eax
  00041	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  00044	83 c1 04	 add	 ecx, 4
  00047	8b 11		 mov	 edx, DWORD PTR [ecx]
  00049	ff 52 08	 call	 DWORD PTR [edx+8]

; 218  : 	if (!pMainInstance)

  0004c	85 f6		 test	 esi, esi
  0004e	75 15		 jne	 SHORT $LN2@playerIsPV
$LN12@playerIsPV:

; 219  : 		return Py_BuildValue("i", 0);

  00050	6a 00		 push	 0

; 221  : 		return Py_BuildValue("i", 0);
; 222  : 
; 223  : 	return Py_BuildValue("i", pMainInstance->IsPVPInstance(*pTargetInstance));

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0005d	83 c4 08	 add	 esp, 8
  00060	5e		 pop	 esi

; 224  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN2@playerIsPV:

; 220  : 	if (!pTargetInstance)

  00065	85 c0		 test	 eax, eax
  00067	74 e7		 je	 SHORT $LN12@playerIsPV

; 221  : 		return Py_BuildValue("i", 0);
; 222  : 
; 223  : 	return Py_BuildValue("i", pMainInstance->IsPVPInstance(*pTargetInstance));

  00069	50		 push	 eax
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?IsPVPInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsPVPInstance
  00071	0f b6 c0	 movzx	 eax, al
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00080	83 c4 08	 add	 esp, 8
  00083	5e		 pop	 esi

; 224  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?playerIsPVPInstance@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsPVPInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsSameEmpire@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsSameEmpire@@YAPAU_object@@PAU1@0@Z PROC	; playerIsSameEmpire, COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 228  : 	int iVID;
; 229  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN3@playerIsSa

; 230  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 240  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@playerIsSa:

; 231  : 
; 232  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002d	83 c1 04	 add	 ecx, 4
  00030	56		 push	 esi
  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 233  : 	CInstanceBase * pTargetInstance = CPythonCharacterManager::Instance().GetInstancePtr(iVID);

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0003f	8b f0		 mov	 esi, eax
  00041	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  00044	83 c1 04	 add	 ecx, 4
  00047	8b 11		 mov	 edx, DWORD PTR [ecx]
  00049	ff 52 08	 call	 DWORD PTR [edx+8]

; 234  : 	if (!pMainInstance)

  0004c	85 f6		 test	 esi, esi
  0004e	75 15		 jne	 SHORT $LN2@playerIsSa
$LN12@playerIsSa:

; 235  : 		return Py_BuildValue("i", FALSE);

  00050	6a 00		 push	 0

; 237  : 		return Py_BuildValue("i", FALSE);
; 238  : 
; 239  : 	return Py_BuildValue("i", pMainInstance->IsSameEmpire(*pTargetInstance));

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0005d	83 c4 08	 add	 esp, 8
  00060	5e		 pop	 esi

; 240  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN2@playerIsSa:

; 236  : 	if (!pTargetInstance)

  00065	85 c0		 test	 eax, eax
  00067	74 e7		 je	 SHORT $LN12@playerIsSa

; 237  : 		return Py_BuildValue("i", FALSE);
; 238  : 
; 239  : 	return Py_BuildValue("i", pMainInstance->IsSameEmpire(*pTargetInstance));

  00069	50		 push	 eax
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?IsSameEmpire@CInstanceBase@@QAEHAAV1@@Z ; CInstanceBase::IsSameEmpire
  00071	50		 push	 eax
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0007d	83 c4 08	 add	 esp, 8
  00080	5e		 pop	 esi

; 240  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?playerIsSameEmpire@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsSameEmpire
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsChallengeInstance@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsChallengeInstance@@YAPAU_object@@PAU1@0@Z PROC	; playerIsChallengeInstance, COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 244  : 	int iVID;
; 245  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerIsCh

; 246  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 249  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerIsCh:

; 247  : 
; 248  : 	return Py_BuildValue("i", CPythonPlayer::Instance().IsChallengeInstance(iVID));

  00027	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?IsChallengeInstance@CPythonPlayer@@QAE_NK@Z ; CPythonPlayer::IsChallengeInstance
  00035	0f b6 c0	 movzx	 eax, al
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00044	83 c4 08	 add	 esp, 8

; 249  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?playerIsChallengeInstance@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsChallengeInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsRevengeInstance@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsRevengeInstance@@YAPAU_object@@PAU1@0@Z PROC	; playerIsRevengeInstance, COMDAT

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 253  : 	int iVID;
; 254  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerIsRe

; 255  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 258  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerIsRe:

; 256  : 
; 257  : 	return Py_BuildValue("i", CPythonPlayer::Instance().IsRevengeInstance(iVID));

  00027	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?IsRevengeInstance@CPythonPlayer@@QAE_NK@Z ; CPythonPlayer::IsRevengeInstance
  00035	0f b6 c0	 movzx	 eax, al
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00044	83 c4 08	 add	 esp, 8

; 258  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?playerIsRevengeInstance@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsRevengeInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsCantFightInstance@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsCantFightInstance@@YAPAU_object@@PAU1@0@Z PROC	; playerIsCantFightInstance, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 262  : 	int iVID;
; 263  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerIsCa

; 264  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 267  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerIsCa:

; 265  : 
; 266  : 	return Py_BuildValue("i", CPythonPlayer::Instance().IsCantFightInstance(iVID));

  00027	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?IsCantFightInstance@CPythonPlayer@@QAE_NK@Z ; CPythonPlayer::IsCantFightInstance
  00035	0f b6 c0	 movzx	 eax, al
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00044	83 c4 08	 add	 esp, 8

; 267  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?playerIsCantFightInstance@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsCantFightInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetCharacterDistance@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetCharacterDistance@@YAPAU_object@@PAU1@0@Z PROC ; playerGetCharacterDistance, COMDAT

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 271  : 	int iVID;
; 272  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00009	8d 44 24 38	 lea	 eax, DWORD PTR _iVID$[esp+60]
  0000d	56		 push	 esi
  0000e	50		 push	 eax
  0000f	6a 00		 push	 0
  00011	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00014	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	84 c0		 test	 al, al
  0001e	75 0f		 jne	 SHORT $LN3@playerGetC

; 273  : 		return Py_BuildException();

  00020	6a 00		 push	 0
  00022	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00027	83 c4 04	 add	 esp, 4

; 283  : }

  0002a	5e		 pop	 esi
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN3@playerGetC:

; 274  : 
; 275  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00035	83 c1 04	 add	 ecx, 4
  00038	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003a	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 276  : 	CInstanceBase * pTargetInstance = CPythonCharacterManager::Instance().GetInstancePtr(iVID);

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00046	8b f0		 mov	 esi, eax
  00048	ff 74 24 3c	 push	 DWORD PTR _iVID$[esp+64]
  0004c	83 c1 04	 add	 ecx, 4
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 52 08	 call	 DWORD PTR [edx+8]

; 277  : 	if (!pMainInstance)

  00054	85 f6		 test	 esi, esi
  00056	75 0a		 jne	 SHORT $LN2@playerGetC
$LN11@playerGetC:

; 278  : 		return Py_BuildValue("f", -1.0f);

  00058	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bff0000000000000
  00060	eb 10		 jmp	 SHORT $LN10@playerGetC
$LN2@playerGetC:

; 279  : 	if (!pTargetInstance)

  00062	85 c0		 test	 eax, eax
  00064	74 f2		 je	 SHORT $LN11@playerGetC

; 280  : 		return Py_BuildValue("f", -1.0f);
; 281  : 
; 282  : 	return Py_BuildValue("f", pMainInstance->GetDistance(pTargetInstance));

  00066	50		 push	 eax
  00067	8b ce		 mov	 ecx, esi
  00069	e8 00 00 00 00	 call	 ?GetDistance@CInstanceBase@@QAEMPAV1@@Z ; CInstanceBase::GetDistance
  0006e	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
$LN10@playerGetC:
  00072	83 ec 08	 sub	 esp, 8
  00075	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH

; 283  : }

  00088	5e		 pop	 esi
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?playerGetCharacterDistance@@YAPAU_object@@PAU1@0@Z ENDP ; playerGetCharacterDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsInSafeArea@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsInSafeArea@@YAPAU_object@@PAU1@0@Z PROC	; playerIsInSafeArea, COMDAT

; 287  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 288  : 	if (!pMainInstance)

  00011	85 c0		 test	 eax, eax
  00013	75 10		 jne	 SHORT $LN1@playerIsIn

; 289  : 		return Py_BuildValue("i", FALSE);

  00015	50		 push	 eax

; 290  : 
; 291  : 	return Py_BuildValue("i", pMainInstance->IsInSafe());

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00021	83 c4 08	 add	 esp, 8

; 292  : }

  00024	c3		 ret	 0
$LN1@playerIsIn:

; 290  : 
; 291  : 	return Py_BuildValue("i", pMainInstance->IsInSafe());

  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 ?IsInSafe@CInstanceBase@@QAEHXZ ; CInstanceBase::IsInSafe
  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00038	83 c4 08	 add	 esp, 8

; 292  : }

  0003b	c3		 ret	 0
?playerIsInSafeArea@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsInSafeArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsMountingHorse@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsMountingHorse@@YAPAU_object@@PAU1@0@Z PROC	; playerIsMountingHorse, COMDAT

; 296  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 297  : 	if (!pMainInstance)

  00011	85 c0		 test	 eax, eax
  00013	75 10		 jne	 SHORT $LN1@playerIsMo

; 298  : 		return Py_BuildValue("i", FALSE);

  00015	50		 push	 eax

; 299  : 
; 300  : 	return Py_BuildValue("i", pMainInstance->IsMountingHorse());

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00021	83 c4 08	 add	 esp, 8

; 301  : }

  00024	c3		 ret	 0
$LN1@playerIsMo:

; 299  : 
; 300  : 	return Py_BuildValue("i", pMainInstance->IsMountingHorse());

  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 ?IsMountingHorse@CInstanceBase@@QAEHXZ ; CInstanceBase::IsMountingHorse
  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00038	83 c4 08	 add	 esp, 8

; 301  : }

  0003b	c3		 ret	 0
?playerIsMountingHorse@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsMountingHorse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsObserverMode@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsObserverMode@@YAPAU_object@@PAU1@0@Z PROC	; playerIsObserverMode, COMDAT

; 305  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 306  : 	return Py_BuildValue("i", rkPlayer.IsObserverMode());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsObserverMode@CPythonPlayer@@QAE_NXZ ; CPythonPlayer::IsObserverMode
  0000b	0f b6 c0	 movzx	 eax, al
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 307  : }

  0001d	c3		 ret	 0
?playerIsObserverMode@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsObserverMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerActEmotion@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerActEmotion@@YAPAU_object@@PAU1@0@Z PROC		; playerActEmotion, COMDAT

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 311  : 	int iVID;
; 312  : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerActE

; 313  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 318  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerActE:

; 314  : 
; 315  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 316  : 	rkPlayer.ActEmotion(iVID);

  00027	51		 push	 ecx
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002e	e8 00 00 00 00	 call	 ?ActEmotion@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::ActEmotion

; 317  : 	return Py_BuildNone();

  00033	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 318  : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?playerActEmotion@@YAPAU_object@@PAU1@0@Z ENDP		; playerActEmotion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerShowPlayer@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerShowPlayer@@YAPAU_object@@PAU1@0@Z PROC		; playerShowPlayer, COMDAT

; 322  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 323  : 	if (pMainInstance)

  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN1@playerShow

; 324  : 		pMainInstance->GetGraphicThingInstanceRef().Show();

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?GetGraphicThingInstanceRef@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstanceRef
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?Show@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Show
$LN1@playerShow:

; 325  : 	return Py_BuildNone();

  00023	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerShowPlayer@@YAPAU_object@@PAU1@0@Z ENDP		; playerShowPlayer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerHidePlayer@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerHidePlayer@@YAPAU_object@@PAU1@0@Z PROC		; playerHidePlayer, COMDAT

; 330  : 	CInstanceBase * pMainInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 331  : 	if (pMainInstance)

  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN1@playerHide

; 332  : 		pMainInstance->GetGraphicThingInstanceRef().Hide();

  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?GetGraphicThingInstanceRef@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstanceRef
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ?Hide@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Hide
$LN1@playerHide:

; 333  : 	return Py_BuildNone();

  00023	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerHidePlayer@@YAPAU_object@@PAU1@0@Z ENDP		; playerHidePlayer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerComboAttack@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerComboAttack@@YAPAU_object@@PAU1@0@Z PROC		; playerComboAttack, COMDAT

; 339  : 	CPythonPlayer::Instance().NEW_Attack();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?NEW_Attack@CPythonPlayer@@QAEXXZ ; CPythonPlayer::NEW_Attack

; 340  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerComboAttack@@YAPAU_object@@PAU1@0@Z ENDP		; playerComboAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRegisterEffect@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iEft$ = -8						; size = 4
_szFileName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRegisterEffect@@YAPAU_object@@PAU1@0@Z PROC	; playerRegisterEffect, COMDAT

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 346  : 	int iEft;
; 347  : 	if (!PyTuple_GetInteger(poArgs, 0, &iEft))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iEft$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 09		 jne	 SHORT $LN3@playerRegi
$LN8@playerRegi:

; 348  : 		return Py_BadArgument();

  0001b	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 359  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN3@playerRegi:

; 349  : 
; 350  : 	char* szFileName;
; 351  : 	if (!PyTuple_GetString(poArgs, 1, &szFileName))

  00024	8d 45 fc	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00027	50		 push	 eax
  00028	6a 01		 push	 1
  0002a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0002d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	84 c0		 test	 al, al
  00037	74 e2		 je	 SHORT $LN8@playerRegi

; 352  : 		return Py_BadArgument();
; 353  : 
; 354  : 	CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 355  : 	if (!rkPlayer.RegisterEffect(iEft, szFileName, false))

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0003f	6a 00		 push	 0
  00041	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  00044	ff 75 f8	 push	 DWORD PTR _iEft$[ebp]
  00047	e8 00 00 00 00	 call	 ?RegisterEffect@CPythonPlayer@@QAE_NKPBD_N@Z ; CPythonPlayer::RegisterEffect
  0004c	84 c0		 test	 al, al
  0004e	75 17		 jne	 SHORT $LN1@playerRegi

; 356  : 		return Py_BuildException("CPythonPlayer::RegisterEffect(eEft=%d, szFileName=%s", iEft, szFileName);

  00050	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  00053	ff 75 f8	 push	 DWORD PTR _iEft$[ebp]
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@ILFGGFEI@CPythonPlayer?3?3RegisterEffect?$CIeE@
  0005b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 359  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
$LN1@playerRegi:

; 357  : 
; 358  : 	return Py_BuildNone();

  00067	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 359  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?playerRegisterEffect@@YAPAU_object@@PAU1@0@Z ENDP	; playerRegisterEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRegisterCacheEffect@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iEft$ = -8						; size = 4
_szFileName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRegisterCacheEffect@@YAPAU_object@@PAU1@0@Z PROC	; playerRegisterCacheEffect, COMDAT

; 362  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 363  : 	int iEft;
; 364  : 	if (!PyTuple_GetInteger(poArgs, 0, &iEft))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iEft$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 09		 jne	 SHORT $LN3@playerRegi
$LN8@playerRegi:

; 365  : 		return Py_BadArgument();

  0001b	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 376  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN3@playerRegi:

; 366  : 
; 367  : 	char* szFileName;
; 368  : 	if (!PyTuple_GetString(poArgs, 1, &szFileName))

  00024	8d 45 fc	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00027	50		 push	 eax
  00028	6a 01		 push	 1
  0002a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0002d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	84 c0		 test	 al, al
  00037	74 e2		 je	 SHORT $LN8@playerRegi

; 369  : 		return Py_BadArgument();
; 370  : 
; 371  : 	CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 372  : 	if (!rkPlayer.RegisterEffect(iEft, szFileName, true))

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0003f	6a 01		 push	 1
  00041	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  00044	ff 75 f8	 push	 DWORD PTR _iEft$[ebp]
  00047	e8 00 00 00 00	 call	 ?RegisterEffect@CPythonPlayer@@QAE_NKPBD_N@Z ; CPythonPlayer::RegisterEffect
  0004c	84 c0		 test	 al, al
  0004e	75 17		 jne	 SHORT $LN1@playerRegi

; 373  : 		return Py_BuildException("CPythonPlayer::RegisterEffect(eEft=%d, szFileName=%s", iEft, szFileName);

  00050	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  00053	ff 75 f8	 push	 DWORD PTR _iEft$[ebp]
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@ILFGGFEI@CPythonPlayer?3?3RegisterEffect?$CIeE@
  0005b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 376  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
$LN1@playerRegi:

; 374  : 
; 375  : 	return Py_BuildNone();

  00067	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 376  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?playerRegisterCacheEffect@@YAPAU_object@@PAU1@0@Z ENDP	; playerRegisterCacheEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetAttackKeyState@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_isPressed$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetAttackKeyState@@YAPAU_object@@PAU1@0@Z PROC	; playerSetAttackKeyState, COMDAT

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 380  : 	int isPressed;
; 381  : 	if (!PyTuple_GetInteger(poArgs, 0, &isPressed))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _isPressed$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 11		 jne	 SHORT $LN1@playerSetA

; 382  : 		return Py_BuildException("playerSetAttackKeyState(isPressed) - There is no first argument");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@OHLDKNFC@playerSetAttackKeyState?$CIisPresse@
  0001e	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00023	83 c4 04	 add	 esp, 4

; 387  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN1@playerSetA:

; 383  : 
; 384  : 	CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 385  : 	rkPlayer.SetAttackKeyState(isPressed ? true : false);

  0002a	83 7d fc 00	 cmp	 DWORD PTR _isPressed$[ebp], 0
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00034	0f 95 c0	 setne	 al
  00037	0f b6 c0	 movzx	 eax, al
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?SetAttackKeyState@CPythonPlayer@@QAEX_N@Z ; CPythonPlayer::SetAttackKeyState

; 386  : 	return Py_BuildNone();

  00040	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 387  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?playerSetAttackKeyState@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetAttackKeyState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetSingleDIKKeyState@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_eDIK$ = -8						; size = 4
_isPressed$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetSingleDIKKeyState@@YAPAU_object@@PAU1@0@Z PROC ; playerSetSingleDIKKeyState, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 391  : 	int eDIK;
; 392  : 	if (!PyTuple_GetInteger(poArgs, 0, &eDIK))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _eDIK$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 11		 jne	 SHORT $LN2@playerSetS

; 393  : 		return Py_BuildException("playerSetSingleDIKKeyState(eDIK, isPressed) - There is no first argument");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@BNKMOLIP@playerSetSingleDIKKeyState?$CIeDIK?0@
  00020	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00025	83 c4 04	 add	 esp, 4

; 402  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN2@playerSetS:

; 394  : 
; 395  : 	int isPressed;
; 396  : 	if (!PyTuple_GetInteger(poArgs, 1, &isPressed))

  0002c	8d 45 fc	 lea	 eax, DWORD PTR _isPressed$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00035	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	84 c0		 test	 al, al
  0003f	75 11		 jne	 SHORT $LN1@playerSetS

; 397  : 		return Py_BuildException("playerSetSingleDIKKeyState(eDIK, isPressed) - There is no second argument");

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@IDBGKDBN@playerSetSingleDIKKeyState?$CIeDIK?0@
  00046	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0004b	83 c4 04	 add	 esp, 4

; 402  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN1@playerSetS:

; 398  : 
; 399  : 	CPythonPlayer & rkPlayer = CPythonPlayer::Instance();
; 400  : 	rkPlayer.NEW_SetSingleDIKKeyState(eDIK, isPressed ? true : false);

  00052	83 7d fc 00	 cmp	 DWORD PTR _isPressed$[ebp], 0
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0005c	0f 95 c0	 setne	 al
  0005f	0f b6 c0	 movzx	 eax, al
  00062	50		 push	 eax
  00063	ff 75 f8	 push	 DWORD PTR _eDIK$[ebp]
  00066	e8 00 00 00 00	 call	 ?NEW_SetSingleDIKKeyState@CPythonPlayer@@QAEXH_N@Z ; CPythonPlayer::NEW_SetSingleDIKKeyState

; 401  : 	return Py_BuildNone();

  0006b	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 402  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?playerSetSingleDIKKeyState@@YAPAU_object@@PAU1@0@Z ENDP ; playerSetSingleDIKKeyState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerEndKeyWalkingImmediately@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerEndKeyWalkingImmediately@@YAPAU_object@@PAU1@0@Z PROC ; playerEndKeyWalkingImmediately, COMDAT

; 406  : 	CPythonPlayer::Instance().NEW_Stop();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?NEW_Stop@CPythonPlayer@@QAEXXZ ; CPythonPlayer::NEW_Stop

; 407  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerEndKeyWalkingImmediately@@YAPAU_object@@PAU1@0@Z ENDP ; playerEndKeyWalkingImmediately
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerStartMouseWalking@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerStartMouseWalking@@YAPAU_object@@PAU1@0@Z PROC	; playerStartMouseWalking, COMDAT

; 413  : 	return Py_BuildNone();

  00000	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerStartMouseWalking@@YAPAU_object@@PAU1@0@Z ENDP	; playerStartMouseWalking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerEndMouseWalking@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerEndMouseWalking@@YAPAU_object@@PAU1@0@Z PROC	; playerEndMouseWalking, COMDAT

; 418  : 	return Py_BuildNone();

  00000	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerEndMouseWalking@@YAPAU_object@@PAU1@0@Z ENDP	; playerEndMouseWalking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerResetCameraRotation@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerResetCameraRotation@@YAPAU_object@@PAU1@0@Z PROC	; playerResetCameraRotation, COMDAT

; 423  : 	CPythonPlayer::Instance().NEW_ResetCameraRotation();

  00000	e8 00 00 00 00	 call	 ?NEW_ResetCameraRotation@CPythonPlayer@@QAEXXZ ; CPythonPlayer::NEW_ResetCameraRotation

; 424  : 	return Py_BuildNone();

  00005	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerResetCameraRotation@@YAPAU_object@@PAU1@0@Z ENDP	; playerResetCameraRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetAutoCameraRotationSpeed@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fCmrRotSpd$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetAutoCameraRotationSpeed@@YAPAU_object@@PAU1@0@Z PROC ; playerSetAutoCameraRotationSpeed, COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 429  : 	float fCmrRotSpd;
; 430  : 	if (!PyTuple_GetFloat(poArgs, 0, &fCmrRotSpd))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _fCmrRotSpd$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerSetA

; 431  : 		return Py_BuildException();	

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 436  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerSetA:

; 432  : 
; 433  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 434  : 	rkPlayer.NEW_SetAutoCameraRotationSpeed(fCmrRotSpd);

  00027	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _fCmrRotSpd$[ebp]
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00032	e8 00 00 00 00	 call	 ?NEW_SetAutoCameraRotationSpeed@CPythonPlayer@@QAEXM@Z ; CPythonPlayer::NEW_SetAutoCameraRotationSpeed

; 435  : 	return Py_BuildNone();

  00037	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 436  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?playerSetAutoCameraRotationSpeed@@YAPAU_object@@PAU1@0@Z ENDP ; playerSetAutoCameraRotationSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetMouseState@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_eMBT$ = -8						; size = 4
_eMBS$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetMouseState@@YAPAU_object@@PAU1@0@Z PROC	; playerSetMouseState, COMDAT

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 440  : 	int eMBT;
; 441  : 	if (!PyTuple_GetInteger(poArgs, 0, &eMBT))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _eMBT$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerSetM
$LN7@playerSetM:

; 442  : 		return Py_BuildException();	

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 452  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerSetM:

; 443  : 
; 444  : 	int eMBS;
; 445  : 	if (!PyTuple_GetInteger(poArgs, 1, &eMBS))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _eMBS$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@playerSetM

; 446  : 		return Py_BuildException();	
; 447  : 
; 448  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 449  : 	rkPlayer.NEW_SetMouseState(eMBT, eMBS);

  0003e	ff 75 fc	 push	 DWORD PTR _eMBS$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00047	ff 75 f8	 push	 DWORD PTR _eMBT$[ebp]
  0004a	e8 00 00 00 00	 call	 ?NEW_SetMouseState@CPythonPlayer@@QAE_NHH@Z ; CPythonPlayer::NEW_SetMouseState

; 450  : 
; 451  : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 452  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?playerSetMouseState@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetMouseState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetMouseFunc@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_eMBT$ = -8						; size = 4
_eMBS$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetMouseFunc@@YAPAU_object@@PAU1@0@Z PROC	; playerSetMouseFunc, COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 456  : 	int eMBT;
; 457  : 	if (!PyTuple_GetInteger(poArgs, 0, &eMBT))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _eMBT$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerSetM
$LN7@playerSetM:

; 458  : 		return Py_BuildException();	

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 468  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerSetM:

; 459  : 
; 460  : 	int eMBS;
; 461  : 	if (!PyTuple_GetInteger(poArgs, 1, &eMBS))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _eMBS$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@playerSetM

; 462  : 		return Py_BuildException();	
; 463  : 
; 464  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 465  : 	rkPlayer.NEW_SetMouseFunc(eMBT, eMBS);

  0003e	ff 75 fc	 push	 DWORD PTR _eMBS$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00047	ff 75 f8	 push	 DWORD PTR _eMBT$[ebp]
  0004a	e8 00 00 00 00	 call	 ?NEW_SetMouseFunc@CPythonPlayer@@QAE_NHH@Z ; CPythonPlayer::NEW_SetMouseFunc

; 466  : 
; 467  : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 468  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?playerSetMouseFunc@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetMouseFunc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetMouseFunc@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_eMBT$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetMouseFunc@@YAPAU_object@@PAU1@0@Z PROC	; playerGetMouseFunc, COMDAT

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 472  : 	int eMBT;
; 473  : 	if (!PyTuple_GetInteger(poArgs, 0, &eMBT))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _eMBT$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerGetM

; 474  : 		return Py_BuildException();	

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 478  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerGetM:

; 475  : 
; 476  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 477  : 	return Py_BuildValue("i", rkPlayer.NEW_GetMouseFunc(eMBT));

  00027	ff 75 fc	 push	 DWORD PTR _eMBT$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?NEW_GetMouseFunc@CPythonPlayer@@QAEHH@Z ; CPythonPlayer::NEW_GetMouseFunc
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 478  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?playerGetMouseFunc@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetMouseFunc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetMouseMiddleButtonState@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_eMBS$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetMouseMiddleButtonState@@YAPAU_object@@PAU1@0@Z PROC ; playerSetMouseMiddleButtonState, COMDAT

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 482  : 	int eMBS;
; 483  : 	if (!PyTuple_GetInteger(poArgs, 0, &eMBS))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _eMBS$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerSetM

; 484  : 		return Py_BuildException();	

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 490  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerSetM:

; 485  : 
; 486  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 487  : 	rkPlayer.NEW_SetMouseMiddleButtonState(eMBS);

  00027	ff 75 fc	 push	 DWORD PTR _eMBS$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?NEW_SetMouseMiddleButtonState@CPythonPlayer@@QAEXH@Z ; CPythonPlayer::NEW_SetMouseMiddleButtonState

; 488  : 
; 489  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 490  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?playerSetMouseMiddleButtonState@@YAPAU_object@@PAU1@0@Z ENDP ; playerSetMouseMiddleButtonState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetName@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetName@@YAPAU_object@@PAU1@0@Z PROC		; playerGetName, COMDAT

; 496  : 	return Py_BuildValue("s", CPythonPlayer::Instance().GetName()); 

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 50 14	 call	 DWORD PTR [eax+20]
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 497  : }

  0001d	c3		 ret	 0
?playerGetName@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetRace@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetRace@@YAPAU_object@@PAU1@0@Z PROC		; playerGetRace, COMDAT

; 501  : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetRace());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetRace@CPythonPlayer@@QAEKXZ ; CPythonPlayer::GetRace
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 502  : }

  0001a	c3		 ret	 0
?playerGetRace@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetRace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\instancebase.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetJob@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetJob@@YAPAU_object@@PAU1@0@Z PROC		; playerGetJob, COMDAT

; 506  : 	int race = CPythonPlayer::Instance().GetRace();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetRace@CPythonPlayer@@QAEKXZ ; CPythonPlayer::GetRace
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\instancebase.h

; 1109 : 	return race % JOB_NUM;

  0000b	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00010	79 05		 jns	 SHORT $LN7@playerGetJ
  00012	48		 dec	 eax
  00013	83 c8 fc	 or	 eax, -4			; fffffffcH
  00016	40		 inc	 eax
$LN7@playerGetJ:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 508  : 	return Py_BuildValue("i", job);

  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00023	83 c4 08	 add	 esp, 8

; 509  : }

  00026	c3		 ret	 0
?playerGetJob@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetJob
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetPlayTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetPlayTime@@YAPAU_object@@PAU1@0@Z PROC		; playerGetPlayTime, COMDAT

; 513  : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetPlayTime()); 

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetPlayTime@CPythonPlayer@@QAEKXZ ; CPythonPlayer::GetPlayTime
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 514  : }

  0001a	c3		 ret	 0
?playerGetPlayTime@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetPlayTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetPlayTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iTime$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetPlayTime@@YAPAU_object@@PAU1@0@Z PROC		; playerSetPlayTime, COMDAT

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 518  : 	int iTime;
; 519  : 	if (!PyTuple_GetInteger(poArgs, 0, &iTime))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iTime$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerSetP

; 520  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 524  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerSetP:

; 521  : 
; 522  : 	CPythonPlayer::Instance().SetPlayTime(iTime);

  00027	ff 75 fc	 push	 DWORD PTR _iTime$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?SetPlayTime@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::SetPlayTime

; 523  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 524  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?playerSetPlayTime@@YAPAU_object@@PAU1@0@Z ENDP		; playerSetPlayTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsSkillCoolTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsSkillCoolTime@@YAPAU_object@@PAU1@0@Z PROC	; playerIsSkillCoolTime, COMDAT

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 528  : 	int iSlotIndex;
; 529  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerIsSk

; 530  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 533  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerIsSk:

; 531  : 
; 532  : 	return Py_BuildValue("i", CPythonPlayer::Instance().IsSkillCoolTime(iSlotIndex));

  00027	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?IsSkillCoolTime@CPythonPlayer@@QAEHK@Z ; CPythonPlayer::IsSkillCoolTime
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 533  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?playerIsSkillCoolTime@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsSkillCoolTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetSkillCoolTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fCoolTime$1$ = -8					; size = 4
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetSkillCoolTime@@YAPAU_object@@PAU1@0@Z PROC	; playerGetSkillCoolTime, COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 537  : 	int iSlotIndex;
; 538  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN1@playerGetS

; 539  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 544  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN1@playerGetS:

; 540  : 
; 541  : 	float fCoolTime = CPythonPlayer::Instance().GetSkillCoolTime(iSlotIndex);

  00029	8b 55 fc	 mov	 edx, DWORD PTR _iSlotIndex$[ebp]
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ?GetSkillCoolTime@CPythonPlayer@@QAEMK@Z ; CPythonPlayer::GetSkillCoolTime

; 542  : 	float fElapsedCoolTime = CPythonPlayer::Instance().GetSkillElapsedCoolTime(iSlotIndex);

  00038	52		 push	 edx
  00039	f3 0f 11 45 f8	 movss	 DWORD PTR _fCoolTime$1$[ebp], xmm0
  0003e	e8 00 00 00 00	 call	 ?GetSkillElapsedCoolTime@CPythonPlayer@@QAEMK@Z ; CPythonPlayer::GetSkillElapsedCoolTime
  00043	0f 57 c9	 xorps	 xmm1, xmm1

; 543  : 	return Py_BuildValue("ff", fCoolTime, fElapsedCoolTime);

  00046	83 ec 10	 sub	 esp, 16			; 00000010H
  00049	f3 0f 5a c8	 cvtss2sd xmm1, xmm0
  0004d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fCoolTime$1$[ebp]
  00052	0f 5a c0	 cvtps2pd xmm0, xmm0
  00055	f2 0f 11 4c 24
	08		 movsd	 QWORD PTR [esp+8], xmm1
  0005b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_02HPEDFNFO@ff?$AA@
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0006b	83 c4 14	 add	 esp, 20			; 00000014H

; 544  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?playerGetSkillCoolTime@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetSkillCoolTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsSkillActive@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsSkillActive@@YAPAU_object@@PAU1@0@Z PROC	; playerIsSkillActive, COMDAT

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 548  : 	int iSlotIndex;
; 549  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerIsSk

; 550  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 553  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerIsSk:

; 551  : 
; 552  : 	return Py_BuildValue("i", CPythonPlayer::Instance().IsSkillActive(iSlotIndex));

  00027	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?IsSkillActive@CPythonPlayer@@QAEHK@Z ; CPythonPlayer::IsSkillActive
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 553  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?playerIsSkillActive@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsSkillActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerUseGuildSkill@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSkillSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerUseGuildSkill@@YAPAU_object@@PAU1@0@Z PROC	; playerUseGuildSkill, COMDAT

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 557  : 	int iSkillSlotIndex;
; 558  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSkillSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSkillSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerUseG

; 559  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 563  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerUseG:

; 560  : 
; 561  : 	CPythonPlayer::Instance().UseGuildSkill(iSkillSlotIndex);

  00027	ff 75 fc	 push	 DWORD PTR _iSkillSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?UseGuildSkill@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::UseGuildSkill

; 562  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 563  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?playerUseGuildSkill@@YAPAU_object@@PAU1@0@Z ENDP	; playerUseGuildSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerAffectIndexToSkillIndex@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_dwSkillIndex$ = -8					; size = 4
_iAffectIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerAffectIndexToSkillIndex@@YAPAU_object@@PAU1@0@Z PROC ; playerAffectIndexToSkillIndex, COMDAT

; 566  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 567  : 	int iAffectIndex;
; 568  : 	if (!PyTuple_GetInteger(poArgs, 0, &iAffectIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iAffectIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerAffe

; 569  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 576  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerAffe:

; 570  : 
; 571  : 	DWORD dwSkillIndex;
; 572  : 	if (!CPythonPlayer::Instance().AffectIndexToSkillIndex(iAffectIndex, &dwSkillIndex))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _dwSkillIndex$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iAffectIndex$[ebp]
  00036	e8 00 00 00 00	 call	 ?AffectIndexToSkillIndex@CPythonPlayer@@QAE_NKPAK@Z ; CPythonPlayer::AffectIndexToSkillIndex
  0003b	84 c0		 test	 al, al
  0003d	75 14		 jne	 SHORT $LN1@playerAffe

; 573  : 		return Py_BuildValue("i", 0);

  0003f	6a 00		 push	 0

; 574  : 
; 575  : 	return Py_BuildValue("i", dwSkillIndex);

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004c	83 c4 08	 add	 esp, 8

; 576  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN1@playerAffe:

; 574  : 
; 575  : 	return Py_BuildValue("i", dwSkillIndex);

  00053	ff 75 f8	 push	 DWORD PTR _dwSkillIndex$[ebp]
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00061	83 c4 08	 add	 esp, 8

; 576  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?playerAffectIndexToSkillIndex@@YAPAU_object@@PAU1@0@Z ENDP ; playerAffectIndexToSkillIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetEXP@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetEXP@@YAPAU_object@@PAU1@0@Z PROC		; playerGetEXP, COMDAT

; 580  : 	DWORD dwEXP = CPythonPlayer::Instance().GetStatus(POINT_EXP);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	6a 03		 push	 3
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	ff 50 10	 call	 DWORD PTR [eax+16]

; 581  : 	return Py_BuildValue("l", dwEXP);

  00010	50		 push	 eax
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_01HHGOMJKL@l?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001c	83 c4 08	 add	 esp, 8

; 582  : }

  0001f	c3		 ret	 0
?playerGetEXP@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetEXP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetStatus@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iType$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetStatus@@YAPAU_object@@PAU1@0@Z PROC		; playerGetStatus, COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 586  : 	int iType;
; 587  : 	if (!PyTuple_GetInteger(poArgs, 0, &iType))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iType$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN3@playerGetS

; 588  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 602  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@playerGetS:

; 589  : 
; 590  : 	long iValue = CPythonPlayer::Instance().GetStatus(iType);

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002d	83 c1 04	 add	 ecx, 4
  00030	56		 push	 esi
  00031	ff 75 fc	 push	 DWORD PTR _iType$[ebp]
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	ff 50 10	 call	 DWORD PTR [eax+16]

; 591  : 
; 592  : 	if (POINT_ATT_SPEED == iType)

  00039	83 7d fc 11	 cmp	 DWORD PTR _iType$[ebp], 17 ; 00000011H
  0003d	8b f0		 mov	 esi, eax
  0003f	75 27		 jne	 SHORT $LN1@playerGetS

; 593  : 	{
; 594  : 		CInstanceBase * pInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00047	83 c1 04	 add	 ecx, 4
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	ff 92 88 00 00
	00		 call	 DWORD PTR [edx+136]

; 595  : 		if (pInstance && (CItemData::WEAPON_TWO_HANDED == pInstance->GetWeaponType()))

  00052	85 c0		 test	 eax, eax
  00054	74 12		 je	 SHORT $LN1@playerGetS
  00056	8b c8		 mov	 ecx, eax
  00058	e8 00 00 00 00	 call	 ?GetWeaponType@CInstanceBase@@QAEKXZ ; CInstanceBase::GetWeaponType
  0005d	83 f8 03	 cmp	 eax, 3
  00060	75 06		 jne	 SHORT $LN1@playerGetS

; 596  : 		{
; 597  : 			iValue -= TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE;

  00062	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE@@3HA ; TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE
$LN1@playerGetS:

; 598  : 		}
; 599  : 	}
; 600  : 
; 601  : 	return Py_BuildValue("i", iValue);

  00068	56		 push	 esi
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00074	83 c4 08	 add	 esp, 8
  00077	5e		 pop	 esi

; 602  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?playerGetStatus@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetStatus@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iType$ = -8						; size = 4
_iValue$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetStatus@@YAPAU_object@@PAU1@0@Z PROC		; playerSetStatus, COMDAT

; 605  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 606  : 	int iType;
; 607  : 	if (!PyTuple_GetInteger(poArgs, 0, &iType))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iType$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerSetS
$LN7@playerSetS:

; 608  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 616  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerSetS:

; 609  : 
; 610  : 	int iValue;
; 611  : 	if (!PyTuple_GetInteger(poArgs, 1, &iValue))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _iValue$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@playerSetS

; 612  : 		return Py_BuildException();
; 613  : 
; 614  : 	CPythonPlayer::Instance().SetStatus(iType, iValue);

  0003e	ff 75 fc	 push	 DWORD PTR _iValue$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00047	ff 75 f8	 push	 DWORD PTR _iType$[ebp]
  0004a	e8 00 00 00 00	 call	 ?SetStatus@CPythonPlayer@@QAEXKJ@Z ; CPythonPlayer::SetStatus

; 615  : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 616  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?playerSetStatus@@YAPAU_object@@PAU1@0@Z ENDP		; playerSetStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetElk@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetElk@@YAPAU_object@@PAU1@0@Z PROC		; playerGetElk, COMDAT

; 620  : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetStatus(POINT_GOLD));

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	6a 0b		 push	 11			; 0000000bH
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	ff 50 10	 call	 DWORD PTR [eax+16]
  00010	50		 push	 eax
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001c	83 c4 08	 add	 esp, 8

; 621  : }

  0001f	c3		 ret	 0
?playerGetElk@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetElk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetGuildID@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetGuildID@@YAPAU_object@@PAU1@0@Z PROC		; playerGetGuildID, COMDAT

; 625  : 	CInstanceBase * pInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 626  : 	if (!pInstance)

  00011	85 c0		 test	 eax, eax
  00013	75 10		 jne	 SHORT $LN1@playerGetG

; 627  : 		return Py_BuildValue("i", 0);

  00015	50		 push	 eax

; 628  : 	return Py_BuildValue("i", pInstance->GetGuildID());

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00021	83 c4 08	 add	 esp, 8

; 629  : }

  00024	c3		 ret	 0
$LN1@playerGetG:

; 628  : 	return Py_BuildValue("i", pInstance->GetGuildID());

  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 ?GetGuildID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetGuildID
  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00038	83 c4 08	 add	 esp, 8

; 629  : }

  0003b	c3		 ret	 0
?playerGetGuildID@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetGuildID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetGuildName@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_strName$2 = -44					; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetGuildName@@YAPAU_object@@PAU1@0@Z PROC	; playerGetGuildName, COMDAT

; 632  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?playerGetGuildName@@YAPAU_object@@PAU1@0@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 20	 sub	 esp, 32			; 00000020H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 18	 mov	 DWORD PTR __$ArrayPad$[esp+44], eax
  00022	56		 push	 esi
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c4		 xor	 eax, esp
  0002a	50		 push	 eax
  0002b	8d 44 24 28	 lea	 eax, DWORD PTR __$EHRec$[esp+52]
  0002f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 633  : 	CInstanceBase * pInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0003b	83 c1 04	 add	 ecx, 4
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 634  : 	if (pInstance)

  00046	85 c0		 test	 eax, eax
  00048	0f 84 82 00 00
	00		 je	 $LN108@playerGetG

; 635  : 	{
; 636  : 		DWORD dwID = pInstance->GetGuildID();

  0004e	8b c8		 mov	 ecx, eax
  00050	e8 00 00 00 00	 call	 ?GetGuildID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetGuildID
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00055	c7 44 24 1c 0f
	00 00 00	 mov	 DWORD PTR _strName$2[esp+72], 15 ; 0000000fH

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0005d	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _strName$2[esp+68], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00065	c6 44 24 08 00	 mov	 BYTE PTR _strName$2[esp+52], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 638  : 		if (CPythonGuild::Instance().GetGuildName(dwID, &strName))

  0006a	8d 4c 24 08	 lea	 ecx, DWORD PTR _strName$2[esp+52]
  0006e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 0
  00076	51		 push	 ecx
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGuild@@@@0PAVCPythonGuild@@A ; CSingleton<CPythonGuild>::ms_singleton
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?GetGuildName@CPythonGuild@@QAE_NKPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonGuild::GetGuildName
  00083	84 c0		 test	 al, al
  00085	74 36		 je	 SHORT $LN1@playerGetG
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00087	83 7c 24 1c 10	 cmp	 DWORD PTR _strName$2[esp+72], 16 ; 00000010H
  0008c	8d 44 24 08	 lea	 eax, DWORD PTR _strName$2[esp+52]
  00090	0f 43 44 24 08	 cmovae	 eax, DWORD PTR _strName$2[esp+52]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 639  : 			return Py_BuildValue("s", strName.c_str());

  00095	50		 push	 eax
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000a1	83 c4 08	 add	 esp, 8
  000a4	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000a6	83 7c 24 1c 10	 cmp	 DWORD PTR _strName$2[esp+72], 16 ; 00000010H
  000ab	72 0c		 jb	 SHORT $LN76@playerGetG
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000ad	ff 74 24 08	 push	 DWORD PTR _strName$2[esp+52]
  000b1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b6	83 c4 04	 add	 esp, 4
$LN76@playerGetG:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 639  : 			return Py_BuildValue("s", strName.c_str());

  000b9	8b c6		 mov	 eax, esi
  000bb	eb 26		 jmp	 SHORT $LN3@playerGetG
$LN1@playerGetG:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000bd	83 7c 24 1c 10	 cmp	 DWORD PTR _strName$2[esp+72], 16 ; 00000010H
  000c2	72 0c		 jb	 SHORT $LN108@playerGetG
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000c4	ff 74 24 08	 push	 DWORD PTR _strName$2[esp+52]
  000c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000cd	83 c4 04	 add	 esp, 4
$LN108@playerGetG:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 641  : 	return Py_BuildValue("s", "");

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000e0	83 c4 08	 add	 esp, 8
$LN3@playerGetG:

; 642  : }

  000e3	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  000e7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ee	59		 pop	 ecx
  000ef	5e		 pop	 esi
  000f0	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+44]
  000f4	33 cc		 xor	 ecx, esp
  000f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?playerGetGuildName@@YAPAU_object@@PAU1@0@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _strName$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?playerGetGuildName@@YAPAU_object@@PAU1@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 dc	 lea	 eax, DWORD PTR [edx-36]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 04	 add	 eax, 4
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?playerGetGuildName@@YAPAU_object@@PAU1@0@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?playerGetGuildName@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetGuildName
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetAlignmentData@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetAlignmentData@@YAPAU_object@@PAU1@0@Z PROC	; playerGetAlignmentData, COMDAT

; 646  : 	CInstanceBase * pInstance = CPythonPlayer::Instance().NEW_GetMainActorPtr();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	56		 push	 esi
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 647  : 	int iAlignmentPoint = 0;

  00012	33 f6		 xor	 esi, esi
  00014	8b c8		 mov	 ecx, eax

; 648  : 	int iAlignmentGrade = 4;

  00016	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 649  : 	if (pInstance)

  00019	85 c9		 test	 ecx, ecx
  0001b	74 0c		 je	 SHORT $LN1@playerGetA

; 650  : 	{
; 651  : 		iAlignmentPoint = pInstance->GetAlignment();

  0001d	e8 00 00 00 00	 call	 ?GetAlignment@CInstanceBase@@QAEHXZ ; CInstanceBase::GetAlignment
  00022	8b f0		 mov	 esi, eax

; 652  : 		iAlignmentGrade = pInstance->GetAlignmentGrade();

  00024	e8 00 00 00 00	 call	 ?GetAlignmentGrade@CInstanceBase@@QAEIXZ ; CInstanceBase::GetAlignmentGrade
$LN1@playerGetA:

; 653  : 	}
; 654  : 	return Py_BuildValue("ii", iAlignmentPoint, iAlignmentGrade);

  00029	50		 push	 eax
  0002a	56		 push	 esi
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii?$AA@
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	5e		 pop	 esi

; 655  : }

  0003a	c3		 ret	 0
?playerGetAlignmentData@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetAlignmentData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetSkill@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -8					; size = 4
_iSkillIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetSkill@@YAPAU_object@@PAU1@0@Z PROC		; playerSetSkill, COMDAT

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 659  : 	int iSlotIndex;
; 660  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerSetS
$LN7@playerSetS:

; 661  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 669  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerSetS:

; 662  : 
; 663  : 	int iSkillIndex;
; 664  : 	if (!PyTuple_GetInteger(poArgs, 1, &iSkillIndex))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _iSkillIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@playerSetS

; 665  : 		return Py_BuildException();
; 666  : 
; 667  : 	CPythonPlayer::Instance().SetSkill(iSlotIndex, iSkillIndex);

  0003e	ff 75 fc	 push	 DWORD PTR _iSkillIndex$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00047	ff 75 f8	 push	 DWORD PTR _iSlotIndex$[ebp]
  0004a	e8 00 00 00 00	 call	 ?SetSkill@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::SetSkill

; 668  : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 669  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?playerSetSkill@@YAPAU_object@@PAU1@0@Z ENDP		; playerSetSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetSkillIndex@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetSkillIndex@@YAPAU_object@@PAU1@0@Z PROC	; playerGetSkillIndex, COMDAT

; 672  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 673  : 	int iSlotIndex;
; 674  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerGetS

; 675  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 678  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerGetS:

; 676  : 
; 677  : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetSkillIndex(iSlotIndex));

  00027	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?GetSkillIndex@CPythonPlayer@@QAEHK@Z ; CPythonPlayer::GetSkillIndex
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 678  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?playerGetSkillIndex@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetSkillIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetSkillSlotIndex@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_dwSlotIndex$ = -8					; size = 4
_iSkillIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetSkillSlotIndex@@YAPAU_object@@PAU1@0@Z PROC	; playerGetSkillSlotIndex, COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 682  : 	int iSkillIndex;
; 683  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSkillIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iSkillIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerGetS
$LN7@playerGetS:

; 684  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 691  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerGetS:

; 685  : 
; 686  : 	DWORD dwSlotIndex;
; 687  : 	if (!CPythonPlayer::Instance().GetSkillSlotIndex(iSkillIndex, &dwSlotIndex))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iSkillIndex$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetSkillSlotIndex@CPythonPlayer@@QAE_NKPAK@Z ; CPythonPlayer::GetSkillSlotIndex
  0003b	84 c0		 test	 al, al
  0003d	74 dc		 je	 SHORT $LN7@playerGetS

; 688  : 		return Py_BuildException();
; 689  : 
; 690  : 	return Py_BuildValue("i", dwSlotIndex);

  0003f	ff 75 f8	 push	 DWORD PTR _dwSlotIndex$[ebp]
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004d	83 c4 08	 add	 esp, 8

; 691  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?playerGetSkillSlotIndex@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetSkillSlotIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetSkillGrade@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetSkillGrade@@YAPAU_object@@PAU1@0@Z PROC	; playerGetSkillGrade, COMDAT

; 694  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 695  : 	int iSlotIndex;
; 696  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerGetS

; 697  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 700  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerGetS:

; 698  : 
; 699  : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetSkillGrade(iSlotIndex));

  00027	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?GetSkillGrade@CPythonPlayer@@QAEHK@Z ; CPythonPlayer::GetSkillGrade
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 700  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?playerGetSkillGrade@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetSkillGrade
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetSkillLevel@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetSkillLevel@@YAPAU_object@@PAU1@0@Z PROC	; playerGetSkillLevel, COMDAT

; 703  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 704  : 	int iSlotIndex;
; 705  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerGetS

; 706  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 709  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerGetS:

; 707  : 
; 708  : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetSkillLevel(iSlotIndex));

  00027	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?GetSkillLevel@CPythonPlayer@@QAEHK@Z ; CPythonPlayer::GetSkillLevel
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 709  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?playerGetSkillLevel@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetSkillLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetSkillCurrentEfficientPercentage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetSkillCurrentEfficientPercentage@@YAPAU_object@@PAU1@0@Z PROC ; playerGetSkillCurrentEfficientPercentage, COMDAT

; 712  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 713  : 	int iSlotIndex;
; 714  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerGetS

; 715  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 718  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerGetS:

; 716  : 
; 717  : 	return Py_BuildValue("f", CPythonPlayer::Instance().GetSkillCurrentEfficientPercentage(iSlotIndex));

  00027	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?GetSkillCurrentEfficientPercentage@CPythonPlayer@@QAEMK@Z ; CPythonPlayer::GetSkillCurrentEfficientPercentage
  00035	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00039	83 ec 08	 sub	 esp, 8
  0003c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 718  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?playerGetSkillCurrentEfficientPercentage@@YAPAU_object@@PAU1@0@Z ENDP ; playerGetSkillCurrentEfficientPercentage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetSkillNextEfficientPercentage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetSkillNextEfficientPercentage@@YAPAU_object@@PAU1@0@Z PROC ; playerGetSkillNextEfficientPercentage, COMDAT

; 720  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 721  : 	int iSlotIndex;
; 722  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerGetS

; 723  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 726  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerGetS:

; 724  : 
; 725  : 	return Py_BuildValue("f", CPythonPlayer::Instance().GetSkillNextEfficientPercentage(iSlotIndex));

  00027	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?GetSkillNextEfficientPercentage@CPythonPlayer@@QAEMK@Z ; CPythonPlayer::GetSkillNextEfficientPercentage
  00035	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00039	83 ec 08	 sub	 esp, 8
  0003c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 726  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?playerGetSkillNextEfficientPercentage@@YAPAU_object@@PAU1@0@Z ENDP ; playerGetSkillNextEfficientPercentage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerClickSkillSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSkillSlot$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerClickSkillSlot@@YAPAU_object@@PAU1@0@Z PROC	; playerClickSkillSlot, COMDAT

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 730  : 	int iSkillSlot;
; 731  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSkillSlot))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSkillSlot$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 09		 jne	 SHORT $LN1@playerClic

; 732  : 		return Py_BadArgument();

  00019	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 737  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN1@playerClic:

; 733  : 
; 734  : 	CPythonPlayer::Instance().ClickSkillSlot(iSkillSlot);

  00022	ff 75 fc	 push	 DWORD PTR _iSkillSlot$[ebp]
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002b	e8 00 00 00 00	 call	 ?ClickSkillSlot@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::ClickSkillSlot

; 735  : 
; 736  : 	return Py_BuildNone();

  00030	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 737  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?playerClickSkillSlot@@YAPAU_object@@PAU1@0@Z ENDP	; playerClickSkillSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerChangeCurrentSkillNumberOnly@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerChangeCurrentSkillNumberOnly@@YAPAU_object@@PAU1@0@Z PROC ; playerChangeCurrentSkillNumberOnly, COMDAT

; 740  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 741  : 	int iSlotIndex;
; 742  : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 09		 jne	 SHORT $LN1@playerChan

; 743  : 		return Py_BadArgument();

  00019	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 748  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN1@playerChan:

; 744  : 
; 745  : 	CPythonPlayer::Instance().ChangeCurrentSkillNumberOnly(iSlotIndex);

  00022	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002b	e8 00 00 00 00	 call	 ?ChangeCurrentSkillNumberOnly@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::ChangeCurrentSkillNumberOnly

; 746  : 
; 747  : 	return Py_BuildNone();

  00030	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 748  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?playerChangeCurrentSkillNumberOnly@@YAPAU_object@@PAU1@0@Z ENDP ; playerChangeCurrentSkillNumberOnly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerClearSkillDict@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerClearSkillDict@@YAPAU_object@@PAU1@0@Z PROC	; playerClearSkillDict, COMDAT

; 752  : 	CPythonPlayer::Instance().ClearSkillDict();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?ClearSkillDict@CPythonPlayer@@QAEXXZ ; CPythonPlayer::ClearSkillDict

; 753  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerClearSkillDict@@YAPAU_object@@PAU1@0@Z ENDP	; playerClearSkillDict
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerMoveItem@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_srcCell$ = -8						; size = 3
_dstCell$ = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerMoveItem@@YAPAU_object@@PAU1@0@Z PROC		; playerMoveItem, COMDAT

; 757  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 760  : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 760  : 	switch (PyTuple_Size(poArgs))

  0000f	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00010	c6 45 f8 01	 mov	 BYTE PTR _srcCell$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00014	66 89 45 f9	 mov	 WORD PTR _srcCell$[ebp+1], ax

; 186  : 		window_type =     INVENTORY;

  00018	c6 45 fc 01	 mov	 BYTE PTR _dstCell$[ebp], 1

; 187  : 		cell = WORD_MAX;

  0001c	66 89 45 fd	 mov	 WORD PTR _dstCell$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 760  : 	switch (PyTuple_Size(poArgs))

  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00026	83 c4 04	 add	 esp, 4
  00029	83 e8 02	 sub	 eax, 2
  0002c	74 5c		 je	 SHORT $LN9@playerMove
  0002e	83 e8 02	 sub	 eax, 2
  00031	75 6a		 jne	 SHORT $LN20@playerMove

; 767  : 			return Py_BuildException();
; 768  : 		break;
; 769  : 	case 4:
; 770  : 		if (!PyTuple_GetByte(poArgs, 0, &srcCell.window_type))

  00033	8d 45 f8	 lea	 eax, DWORD PTR _srcCell$[ebp]
  00036	50		 push	 eax
  00037	6a 00		 push	 0
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	84 c0		 test	 al, al
  00044	74 57		 je	 SHORT $LN20@playerMove

; 771  : 			return Py_BuildException();
; 772  : 		if (!PyTuple_GetInteger(poArgs, 1, &srcCell.cell))

  00046	8d 45 f9	 lea	 eax, DWORD PTR _srcCell$[ebp+1]
  00049	50		 push	 eax
  0004a	6a 01		 push	 1
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	84 c0		 test	 al, al
  00057	74 44		 je	 SHORT $LN20@playerMove

; 773  : 			return Py_BuildException();
; 774  : 		if (!PyTuple_GetByte(poArgs, 2, &dstCell.window_type))

  00059	8d 45 fc	 lea	 eax, DWORD PTR _dstCell$[ebp]
  0005c	50		 push	 eax
  0005d	6a 02		 push	 2
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	84 c0		 test	 al, al
  0006a	74 31		 je	 SHORT $LN20@playerMove

; 775  : 			return Py_BuildException();
; 776  : 		if (!PyTuple_GetInteger(poArgs, 3, &dstCell.cell))

  0006c	8d 45 fd	 lea	 eax, DWORD PTR _dstCell$[ebp+1]
  0006f	50		 push	 eax
  00070	6a 03		 push	 3
  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	6a 00		 push	 0
  0007d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00082	83 c4 04	 add	 esp, 4

; 784  : }

  00085	5e		 pop	 esi
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN9@playerMove:

; 761  : 	{
; 762  : 	case 2:
; 763  : 		int iSourceSlotIndex;
; 764  : 		if (!PyTuple_GetInteger(poArgs, 0, &srcCell.cell))

  0008a	8d 45 f9	 lea	 eax, DWORD PTR _srcCell$[ebp+1]
  0008d	50		 push	 eax
  0008e	6a 00		 push	 0
  00090	56		 push	 esi
  00091	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	84 c0		 test	 al, al
  0009b	75 0f		 jne	 SHORT $LN8@playerMove
$LN20@playerMove:

; 765  : 			return Py_BuildException();

  0009d	6a 00		 push	 0
  0009f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  000a4	83 c4 04	 add	 esp, 4

; 784  : }

  000a7	5e		 pop	 esi
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN8@playerMove:

; 766  : 		if (!PyTuple_GetInteger(poArgs, 1, &dstCell.cell))

  000ac	8d 45 fd	 lea	 eax, DWORD PTR _dstCell$[ebp+1]
  000af	50		 push	 eax
  000b0	6a 01		 push	 1
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	84 c0		 test	 al, al
  000bd	74 de		 je	 SHORT $LN20@playerMove

; 777  : 			return Py_BuildException();
; 778  : 	default:
; 779  : 		return Py_BuildException();
; 780  : 	}
; 781  : 
; 782  : 	CPythonPlayer::Instance().MoveItemData(srcCell, dstCell);

  000bf	0f b7 45 fc	 movzx	 eax, WORD PTR _dstCell$[ebp]
  000c3	51		 push	 ecx
  000c4	8b cc		 mov	 ecx, esp
  000c6	51		 push	 ecx
  000c7	66 89 01	 mov	 WORD PTR [ecx], ax
  000ca	8a 45 fe	 mov	 al, BYTE PTR _dstCell$[ebp+2]
  000cd	88 41 02	 mov	 BYTE PTR [ecx+2], al
  000d0	8b cc		 mov	 ecx, esp
  000d2	0f b7 45 f8	 movzx	 eax, WORD PTR _srcCell$[ebp]
  000d6	66 89 01	 mov	 WORD PTR [ecx], ax
  000d9	8a 45 fa	 mov	 al, BYTE PTR _srcCell$[ebp+2]
  000dc	88 41 02	 mov	 BYTE PTR [ecx+2], al
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000e5	e8 00 00 00 00	 call	 ?MoveItemData@CPythonPlayer@@QAEXUSItemPos@@0@Z ; CPythonPlayer::MoveItemData

; 783  : 	return Py_BuildNone();

  000ea	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 784  : }

  000ef	5e		 pop	 esi
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
?playerMoveItem@@YAPAU_object@@PAU1@0@Z ENDP		; playerMoveItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSendClickItemPacket@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_ivid$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSendClickItemPacket@@YAPAU_object@@PAU1@0@Z PROC	; playerSendClickItemPacket, COMDAT

; 787  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 788  : 	int ivid;
; 789  : 	if (!PyTuple_GetInteger(poArgs, 0, &ivid))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _ivid$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerSend

; 790  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 794  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerSend:

; 791  : 
; 792  : 	CPythonPlayer::Instance().SendClickItemPacket(ivid);

  00027	ff 75 fc	 push	 DWORD PTR _ivid$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?SendClickItemPacket@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::SendClickItemPacket

; 793  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 794  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?playerSendClickItemPacket@@YAPAU_object@@PAU1@0@Z ENDP	; playerSendClickItemPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetItemIndex@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$1 = -8					; size = 4
_Cell$2 = -4						; size = 3
$T3 = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetItemIndex@@YAPAU_object@@PAU1@0@Z PROC	; playerGetItemIndex, COMDAT

; 797  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 798  : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000a	56		 push	 esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00011	83 c4 04	 add	 esp, 4
  00014	48		 dec	 eax
  00015	74 3c		 je	 SHORT $LN6@playerGetI
  00017	48		 dec	 eax
  00018	75 4c		 jne	 SHORT $LN20@playerGetI
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0001a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001f	c6 45 fc 01	 mov	 BYTE PTR _Cell$2[ebp], 1
  00023	66 89 45 fd	 mov	 WORD PTR _Cell$2[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 812  : 			if (!PyTuple_GetByte(poArgs, 0, &Cell.window_type))

  00027	8d 45 fc	 lea	 eax, DWORD PTR _Cell$2[ebp]
  0002a	50		 push	 eax
  0002b	6a 00		 push	 0
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	84 c0		 test	 al, al
  00038	74 2c		 je	 SHORT $LN20@playerGetI

; 813  : 				return Py_BuildException();
; 814  : 			if (!PyTuple_GetInteger(poArgs, 1, &Cell.cell))

  0003a	8d 45 fd	 lea	 eax, DWORD PTR _Cell$2[ebp+1]
  0003d	50		 push	 eax
  0003e	6a 01		 push	 1
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	84 c0		 test	 al, al
  0004b	74 19		 je	 SHORT $LN20@playerGetI

; 815  : 				return Py_BuildException();
; 816  : 
; 817  : 			int ItemIndex = CPythonPlayer::Instance().GetItemIndex(Cell);

  0004d	66 8b 45 fc	 mov	 ax, WORD PTR _Cell$2[ebp]

; 818  : 			return Py_BuildValue("i", ItemIndex);

  00051	eb 32		 jmp	 SHORT $LN19@playerGetI
$LN6@playerGetI:

; 799  : 	{
; 800  : 	case 1:
; 801  : 		{
; 802  : 			int iSlotIndex;
; 803  : 			if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00053	8d 45 f8	 lea	 eax, DWORD PTR _iSlotIndex$1[ebp]
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	84 c0		 test	 al, al
  00064	75 0f		 jne	 SHORT $LN5@playerGetI
$LN20@playerGetI:

; 804  : 				return Py_BuildException();

  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0006d	83 c4 04	 add	 esp, 4

; 819  : 		}
; 820  : 	default:
; 821  : 		return Py_BuildException();
; 822  : 
; 823  : 	}
; 824  : }

  00070	5e		 pop	 esi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN5@playerGetI:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  00075	0f b7 45 f8	 movzx	 eax, WORD PTR _iSlotIndex$1[ebp]
  00079	c6 45 fc 01	 mov	 BYTE PTR $T3[ebp], 1
  0007d	66 89 45 fd	 mov	 WORD PTR $T3[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 806  : 			int ItemIndex = CPythonPlayer::Instance().GetItemIndex(TItemPos (INVENTORY, iSlotIndex));

  00081	0f b7 45 fc	 movzx	 eax, WORD PTR $T3[ebp]
$LN19@playerGetI:
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0008b	83 c1 04	 add	 ecx, 4
  0008e	51		 push	 ecx
  0008f	8b d4		 mov	 edx, esp
  00091	8b 31		 mov	 esi, DWORD PTR [ecx]
  00093	66 89 02	 mov	 WORD PTR [edx], ax
  00096	8a 45 fe	 mov	 al, BYTE PTR $T3[ebp+2]
  00099	88 42 02	 mov	 BYTE PTR [edx+2], al
  0009c	ff 56 40	 call	 DWORD PTR [esi+64]

; 807  : 			return Py_BuildValue("i", ItemIndex);

  0009f	50		 push	 eax
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000ab	83 c4 08	 add	 esp, 8

; 819  : 		}
; 820  : 	default:
; 821  : 		return Py_BuildException();
; 822  : 
; 823  : 	}
; 824  : }

  000ae	5e		 pop	 esi
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?playerGetItemIndex@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetItemIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetItemFlags@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$1 = -8					; size = 4
_Cell$2 = -4						; size = 3
$T3 = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetItemFlags@@YAPAU_object@@PAU1@0@Z PROC	; playerGetItemFlags, COMDAT

; 827  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 828  : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000a	56		 push	 esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00011	83 c4 04	 add	 esp, 4
  00014	48		 dec	 eax
  00015	74 3c		 je	 SHORT $LN6@playerGetI
  00017	48		 dec	 eax
  00018	75 4c		 jne	 SHORT $LN20@playerGetI
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0001a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001f	c6 45 fc 01	 mov	 BYTE PTR _Cell$2[ebp], 1
  00023	66 89 45 fd	 mov	 WORD PTR _Cell$2[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 842  : 			if (!PyTuple_GetByte(poArgs, 0, &Cell.window_type))

  00027	8d 45 fc	 lea	 eax, DWORD PTR _Cell$2[ebp]
  0002a	50		 push	 eax
  0002b	6a 00		 push	 0
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	84 c0		 test	 al, al
  00038	74 2c		 je	 SHORT $LN20@playerGetI

; 843  : 				return Py_BuildException();
; 844  : 
; 845  : 			if (!PyTuple_GetInteger(poArgs, 1, &Cell.cell))

  0003a	8d 45 fd	 lea	 eax, DWORD PTR _Cell$2[ebp+1]
  0003d	50		 push	 eax
  0003e	6a 01		 push	 1
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	84 c0		 test	 al, al
  0004b	74 19		 je	 SHORT $LN20@playerGetI

; 846  : 				return Py_BuildException();
; 847  : 
; 848  : 			DWORD flags = CPythonPlayer::Instance().GetItemFlags(Cell);

  0004d	66 8b 45 fc	 mov	 ax, WORD PTR _Cell$2[ebp]

; 849  : 			return Py_BuildValue("i", flags);

  00051	eb 32		 jmp	 SHORT $LN19@playerGetI
$LN6@playerGetI:

; 829  : 	{
; 830  : 	case 1:
; 831  : 		{
; 832  : 			int iSlotIndex;
; 833  : 			if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00053	8d 45 f8	 lea	 eax, DWORD PTR _iSlotIndex$1[ebp]
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	84 c0		 test	 al, al
  00064	75 0f		 jne	 SHORT $LN5@playerGetI
$LN20@playerGetI:

; 834  : 				return Py_BuildException();

  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0006d	83 c4 04	 add	 esp, 4

; 850  : 		}
; 851  : 	default:
; 852  : 		return Py_BuildException();
; 853  : 	}
; 854  : }

  00070	5e		 pop	 esi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN5@playerGetI:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  00075	0f b7 45 f8	 movzx	 eax, WORD PTR _iSlotIndex$1[ebp]
  00079	c6 45 fc 01	 mov	 BYTE PTR $T3[ebp], 1
  0007d	66 89 45 fd	 mov	 WORD PTR $T3[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 836  : 			DWORD flags = CPythonPlayer::Instance().GetItemFlags(TItemPos(INVENTORY, iSlotIndex));

  00081	0f b7 45 fc	 movzx	 eax, WORD PTR $T3[ebp]
$LN19@playerGetI:
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0008b	83 c1 04	 add	 ecx, 4
  0008e	51		 push	 ecx
  0008f	8b d4		 mov	 edx, esp
  00091	8b 31		 mov	 esi, DWORD PTR [ecx]
  00093	66 89 02	 mov	 WORD PTR [edx], ax
  00096	8a 45 fe	 mov	 al, BYTE PTR $T3[ebp+2]
  00099	88 42 02	 mov	 BYTE PTR [edx+2], al
  0009c	ff 56 44	 call	 DWORD PTR [esi+68]

; 837  : 			return Py_BuildValue("i", flags);

  0009f	50		 push	 eax
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000ab	83 c4 08	 add	 esp, 8

; 850  : 		}
; 851  : 	default:
; 852  : 		return Py_BuildException();
; 853  : 	}
; 854  : }

  000ae	5e		 pop	 esi
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?playerGetItemFlags@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetItemFlags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetItemCount@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$1 = -8					; size = 4
_Cell$2 = -4						; size = 3
$T3 = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetItemCount@@YAPAU_object@@PAU1@0@Z PROC	; playerGetItemCount, COMDAT

; 858  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 859  : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000a	56		 push	 esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00011	83 c4 04	 add	 esp, 4
  00014	48		 dec	 eax
  00015	74 3c		 je	 SHORT $LN6@playerGetI
  00017	48		 dec	 eax
  00018	75 4c		 jne	 SHORT $LN20@playerGetI
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0001a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001f	c6 45 fc 01	 mov	 BYTE PTR _Cell$2[ebp], 1
  00023	66 89 45 fd	 mov	 WORD PTR _Cell$2[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 873  : 			if (!PyTuple_GetByte(poArgs, 0, &Cell.window_type))

  00027	8d 45 fc	 lea	 eax, DWORD PTR _Cell$2[ebp]
  0002a	50		 push	 eax
  0002b	6a 00		 push	 0
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	84 c0		 test	 al, al
  00038	74 2c		 je	 SHORT $LN20@playerGetI

; 874  : 				return Py_BuildException();
; 875  : 
; 876  : 			if (!PyTuple_GetInteger(poArgs, 1, &Cell.cell))

  0003a	8d 45 fd	 lea	 eax, DWORD PTR _Cell$2[ebp+1]
  0003d	50		 push	 eax
  0003e	6a 01		 push	 1
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	84 c0		 test	 al, al
  0004b	74 19		 je	 SHORT $LN20@playerGetI

; 877  : 				return Py_BuildException();
; 878  : 
; 879  : 			int ItemNum = CPythonPlayer::Instance().GetItemCount(Cell);

  0004d	66 8b 45 fc	 mov	 ax, WORD PTR _Cell$2[ebp]

; 880  : 
; 881  : 			return Py_BuildValue("i", ItemNum);

  00051	eb 32		 jmp	 SHORT $LN19@playerGetI
$LN6@playerGetI:

; 860  : 	{
; 861  : 	case 1:
; 862  : 		{
; 863  : 			int iSlotIndex;
; 864  : 			if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00053	8d 45 f8	 lea	 eax, DWORD PTR _iSlotIndex$1[ebp]
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	84 c0		 test	 al, al
  00064	75 0f		 jne	 SHORT $LN5@playerGetI
$LN20@playerGetI:

; 865  : 				return Py_BuildException();

  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0006d	83 c4 04	 add	 esp, 4

; 882  : 		}
; 883  : 	default:
; 884  : 		return Py_BuildException();
; 885  : 
; 886  : 	}
; 887  : }

  00070	5e		 pop	 esi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN5@playerGetI:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  00075	0f b7 45 f8	 movzx	 eax, WORD PTR _iSlotIndex$1[ebp]
  00079	c6 45 fc 01	 mov	 BYTE PTR $T3[ebp], 1
  0007d	66 89 45 fd	 mov	 WORD PTR $T3[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 867  : 			int ItemNum = CPythonPlayer::Instance().GetItemCount(TItemPos (INVENTORY, iSlotIndex));

  00081	0f b7 45 fc	 movzx	 eax, WORD PTR $T3[ebp]
$LN19@playerGetI:
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0008b	83 c1 04	 add	 ecx, 4
  0008e	51		 push	 ecx
  0008f	8b d4		 mov	 edx, esp
  00091	8b 31		 mov	 esi, DWORD PTR [ecx]
  00093	66 89 02	 mov	 WORD PTR [edx], ax
  00096	8a 45 fe	 mov	 al, BYTE PTR $T3[ebp+2]
  00099	88 42 02	 mov	 BYTE PTR [edx+2], al
  0009c	ff 56 48	 call	 DWORD PTR [esi+72]

; 868  : 			return Py_BuildValue("i", ItemNum);

  0009f	50		 push	 eax
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000ab	83 c4 08	 add	 esp, 8

; 882  : 		}
; 883  : 	default:
; 884  : 		return Py_BuildException();
; 885  : 
; 886  : 	}
; 887  : }

  000ae	5e		 pop	 esi
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?playerGetItemCount@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetItemCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetItemCount@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$1 = -12					; size = 4
_bCount$2 = -8						; size = 1
_bCount$3 = -8						; size = 1
_Cell$4 = -4						; size = 3
$T5 = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetItemCount@@YAPAU_object@@PAU1@0@Z PROC	; playerSetItemCount, COMDAT

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 891  : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000a	56		 push	 esi
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00011	83 c4 04	 add	 esp, 4
  00014	83 e8 02	 sub	 eax, 2
  00017	74 52		 je	 SHORT $LN9@playerSetI
  00019	48		 dec	 eax
  0001a	75 62		 jne	 SHORT $LN23@playerSetI
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0001c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00021	c6 45 fc 01	 mov	 BYTE PTR _Cell$4[ebp], 1
  00025	66 89 45 fd	 mov	 WORD PTR _Cell$4[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 912  : 			if (!PyTuple_GetByte(poArgs, 0, &Cell.window_type))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _Cell$4[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	84 c0		 test	 al, al
  0003a	74 42		 je	 SHORT $LN23@playerSetI

; 913  : 				return Py_BuildException();
; 914  : 
; 915  : 			if (!PyTuple_GetInteger(poArgs, 1, &Cell.cell))

  0003c	8d 45 fd	 lea	 eax, DWORD PTR _Cell$4[ebp+1]
  0003f	50		 push	 eax
  00040	6a 01		 push	 1
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	84 c0		 test	 al, al
  0004d	74 2f		 je	 SHORT $LN23@playerSetI

; 916  : 				return Py_BuildException();
; 917  : 
; 918  : 			BYTE bCount;
; 919  : 			if (!PyTuple_GetInteger(poArgs, 2, &bCount))

  0004f	8d 45 f8	 lea	 eax, DWORD PTR _bCount$3[ebp]
  00052	50		 push	 eax
  00053	6a 02		 push	 2
  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	84 c0		 test	 al, al
  00060	74 1c		 je	 SHORT $LN23@playerSetI

; 920  : 				return Py_BuildException();
; 921  : 
; 922  : 			CPythonPlayer::Instance().SetItemCount(Cell, bCount);

  00062	ff 75 f8	 push	 DWORD PTR _bCount$3[ebp]
  00065	66 8b 45 fc	 mov	 ax, WORD PTR _Cell$4[ebp]

; 923  : 
; 924  : 			return Py_BuildNone();

  00069	eb 4d		 jmp	 SHORT $LN22@playerSetI
$LN9@playerSetI:

; 892  : 	{
; 893  : 	case 2:
; 894  : 		{
; 895  : 			int iSlotIndex;
; 896  : 			if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  0006b	8d 45 f4	 lea	 eax, DWORD PTR _iSlotIndex$1[ebp]
  0006e	50		 push	 eax
  0006f	6a 00		 push	 0
  00071	56		 push	 esi
  00072	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	84 c0		 test	 al, al
  0007c	75 0f		 jne	 SHORT $LN8@playerSetI
$LN23@playerSetI:

; 897  : 				return Py_BuildException();

  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00085	83 c4 04	 add	 esp, 4

; 925  : 		}
; 926  : 	default:
; 927  : 		return Py_BuildException();
; 928  : 
; 929  : 	}
; 930  : }

  00088	5e		 pop	 esi
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN8@playerSetI:

; 898  : 
; 899  : 			BYTE bCount;
; 900  : 			if (!PyTuple_GetInteger(poArgs, 1, &bCount))

  0008d	8d 45 f8	 lea	 eax, DWORD PTR _bCount$2[ebp]
  00090	50		 push	 eax
  00091	6a 01		 push	 1
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	84 c0		 test	 al, al
  0009e	74 de		 je	 SHORT $LN23@playerSetI

; 901  : 				return Py_BuildException();
; 902  : 
; 903  : 			if (0 == bCount)

  000a0	8b 55 f8	 mov	 edx, DWORD PTR _bCount$2[ebp]
  000a3	84 d2		 test	 dl, dl
  000a5	74 d7		 je	 SHORT $LN23@playerSetI
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  000a7	0f b7 45 f4	 movzx	 eax, WORD PTR _iSlotIndex$1[ebp]
  000ab	c6 45 fc 01	 mov	 BYTE PTR $T5[ebp], 1
  000af	66 89 45 fd	 mov	 WORD PTR $T5[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 906  : 			CPythonPlayer::Instance().SetItemCount(TItemPos (INVENTORY, iSlotIndex), bCount);

  000b3	0f b7 45 fc	 movzx	 eax, WORD PTR $T5[ebp]
  000b7	52		 push	 edx
$LN22@playerSetI:
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000be	83 c1 04	 add	 ecx, 4
  000c1	51		 push	 ecx
  000c2	8b d4		 mov	 edx, esp
  000c4	8b 31		 mov	 esi, DWORD PTR [ecx]
  000c6	66 89 02	 mov	 WORD PTR [edx], ax
  000c9	8a 45 fe	 mov	 al, BYTE PTR $T5[ebp+2]
  000cc	88 42 02	 mov	 BYTE PTR [edx+2], al
  000cf	ff 56 34	 call	 DWORD PTR [esi+52]

; 907  : 			return Py_BuildNone();

  000d2	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 925  : 		}
; 926  : 	default:
; 927  : 		return Py_BuildException();
; 928  : 
; 929  : 	}
; 930  : }

  000d7	5e		 pop	 esi
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
?playerSetItemCount@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetItemCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetItemCountByVnum@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_ivnum$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetItemCountByVnum@@YAPAU_object@@PAU1@0@Z PROC	; playerGetItemCountByVnum, COMDAT

; 933  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 934  : 	int ivnum;
; 935  : 	if (!PyTuple_GetInteger(poArgs, 0, &ivnum))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _ivnum$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerGetI

; 936  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 940  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerGetI:

; 937  : 
; 938  : 	int ItemNum = CPythonPlayer::Instance().GetItemCountByVnum(ivnum);

  00027	ff 75 fc	 push	 DWORD PTR _ivnum$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?GetItemCountByVnum@CPythonPlayer@@QAEKK@Z ; CPythonPlayer::GetItemCountByVnum

; 939  : 	return Py_BuildValue("i", ItemNum);

  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 940  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?playerGetItemCountByVnum@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetItemCountByVnum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iMetinSocketIndex$ = -8				; size = 4
_Cell$ = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z PROC	; playerGetItemMetinSocket, COMDAT

; 943  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 947  : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 947  : 	switch (PyTuple_Size(poArgs))

  0000f	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00010	c6 45 fc 01	 mov	 BYTE PTR _Cell$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00014	66 89 45 fd	 mov	 WORD PTR _Cell$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 947  : 	switch (PyTuple_Size(poArgs))

  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001e	83 c4 04	 add	 esp, 4
  00021	83 e8 02	 sub	 eax, 2
  00024	74 4b		 je	 SHORT $LN8@playerGetI
  00026	48		 dec	 eax
  00027	75 39		 jne	 SHORT $LN17@playerGetI

; 954  : 			return Py_BuildException();
; 955  : 
; 956  : 		break;
; 957  : 	case 3:
; 958  : 		if (!PyTuple_GetByte(poArgs, 0, &Cell.window_type))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _Cell$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	84 c0		 test	 al, al
  0003a	74 26		 je	 SHORT $LN17@playerGetI

; 959  : 			return Py_BuildException();
; 960  : 		if (!PyTuple_GetInteger(poArgs, 1, &Cell.cell))

  0003c	8d 45 fd	 lea	 eax, DWORD PTR _Cell$[ebp+1]
  0003f	50		 push	 eax
  00040	6a 01		 push	 1
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	84 c0		 test	 al, al
  0004d	74 13		 je	 SHORT $LN17@playerGetI

; 961  : 			return Py_BuildException();
; 962  : 		if (!PyTuple_GetInteger(poArgs, 2, &iMetinSocketIndex))

  0004f	8d 45 f8	 lea	 eax, DWORD PTR _iMetinSocketIndex$[ebp]
  00052	50		 push	 eax
  00053	6a 02		 push	 2
  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	84 c0		 test	 al, al
  00060	75 35		 jne	 SHORT $LN6@playerGetI
$LN17@playerGetI:

; 963  : 			return Py_BuildException();

  00062	6a 00		 push	 0
  00064	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00069	83 c4 04	 add	 esp, 4

; 973  : }

  0006c	5e		 pop	 esi
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN8@playerGetI:

; 948  : 	{
; 949  : 	case 2:
; 950  : 		if (!PyTuple_GetInteger(poArgs, 0, &Cell.cell))

  00071	8d 45 fd	 lea	 eax, DWORD PTR _Cell$[ebp+1]
  00074	50		 push	 eax
  00075	6a 00		 push	 0
  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	84 c0		 test	 al, al
  00082	74 de		 je	 SHORT $LN17@playerGetI

; 951  : 			return Py_BuildException();
; 952  : 
; 953  : 		if (!PyTuple_GetInteger(poArgs, 1, &iMetinSocketIndex))

  00084	8d 45 f8	 lea	 eax, DWORD PTR _iMetinSocketIndex$[ebp]
  00087	50		 push	 eax
  00088	6a 01		 push	 1
  0008a	56		 push	 esi
  0008b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	84 c0		 test	 al, al
  00095	74 cb		 je	 SHORT $LN17@playerGetI
$LN6@playerGetI:

; 964  : 
; 965  : 		break;
; 966  : 
; 967  : 	default:
; 968  : 		return Py_BuildException();
; 969  : 
; 970  : 	}
; 971  : 	int nMetinSocketValue = CPythonPlayer::Instance().GetItemMetinSocket(Cell, iMetinSocketIndex);

  00097	ff 75 f8	 push	 DWORD PTR _iMetinSocketIndex$[ebp]
  0009a	66 8b 45 fc	 mov	 ax, WORD PTR _Cell$[ebp]
  0009e	51		 push	 ecx
  0009f	8b cc		 mov	 ecx, esp
  000a1	66 89 01	 mov	 WORD PTR [ecx], ax
  000a4	8a 45 fe	 mov	 al, BYTE PTR _Cell$[ebp+2]
  000a7	88 41 02	 mov	 BYTE PTR [ecx+2], al
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000b0	e8 00 00 00 00	 call	 ?GetItemMetinSocket@CPythonPlayer@@QAEKUSItemPos@@K@Z ; CPythonPlayer::GetItemMetinSocket

; 972  : 	return Py_BuildValue("i", nMetinSocketValue);

  000b5	50		 push	 eax
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000c1	83 c4 08	 add	 esp, 8

; 973  : }

  000c4	5e		 pop	 esi
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?playerGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetItemMetinSocket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetItemAttribute@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iAttributeSlotIndex$ = -16				; size = 4
_Cell$ = -12						; size = 3
_sValue$ = -8						; size = 2
_byType$ = -1						; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetItemAttribute@@YAPAU_object@@PAU1@0@Z PROC	; playerGetItemAttribute, COMDAT

; 976  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 980  : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 980  : 	switch (PyTuple_Size(poArgs))

  0000f	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00010	c6 45 f4 01	 mov	 BYTE PTR _Cell$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00014	66 89 45 f5	 mov	 WORD PTR _Cell$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 980  : 	switch (PyTuple_Size(poArgs))

  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001e	83 c4 04	 add	 esp, 4
  00021	83 e8 02	 sub	 eax, 2
  00024	74 4b		 je	 SHORT $LN8@playerGetI
  00026	48		 dec	 eax
  00027	75 39		 jne	 SHORT $LN17@playerGetI

; 987  : 			return Py_BuildException();
; 988  : 
; 989  : 		break;
; 990  : 	case 3:
; 991  : 		if (!PyTuple_GetByte(poArgs, 0, &Cell.window_type))

  00029	8d 45 f4	 lea	 eax, DWORD PTR _Cell$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	84 c0		 test	 al, al
  0003a	74 26		 je	 SHORT $LN17@playerGetI

; 992  : 			return Py_BuildException();
; 993  : 
; 994  : 		if (!PyTuple_GetInteger(poArgs, 1, &Cell.cell))

  0003c	8d 45 f5	 lea	 eax, DWORD PTR _Cell$[ebp+1]
  0003f	50		 push	 eax
  00040	6a 01		 push	 1
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	84 c0		 test	 al, al
  0004d	74 13		 je	 SHORT $LN17@playerGetI

; 995  : 			return Py_BuildException();
; 996  : 
; 997  : 		if (!PyTuple_GetInteger(poArgs, 2, &iAttributeSlotIndex))

  0004f	8d 45 f0	 lea	 eax, DWORD PTR _iAttributeSlotIndex$[ebp]
  00052	50		 push	 eax
  00053	6a 02		 push	 2
  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	84 c0		 test	 al, al
  00060	75 35		 jne	 SHORT $LN6@playerGetI
$LN17@playerGetI:

; 998  : 			return Py_BuildException();

  00062	6a 00		 push	 0
  00064	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00069	83 c4 04	 add	 esp, 4

; 1008 : }

  0006c	5e		 pop	 esi
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN8@playerGetI:

; 981  : 	{
; 982  : 	case 2:
; 983  : 		if (!PyTuple_GetInteger(poArgs, 0, &Cell.cell))

  00071	8d 45 f5	 lea	 eax, DWORD PTR _Cell$[ebp+1]
  00074	50		 push	 eax
  00075	6a 00		 push	 0
  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	84 c0		 test	 al, al
  00082	74 de		 je	 SHORT $LN17@playerGetI

; 984  : 			return Py_BuildException();
; 985  : 
; 986  : 		if (!PyTuple_GetInteger(poArgs, 1, &iAttributeSlotIndex))

  00084	8d 45 f0	 lea	 eax, DWORD PTR _iAttributeSlotIndex$[ebp]
  00087	50		 push	 eax
  00088	6a 01		 push	 1
  0008a	56		 push	 esi
  0008b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	84 c0		 test	 al, al
  00095	74 cb		 je	 SHORT $LN17@playerGetI
$LN6@playerGetI:

; 999  : 		break;
; 1000 : 	default:
; 1001 : 		return Py_BuildException();
; 1002 : 	}
; 1003 : 	BYTE byType;
; 1004 : 	short sValue;
; 1005 : 	CPythonPlayer::Instance().GetItemAttribute(Cell, iAttributeSlotIndex, &byType, &sValue);

  00097	8d 45 f8	 lea	 eax, DWORD PTR _sValue$[ebp]
  0009a	50		 push	 eax
  0009b	8d 45 ff	 lea	 eax, DWORD PTR _byType$[ebp]
  0009e	50		 push	 eax
  0009f	ff 75 f0	 push	 DWORD PTR _iAttributeSlotIndex$[ebp]
  000a2	66 8b 45 f4	 mov	 ax, WORD PTR _Cell$[ebp]
  000a6	51		 push	 ecx
  000a7	8b cc		 mov	 ecx, esp
  000a9	66 89 01	 mov	 WORD PTR [ecx], ax
  000ac	8a 45 f6	 mov	 al, BYTE PTR _Cell$[ebp+2]
  000af	88 41 02	 mov	 BYTE PTR [ecx+2], al
  000b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000b8	e8 00 00 00 00	 call	 ?GetItemAttribute@CPythonPlayer@@QAEXUSItemPos@@KPAEPAF@Z ; CPythonPlayer::GetItemAttribute

; 1006 : 
; 1007 : 	return Py_BuildValue("ii", byType, sValue);

  000bd	0f bf 45 f8	 movsx	 eax, WORD PTR _sValue$[ebp]
  000c1	50		 push	 eax
  000c2	0f b6 45 ff	 movzx	 eax, BYTE PTR _byType$[ebp]
  000c6	50		 push	 eax
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii?$AA@
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1008 : }

  000d5	5e		 pop	 esi
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
?playerGetItemAttribute@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetItemAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetItemLink@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pItemData$ = -1296					; size = 4
_Cell$ = -1292						; size = 3
_isAttr$1$ = -1285					; size = 1
_buf$ = -1284						; size = 1024
_itemlink$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetItemLink@@YAPAU_object@@PAU1@0@Z PROC		; playerGetItemLink, COMDAT

; 1011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 05 00
	00		 sub	 esp, 1296		; 00000510H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  00018	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001d	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1014 : 	switch (PyTuple_Size(poArgs))

  0001e	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  0001f	c6 85 f4 fa ff
	ff 01		 mov	 BYTE PTR _Cell$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00026	66 89 85 f5 fa
	ff ff		 mov	 WORD PTR _Cell$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1014 : 	switch (PyTuple_Size(poArgs))

  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00033	83 c4 04	 add	 esp, 4
  00036	48		 dec	 eax
  00037	74 24		 je	 SHORT $LN18@playerGetI
  00039	48		 dec	 eax
  0003a	75 37		 jne	 SHORT $LN36@playerGetI

; 1019 : 		break;
; 1020 : 	case 2:
; 1021 : 		if (!PyTuple_GetByte(poArgs, 0, &Cell.window_type))

  0003c	8d 85 f4 fa ff
	ff		 lea	 eax, DWORD PTR _Cell$[ebp]
  00042	50		 push	 eax
  00043	6a 00		 push	 0
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	84 c0		 test	 al, al
  00050	74 21		 je	 SHORT $LN36@playerGetI

; 1022 : 			return Py_BuildException();
; 1023 : 		if (!PyTuple_GetInteger(poArgs, 1, &Cell.cell))

  00052	8d 85 f5 fa ff
	ff		 lea	 eax, DWORD PTR _Cell$[ebp+1]
  00058	50		 push	 eax
  00059	6a 01		 push	 1

; 1024 : 			return Py_BuildException();

  0005b	eb 09		 jmp	 SHORT $LN37@playerGetI
$LN18@playerGetI:

; 1015 : 	{
; 1016 : 	case 1:	
; 1017 : 		if (!PyTuple_GetInteger(poArgs, 0, &Cell.cell))

  0005d	8d 85 f5 fa ff
	ff		 lea	 eax, DWORD PTR _Cell$[ebp+1]
  00063	50		 push	 eax
  00064	6a 00		 push	 0
$LN37@playerGetI:
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	84 c0		 test	 al, al
  00071	75 1b		 jne	 SHORT $LN17@playerGetI
$LN36@playerGetI:

; 1018 : 			return Py_BuildException();

  00073	6a 00		 push	 0
  00075	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0007a	83 c4 04	 add	 esp, 4

; 1070 : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00083	33 cd		 xor	 ecx, ebp
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN17@playerGetI:

; 1025 : 		break;
; 1026 : 	default:
; 1027 : 		return Py_BuildException();
; 1028 : 	}
; 1029 : 	const TItemData * pPlayerItem = CPythonPlayer::Instance().GetItemData(Cell);

  0008e	66 8b 85 f4 fa
	ff ff		 mov	 ax, WORD PTR _Cell$[ebp]
  00095	51		 push	 ecx
  00096	8b cc		 mov	 ecx, esp
  00098	66 89 01	 mov	 WORD PTR [ecx], ax
  0009b	8a 85 f6 fa ff
	ff		 mov	 al, BYTE PTR _Cell$[ebp+2]
  000a1	88 41 02	 mov	 BYTE PTR [ecx+2], al
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000aa	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData
  000af	8b f0		 mov	 esi, eax

; 1030 : 	CItemData * pItemData = NULL;

  000b1	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _pItemData$[ebp], 0

; 1031 : 	char buf[1024];
; 1032 : 
; 1033 : 	if (pPlayerItem && CItemManager::Instance().GetItemDataPointer(pPlayerItem->vnum, &pItemData))

  000bb	85 f6		 test	 esi, esi
  000bd	0f 84 0e 01 00
	00		 je	 $LN12@playerGetI
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  000c9	8d 85 f0 fa ff
	ff		 lea	 eax, DWORD PTR _pItemData$[ebp]
  000cf	50		 push	 eax
  000d0	ff 36		 push	 DWORD PTR [esi]
  000d2	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  000d7	85 c0		 test	 eax, eax
  000d9	0f 84 f2 00 00
	00		 je	 $LN12@playerGetI

; 1034 : 	{
; 1035 : 		char itemlink[256];
; 1036 : 		int len;
; 1037 : 		bool isAttr = false;
; 1038 : 
; 1039 : 		len = snprintf(itemlink, sizeof(itemlink), "item:%x:%x:%x:%x:%x", 
; 1040 : 				pPlayerItem->vnum, pPlayerItem->flags,
; 1041 : 				pPlayerItem->alSockets[0], pPlayerItem->alSockets[1], pPlayerItem->alSockets[2]);

  000df	ff 76 15	 push	 DWORD PTR [esi+21]
  000e2	32 c0		 xor	 al, al
  000e4	ff 76 11	 push	 DWORD PTR [esi+17]
  000e7	88 85 fb fa ff
	ff		 mov	 BYTE PTR _isAttr$1$[ebp], al
  000ed	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _itemlink$1[ebp]
  000f3	ff 76 0d	 push	 DWORD PTR [esi+13]
  000f6	ff 76 05	 push	 DWORD PTR [esi+5]
  000f9	ff 36		 push	 DWORD PTR [esi]
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FGPADLIF@item?3?$CFx?3?$CFx?3?$CFx?3?$CFx?3?$CFx?$AA@
  00100	68 00 01 00 00	 push	 256			; 00000100H
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 __snprintf
  0010b	83 c4 20	 add	 esp, 32			; 00000020H
  0010e	8b f8		 mov	 edi, eax
  00110	83 c6 19	 add	 esi, 25			; 00000019H
  00113	bb 07 00 00 00	 mov	 ebx, 7
$LL11@playerGetI:

; 1044 : 			if (pPlayerItem->aAttr[i].bType != 0)

  00118	8a 0e		 mov	 cl, BYTE PTR [esi]
  0011a	84 c9		 test	 cl, cl
  0011c	74 30		 je	 SHORT $LN10@playerGetI

; 1045 : 			{
; 1046 : 				len += snprintf(itemlink + len, sizeof(itemlink) - len, ":%x:%d", 
; 1047 : 						pPlayerItem->aAttr[i].bType, pPlayerItem->aAttr[i].sValue);

  0011e	0f bf 46 01	 movsx	 eax, WORD PTR [esi+1]
  00122	50		 push	 eax
  00123	0f b6 c1	 movzx	 eax, cl
  00126	50		 push	 eax
  00127	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0012c	2b c7		 sub	 eax, edi
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_06FAMCNHHL@?3?$CFx?3?$CFd?$AA@
  00133	50		 push	 eax
  00134	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _itemlink$1[ebp]
  0013a	03 c7		 add	 eax, edi
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 __snprintf
  00142	83 c4 14	 add	 esp, 20			; 00000014H

; 1048 : 				isAttr = true;

  00145	c6 85 fb fa ff
	ff 01		 mov	 BYTE PTR _isAttr$1$[ebp], 1
  0014c	03 f8		 add	 edi, eax
$LN10@playerGetI:

; 1042 : 
; 1043 : 		for (int i = 0; i < ITEM_ATTRIBUTE_SLOT_MAX_NUM; ++i)

  0014e	83 c6 03	 add	 esi, 3
  00151	4b		 dec	 ebx
  00152	75 c4		 jne	 SHORT $LL11@playerGetI

; 1049 : 			}
; 1050 : 
; 1051 : 
; 1052 : 		if( GetDefaultCodePage() == CP_ARABIC ) {

  00154	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage

; 1053 : 			if (isAttr)
; 1054 : 				//"item:::0:1:2"
; 1055 : 				snprintf(buf, sizeof(buf), " |h|r[%s]|cffffc700|H%s|h", pItemData->GetName(), itemlink);

  00159	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR _pItemData$[ebp]
  0015f	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  00164	8a 85 fb fa ff
	ff		 mov	 al, BYTE PTR _isAttr$1$[ebp]
  0016a	75 25		 jne	 SHORT $LN7@playerGetI
  0016c	84 c0		 test	 al, al
  0016e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _itemlink$1[ebp]
  00174	50		 push	 eax
  00175	74 0d		 je	 SHORT $LN6@playerGetI
  00177	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  0017c	50		 push	 eax
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MCOKCAKI@?5?$HMh?$HMr?$FL?$CFs?$FN?$HMcffffc700?$HMH?$CFs?$HMh?$AA@

; 1056 : 			else

  00182	eb 37		 jmp	 SHORT $LN35@playerGetI
$LN6@playerGetI:

; 1057 : 				snprintf(buf, sizeof(buf), " |h|r[%s]|cfff1e6c0|H%s|h", pItemData->GetName(), itemlink);

  00184	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  00189	50		 push	 eax
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MGKBEPOF@?5?$HMh?$HMr?$FL?$CFs?$FN?$HMcfff1e6c0?$HMH?$CFs?$HMh?$AA@

; 1058 : 		} else {

  0018f	eb 2a		 jmp	 SHORT $LN35@playerGetI
$LN7@playerGetI:

; 1059 : 			if (isAttr)

  00191	84 c0		 test	 al, al
  00193	74 14		 je	 SHORT $LN3@playerGetI

; 1060 : 				//"item:::0:1:2"
; 1061 : 				snprintf(buf, sizeof(buf), "|cffffc700|H%s|h[%s]|h|r", itemlink, pItemData->GetName());

  00195	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  0019a	50		 push	 eax
  0019b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _itemlink$1[ebp]
  001a1	50		 push	 eax
  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DABMGIOF@?$HMcffffc700?$HMH?$CFs?$HMh?$FL?$CFs?$FN?$HMh?$HMr?$AA@

; 1062 : 			else

  001a7	eb 12		 jmp	 SHORT $LN35@playerGetI
$LN3@playerGetI:

; 1063 : 				snprintf(buf, sizeof(buf), "|cfff1e6c0|H%s|h[%s]|h|r", itemlink, pItemData->GetName());

  001a9	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  001ae	50		 push	 eax
  001af	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _itemlink$1[ebp]
  001b5	50		 push	 eax
  001b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GPGFNPLK@?$HMcfff1e6c0?$HMH?$CFs?$HMh?$FL?$CFs?$FN?$HMh?$HMr?$AA@
$LN35@playerGetI:
  001bb	8d 85 fc fa ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  001c1	68 00 04 00 00	 push	 1024			; 00000400H
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 __snprintf
  001cc	83 c4 14	 add	 esp, 20			; 00000014H

; 1064 : 		}
; 1065 : 	}
; 1066 : 	else

  001cf	eb 07		 jmp	 SHORT $LN1@playerGetI
$LN12@playerGetI:

; 1067 : 		buf[0] = '\0';

  001d1	c6 85 fc fa ff
	ff 00		 mov	 BYTE PTR _buf$[ebp], 0
$LN1@playerGetI:

; 1068 : 
; 1069 : 	return Py_BuildValue("s", buf);

  001d8	8d 85 fc fa ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  001de	50		 push	 eax
  001df	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue

; 1070 : }

  001ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ed	83 c4 08	 add	 esp, 8
  001f0	33 cd		 xor	 ecx, ebp
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
  001f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c3		 ret	 0
?playerGetItemLink@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetItemLink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetISellItemPrice@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pItemData$ = -8					; size = 4
_Cell$ = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetISellItemPrice@@YAPAU_object@@PAU1@0@Z PROC	; playerGetISellItemPrice, COMDAT

; 1073 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1076 : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000f	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1076 : 	switch (PyTuple_Size(poArgs))

  00010	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00011	c6 45 fc 01	 mov	 BYTE PTR _Cell$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00015	66 89 45 fd	 mov	 WORD PTR _Cell$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1076 : 	switch (PyTuple_Size(poArgs))

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001f	83 c4 04	 add	 esp, 4
  00022	48		 dec	 eax
  00023	74 1e		 je	 SHORT $LN9@playerGetI
  00025	48		 dec	 eax
  00026	75 2e		 jne	 SHORT $LN25@playerGetI

; 1081 : 		break;
; 1082 : 	case 2:
; 1083 : 		if (!PyTuple_GetByte(poArgs, 0, &Cell.window_type))

  00028	8d 45 fc	 lea	 eax, DWORD PTR _Cell$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	84 c0		 test	 al, al
  00039	74 1b		 je	 SHORT $LN25@playerGetI

; 1084 : 			return Py_BuildException();
; 1085 : 		if (!PyTuple_GetInteger(poArgs, 1, &Cell.cell))

  0003b	8d 45 fd	 lea	 eax, DWORD PTR _Cell$[ebp+1]
  0003e	50		 push	 eax
  0003f	6a 01		 push	 1

; 1086 : 			return Py_BuildException();

  00041	eb 06		 jmp	 SHORT $LN26@playerGetI
$LN9@playerGetI:

; 1077 : 	{
; 1078 : 	case 1:	
; 1079 : 		if (!PyTuple_GetInteger(poArgs, 0, &Cell.cell))

  00043	8d 45 fd	 lea	 eax, DWORD PTR _Cell$[ebp+1]
  00046	50		 push	 eax
  00047	6a 00		 push	 0
$LN26@playerGetI:
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	84 c0		 test	 al, al
  00054	75 10		 jne	 SHORT $LN8@playerGetI
$LN25@playerGetI:

; 1080 : 			return Py_BuildException();

  00056	6a 00		 push	 0
  00058	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0005d	83 c4 04	 add	 esp, 4

; 1105 : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN8@playerGetI:

; 1093 : 	if (!CItemManager::Instance().GetItemDataPointer(CPythonPlayer::Instance().GetItemIndex(Cell), &pItemData))

  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0006c	8d 45 f8	 lea	 eax, DWORD PTR _pItemData$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  0006f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1093 : 	if (!CItemManager::Instance().GetItemDataPointer(CPythonPlayer::Instance().GetItemIndex(Cell), &pItemData))

  00075	83 c1 04	 add	 ecx, 4
  00078	50		 push	 eax
  00079	66 8b 45 fc	 mov	 ax, WORD PTR _Cell$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 31		 mov	 esi, DWORD PTR [ecx]
  00080	8b d4		 mov	 edx, esp
  00082	66 89 02	 mov	 WORD PTR [edx], ax
  00085	8a 45 fe	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00088	88 42 02	 mov	 BYTE PTR [edx+2], al
  0008b	ff 56 40	 call	 DWORD PTR [esi+64]
  0008e	50		 push	 eax
  0008f	8b cf		 mov	 ecx, edi
  00091	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  00096	85 c0		 test	 eax, eax
  00098	75 15		 jne	 SHORT $LN3@playerGetI

; 1094 : 		return Py_BuildValue("i", 0);

  0009a	50		 push	 eax

; 1104 : 	return Py_BuildValue("i", iPrice);

  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000a6	83 c4 08	 add	 esp, 8

; 1105 : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
$LN3@playerGetI:

; 1095 : 
; 1096 : 	int iPrice;
; 1097 : 
; 1098 : 	if (pItemData->IsFlag(CItemData::ITEM_FLAG_COUNT_PER_1GOLD))

  000af	8b 4d f8	 mov	 ecx, DWORD PTR _pItemData$[ebp]
  000b2	6a 08		 push	 8
  000b4	e8 00 00 00 00	 call	 ?IsFlag@CItemData@@QBEHK@Z ; CItemData::IsFlag

; 1099 : 		iPrice = CPythonPlayer::Instance().GetItemCount(Cell) / pItemData->GetISellItemPrice();

  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000bf	83 c1 04	 add	 ecx, 4
  000c2	85 c0		 test	 eax, eax
  000c4	66 8b 45 fc	 mov	 ax, WORD PTR _Cell$[ebp]
  000c8	51		 push	 ecx
  000c9	8b d4		 mov	 edx, esp
  000cb	8b 31		 mov	 esi, DWORD PTR [ecx]
  000cd	66 89 02	 mov	 WORD PTR [edx], ax
  000d0	8a 45 fe	 mov	 al, BYTE PTR _Cell$[ebp+2]
  000d3	88 42 02	 mov	 BYTE PTR [edx+2], al
  000d6	74 19		 je	 SHORT $LN2@playerGetI
  000d8	ff 56 48	 call	 DWORD PTR [esi+72]
  000db	8b 4d f8	 mov	 ecx, DWORD PTR _pItemData$[ebp]
  000de	8b f0		 mov	 esi, eax
  000e0	e8 00 00 00 00	 call	 ?GetISellItemPrice@CItemData@@QBEKXZ ; CItemData::GetISellItemPrice
  000e5	8b c8		 mov	 ecx, eax
  000e7	33 d2		 xor	 edx, edx
  000e9	8b c6		 mov	 eax, esi
  000eb	f7 f1		 div	 ecx
  000ed	8b f0		 mov	 esi, eax

; 1100 : 	else

  000ef	eb 10		 jmp	 SHORT $LN1@playerGetI
$LN2@playerGetI:

; 1101 : 		iPrice = pItemData->GetISellItemPrice() * CPythonPlayer::Instance().GetItemCount(Cell);

  000f1	ff 56 48	 call	 DWORD PTR [esi+72]
  000f4	8b 4d f8	 mov	 ecx, DWORD PTR _pItemData$[ebp]
  000f7	8b f0		 mov	 esi, eax
  000f9	e8 00 00 00 00	 call	 ?GetISellItemPrice@CItemData@@QBEKXZ ; CItemData::GetISellItemPrice
  000fe	0f af f0	 imul	 esi, eax
$LN1@playerGetI:

; 1102 : 
; 1103 : 	iPrice /= 5;

  00101	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00106	f7 ee		 imul	 esi
  00108	d1 fa		 sar	 edx, 1
  0010a	8b c2		 mov	 eax, edx
  0010c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0010f	03 c2		 add	 eax, edx

; 1104 : 	return Py_BuildValue("i", iPrice);

  00111	50		 push	 eax
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0011d	83 c4 08	 add	 esp, 8

; 1105 : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
?playerGetISellItemPrice@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetISellItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetQuickPage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetQuickPage@@YAPAU_object@@PAU1@0@Z PROC	; playerGetQuickPage, COMDAT

; 1109 : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetQuickPage());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetQuickPage@CPythonPlayer@@QAEHXZ ; CPythonPlayer::GetQuickPage
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 1110 : }

  0001a	c3		 ret	 0
?playerGetQuickPage@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetQuickPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetQuickPage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iPageIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetQuickPage@@YAPAU_object@@PAU1@0@Z PROC	; playerSetQuickPage, COMDAT

; 1113 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1114 : 	int iPageIndex;
; 1115 : 	if (!PyTuple_GetInteger(poArgs, 0, &iPageIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iPageIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerSetQ

; 1116 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1120 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerSetQ:

; 1117 : 
; 1118 : 	CPythonPlayer::Instance().SetQuickPage(iPageIndex);

  00027	ff 75 fc	 push	 DWORD PTR _iPageIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?SetQuickPage@CPythonPlayer@@QAEXH@Z ; CPythonPlayer::SetQuickPage

; 1119 : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1120 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?playerSetQuickPage@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetQuickPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerLocalQuickSlotIndexToGlobalQuickSlotIndex@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iLocalSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerLocalQuickSlotIndexToGlobalQuickSlotIndex@@YAPAU_object@@PAU1@0@Z PROC ; playerLocalQuickSlotIndexToGlobalQuickSlotIndex, COMDAT

; 1123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1124 : 	int iLocalSlotIndex;
; 1125 : 	if (!PyTuple_GetInteger(poArgs, 0, &iLocalSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iLocalSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerLoca

; 1126 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1130 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerLoca:

; 1127 : 
; 1128 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 1129 : 	return Py_BuildValue("i", rkPlayer.LocalQuickSlotIndexToGlobalQuickSlotIndex(iLocalSlotIndex));

  00027	ff 75 fc	 push	 DWORD PTR _iLocalSlotIndex$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z ; CPythonPlayer::LocalQuickSlotIndexToGlobalQuickSlotIndex
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 1130 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?playerLocalQuickSlotIndexToGlobalQuickSlotIndex@@YAPAU_object@@PAU1@0@Z ENDP ; playerLocalQuickSlotIndexToGlobalQuickSlotIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_dwWndType$ = -12					; size = 4
_dwWndItemPos$ = -8					; size = 4
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetLocalQuickSlot@@YAPAU_object@@PAU1@0@Z PROC	; playerGetLocalQuickSlot, COMDAT

; 1134 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1135 : 	int iSlotIndex;
; 1136 : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN1@playerGetL

; 1137 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1146 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN1@playerGetL:

; 1138 : 
; 1139 : 	DWORD dwWndType;
; 1140 : 	DWORD dwWndItemPos;
; 1141 : 
; 1142 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 1143 : 	rkPlayer.GetLocalQuickSlotData(iSlotIndex, &dwWndType, &dwWndItemPos);

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _dwWndItemPos$[ebp]
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR _dwWndType$[ebp]
  00036	50		 push	 eax
  00037	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetLocalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z ; CPythonPlayer::GetLocalQuickSlotData

; 1144 : 
; 1145 : 	return Py_BuildValue("ii", dwWndType, dwWndItemPos);

  0003f	ff 75 f8	 push	 DWORD PTR _dwWndItemPos$[ebp]
  00042	ff 75 f4	 push	 DWORD PTR _dwWndType$[ebp]
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii?$AA@
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1146 : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?playerGetLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_dwWndType$ = -12					; size = 4
_dwWndItemPos$ = -8					; size = 4
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z PROC	; playerGetGlobalQuickSlot, COMDAT

; 1149 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1150 : 	int iSlotIndex;
; 1151 : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN1@playerGetG

; 1152 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1161 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN1@playerGetG:

; 1153 : 
; 1154 : 	DWORD dwWndType;
; 1155 : 	DWORD dwWndItemPos;
; 1156 : 
; 1157 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 1158 : 	rkPlayer.GetGlobalQuickSlotData(iSlotIndex, &dwWndType, &dwWndItemPos);

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _dwWndItemPos$[ebp]
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR _dwWndType$[ebp]
  00036	50		 push	 eax
  00037	ff 75 fc	 push	 DWORD PTR _iSlotIndex$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetGlobalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z ; CPythonPlayer::GetGlobalQuickSlotData

; 1159 : 
; 1160 : 	return Py_BuildValue("ii", dwWndType, dwWndItemPos);

  0003f	ff 75 f8	 push	 DWORD PTR _dwWndItemPos$[ebp]
  00042	ff 75 f4	 push	 DWORD PTR _dwWndType$[ebp]
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii?$AA@
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1161 : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?playerGetGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetGlobalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRequestAddLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nSlotIndex$ = -12					; size = 4
_nWndType$ = -8						; size = 4
_nWndItemPos$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRequestAddLocalQuickSlot@@YAPAU_object@@PAU1@0@Z PROC ; playerRequestAddLocalQuickSlot, COMDAT

; 1165 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1166 : 	int nSlotIndex;
; 1167 : 	int nWndType;
; 1168 : 	int nWndItemPos;
; 1169 : 	
; 1170 : 	if (!PyTuple_GetInteger(poArgs, 0, &nSlotIndex))

  00006	8d 45 f4	 lea	 eax, DWORD PTR _nSlotIndex$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	84 c0		 test	 al, al
  0001b	75 0f		 jne	 SHORT $LN3@playerRequ
$LN8@playerRequ:

; 1171 : 		return Py_BuildException();

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00024	83 c4 04	 add	 esp, 4
  00027	5e		 pop	 esi

; 1183 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN3@playerRequ:

; 1172 : 
; 1173 : 	if (!PyTuple_GetInteger(poArgs, 1, &nWndType))

  0002c	8d 45 f8	 lea	 eax, DWORD PTR _nWndType$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	74 de		 je	 SHORT $LN8@playerRequ

; 1174 : 		return Py_BuildException();
; 1175 : 
; 1176 : 	if (!PyTuple_GetInteger(poArgs, 2, &nWndItemPos))

  0003f	8d 45 fc	 lea	 eax, DWORD PTR _nWndItemPos$[ebp]
  00042	50		 push	 eax
  00043	6a 02		 push	 2
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	84 c0		 test	 al, al
  00050	74 cb		 je	 SHORT $LN8@playerRequ

; 1177 : 		return Py_BuildException();
; 1178 : 
; 1179 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 1180 : 	rkPlayer.RequestAddLocalQuickSlot(nSlotIndex, nWndType, nWndItemPos);

  00052	ff 75 fc	 push	 DWORD PTR _nWndItemPos$[ebp]
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0005b	ff 75 f8	 push	 DWORD PTR _nWndType$[ebp]
  0005e	ff 75 f4	 push	 DWORD PTR _nSlotIndex$[ebp]
  00061	e8 00 00 00 00	 call	 ?RequestAddLocalQuickSlot@CPythonPlayer@@QAEXKKK@Z ; CPythonPlayer::RequestAddLocalQuickSlot

; 1181 : 
; 1182 : 	return Py_BuildNone();

  00066	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  0006b	5e		 pop	 esi

; 1183 : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?playerRequestAddLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ENDP ; playerRequestAddLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRequestAddToEmptyLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nWndType$ = -8						; size = 4
_nWndItemPos$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRequestAddToEmptyLocalQuickSlot@@YAPAU_object@@PAU1@0@Z PROC ; playerRequestAddToEmptyLocalQuickSlot, COMDAT

; 1186 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1187 : 	int nWndType;
; 1188 : 	if (!PyTuple_GetInteger(poArgs, 0, &nWndType))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _nWndType$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerRequ
$LN7@playerRequ:

; 1189 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1199 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerRequ:

; 1190 : 
; 1191 : 	int nWndItemPos;
; 1192 : 	if (!PyTuple_GetInteger(poArgs, 1, &nWndItemPos))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _nWndItemPos$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@playerRequ

; 1193 : 		return Py_BuildException();
; 1194 : 
; 1195 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 1196 : 	rkPlayer.RequestAddToEmptyLocalQuickSlot(nWndType, nWndItemPos);

  0003e	ff 75 fc	 push	 DWORD PTR _nWndItemPos$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00047	ff 75 f8	 push	 DWORD PTR _nWndType$[ebp]
  0004a	e8 00 00 00 00	 call	 ?RequestAddToEmptyLocalQuickSlot@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::RequestAddToEmptyLocalQuickSlot

; 1197 : 
; 1198 : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1199 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?playerRequestAddToEmptyLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ENDP ; playerRequestAddToEmptyLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRequestDeleteGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nGlobalSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRequestDeleteGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z PROC ; playerRequestDeleteGlobalQuickSlot, COMDAT

; 1202 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1203 : 	int nGlobalSlotIndex;
; 1204 : 	if (!PyTuple_GetInteger(poArgs, 0, &nGlobalSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _nGlobalSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerRequ

; 1205 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1210 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerRequ:

; 1206 : 
; 1207 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 1208 : 	rkPlayer.RequestDeleteGlobalQuickSlot(nGlobalSlotIndex);	

  00027	ff 75 fc	 push	 DWORD PTR _nGlobalSlotIndex$[ebp]
  0002a	e8 00 00 00 00	 call	 ?RequestDeleteGlobalQuickSlot@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RequestDeleteGlobalQuickSlot

; 1209 : 	return Py_BuildNone();

  0002f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1210 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?playerRequestDeleteGlobalQuickSlot@@YAPAU_object@@PAU1@0@Z ENDP ; playerRequestDeleteGlobalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRequestMoveGlobalQuickSlotToLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nGlobalSrcSlotIndex$ = -8				; size = 4
_nLocalDstSlotIndex$ = -4				; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRequestMoveGlobalQuickSlotToLocalQuickSlot@@YAPAU_object@@PAU1@0@Z PROC ; playerRequestMoveGlobalQuickSlotToLocalQuickSlot, COMDAT

; 1213 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1214 : 	int nGlobalSrcSlotIndex;
; 1215 : 	int nLocalDstSlotIndex;
; 1216 : 
; 1217 : 	if (!PyTuple_GetInteger(poArgs, 0, &nGlobalSrcSlotIndex))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _nGlobalSrcSlotIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerRequ
$LN7@playerRequ:

; 1218 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1226 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerRequ:

; 1219 : 
; 1220 : 	if (!PyTuple_GetInteger(poArgs, 1, &nLocalDstSlotIndex))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _nLocalDstSlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@playerRequ

; 1221 : 		return Py_BuildException();
; 1222 : 
; 1223 : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();
; 1224 : 	rkPlayer.RequestMoveGlobalQuickSlotToLocalQuickSlot(nGlobalSrcSlotIndex, nLocalDstSlotIndex);

  0003e	ff 75 fc	 push	 DWORD PTR _nLocalDstSlotIndex$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00047	ff 75 f8	 push	 DWORD PTR _nGlobalSrcSlotIndex$[ebp]
  0004a	e8 00 00 00 00	 call	 ?RequestMoveGlobalQuickSlotToLocalQuickSlot@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::RequestMoveGlobalQuickSlotToLocalQuickSlot

; 1225 : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1226 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?playerRequestMoveGlobalQuickSlotToLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ENDP ; playerRequestMoveGlobalQuickSlotToLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRequestUseLocalQuickSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iLocalPosition$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRequestUseLocalQuickSlot@@YAPAU_object@@PAU1@0@Z PROC ; playerRequestUseLocalQuickSlot, COMDAT

; 1229 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1230 : 	int iLocalPosition;
; 1231 : 	if (!PyTuple_GetInteger(poArgs, 0, &iLocalPosition))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iLocalPosition$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerRequ

; 1232 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1237 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerRequ:

; 1233 : 
; 1234 : 	CPythonPlayer::Instance().RequestUseLocalQuickSlot(iLocalPosition);

  00027	ff 75 fc	 push	 DWORD PTR _iLocalPosition$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?RequestUseLocalQuickSlot@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RequestUseLocalQuickSlot

; 1235 : 
; 1236 : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1237 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?playerRequestUseLocalQuickSlot@@YAPAU_object@@PAU1@0@Z ENDP ; playerRequestUseLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRemoveQuickSlotByValue@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iType$ = -8						; size = 4
_iPosition$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRemoveQuickSlotByValue@@YAPAU_object@@PAU1@0@Z PROC ; playerRemoveQuickSlotByValue, COMDAT

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1241 : 	int iType;
; 1242 : 	if (!PyTuple_GetInteger(poArgs, 0, &iType))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iType$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerRemo
$LN7@playerRemo:

; 1243 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1252 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerRemo:

; 1244 : 	
; 1245 : 	int iPosition;
; 1246 : 	if (!PyTuple_GetInteger(poArgs, 1, &iPosition))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _iPosition$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@playerRemo

; 1247 : 		return Py_BuildException();
; 1248 : 
; 1249 : 	CPythonPlayer::Instance().RemoveQuickSlotByValue(iType, iPosition);

  0003e	ff 75 fc	 push	 DWORD PTR _iPosition$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00047	ff 75 f8	 push	 DWORD PTR _iType$[ebp]
  0004a	e8 00 00 00 00	 call	 ?RemoveQuickSlotByValue@CPythonPlayer@@QAEXHH@Z ; CPythonPlayer::RemoveQuickSlotByValue

; 1250 : 
; 1251 : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1252 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?playerRemoveQuickSlotByValue@@YAPAU_object@@PAU1@0@Z ENDP ; playerRemoveQuickSlotByValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerisItem@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -8					; size = 4
$T1 = -3						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerisItem@@YAPAU_object@@PAU1@0@Z PROC		; playerisItem, COMDAT

; 1255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1256 : 	int iSlotIndex;
; 1257 : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN1@playerisIt

; 1258 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1263 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN1@playerisIt:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  00029	0f b7 45 f8	 movzx	 eax, WORD PTR _iSlotIndex$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1260 : 	char Flag = CPythonPlayer::Instance().IsItem(TItemPos(INVENTORY, iSlotIndex));

  0002d	51		 push	 ecx
  0002e	8b cc		 mov	 ecx, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  00030	66 89 45 fe	 mov	 WORD PTR $T1[ebp+1], ax
  00034	c6 45 fd 01	 mov	 BYTE PTR $T1[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1260 : 	char Flag = CPythonPlayer::Instance().IsItem(TItemPos(INVENTORY, iSlotIndex));

  00038	0f b7 45 fd	 movzx	 eax, WORD PTR $T1[ebp]
  0003c	66 89 01	 mov	 WORD PTR [ecx], ax
  0003f	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp+2]
  00042	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0004b	e8 00 00 00 00	 call	 ?IsItem@CPythonPlayer@@QAEDUSItemPos@@@Z ; CPythonPlayer::IsItem

; 1261 : 
; 1262 : 	return Py_BuildValue("i", Flag);

  00050	0f be c0	 movsx	 eax, al
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0005f	83 c4 08	 add	 esp, 8

; 1263 : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?playerisItem@@YAPAU_object@@PAU1@0@Z ENDP		; playerisItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsEquipmentSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsEquipmentSlot@@YAPAU_object@@PAU1@0@Z PROC	; playerIsEquipmentSlot, COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1280 : 	int iSlotIndex;
; 1281 : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN3@playerIsEq

; 1282 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1289 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@playerIsEq:

; 1283 : 
; 1284 : 	if (iSlotIndex >= c_Equipment_Start)

  00027	8b 45 fc	 mov	 eax, DWORD PTR _iSlotIndex$[ebp]
  0002a	05 1f ff ff ff	 add	 eax, -225		; ffffff1fH
  0002f	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00032	77 14		 ja	 SHORT $LN1@playerIsEq

; 1285 : 	if (iSlotIndex <= c_DragonSoul_Equip_End)
; 1286 : 		return Py_BuildValue("i", 1);

  00034	6a 01		 push	 1

; 1287 : 
; 1288 : 	return Py_BuildValue("i", 0);

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 1289 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
$LN1@playerIsEq:

; 1287 : 
; 1288 : 	return Py_BuildValue("i", 0);

  00048	6a 00		 push	 0
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00055	83 c4 08	 add	 esp, 8

; 1289 : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?playerIsEquipmentSlot@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsEquipmentSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsDSEquipmentSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -8					; size = 4
_bWindowType$ = -1					; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsDSEquipmentSlot@@YAPAU_object@@PAU1@0@Z PROC	; playerIsDSEquipmentSlot, COMDAT

; 1292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1293 : 	BYTE bWindowType;
; 1294 : 	if (!PyTuple_GetInteger(poArgs, 0, &bWindowType))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _bWindowType$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN5@playerIsDS
$LN9@playerIsDS:

; 1295 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1306 : 
; 1307 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN5@playerIsDS:

; 1296 : 	int iSlotIndex;
; 1297 : 	if (!PyTuple_GetInteger(poArgs, 1, &iSlotIndex))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN9@playerIsDS

; 1298 : 		return Py_BuildException();
; 1299 : 
; 1300 : 	if (INVENTORY == bWindowType)

  0003e	80 7d ff 01	 cmp	 BYTE PTR _bWindowType$[ebp], 1
  00042	75 21		 jne	 SHORT $LN1@playerIsDS

; 1301 : 	if (iSlotIndex >= c_DragonSoul_Equip_Start)

  00044	8b 45 f8	 mov	 eax, DWORD PTR _iSlotIndex$[ebp]
  00047	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  0004c	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0004f	77 14		 ja	 SHORT $LN1@playerIsDS

; 1302 : 	if (iSlotIndex <= c_DragonSoul_Equip_End)
; 1303 : 		return Py_BuildValue("i", 1);

  00051	6a 01		 push	 1

; 1304 : 
; 1305 : 	return Py_BuildValue("i", 0);

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0005e	83 c4 08	 add	 esp, 8

; 1306 : 
; 1307 : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN1@playerIsDS:

; 1304 : 
; 1305 : 	return Py_BuildValue("i", 0);

  00065	6a 00		 push	 0
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00072	83 c4 08	 add	 esp, 8

; 1306 : 
; 1307 : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?playerIsDSEquipmentSlot@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsDSEquipmentSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsCostumeSlot@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsCostumeSlot@@YAPAU_object@@PAU1@0@Z PROC	; playerIsCostumeSlot, COMDAT

; 1310 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1311 : 	int iSlotIndex;
; 1312 : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN3@playerIsCo

; 1313 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1322 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@playerIsCo:

; 1314 : 
; 1315 : #ifdef ENABLE_COSTUME_SYSTEM
; 1316 : 	if (iSlotIndex >= c_Costume_Slot_Start)

  00027	8b 45 fc	 mov	 eax, DWORD PTR _iSlotIndex$[ebp]
  0002a	05 0c ff ff ff	 add	 eax, -244		; ffffff0cH
  0002f	83 f8 02	 cmp	 eax, 2
  00032	77 14		 ja	 SHORT $LN1@playerIsCo

; 1317 : 	if (iSlotIndex <= c_Costume_Slot_End)
; 1318 : 		return Py_BuildValue("i", 1);

  00034	6a 01		 push	 1

; 1319 : #endif
; 1320 : 
; 1321 : 	return Py_BuildValue("i", 0);

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 1322 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
$LN1@playerIsCo:

; 1319 : #endif
; 1320 : 
; 1321 : 	return Py_BuildValue("i", 0);

  00048	6a 00		 push	 0
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00055	83 c4 08	 add	 esp, 8

; 1322 : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?playerIsCostumeSlot@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsCostumeSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsOpenPrivateShop@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsOpenPrivateShop@@YAPAU_object@@PAU1@0@Z PROC	; playerIsOpenPrivateShop, COMDAT

; 1326 : 	return Py_BuildValue("i", CPythonPlayer::Instance().IsOpenPrivateShop());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsOpenPrivateShop@CPythonPlayer@@QAE_NXZ ; CPythonPlayer::IsOpenPrivateShop
  0000b	0f b6 c0	 movzx	 eax, al
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 1327 : }

  0001d	c3		 ret	 0
?playerIsOpenPrivateShop@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsOpenPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsValuableItem@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pItemData$1$ = -8					; size = 4
_SlotIndex$ = -4					; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsValuableItem@@YAPAU_object@@PAU1@0@Z PROC	; playerIsValuableItem, COMDAT

; 1330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1333 : 	switch (PyTuple_Size (poArgs))

  00008	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00010	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1333 : 	switch (PyTuple_Size (poArgs))

  00011	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00012	c6 45 fc 01	 mov	 BYTE PTR _SlotIndex$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00016	66 89 45 fd	 mov	 WORD PTR _SlotIndex$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1333 : 	switch (PyTuple_Size (poArgs))

  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00020	83 c4 04	 add	 esp, 4
  00023	48		 dec	 eax
  00024	74 16		 je	 SHORT $LN12@playerIsVa
  00026	48		 dec	 eax
  00027	75 26		 jne	 SHORT $LN33@playerIsVa

; 1338 : 		break;
; 1339 : 	case 2:
; 1340 : 		if (!PyTuple_GetInteger(poArgs, 0, &SlotIndex.window_type))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _SlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	84 c0		 test	 al, al
  0003a	74 13		 je	 SHORT $LN33@playerIsVa
$LN12@playerIsVa:

; 1334 : 	{
; 1335 : 	case 1:
; 1336 : 		if (!PyTuple_GetInteger(poArgs, 0, &SlotIndex.cell))

  0003c	8d 45 fd	 lea	 eax, DWORD PTR _SlotIndex$[ebp+1]
  0003f	50		 push	 eax
  00040	6a 00		 push	 0
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	84 c0		 test	 al, al
  0004d	75 11		 jne	 SHORT $LN11@playerIsVa
$LN33@playerIsVa:

; 1337 : 			return Py_BuildException();

  0004f	6a 00		 push	 0
  00051	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00056	83 c4 04	 add	 esp, 4

; 1367 : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN11@playerIsVa:

; 1341 : 			return Py_BuildException();
; 1342 : 		if (!PyTuple_GetInteger(poArgs, 0, &SlotIndex.cell))
; 1343 : 			return Py_BuildException();
; 1344 : 		break;
; 1345 : 	default:
; 1346 : 		return Py_BuildException();
; 1347 : 	}
; 1348 : 
; 1349 : 	DWORD dwItemIndex = CPythonPlayer::Instance().GetItemIndex(SlotIndex);

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00066	66 8b 45 fc	 mov	 ax, WORD PTR _SlotIndex$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	51		 push	 ecx
  0006e	8b d4		 mov	 edx, esp
  00070	8b 31		 mov	 esi, DWORD PTR [ecx]
  00072	66 89 02	 mov	 WORD PTR [edx], ax
  00075	8a 45 fe	 mov	 al, BYTE PTR _SlotIndex$[ebp+2]
  00078	88 42 02	 mov	 BYTE PTR [edx+2], al
  0007b	ff 56 40	 call	 DWORD PTR [esi+64]

; 1350 : 	CItemManager::Instance().SelectItemData(dwItemIndex);

  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 1351 : 	CItemData * pItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00090	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer
  00095	89 45 f8	 mov	 DWORD PTR _pItemData$1$[ebp], eax

; 1352 : 	if (!pItemData)

  00098	85 c0		 test	 eax, eax
  0009a	75 14		 jne	 SHORT $LN6@playerIsVa

; 1353 : 		return Py_BuildException("Can't find item data");

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BGKCJNBK@Can?8t?5find?5item?5data?$AA@
  000a1	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  000a6	83 c4 04	 add	 esp, 4

; 1367 : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
$LN6@playerIsVa:
  000b0	8a 5d fe	 mov	 bl, BYTE PTR _SlotIndex$[ebp+2]

; 1354 : 
; 1355 : 	BOOL hasMetinSocket = FALSE;

  000b3	33 f6		 xor	 esi, esi

; 1356 : 	BOOL isHighPrice = FALSE;
; 1357 : 
; 1358 : 	for (int i = 0; i < METIN_SOCKET_COUNT; ++i)

  000b5	33 ff		 xor	 edi, edi
$LL5@playerIsVa:

; 1359 : 		if (CPythonPlayer::METIN_SOCKET_TYPE_NONE != CPythonPlayer::Instance().GetItemMetinSocket(SlotIndex, i))

  000b7	57		 push	 edi
  000b8	51		 push	 ecx
  000b9	66 8b 4d fc	 mov	 cx, WORD PTR _SlotIndex$[ebp]
  000bd	8b c4		 mov	 eax, esp
  000bf	66 89 08	 mov	 WORD PTR [eax], cx
  000c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000c8	88 58 02	 mov	 BYTE PTR [eax+2], bl
  000cb	e8 00 00 00 00	 call	 ?GetItemMetinSocket@CPythonPlayer@@QAEKUSItemPos@@K@Z ; CPythonPlayer::GetItemMetinSocket
  000d0	85 c0		 test	 eax, eax
  000d2	b8 01 00 00 00	 mov	 eax, 1
  000d7	0f 45 f0	 cmovne	 esi, eax
  000da	47		 inc	 edi
  000db	83 ff 06	 cmp	 edi, 6
  000de	7c d7		 jl	 SHORT $LL5@playerIsVa

; 1360 : 			hasMetinSocket = TRUE;
; 1361 : 
; 1362 : 	DWORD dwValue = pItemData->GetISellItemPrice();

  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _pItemData$1$[ebp]
  000e3	e8 00 00 00 00	 call	 ?GetISellItemPrice@CItemData@@QBEKXZ ; CItemData::GetISellItemPrice

; 1363 : 	if (dwValue > 5000)

  000e8	3d 88 13 00 00	 cmp	 eax, 5000		; 00001388H
  000ed	bb 00 00 00 00	 mov	 ebx, 0
  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	0f 47 d8	 cmova	 ebx, eax

; 1364 : 		isHighPrice = TRUE;
; 1365 : 
; 1366 : 	return Py_BuildValue("i", hasMetinSocket || isHighPrice);

  000fa	85 f6		 test	 esi, esi
  000fc	75 06		 jne	 SHORT $LN18@playerIsVa
  000fe	85 db		 test	 ebx, ebx
  00100	75 02		 jne	 SHORT $LN18@playerIsVa
  00102	33 c0		 xor	 eax, eax
$LN18@playerIsVa:
  00104	50		 push	 eax
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00110	83 c4 08	 add	 esp, 8

; 1367 : }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
?playerIsValuableItem@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsValuableItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?GetItemGrade@@YAHPBD@Z
_TEXT	SEGMENT
_strName$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
?GetItemGrade@@YAHPBD@Z PROC				; GetItemGrade, COMDAT
; _c_szItemName$ = ecx

; 1370 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 18	 mov	 DWORD PTR __$ArrayPad$[esp+28], eax
  00014	8b d1		 mov	 edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00016	c7 44 24 14 0f
	00 00 00	 mov	 DWORD PTR _strName$[esp+48], 15 ; 0000000fH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1370 : {

  0001e	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _strName$[esp+48], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00027	c6 44 24 04 00	 mov	 BYTE PTR _strName$[esp+32], 0

; 523  : 			: _CSTD strlen(_First));

  0002c	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0002f	75 04		 jne	 SHORT $LN50@GetItemGra
  00031	33 c9		 xor	 ecx, ecx
  00033	eb 0c		 jmp	 SHORT $LN51@GetItemGra
$LN50@GetItemGra:
  00035	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL96@GetItemGra:
  00038	8a 01		 mov	 al, BYTE PTR [ecx]
  0003a	41		 inc	 ecx
  0003b	84 c0		 test	 al, al
  0003d	75 f9		 jne	 SHORT $LL96@GetItemGra
  0003f	2b ce		 sub	 ecx, esi
$LN51@GetItemGra:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00041	51		 push	 ecx
  00042	52		 push	 edx
  00043	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strName$[esp+40]
  00047	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1793 : 		return (this->_Mysize == 0);

  0004c	8b 74 24 14	 mov	 esi, DWORD PTR _strName$[esp+48]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1372 : 	if (strName.empty())

  00050	8b 4c 24 18	 mov	 ecx, DWORD PTR _strName$[esp+52]
  00054	8b 54 24 04	 mov	 edx, DWORD PTR _strName$[esp+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

  00058	85 f6		 test	 esi, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1372 : 	if (strName.empty())

  0005a	75 04		 jne	 SHORT $LN3@GetItemGra
  0005c	33 f6		 xor	 esi, esi
  0005e	eb 1e		 jmp	 SHORT $LN7@GetItemGra
$LN3@GetItemGra:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00060	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00063	8d 44 24 04	 lea	 eax, DWORD PTR _strName$[esp+32]
  00067	0f 43 c2	 cmovae	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1375 : 	char chGrade = strName[strName.length() - 1];

  0006a	8a 44 30 ff	 mov	 al, BYTE PTR [eax+esi-1]

; 1376 : 	if (chGrade < '0' || chGrade > '9')

  0006e	3c 30		 cmp	 al, 48			; 00000030H
  00070	7c 04		 jl	 SHORT $LN1@GetItemGra
  00072	3c 39		 cmp	 al, 57			; 00000039H
  00074	7e 02		 jle	 SHORT $LN2@GetItemGra
$LN1@GetItemGra:

; 1377 : 		chGrade = '0';

  00076	b0 30		 mov	 al, 48			; 00000030H
$LN2@GetItemGra:

; 1378 : 
; 1379 : 	int iGrade = chGrade - '0';

  00078	0f be f0	 movsx	 esi, al
  0007b	83 ee 30	 sub	 esi, 48			; 00000030H
$LN7@GetItemGra:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0007e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00081	72 09		 jb	 SHORT $LN97@GetItemGra
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00089	83 c4 04	 add	 esp, 4
$LN97@GetItemGra:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1381 : }

  0008c	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  00090	8b c6		 mov	 eax, esi
  00092	5e		 pop	 esi
  00093	33 cc		 xor	 ecx, esp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?GetItemGrade@@YAHPBD@Z ENDP				; GetItemGrade
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetItemGrade@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_SlotIndex$ = -4					; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetItemGrade@@YAPAU_object@@PAU1@0@Z PROC	; playerGetItemGrade, COMDAT

; 1384 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1386 : 	switch (PyTuple_Size(poArgs))

  00005	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  00008	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1386 : 	switch (PyTuple_Size(poArgs))

  0000d	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  0000e	c6 45 fc 01	 mov	 BYTE PTR _SlotIndex$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00012	66 89 45 fd	 mov	 WORD PTR _SlotIndex$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1386 : 	switch (PyTuple_Size(poArgs))

  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001c	83 c4 04	 add	 esp, 4
  0001f	48		 dec	 eax
  00020	74 1e		 je	 SHORT $LN7@playerGetI
  00022	48		 dec	 eax
  00023	75 2e		 jne	 SHORT $LN20@playerGetI

; 1391 : 		break;
; 1392 : 	case 2:
; 1393 : 		if (!PyTuple_GetInteger(poArgs, 0, &SlotIndex.window_type))

  00025	8d 45 fc	 lea	 eax, DWORD PTR _SlotIndex$[ebp]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	84 c0		 test	 al, al
  00036	74 1b		 je	 SHORT $LN20@playerGetI

; 1394 : 			return Py_BuildException();
; 1395 : 		if (!PyTuple_GetInteger(poArgs, 1, &SlotIndex.cell))

  00038	8d 45 fd	 lea	 eax, DWORD PTR _SlotIndex$[ebp+1]
  0003b	50		 push	 eax
  0003c	6a 01		 push	 1

; 1396 : 			return Py_BuildException();

  0003e	eb 06		 jmp	 SHORT $LN21@playerGetI
$LN7@playerGetI:

; 1387 : 	{
; 1388 : 	case 1:
; 1389 : 		if (!PyTuple_GetInteger(poArgs, 0, &SlotIndex.cell))

  00040	8d 45 fd	 lea	 eax, DWORD PTR _SlotIndex$[ebp+1]
  00043	50		 push	 eax
  00044	6a 00		 push	 0
$LN21@playerGetI:
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	84 c0		 test	 al, al
  00051	75 0f		 jne	 SHORT $LN6@playerGetI
$LN20@playerGetI:

; 1390 : 			return Py_BuildException();

  00053	6a 00		 push	 0
  00055	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0005a	83 c4 04	 add	 esp, 4

; 1409 : }

  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN6@playerGetI:

; 1397 : 		break;
; 1398 : 	default:
; 1399 : 		return Py_BuildException();
; 1400 : 	}
; 1401 : 
; 1402 : 	int iItemIndex = CPythonPlayer::Instance().GetItemIndex(SlotIndex);

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00068	66 8b 45 fc	 mov	 ax, WORD PTR _SlotIndex$[ebp]
  0006c	83 c1 04	 add	 ecx, 4
  0006f	51		 push	 ecx
  00070	8b d4		 mov	 edx, esp
  00072	8b 31		 mov	 esi, DWORD PTR [ecx]
  00074	66 89 02	 mov	 WORD PTR [edx], ax
  00077	8a 45 fe	 mov	 al, BYTE PTR _SlotIndex$[ebp+2]
  0007a	88 42 02	 mov	 BYTE PTR [edx+2], al
  0007d	ff 56 40	 call	 DWORD PTR [esi+64]

; 1403 : 	CItemManager::Instance().SelectItemData(iItemIndex);

  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 1404 : 	CItemData * pItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00092	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer

; 1405 : 	if (!pItemData)

  00097	85 c0		 test	 eax, eax
  00099	75 12		 jne	 SHORT $LN1@playerGetI

; 1406 : 		return Py_BuildException("Can't find item data");

  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BGKCJNBK@Can?8t?5find?5item?5data?$AA@
  000a0	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  000a5	83 c4 04	 add	 esp, 4

; 1409 : }

  000a8	5e		 pop	 esi
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN1@playerGetI:

; 1407 : 
; 1408 : 	return Py_BuildValue("i", GetItemGrade(pItemData->GetName()));

  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  000b4	8b c8		 mov	 ecx, eax
  000b6	e8 00 00 00 00	 call	 ?GetItemGrade@@YAHPBD@Z	; GetItemGrade
  000bb	50		 push	 eax
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000c7	83 c4 08	 add	 esp, 8

; 1409 : }

  000ca	5e		 pop	 esi
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?playerGetItemGrade@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetItemGrade
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerCanRefine@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iScrollItemIndex$ = -8					; size = 4
_TargetSlotIndex$ = -4					; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerCanRefine@@YAPAU_object@@PAU1@0@Z PROC		; playerCanRefine, COMDAT

; 1441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1445 : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000f	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1445 : 	switch (PyTuple_Size(poArgs))

  00010	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00011	c6 45 fc 01	 mov	 BYTE PTR _TargetSlotIndex$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00015	66 89 45 fd	 mov	 WORD PTR _TargetSlotIndex$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1445 : 	switch (PyTuple_Size(poArgs))

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001f	83 c4 04	 add	 esp, 4
  00022	83 e8 02	 sub	 eax, 2
  00025	74 47		 je	 SHORT $LN16@playerCanR
  00027	48		 dec	 eax
  00028	75 39		 jne	 SHORT $LN37@playerCanR

; 1451 : 			return Py_BadArgument();
; 1452 : 		break;
; 1453 : 	case 3:
; 1454 : 		if (!PyTuple_GetInteger(poArgs, 0, &iScrollItemIndex))

  0002a	8d 45 f8	 lea	 eax, DWORD PTR _iScrollItemIndex$[ebp]
  0002d	50		 push	 eax
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	84 c0		 test	 al, al
  0003b	74 26		 je	 SHORT $LN37@playerCanR

; 1455 : 			return Py_BadArgument();
; 1456 : 		if (!PyTuple_GetInteger(poArgs, 1, &TargetSlotIndex.window_type))

  0003d	8d 45 fc	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp]
  00040	50		 push	 eax
  00041	6a 01		 push	 1
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	84 c0		 test	 al, al
  0004e	74 13		 je	 SHORT $LN37@playerCanR

; 1457 : 			return Py_BadArgument();
; 1458 : 		if (!PyTuple_GetInteger(poArgs, 2, &TargetSlotIndex.cell))

  00050	8d 45 fd	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp+1]
  00053	50		 push	 eax
  00054	6a 02		 push	 2
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	84 c0		 test	 al, al
  00061	75 31		 jne	 SHORT $LN14@playerCanR
$LN37@playerCanR:

; 1459 : 			return Py_BadArgument();

  00063	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 1500 : 	}
; 1501 : 
; 1502 : 	return Py_BuildValue("i", REFINE_CANT);
; 1503 : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN16@playerCanR:

; 1446 : 	{
; 1447 : 	case 2:
; 1448 : 		if (!PyTuple_GetInteger(poArgs, 0, &iScrollItemIndex))

  0006e	8d 45 f8	 lea	 eax, DWORD PTR _iScrollItemIndex$[ebp]
  00071	50		 push	 eax
  00072	6a 00		 push	 0
  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	84 c0		 test	 al, al
  0007f	74 e2		 je	 SHORT $LN37@playerCanR

; 1449 : 			return Py_BadArgument();
; 1450 : 		if (!PyTuple_GetInteger(poArgs, 1, &TargetSlotIndex.cell))

  00081	8d 45 fd	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp+1]
  00084	50		 push	 eax
  00085	6a 01		 push	 1
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	84 c0		 test	 al, al
  00092	74 cf		 je	 SHORT $LN37@playerCanR
$LN14@playerCanR:

; 1460 : 		break;
; 1461 : 	default:
; 1462 : 		return Py_BadArgument();
; 1463 : 	}
; 1464 : 
; 1465 : 	if (CPythonPlayer::Instance().IsEquipmentSlot(TargetSlotIndex))

  00094	66 8b 45 fc	 mov	 ax, WORD PTR _TargetSlotIndex$[ebp]
  00098	51		 push	 ecx
  00099	8b cc		 mov	 ecx, esp
  0009b	66 89 01	 mov	 WORD PTR [ecx], ax
  0009e	8a 45 fe	 mov	 al, BYTE PTR _TargetSlotIndex$[ebp+2]
  000a1	88 41 02	 mov	 BYTE PTR [ecx+2], al
  000a4	e8 00 00 00 00	 call	 ?IsEquipmentSlot@CPythonPlayer@@QAE_NUSItemPos@@@Z ; CPythonPlayer::IsEquipmentSlot
  000a9	84 c0		 test	 al, al
  000ab	74 16		 je	 SHORT $LN8@playerCanR

; 1466 : 	{
; 1467 : 		return Py_BuildValue("i", REFINE_CANT_REFINE_METIN_TO_EQUIPMENT);

  000ad	6a 06		 push	 6

; 1496 : 	}
; 1497 : 	else
; 1498 : 	{
; 1499 : 		return Py_BuildValue("i", REFINE_NOT_NEXT_GRADE_ITEM);

  000af	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000ba	83 c4 08	 add	 esp, 8

; 1500 : 	}
; 1501 : 
; 1502 : 	return Py_BuildValue("i", REFINE_CANT);
; 1503 : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
$LN8@playerCanR:

; 1468 : 	}
; 1469 : 
; 1470 : 	// Scroll
; 1471 : 	CItemManager::Instance().SelectItemData(iScrollItemIndex);

  000c3	ff 75 f8	 push	 DWORD PTR _iScrollItemIndex$[ebp]
  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  000cc	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 1472 : 	CItemData * pScrollItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  000d7	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer
  000dc	8b f8		 mov	 edi, eax

; 1473 : 	if (!pScrollItemData)

  000de	85 ff		 test	 edi, edi
  000e0	75 16		 jne	 SHORT $LN7@playerCanR
$LN36@playerCanR:

; 1474 : 		return Py_BuildValue("i", REFINE_CANT);

  000e2	6a 00		 push	 0

; 1496 : 	}
; 1497 : 	else
; 1498 : 	{
; 1499 : 		return Py_BuildValue("i", REFINE_NOT_NEXT_GRADE_ITEM);

  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000ef	83 c4 08	 add	 esp, 8

; 1500 : 	}
; 1501 : 
; 1502 : 	return Py_BuildValue("i", REFINE_CANT);
; 1503 : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
$LN7@playerCanR:

; 1475 : 	int iScrollType = pScrollItemData->GetType();

  000f8	8b cf		 mov	 ecx, edi
  000fa	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType

; 1476 : 	int iScrollSubType = pScrollItemData->GetSubType();

  000ff	8b cf		 mov	 ecx, edi
  00101	0f b6 f0	 movzx	 esi, al
  00104	e8 00 00 00 00	 call	 ?GetSubType@CItemData@@QBEEXZ ; CItemData::GetSubType
  00109	0f b6 c0	 movzx	 eax, al

; 1477 : 	if (iScrollType != CItemData::ITEM_TYPE_USE)

  0010c	83 fe 03	 cmp	 esi, 3
  0010f	75 d1		 jne	 SHORT $LN36@playerCanR

; 1478 : 		return Py_BuildValue("i", REFINE_CANT);
; 1479 : 	if (iScrollSubType != CItemData::USE_TUNING)

  00111	83 f8 02	 cmp	 eax, 2
  00114	75 cc		 jne	 SHORT $LN36@playerCanR

; 1480 : 		return Py_BuildValue("i", REFINE_CANT);
; 1481 : 
; 1482 : 	// Target Item
; 1483 : 	int iTargetItemIndex = CPythonPlayer::Instance().GetItemIndex(TargetSlotIndex);

  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0011c	66 8b 45 fc	 mov	 ax, WORD PTR _TargetSlotIndex$[ebp]
  00120	83 c1 04	 add	 ecx, 4
  00123	51		 push	 ecx
  00124	8b d4		 mov	 edx, esp
  00126	8b 31		 mov	 esi, DWORD PTR [ecx]
  00128	66 89 02	 mov	 WORD PTR [edx], ax
  0012b	8a 45 fe	 mov	 al, BYTE PTR _TargetSlotIndex$[ebp+2]
  0012e	88 42 02	 mov	 BYTE PTR [edx+2], al
  00131	ff 56 40	 call	 DWORD PTR [esi+64]

; 1484 : 	CItemManager::Instance().SelectItemData(iTargetItemIndex);

  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 1485 : 	CItemData * pTargetItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00146	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer
  0014b	8b f0		 mov	 esi, eax

; 1486 : 	if (!pTargetItemData)

  0014d	85 f6		 test	 esi, esi
  0014f	74 91		 je	 SHORT $LN36@playerCanR

; 1487 : 		return Py_BuildValue("i", REFINE_CANT);
; 1488 : 	int iTargetType = pTargetItemData->GetType();

  00151	8b ce		 mov	 ecx, esi
  00153	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType

; 1489 : 	//int iTargetSubType = pTargetItemData->GetSubType();
; 1490 : 	if (CItemData::ITEM_TYPE_ROD == iTargetType)

  00158	3c 0d		 cmp	 al, 13			; 0000000dH
  0015a	75 16		 jne	 SHORT $LN3@playerCanR

; 1491 : 		return Py_BuildValue("i", REFINE_CANT_REFINE_ROD);

  0015c	6a 07		 push	 7

; 1496 : 	}
; 1497 : 	else
; 1498 : 	{
; 1499 : 		return Py_BuildValue("i", REFINE_NOT_NEXT_GRADE_ITEM);

  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00169	83 c4 08	 add	 esp, 8

; 1500 : 	}
; 1501 : 
; 1502 : 	return Py_BuildValue("i", REFINE_CANT);
; 1503 : }

  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
$LN3@playerCanR:

; 1492 : 
; 1493 : 	if (pTargetItemData->HasNextGrade())

  00172	8b ce		 mov	 ecx, esi
  00174	e8 00 00 00 00	 call	 ?HasNextGrade@CItemData@@QBEHXZ ; CItemData::HasNextGrade
  00179	85 c0		 test	 eax, eax
  0017b	74 16		 je	 SHORT $LN2@playerCanR

; 1494 : 	{
; 1495 : 		return Py_BuildValue("i", REFINE_OK);

  0017d	6a 01		 push	 1

; 1496 : 	}
; 1497 : 	else
; 1498 : 	{
; 1499 : 		return Py_BuildValue("i", REFINE_NOT_NEXT_GRADE_ITEM);

  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0018a	83 c4 08	 add	 esp, 8

; 1500 : 	}
; 1501 : 
; 1502 : 	return Py_BuildValue("i", REFINE_CANT);
; 1503 : }

  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c3		 ret	 0
$LN2@playerCanR:

; 1496 : 	}
; 1497 : 	else
; 1498 : 	{
; 1499 : 		return Py_BuildValue("i", REFINE_NOT_NEXT_GRADE_ITEM);

  00193	6a 05		 push	 5
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  001a0	83 c4 08	 add	 esp, 8

; 1500 : 	}
; 1501 : 
; 1502 : 	return Py_BuildValue("i", REFINE_CANT);
; 1503 : }

  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi
  001a5	8b e5		 mov	 esp, ebp
  001a7	5d		 pop	 ebp
  001a8	c3		 ret	 0
?playerCanRefine@@YAPAU_object@@PAU1@0@Z ENDP		; playerCanRefine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerCanAttachMetin@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pMetinItemData$ = -16					; size = 4
_pTargetItemData$ = -12					; size = 4
_iMetinItemID$ = -8					; size = 4
_TargetSlotIndex$ = -4					; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerCanAttachMetin@@YAPAU_object@@PAU1@0@Z PROC	; playerCanAttachMetin, COMDAT

; 1516 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1520 : 	switch (PyTuple_Size(poArgs))

  00008	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00010	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1520 : 	switch (PyTuple_Size(poArgs))

  00011	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00012	c6 45 fc 01	 mov	 BYTE PTR _TargetSlotIndex$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00016	66 89 45 fd	 mov	 WORD PTR _TargetSlotIndex$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1520 : 	switch (PyTuple_Size(poArgs))

  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00020	83 c4 04	 add	 esp, 4
  00023	83 e8 02	 sub	 eax, 2
  00026	74 4d		 je	 SHORT $LN25@playerCanA
  00028	48		 dec	 eax
  00029	75 39		 jne	 SHORT $LN50@playerCanA

; 1526 : 			return Py_BuildException();
; 1527 : 		break;
; 1528 : 	case 3:
; 1529 : 		if (!PyTuple_GetInteger(poArgs, 0, &iMetinItemID))

  0002b	8d 45 f8	 lea	 eax, DWORD PTR _iMetinItemID$[ebp]
  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 26		 je	 SHORT $LN50@playerCanA

; 1530 : 			return Py_BuildException();
; 1531 : 		if (!PyTuple_GetInteger(poArgs, 1, &TargetSlotIndex.window_type))

  0003e	8d 45 fc	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp]
  00041	50		 push	 eax
  00042	6a 01		 push	 1
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	84 c0		 test	 al, al
  0004f	74 13		 je	 SHORT $LN50@playerCanA

; 1532 : 			return Py_BuildException();
; 1533 : 		if (!PyTuple_GetInteger(poArgs, 2, &TargetSlotIndex.cell))

  00051	8d 45 fd	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp+1]
  00054	50		 push	 eax
  00055	6a 02		 push	 2
  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	84 c0		 test	 al, al
  00062	75 37		 jne	 SHORT $LN23@playerCanA
$LN50@playerCanA:

; 1534 : 			return Py_BuildException();

  00064	6a 00		 push	 0
  00066	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0006b	83 c4 04	 add	 esp, 4

; 1593 : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN25@playerCanA:

; 1521 : 	{
; 1522 : 	case 2:
; 1523 : 		if (!PyTuple_GetInteger(poArgs, 0, &iMetinItemID))

  00075	8d 45 f8	 lea	 eax, DWORD PTR _iMetinItemID$[ebp]
  00078	50		 push	 eax
  00079	6a 00		 push	 0
  0007b	56		 push	 esi
  0007c	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	84 c0		 test	 al, al
  00086	74 dc		 je	 SHORT $LN50@playerCanA

; 1524 : 			return Py_BuildException();
; 1525 : 		if (!PyTuple_GetInteger(poArgs, 1, &TargetSlotIndex.cell))

  00088	8d 45 fd	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp+1]
  0008b	50		 push	 eax
  0008c	6a 01		 push	 1
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
  00097	84 c0		 test	 al, al
  00099	74 c9		 je	 SHORT $LN50@playerCanA
$LN23@playerCanA:

; 1535 : 		break;
; 1536 : 	default:
; 1537 : 		return Py_BuildException();
; 1538 : 	}
; 1539 : 	if (CPythonPlayer::Instance().IsEquipmentSlot(TargetSlotIndex))

  0009b	66 8b 45 fc	 mov	 ax, WORD PTR _TargetSlotIndex$[ebp]
  0009f	51		 push	 ecx
  000a0	8b cc		 mov	 ecx, esp
  000a2	66 89 01	 mov	 WORD PTR [ecx], ax
  000a5	8a 45 fe	 mov	 al, BYTE PTR _TargetSlotIndex$[ebp+2]
  000a8	88 41 02	 mov	 BYTE PTR [ecx+2], al
  000ab	e8 00 00 00 00	 call	 ?IsEquipmentSlot@CPythonPlayer@@QAE_NUSItemPos@@@Z ; CPythonPlayer::IsEquipmentSlot
  000b0	84 c0		 test	 al, al
  000b2	74 07		 je	 SHORT $LN17@playerCanA

; 1540 : 	{
; 1541 : 		return Py_BuildValue("i", ATTACH_METIN_CANT_ATTACH_TO_EQUIPMENT);

  000b4	6a 05		 push	 5
  000b6	e9 e4 00 00 00	 jmp	 $LN49@playerCanA
$LN17@playerCanA:

; 1542 : 	}
; 1543 : 
; 1544 : 	CItemData * pMetinItemData;
; 1545 : 	if (!CItemManager::Instance().GetItemDataPointer(iMetinItemID, &pMetinItemData))

  000bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  000c1	8d 45 f0	 lea	 eax, DWORD PTR _pMetinItemData$[ebp]
  000c4	50		 push	 eax
  000c5	ff 75 f8	 push	 DWORD PTR _iMetinItemID$[ebp]
  000c8	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  000cd	85 c0		 test	 eax, eax
  000cf	75 14		 jne	 SHORT $LN16@playerCanA
$LN51@playerCanA:

; 1546 : 		return Py_BuildException("can't find item data");

  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IBGKLIMC@can?8t?5find?5item?5data?$AA@
  000d6	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  000db	83 c4 04	 add	 esp, 4

; 1593 : }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
$LN16@playerCanA:

; 1547 : 
; 1548 : 	DWORD dwTargetItemIndex = CPythonPlayer::Instance().GetItemIndex(TargetSlotIndex);

  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000eb	66 8b 45 fc	 mov	 ax, WORD PTR _TargetSlotIndex$[ebp]
  000ef	83 c1 04	 add	 ecx, 4
  000f2	51		 push	 ecx
  000f3	8b d4		 mov	 edx, esp
  000f5	8b 31		 mov	 esi, DWORD PTR [ecx]
  000f7	66 89 02	 mov	 WORD PTR [edx], ax
  000fa	8a 45 fe	 mov	 al, BYTE PTR _TargetSlotIndex$[ebp+2]
  000fd	88 42 02	 mov	 BYTE PTR [edx+2], al
  00100	ff 56 40	 call	 DWORD PTR [esi+64]

; 1549 : 	CItemData * pTargetItemData;
; 1550 : 	if (!CItemManager::Instance().GetItemDataPointer(dwTargetItemIndex, &pTargetItemData))

  00103	8d 4d f4	 lea	 ecx, DWORD PTR _pTargetItemData$[ebp]
  00106	51		 push	 ecx
  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  00113	85 c0		 test	 eax, eax
  00115	74 ba		 je	 SHORT $LN51@playerCanA

; 1551 : 		return Py_BuildException("can't find item data");
; 1552 : 
; 1553 : 	DWORD dwMetinWearFlags = pMetinItemData->GetWearFlags();

  00117	8b 4d f0	 mov	 ecx, DWORD PTR _pMetinItemData$[ebp]
  0011a	e8 00 00 00 00	 call	 ?GetWearFlags@CItemData@@QBEKXZ ; CItemData::GetWearFlags

; 1554 : 	DWORD dwTargetWearFlags = pTargetItemData->GetWearFlags();

  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetItemData$[ebp]
  00122	8b f0		 mov	 esi, eax
  00124	e8 00 00 00 00	 call	 ?GetWearFlags@CItemData@@QBEKXZ ; CItemData::GetWearFlags

; 1555 : 	if (0 == (dwMetinWearFlags & dwTargetWearFlags))

  00129	85 c6		 test	 eax, esi
  0012b	75 04		 jne	 SHORT $LN14@playerCanA

; 1556 : 		return Py_BuildValue("i", ATTACH_METIN_NOT_MATCHABLE_ITEM);

  0012d	6a 02		 push	 2
  0012f	eb 6e		 jmp	 SHORT $LN49@playerCanA
$LN14@playerCanA:

; 1557 : 	if (CItemData::ITEM_TYPE_ROD == pTargetItemData->GetType())

  00131	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetItemData$[ebp]
  00134	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType
  00139	3c 0d		 cmp	 al, 13			; 0000000dH
  0013b	75 04		 jne	 SHORT $LN13@playerCanA

; 1558 : 		return Py_BuildValue("i", ATTACH_METIN_CANT);

  0013d	6a 00		 push	 0
  0013f	eb 5e		 jmp	 SHORT $LN49@playerCanA
$LN13@playerCanA:

; 1559 : 
; 1560 : 	BOOL bNotExistGoldSocket = FALSE;
; 1561 : 
; 1562 : 	int iSubType = pMetinItemData->GetSubType();

  00141	8b 4d f0	 mov	 ecx, DWORD PTR _pMetinItemData$[ebp]
  00144	33 ff		 xor	 edi, edi
  00146	e8 00 00 00 00	 call	 ?GetSubType@CItemData@@QBEEXZ ; CItemData::GetSubType
  0014b	0f b6 d8	 movzx	 ebx, al

; 1563 : 	for (int i = 0; i < ITEM_SOCKET_SLOT_MAX_NUM; ++i)

  0014e	33 f6		 xor	 esi, esi
$LL12@playerCanA:

; 1564 : 	{
; 1565 : 		DWORD dwSocketType = CPythonPlayer::Instance().GetItemMetinSocket(TargetSlotIndex, i);

  00150	56		 push	 esi
  00151	51		 push	 ecx
  00152	66 8b 4d fc	 mov	 cx, WORD PTR _TargetSlotIndex$[ebp]
  00156	8b c4		 mov	 eax, esp
  00158	66 89 08	 mov	 WORD PTR [eax], cx
  0015b	8a 4d fe	 mov	 cl, BYTE PTR _TargetSlotIndex$[ebp+2]
  0015e	88 48 02	 mov	 BYTE PTR [eax+2], cl
  00161	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00167	e8 00 00 00 00	 call	 ?GetItemMetinSocket@CPythonPlayer@@QAEKUSItemPos@@K@Z ; CPythonPlayer::GetItemMetinSocket

; 1566 : 		if (CItemData::METIN_NORMAL == iSubType)

  0016c	85 db		 test	 ebx, ebx
  0016e	75 0e		 jne	 SHORT $LN9@playerCanA

; 1567 : 		{
; 1568 : 			if (CPythonPlayer::METIN_SOCKET_TYPE_SILVER == dwSocketType ||
; 1569 : 				CPythonPlayer::METIN_SOCKET_TYPE_GOLD == dwSocketType)

  00170	83 f8 01	 cmp	 eax, 1
  00173	74 05		 je	 SHORT $LN43@playerCanA
  00175	83 f8 02	 cmp	 eax, 2
  00178	75 15		 jne	 SHORT $LN11@playerCanA
$LN43@playerCanA:

; 1570 : 			{
; 1571 : 				return Py_BuildValue("i", ATTACH_METIN_OK);

  0017a	6a 01		 push	 1
  0017c	eb 21		 jmp	 SHORT $LN49@playerCanA
$LN9@playerCanA:

; 1572 : 			}
; 1573 : 		}
; 1574 : 		else if (CItemData::METIN_GOLD == iSubType)

  0017e	83 fb 01	 cmp	 ebx, 1
  00181	75 0c		 jne	 SHORT $LN11@playerCanA

; 1575 : 		{
; 1576 : 			if (CPythonPlayer::METIN_SOCKET_TYPE_GOLD == dwSocketType)

  00183	83 f8 02	 cmp	 eax, 2
  00186	74 f2		 je	 SHORT $LN43@playerCanA

; 1577 : 			{
; 1578 : 				return Py_BuildValue("i", ATTACH_METIN_OK);
; 1579 : 			}
; 1580 : 			else if (CPythonPlayer::METIN_SOCKET_TYPE_SILVER == dwSocketType)

  00188	3b c3		 cmp	 eax, ebx
  0018a	8b c3		 mov	 eax, ebx
  0018c	0f 44 f8	 cmove	 edi, eax
$LN11@playerCanA:

; 1563 : 	for (int i = 0; i < ITEM_SOCKET_SLOT_MAX_NUM; ++i)

  0018f	46		 inc	 esi
  00190	83 fe 03	 cmp	 esi, 3
  00193	7c bb		 jl	 SHORT $LL12@playerCanA

; 1581 : 			{
; 1582 : 				bNotExistGoldSocket = TRUE;
; 1583 : 			}
; 1584 : 		}
; 1585 : 	}
; 1586 : 
; 1587 : 	if (bNotExistGoldSocket)

  00195	85 ff		 test	 edi, edi
  00197	74 04		 je	 SHORT $LN1@playerCanA

; 1588 : 	{
; 1589 : 		return Py_BuildValue("i", ATTACH_METIN_NOT_EXIST_GOLD_SOCKET);

  00199	6a 04		 push	 4
  0019b	eb 02		 jmp	 SHORT $LN49@playerCanA
$LN1@playerCanA:

; 1590 : 	}
; 1591 : 
; 1592 : 	return Py_BuildValue("i", ATTACH_METIN_NO_MATCHABLE_SOCKET);

  0019d	6a 03		 push	 3
$LN49@playerCanA:
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  001aa	83 c4 08	 add	 esp, 8

; 1593 : }

  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	5b		 pop	 ebx
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c3		 ret	 0
?playerCanAttachMetin@@YAPAU_object@@PAU1@0@Z ENDP	; playerCanAttachMetin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerCanDetach@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iScrollItemIndex$ = -8					; size = 4
_TargetSlotIndex$ = -4					; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerCanDetach@@YAPAU_object@@PAU1@0@Z PROC		; playerCanDetach, COMDAT

; 1602 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1605 : 	switch (PyTuple_Size (poArgs))

  00008	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00010	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1605 : 	switch (PyTuple_Size (poArgs))

  00011	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00012	c6 45 fc 01	 mov	 BYTE PTR _TargetSlotIndex$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00016	66 89 45 fd	 mov	 WORD PTR _TargetSlotIndex$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1605 : 	switch (PyTuple_Size (poArgs))

  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  00020	83 c4 04	 add	 esp, 4
  00023	83 e8 02	 sub	 eax, 2
  00026	74 48		 je	 SHORT $LN17@playerCanD
  00028	48		 dec	 eax
  00029	75 39		 jne	 SHORT $LN42@playerCanD

; 1611 : 			return Py_BadArgument();
; 1612 : 		break;
; 1613 : 	case 3:
; 1614 : 		if (!PyTuple_GetInteger(poArgs, 0, &iScrollItemIndex))

  0002b	8d 45 f8	 lea	 eax, DWORD PTR _iScrollItemIndex$[ebp]
  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 26		 je	 SHORT $LN42@playerCanD

; 1615 : 			return Py_BadArgument();
; 1616 : 		if (!PyTuple_GetInteger(poArgs, 1, &TargetSlotIndex.window_type))

  0003e	8d 45 fc	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp]
  00041	50		 push	 eax
  00042	6a 01		 push	 1
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	84 c0		 test	 al, al
  0004f	74 13		 je	 SHORT $LN42@playerCanD

; 1617 : 			return Py_BadArgument();
; 1618 : 		if (!PyTuple_GetInteger(poArgs, 2, &TargetSlotIndex.cell))

  00051	8d 45 fd	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp+1]
  00054	50		 push	 eax
  00055	6a 02		 push	 2
  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	84 c0		 test	 al, al
  00062	75 32		 jne	 SHORT $LN15@playerCanD
$LN42@playerCanD:

; 1619 : 			return Py_BadArgument();

  00064	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 1656 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN17@playerCanD:

; 1606 : 	{
; 1607 : 	case 2:
; 1608 : 		if (!PyTuple_GetInteger(poArgs, 0, &iScrollItemIndex))

  00070	8d 45 f8	 lea	 eax, DWORD PTR _iScrollItemIndex$[ebp]
  00073	50		 push	 eax
  00074	6a 00		 push	 0
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	84 c0		 test	 al, al
  00081	74 e1		 je	 SHORT $LN42@playerCanD

; 1609 : 			return Py_BadArgument();
; 1610 : 		if (!PyTuple_GetInteger(poArgs, 1, &TargetSlotIndex.cell))

  00083	8d 45 fd	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp+1]
  00086	50		 push	 eax
  00087	6a 01		 push	 1
  00089	56		 push	 esi
  0008a	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00092	84 c0		 test	 al, al
  00094	74 ce		 je	 SHORT $LN42@playerCanD
$LN15@playerCanD:

; 1620 : 		break;
; 1621 : 	default:
; 1622 : 		return Py_BadArgument();
; 1623 : 	}
; 1624 : 
; 1625 : 	// Scroll
; 1626 : 	CItemManager::Instance().SelectItemData(iScrollItemIndex);

  00096	ff 75 f8	 push	 DWORD PTR _iScrollItemIndex$[ebp]
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0009f	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 1627 : 	CItemData * pScrollItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  000aa	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer
  000af	8b f8		 mov	 edi, eax

; 1628 : 	if (!pScrollItemData)

  000b1	85 ff		 test	 edi, edi
  000b3	75 14		 jne	 SHORT $LN9@playerCanD
$LN43@playerCanD:

; 1629 : 		return Py_BuildException("Can't find item data");

  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BGKCJNBK@Can?8t?5find?5item?5data?$AA@
  000ba	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  000bf	83 c4 04	 add	 esp, 4

; 1656 : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
$LN9@playerCanD:

; 1630 : 	int iScrollType = pScrollItemData->GetType();

  000c9	8b cf		 mov	 ecx, edi
  000cb	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType

; 1631 : 	int iScrollSubType = pScrollItemData->GetSubType();

  000d0	8b cf		 mov	 ecx, edi
  000d2	0f b6 f0	 movzx	 esi, al
  000d5	e8 00 00 00 00	 call	 ?GetSubType@CItemData@@QBEEXZ ; CItemData::GetSubType
  000da	0f b6 c0	 movzx	 eax, al

; 1632 : 	if (iScrollType != CItemData::ITEM_TYPE_USE)

  000dd	83 fe 03	 cmp	 esi, 3
  000e0	75 74		 jne	 SHORT $LN2@playerCanD

; 1633 : 		return Py_BuildValue("i", DETACH_METIN_CANT);
; 1634 : 	if (iScrollSubType != CItemData::USE_DETACHMENT)

  000e2	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  000e5	75 6f		 jne	 SHORT $LN2@playerCanD

; 1635 : 		return Py_BuildValue("i", DETACH_METIN_CANT);
; 1636 : 
; 1637 : 	// Target Item
; 1638 : 	int iTargetItemIndex = CPythonPlayer::Instance().GetItemIndex(TargetSlotIndex);

  000e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000ed	66 8b 45 fc	 mov	 ax, WORD PTR _TargetSlotIndex$[ebp]
  000f1	83 c1 04	 add	 ecx, 4
  000f4	51		 push	 ecx
  000f5	8b d4		 mov	 edx, esp
  000f7	8b 31		 mov	 esi, DWORD PTR [ecx]
  000f9	66 89 02	 mov	 WORD PTR [edx], ax
  000fc	8a 45 fe	 mov	 al, BYTE PTR _TargetSlotIndex$[ebp+2]
  000ff	88 42 02	 mov	 BYTE PTR [edx+2], al
  00102	ff 56 40	 call	 DWORD PTR [esi+64]

; 1639 : 	CItemManager::Instance().SelectItemData(iTargetItemIndex);

  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 1640 : 	CItemData * pTargetItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00117	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer

; 1641 : 	if (!pTargetItemData)

  0011c	85 c0		 test	 eax, eax
  0011e	74 95		 je	 SHORT $LN43@playerCanD

; 1642 : 		return Py_BuildException("Can't find item data");
; 1643 : 	//int iTargetType = pTargetItemData->GetType();
; 1644 : 	//int iTargetSubType = pTargetItemData->GetSubType();
; 1645 : 
; 1646 : 	if (pTargetItemData->IsFlag(CItemData::ITEM_FLAG_REFINEABLE))

  00120	6a 01		 push	 1
  00122	8b c8		 mov	 ecx, eax
  00124	e8 00 00 00 00	 call	 ?IsFlag@CItemData@@QBEHK@Z ; CItemData::IsFlag
  00129	85 c0		 test	 eax, eax
  0012b	74 29		 je	 SHORT $LN2@playerCanD

; 1647 : 	{
; 1648 : 		for (int iSlotCount = 0; iSlotCount < METIN_SOCKET_COUNT; ++iSlotCount)

  0012d	8a 5d fe	 mov	 bl, BYTE PTR _TargetSlotIndex$[ebp+2]
  00130	33 f6		 xor	 esi, esi
  00132	66 8b 7d fc	 mov	 di, WORD PTR _TargetSlotIndex$[ebp]
$LL4@playerCanD:

; 1649 : 			if (CPythonPlayer::Instance().GetItemMetinSocket(TargetSlotIndex, iSlotCount) > 2)

  00136	56		 push	 esi
  00137	51		 push	 ecx
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0013e	8b c4		 mov	 eax, esp
  00140	66 89 38	 mov	 WORD PTR [eax], di
  00143	88 58 02	 mov	 BYTE PTR [eax+2], bl
  00146	e8 00 00 00 00	 call	 ?GetItemMetinSocket@CPythonPlayer@@QAEKUSItemPos@@K@Z ; CPythonPlayer::GetItemMetinSocket
  0014b	83 f8 02	 cmp	 eax, 2
  0014e	77 1d		 ja	 SHORT $LN37@playerCanD

; 1647 : 	{
; 1648 : 		for (int iSlotCount = 0; iSlotCount < METIN_SOCKET_COUNT; ++iSlotCount)

  00150	46		 inc	 esi
  00151	83 fe 06	 cmp	 esi, 6
  00154	7c e0		 jl	 SHORT $LL4@playerCanD
$LN2@playerCanD:

; 1652 : 			}
; 1653 : 	}
; 1654 : 
; 1655 : 	return Py_BuildValue("i", DETACH_METIN_CANT);

  00156	6a 00		 push	 0
$LN41@playerCanD:
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00163	83 c4 08	 add	 esp, 8

; 1656 : }

  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
$LN37@playerCanD:

; 1650 : 			{
; 1651 : 				return Py_BuildValue("i", DETACH_METIN_OK);

  0016d	6a 01		 push	 1
  0016f	eb e7		 jmp	 SHORT $LN41@playerCanD
?playerCanDetach@@YAPAU_object@@PAU1@0@Z ENDP		; playerCanDetach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerCanUnlock@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iKeyItemIndex$ = -8					; size = 4
_TargetSlotIndex$ = -4					; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerCanUnlock@@YAPAU_object@@PAU1@0@Z PROC		; playerCanUnlock, COMDAT

; 1659 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1662 : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1662 : 	switch (PyTuple_Size(poArgs))

  0000f	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00010	c6 45 fc 01	 mov	 BYTE PTR _TargetSlotIndex$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00014	66 89 45 fd	 mov	 WORD PTR _TargetSlotIndex$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1662 : 	switch (PyTuple_Size(poArgs))

  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001e	83 c4 04	 add	 esp, 4
  00021	83 e8 02	 sub	 eax, 2
  00024	74 46		 je	 SHORT $LN12@playerCanU
  00026	48		 dec	 eax
  00027	75 39		 jne	 SHORT $LN31@playerCanU

; 1668 : 			return Py_BadArgument();
; 1669 : 		break;
; 1670 : 	case 3:
; 1671 : 		if (!PyTuple_GetInteger(poArgs, 0, &iKeyItemIndex))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _iKeyItemIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	84 c0		 test	 al, al
  0003a	74 26		 je	 SHORT $LN31@playerCanU

; 1672 : 			return Py_BadArgument();
; 1673 : 		if (!PyTuple_GetInteger(poArgs, 1, &TargetSlotIndex.window_type))

  0003c	8d 45 fc	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp]
  0003f	50		 push	 eax
  00040	6a 01		 push	 1
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	84 c0		 test	 al, al
  0004d	74 13		 je	 SHORT $LN31@playerCanU

; 1674 : 			return Py_BadArgument();
; 1675 : 		if (!PyTuple_GetInteger(poArgs, 2, &TargetSlotIndex.cell))

  0004f	8d 45 fd	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp+1]
  00052	50		 push	 eax
  00053	6a 02		 push	 2
  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	84 c0		 test	 al, al
  00060	75 30		 jne	 SHORT $LN10@playerCanU
$LN31@playerCanU:

; 1676 : 			return Py_BadArgument();

  00062	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 1702 : }

  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
$LN12@playerCanU:

; 1663 : 	{
; 1664 : 	case 2:
; 1665 : 		if (!PyTuple_GetInteger(poArgs, 0, &iKeyItemIndex))

  0006c	8d 45 f8	 lea	 eax, DWORD PTR _iKeyItemIndex$[ebp]
  0006f	50		 push	 eax
  00070	6a 00		 push	 0
  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	84 c0		 test	 al, al
  0007d	74 e3		 je	 SHORT $LN31@playerCanU

; 1666 : 			return Py_BadArgument();
; 1667 : 		if (!PyTuple_GetInteger(poArgs, 1, &TargetSlotIndex.cell))

  0007f	8d 45 fd	 lea	 eax, DWORD PTR _TargetSlotIndex$[ebp+1]
  00082	50		 push	 eax
  00083	6a 01		 push	 1
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	84 c0		 test	 al, al
  00090	74 d0		 je	 SHORT $LN31@playerCanU
$LN10@playerCanU:

; 1677 : 		break;
; 1678 : 	default:
; 1679 : 		return Py_BadArgument();
; 1680 : 	}
; 1681 : 
; 1682 : 	// Key
; 1683 : 	CItemManager::Instance().SelectItemData(iKeyItemIndex);

  00092	ff 75 f8	 push	 DWORD PTR _iKeyItemIndex$[ebp]
  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0009b	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 1684 : 	CItemData * pKeyItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  000a6	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer

; 1685 : 	if (!pKeyItemData)

  000ab	85 c0		 test	 eax, eax
  000ad	75 12		 jne	 SHORT $LN4@playerCanU
$LN32@playerCanU:

; 1686 : 		return Py_BuildException("Can't find item data");

  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BGKCJNBK@Can?8t?5find?5item?5data?$AA@
  000b4	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  000b9	83 c4 04	 add	 esp, 4

; 1702 : }

  000bc	5e		 pop	 esi
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
$LN4@playerCanU:

; 1687 : 	int iKeyType = pKeyItemData->GetType();

  000c1	8b c8		 mov	 ecx, eax
  000c3	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType

; 1688 : 	if (iKeyType != CItemData::ITEM_TYPE_TREASURE_KEY)

  000c8	3c 15		 cmp	 al, 21			; 00000015H
  000ca	74 15		 je	 SHORT $LN3@playerCanU
$LN30@playerCanU:

; 1689 : 		return Py_BuildValue("i", FALSE);

  000cc	6a 00		 push	 0

; 1699 : 		return Py_BuildValue("i", FALSE);
; 1700 : 
; 1701 : 	return Py_BuildValue("i", TRUE);

  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000d9	83 c4 08	 add	 esp, 8

; 1702 : }

  000dc	5e		 pop	 esi
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN3@playerCanU:

; 1690 : 
; 1691 : 	// Target Item
; 1692 : 	int iTargetItemIndex = CPythonPlayer::Instance().GetItemIndex(TargetSlotIndex);

  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000e7	66 8b 45 fc	 mov	 ax, WORD PTR _TargetSlotIndex$[ebp]
  000eb	83 c1 04	 add	 ecx, 4
  000ee	51		 push	 ecx
  000ef	8b d4		 mov	 edx, esp
  000f1	8b 31		 mov	 esi, DWORD PTR [ecx]
  000f3	66 89 02	 mov	 WORD PTR [edx], ax
  000f6	8a 45 fe	 mov	 al, BYTE PTR _TargetSlotIndex$[ebp+2]
  000f9	88 42 02	 mov	 BYTE PTR [edx+2], al
  000fc	ff 56 40	 call	 DWORD PTR [esi+64]

; 1693 : 	CItemManager::Instance().SelectItemData(iTargetItemIndex);

  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 1694 : 	CItemData * pTargetItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00111	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer

; 1695 : 	if (!pTargetItemData)

  00116	85 c0		 test	 eax, eax
  00118	74 95		 je	 SHORT $LN32@playerCanU

; 1696 : 		return Py_BuildException("Can't find item data");
; 1697 : 	int iTargetType = pTargetItemData->GetType();

  0011a	8b c8		 mov	 ecx, eax
  0011c	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType

; 1698 : 	if (iTargetType != CItemData::ITEM_TYPE_TREASURE_BOX)

  00121	3c 14		 cmp	 al, 20			; 00000014H
  00123	75 a7		 jne	 SHORT $LN30@playerCanU

; 1699 : 		return Py_BuildValue("i", FALSE);
; 1700 : 
; 1701 : 	return Py_BuildValue("i", TRUE);

  00125	6a 01		 push	 1
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00132	83 c4 08	 add	 esp, 8

; 1702 : }

  00135	5e		 pop	 esi
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
?playerCanUnlock@@YAPAU_object@@PAU1@0@Z ENDP		; playerCanUnlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsRefineGradeScroll@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_ScrollSlotIndex$ = -4					; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsRefineGradeScroll@@YAPAU_object@@PAU1@0@Z PROC	; playerIsRefineGradeScroll, COMDAT

; 1705 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1707 : 	switch (PyTuple_Size(poArgs))

  00005	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  00008	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1707 : 	switch (PyTuple_Size(poArgs))

  0000d	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  0000e	c6 45 fc 01	 mov	 BYTE PTR _ScrollSlotIndex$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00012	66 89 45 fd	 mov	 WORD PTR _ScrollSlotIndex$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1707 : 	switch (PyTuple_Size(poArgs))

  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001c	83 c4 04	 add	 esp, 4
  0001f	48		 dec	 eax
  00020	74 12		 je	 SHORT $LN7@playerIsRe
  00022	48		 dec	 eax
  00023	74 22		 je	 SHORT $LN6@playerIsRe

; 1716 : 			return Py_BuildException();
; 1717 : 	default:
; 1718 : 		return Py_BuildException();

  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0002c	83 c4 04	 add	 esp, 4
  0002f	5e		 pop	 esi

; 1719 : 	}
; 1720 : 
; 1721 : 	int iScrollItemIndex = CPythonPlayer::Instance().GetItemIndex(ScrollSlotIndex);
; 1722 : 	CItemManager::Instance().SelectItemData(iScrollItemIndex);
; 1723 : 	CItemData * pScrollItemData = CItemManager::Instance().GetSelectedItemDataPointer();
; 1724 : 	if (!pScrollItemData)
; 1725 : 		return Py_BuildException("Can't find item data");
; 1726 : 
; 1727 : 	return Py_BuildValue("i", REFINE_SCROLL_TYPE_UP_GRADE == pScrollItemData->GetValue(0));
; 1728 : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN7@playerIsRe:

; 1708 : 	{
; 1709 : 	case 1:
; 1710 : 		if (!PyTuple_GetInteger(poArgs, 0, &ScrollSlotIndex.cell))

  00034	8d 45 fd	 lea	 eax, DWORD PTR _ScrollSlotIndex$[ebp+1]
  00037	50		 push	 eax
  00038	6a 00		 push	 0
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	84 c0		 test	 al, al
  00045	74 22		 je	 SHORT $LN3@playerIsRe
$LN6@playerIsRe:

; 1711 : 			return Py_BuildException();
; 1712 : 	case 2:
; 1713 : 		if (!PyTuple_GetInteger(poArgs, 0, &ScrollSlotIndex.window_type))

  00047	8d 45 fc	 lea	 eax, DWORD PTR _ScrollSlotIndex$[ebp]
  0004a	50		 push	 eax
  0004b	6a 00		 push	 0
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	84 c0		 test	 al, al
  00058	74 0f		 je	 SHORT $LN3@playerIsRe

; 1714 : 			return Py_BuildException();
; 1715 : 		if (!PyTuple_GetInteger(poArgs, 1, &ScrollSlotIndex.cell))

  0005a	8d 45 fd	 lea	 eax, DWORD PTR _ScrollSlotIndex$[ebp+1]
  0005d	50		 push	 eax
  0005e	6a 01		 push	 1
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@playerIsRe:

; 1716 : 			return Py_BuildException();
; 1717 : 	default:
; 1718 : 		return Py_BuildException();

  00069	6a 00		 push	 0
  0006b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00070	83 c4 04	 add	 esp, 4
  00073	5e		 pop	 esi

; 1719 : 	}
; 1720 : 
; 1721 : 	int iScrollItemIndex = CPythonPlayer::Instance().GetItemIndex(ScrollSlotIndex);
; 1722 : 	CItemManager::Instance().SelectItemData(iScrollItemIndex);
; 1723 : 	CItemData * pScrollItemData = CItemManager::Instance().GetSelectedItemDataPointer();
; 1724 : 	if (!pScrollItemData)
; 1725 : 		return Py_BuildException("Can't find item data");
; 1726 : 
; 1727 : 	return Py_BuildValue("i", REFINE_SCROLL_TYPE_UP_GRADE == pScrollItemData->GetValue(0));
; 1728 : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?playerIsRefineGradeScroll@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsRefineGradeScroll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerUpdate@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerUpdate@@YAPAU_object@@PAU1@0@Z PROC		; playerUpdate, COMDAT

; 1732 : 	CPythonPlayer::Instance().Update();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?Update@CPythonPlayer@@QAEXXZ ; CPythonPlayer::Update

; 1733 : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerUpdate@@YAPAU_object@@PAU1@0@Z ENDP		; playerUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRender@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRender@@YAPAU_object@@PAU1@0@Z PROC		; playerRender, COMDAT

; 1738 : 	return Py_BuildNone();

  00000	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerRender@@YAPAU_object@@PAU1@0@Z ENDP		; playerRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerClear@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerClear@@YAPAU_object@@PAU1@0@Z PROC		; playerClear, COMDAT

; 1743 : 	CPythonPlayer::Instance().Clear();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?Clear@CPythonPlayer@@QAEXXZ ; CPythonPlayer::Clear

; 1744 : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerClear@@YAPAU_object@@PAU1@0@Z ENDP		; playerClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerClearTarget@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerClearTarget@@YAPAU_object@@PAU1@0@Z PROC		; playerClearTarget, COMDAT

; 1749 : 	CPythonPlayer::Instance().SetTarget(0);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	83 c1 04	 add	 ecx, 4
  00009	6a 01		 push	 1
  0000b	6a 00		 push	 0
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	ff 50 60	 call	 DWORD PTR [eax+96]

; 1750 : 	return Py_BuildNone();

  00012	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerClearTarget@@YAPAU_object@@PAU1@0@Z ENDP		; playerClearTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetTarget@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetTarget@@YAPAU_object@@PAU1@0@Z PROC		; playerSetTarget, COMDAT

; 1754 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1755 : 	int iVID;
; 1756 : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerSetT

; 1757 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1761 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerSetT:

; 1758 : 
; 1759 : 	CPythonPlayer::Instance().SetTarget(iVID);

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002d	83 c1 04	 add	 ecx, 4
  00030	6a 01		 push	 1
  00032	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	ff 50 60	 call	 DWORD PTR [eax+96]

; 1760 : 	return Py_BuildNone();

  0003a	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1761 : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?playerSetTarget@@YAPAU_object@@PAU1@0@Z ENDP		; playerSetTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerOpenCharacterMenu@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerOpenCharacterMenu@@YAPAU_object@@PAU1@0@Z PROC	; playerOpenCharacterMenu, COMDAT

; 1764 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1765 : 	int iVID;
; 1766 : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerOpen

; 1767 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1771 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerOpen:

; 1768 : 
; 1769 : 	CPythonPlayer::Instance().OpenCharacterMenu(iVID);

  00027	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?OpenCharacterMenu@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::OpenCharacterMenu

; 1770 : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1771 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?playerOpenCharacterMenu@@YAPAU_object@@PAU1@0@Z ENDP	; playerOpenCharacterMenu
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsPartyMember@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsPartyMember@@YAPAU_object@@PAU1@0@Z PROC	; playerIsPartyMember, COMDAT

; 1774 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1775 : 	int iVID;
; 1776 : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerIsPa

; 1777 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1780 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerIsPa:

; 1778 : 
; 1779 : 	return Py_BuildValue("i", CPythonPlayer::Instance().IsPartyMemberByVID(iVID));

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002d	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  00030	83 c1 04	 add	 ecx, 4
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00038	ff d0		 call	 eax
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00049	83 c4 08	 add	 esp, 8

; 1780 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?playerIsPartyMember@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsPartyMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsPartyLeader@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pPartyMemberInfo$ = -12				; size = 4
_dwPID$ = -8						; size = 4
_iVID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsPartyLeader@@YAPAU_object@@PAU1@0@Z PROC	; playerIsPartyLeader, COMDAT

; 1783 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1784 : 	int iVID;
; 1785 : 	if (!PyTuple_GetInteger(poArgs, 0, &iVID))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iVID$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN3@playerIsPa

; 1786 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1797 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN3@playerIsPa:

; 1787 : 
; 1788 : 	DWORD dwPID;
; 1789 : 	if (!CPythonPlayer::Instance().PartyMemberVIDToPID(iVID, &dwPID))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 55 f8	 lea	 edx, DWORD PTR _dwPID$[ebp]
  00032	83 c1 04	 add	 ecx, 4
  00035	52		 push	 edx
  00036	ff 75 fc	 push	 DWORD PTR _iVID$[ebp]
  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0003e	ff d0		 call	 eax
  00040	84 c0		 test	 al, al
  00042	75 14		 jne	 SHORT $LN2@playerIsPa
$LN11@playerIsPa:

; 1790 : 		return Py_BuildValue("i", FALSE);

  00044	6a 00		 push	 0

; 1794 : 		return Py_BuildValue("i", FALSE);
; 1795 : 
; 1796 : 	return Py_BuildValue("i", CPythonPlayer::PARTY_ROLE_LEADER == pPartyMemberInfo->byState);

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00051	83 c4 08	 add	 esp, 8

; 1797 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN2@playerIsPa:

; 1791 : 
; 1792 : 	CPythonPlayer::TPartyMemberInfo * pPartyMemberInfo;
; 1793 : 	if (!CPythonPlayer::Instance().GetPartyMemberPtr(dwPID, &pPartyMemberInfo))

  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0005e	8d 45 f4	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00061	50		 push	 eax
  00062	ff 75 f8	 push	 DWORD PTR _dwPID$[ebp]
  00065	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  0006a	84 c0		 test	 al, al
  0006c	74 d6		 je	 SHORT $LN11@playerIsPa

; 1794 : 		return Py_BuildValue("i", FALSE);
; 1795 : 
; 1796 : 	return Py_BuildValue("i", CPythonPlayer::PARTY_ROLE_LEADER == pPartyMemberInfo->byState);

  0006e	8b 45 f4	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00071	33 c9		 xor	 ecx, ecx
  00073	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00077	0f 94 c1	 sete	 cl
  0007a	51		 push	 ecx
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00086	83 c4 08	 add	 esp, 8

; 1797 : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?playerIsPartyLeader@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsPartyLeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerIsPartyLeaderByPID@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pPartyMemberInfo$ = -8					; size = 4
_iPID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerIsPartyLeaderByPID@@YAPAU_object@@PAU1@0@Z PROC	; playerIsPartyLeaderByPID, COMDAT

; 1800 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1801 : 	int iPID;
; 1802 : 	if (!PyTuple_GetInteger(poArgs, 0, &iPID))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iPID$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerIsPa

; 1803 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1810 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerIsPa:

; 1804 : 
; 1805 : 	CPythonPlayer::TPartyMemberInfo * pPartyMemberInfo;
; 1806 : 	if (!CPythonPlayer::Instance().GetPartyMemberPtr(iPID, &pPartyMemberInfo))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iPID$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  0003b	84 c0		 test	 al, al
  0003d	75 14		 jne	 SHORT $LN1@playerIsPa

; 1807 : 		return Py_BuildValue("i", FALSE);

  0003f	6a 00		 push	 0

; 1808 : 
; 1809 : 	return Py_BuildValue("i", CPythonPlayer::PARTY_ROLE_LEADER == pPartyMemberInfo->byState);

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004c	83 c4 08	 add	 esp, 8

; 1810 : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN1@playerIsPa:

; 1808 : 
; 1809 : 	return Py_BuildValue("i", CPythonPlayer::PARTY_ROLE_LEADER == pPartyMemberInfo->byState);

  00053	8b 45 f8	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00056	33 c9		 xor	 ecx, ecx
  00058	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  0005c	0f 94 c1	 sete	 cl
  0005f	51		 push	 ecx
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0006b	83 c4 08	 add	 esp, 8

; 1810 : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?playerIsPartyLeaderByPID@@YAPAU_object@@PAU1@0@Z ENDP	; playerIsPartyLeaderByPID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetPartyMemberHPPercentage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pPartyMemberInfo$ = -8					; size = 4
_iPID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetPartyMemberHPPercentage@@YAPAU_object@@PAU1@0@Z PROC ; playerGetPartyMemberHPPercentage, COMDAT

; 1813 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1814 : 	int iPID;
; 1815 : 	if (!PyTuple_GetInteger(poArgs, 0, &iPID))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iPID$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerGetP

; 1816 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1823 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerGetP:

; 1817 : 
; 1818 : 	CPythonPlayer::TPartyMemberInfo * pPartyMemberInfo;
; 1819 : 	if (!CPythonPlayer::Instance().GetPartyMemberPtr(iPID, &pPartyMemberInfo))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iPID$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  0003b	84 c0		 test	 al, al
  0003d	75 14		 jne	 SHORT $LN1@playerGetP

; 1820 : 		return Py_BuildValue("i", FALSE);

  0003f	6a 00		 push	 0

; 1821 : 
; 1822 : 	return Py_BuildValue("i", pPartyMemberInfo->byHPPercentage);

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004c	83 c4 08	 add	 esp, 8

; 1823 : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN1@playerGetP:

; 1821 : 
; 1822 : 	return Py_BuildValue("i", pPartyMemberInfo->byHPPercentage);

  00053	8b 45 f8	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00056	0f b6 40 21	 movzx	 eax, BYTE PTR [eax+33]
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00066	83 c4 08	 add	 esp, 8

; 1823 : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?playerGetPartyMemberHPPercentage@@YAPAU_object@@PAU1@0@Z ENDP ; playerGetPartyMemberHPPercentage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetPartyMemberState@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pPartyMemberInfo$ = -8					; size = 4
_iPID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetPartyMemberState@@YAPAU_object@@PAU1@0@Z PROC	; playerGetPartyMemberState, COMDAT

; 1826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1827 : 	int iPID;
; 1828 : 	if (!PyTuple_GetInteger(poArgs, 0, &iPID))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iPID$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerGetP

; 1829 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1836 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerGetP:

; 1830 : 
; 1831 : 	CPythonPlayer::TPartyMemberInfo * pPartyMemberInfo;
; 1832 : 	if (!CPythonPlayer::Instance().GetPartyMemberPtr(iPID, &pPartyMemberInfo))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iPID$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  0003b	84 c0		 test	 al, al
  0003d	75 14		 jne	 SHORT $LN1@playerGetP

; 1833 : 		return Py_BuildValue("i", FALSE);

  0003f	6a 00		 push	 0

; 1834 : 
; 1835 : 	return Py_BuildValue("i", pPartyMemberInfo->byState);

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004c	83 c4 08	 add	 esp, 8

; 1836 : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN1@playerGetP:

; 1834 : 
; 1835 : 	return Py_BuildValue("i", pPartyMemberInfo->byState);

  00053	8b 45 f8	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00056	0f b6 40 20	 movzx	 eax, BYTE PTR [eax+32]
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00066	83 c4 08	 add	 esp, 8

; 1836 : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?playerGetPartyMemberState@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetPartyMemberState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetPartyMemberAffects@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pPartyMemberInfo$ = -8					; size = 4
_iPID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetPartyMemberAffects@@YAPAU_object@@PAU1@0@Z PROC ; playerGetPartyMemberAffects, COMDAT

; 1839 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1840 : 	int iPID;
; 1841 : 	if (!PyTuple_GetInteger(poArgs, 0, &iPID))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iPID$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerGetP

; 1842 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1855 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerGetP:

; 1843 : 
; 1844 : 	CPythonPlayer::TPartyMemberInfo * pPartyMemberInfo;
; 1845 : 	if (!CPythonPlayer::Instance().GetPartyMemberPtr(iPID, &pPartyMemberInfo))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iPID$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  0003b	84 c0		 test	 al, al
  0003d	75 14		 jne	 SHORT $LN1@playerGetP

; 1846 : 		return Py_BuildValue("i", FALSE);

  0003f	6a 00		 push	 0
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004c	83 c4 08	 add	 esp, 8

; 1855 : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN1@playerGetP:

; 1847 : 
; 1848 : 	return Py_BuildValue("iiiiiii",	pPartyMemberInfo->sAffects[0],
; 1849 : 									pPartyMemberInfo->sAffects[1],
; 1850 : 									pPartyMemberInfo->sAffects[2],
; 1851 : 									pPartyMemberInfo->sAffects[3],
; 1852 : 									pPartyMemberInfo->sAffects[4],
; 1853 : 									pPartyMemberInfo->sAffects[5],
; 1854 : 									pPartyMemberInfo->sAffects[6]);

  00053	8b 4d f8	 mov	 ecx, DWORD PTR _pPartyMemberInfo$[ebp]
  00056	0f bf 41 2e	 movsx	 eax, WORD PTR [ecx+46]
  0005a	50		 push	 eax
  0005b	0f bf 41 2c	 movsx	 eax, WORD PTR [ecx+44]
  0005f	50		 push	 eax
  00060	0f bf 41 2a	 movsx	 eax, WORD PTR [ecx+42]
  00064	50		 push	 eax
  00065	0f bf 41 28	 movsx	 eax, WORD PTR [ecx+40]
  00069	50		 push	 eax
  0006a	0f bf 41 26	 movsx	 eax, WORD PTR [ecx+38]
  0006e	50		 push	 eax
  0006f	0f bf 41 24	 movsx	 eax, WORD PTR [ecx+36]
  00073	50		 push	 eax
  00074	0f bf 41 22	 movsx	 eax, WORD PTR [ecx+34]
  00078	50		 push	 eax
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_07EFJJEBFG@iiiiiii?$AA@
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00084	83 c4 20	 add	 esp, 32			; 00000020H

; 1855 : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?playerGetPartyMemberAffects@@YAPAU_object@@PAU1@0@Z ENDP ; playerGetPartyMemberAffects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRemovePartyMember@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iPID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRemovePartyMember@@YAPAU_object@@PAU1@0@Z PROC	; playerRemovePartyMember, COMDAT

; 1858 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1859 : 	int iPID;
; 1860 : 	if (!PyTuple_GetInteger(poArgs, 0, &iPID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iPID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerRemo

; 1861 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1865 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerRemo:

; 1862 : 
; 1863 : 	CPythonPlayer::Instance().RemovePartyMember(iPID);

  00027	ff 75 fc	 push	 DWORD PTR _iPID$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?RemovePartyMember@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RemovePartyMember

; 1864 : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1865 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?playerRemovePartyMember@@YAPAU_object@@PAU1@0@Z ENDP	; playerRemovePartyMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerExitParty@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerExitParty@@YAPAU_object@@PAU1@0@Z PROC		; playerExitParty, COMDAT

; 1869 : 	CPythonPlayer::Instance().ExitParty();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?ExitParty@CPythonPlayer@@QAEXXZ ; CPythonPlayer::ExitParty

; 1870 : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?playerExitParty@@YAPAU_object@@PAU1@0@Z ENDP		; playerExitParty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetPKMode@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetPKMode@@YAPAU_object@@PAU1@0@Z PROC		; playerGetPKMode, COMDAT

; 1875 : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetPKMode());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetPKMode@CPythonPlayer@@QAEKXZ ; CPythonPlayer::GetPKMode
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 1876 : }

  0001a	c3		 ret	 0
?playerGetPKMode@@YAPAU_object@@PAU1@0@Z ENDP		; playerGetPKMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerHasMobilePhoneNumber@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerHasMobilePhoneNumber@@YAPAU_object@@PAU1@0@Z PROC ; playerHasMobilePhoneNumber, COMDAT

; 1880 : 	return Py_BuildValue("i", CPythonPlayer::Instance().HasMobilePhoneNumber());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?HasMobilePhoneNumber@CPythonPlayer@@QAEHXZ ; CPythonPlayer::HasMobilePhoneNumber
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 1881 : }

  0001a	c3		 ret	 0
?playerHasMobilePhoneNumber@@YAPAU_object@@PAU1@0@Z ENDP ; playerHasMobilePhoneNumber
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetWeaponAttackBonusFlag@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iFlag$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetWeaponAttackBonusFlag@@YAPAU_object@@PAU1@0@Z PROC ; playerSetWeaponAttackBonusFlag, COMDAT

; 1884 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1885 : 	int iFlag;
; 1886 : 	if (!PyTuple_GetInteger(poArgs, 0, &iFlag))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iFlag$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@playerSetW

; 1887 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1890 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@playerSetW:

; 1888 : 
; 1889 : 	return Py_BuildNone();

  00027	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1890 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?playerSetWeaponAttackBonusFlag@@YAPAU_object@@PAU1@0@Z ENDP ; playerSetWeaponAttackBonusFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerToggleCoolTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerToggleCoolTime@@YAPAU_object@@PAU1@0@Z PROC	; playerToggleCoolTime, COMDAT

; 1894 : 	return Py_BuildValue("i", CPythonPlayer::Instance().__ToggleCoolTime());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?__ToggleCoolTime@CPythonPlayer@@QAEHXZ ; CPythonPlayer::__ToggleCoolTime
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 1895 : }

  0001a	c3		 ret	 0
?playerToggleCoolTime@@YAPAU_object@@PAU1@0@Z ENDP	; playerToggleCoolTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerToggleLevelLimit@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerToggleLevelLimit@@YAPAU_object@@PAU1@0@Z PROC	; playerToggleLevelLimit, COMDAT

; 1899 : 	return Py_BuildValue("i", CPythonPlayer::Instance().__ToggleLevelLimit());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?__ToggleLevelLimit@CPythonPlayer@@QAEHXZ ; CPythonPlayer::__ToggleLevelLimit
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 1900 : }

  0001a	c3		 ret	 0
?playerToggleLevelLimit@@YAPAU_object@@PAU1@0@Z ENDP	; playerToggleLevelLimit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetTargetVID@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetTargetVID@@YAPAU_object@@PAU1@0@Z PROC	; playerGetTargetVID, COMDAT

; 1904 : 	return Py_BuildValue("i", CPythonPlayer::Instance().GetTargetVID());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?GetTargetVID@CPythonPlayer@@QAEKXZ ; CPythonPlayer::GetTargetVID
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 1905 : }

  0001a	c3		 ret	 0
?playerGetTargetVID@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetTargetVID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerRegisterEmotionIcon@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -16						; size = 8
_iIndex$ = -8						; size = 4
_szFileName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerRegisterEmotionIcon@@YAPAU_object@@PAU1@0@Z PROC	; playerRegisterEmotionIcon, COMDAT

; 1908 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1909 : 	int iIndex;
; 1910 : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerRegi
$LN25@playerRegi:

; 1911 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1920 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerRegi:

; 1912 : 	char * szFileName;
; 1913 : 	if (!PyTuple_GetString(poArgs, 1, &szFileName))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _szFileName$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN25@playerRegi

; 1914 : 		return Py_BuildException();
; 1915 : 
; 1916 : 	CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(szFileName);

  0003e	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00047	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0004f	89 45 f4	 mov	 DWORD PTR $T2[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00052	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
  00055	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00056	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00059	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::pair<int,CGraphicImage *> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0005e	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0005f	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00062	50		 push	 eax
  00063	51		 push	 ecx
  00064	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_nohint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1919 : 	return Py_BuildNone();

  0006d	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1920 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?playerRegisterEmotionIcon@@YAPAU_object@@PAU1@0@Z ENDP	; playerRegisterEmotionIcon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetEmotionIconImage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_iIndex$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetEmotionIconImage@@YAPAU_object@@PAU1@0@Z PROC	; playerGetEmotionIconImage, COMDAT

; 1923 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1924 : 	int iIndex;
; 1925 : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@playerGetE

; 1926 : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 1932 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@playerGetE:

; 1928 : 	if (m_kMap_iEmotionIndex_pkIconImage.end() == m_kMap_iEmotionIndex_pkIconImage.find(iIndex))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  0002c	50		 push	 eax
  0002d	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::find
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0003c	3b 08		 cmp	 ecx, DWORD PTR [eax]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1928 : 	if (m_kMap_iEmotionIndex_pkIconImage.end() == m_kMap_iEmotionIndex_pkIconImage.find(iIndex))

  0003e	75 14		 jne	 SHORT $LN1@playerGetE

; 1929 : 		return Py_BuildValue("i", 0);

  00040	6a 00		 push	 0

; 1930 : 
; 1931 : 	return Py_BuildValue("i", m_kMap_iEmotionIndex_pkIconImage[iIndex]);

  00042	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004d	83 c4 08	 add	 esp, 8

; 1932 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN1@playerGetE:

; 1930 : 
; 1931 : 	return Py_BuildValue("i", m_kMap_iEmotionIndex_pkIconImage[iIndex]);

  00054	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??A?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAEAAPAVCGraphicImage@@ABH@Z ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::operator[]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0006a	83 c4 08	 add	 esp, 8

; 1932 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?playerGetEmotionIconImage@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetEmotionIconImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetItemData@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iVirtualID$ = -68					; size = 4
_iSlotIndex$ = -64					; size = 4
_iNum$ = -60						; size = 4
$T1 = -55						; size = 3
_kItemInst$ = -52					; size = 46
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetItemData@@YAPAU_object@@PAU1@0@Z PROC		; playerSetItemData, COMDAT

; 1935 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]

; 1936 : 	int iSlotIndex;
; 1937 : 	if (!PyTuple_GetInteger(poArgs, 0, &iSlotIndex))

  00014	8d 45 c0	 lea	 eax, DWORD PTR _iSlotIndex$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	84 c0		 test	 al, al
  00025	75 19		 jne	 SHORT $LN3@playerSetI
$LN10@playerSetI:

; 1938 : 		return Py_BuildException();

  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0002e	83 c4 04	 add	 esp, 4

; 1954 : }

  00031	5e		 pop	 esi
  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN3@playerSetI:

; 1939 : 
; 1940 : 	int iVirtualID;
; 1941 : 	if (!PyTuple_GetInteger(poArgs, 1, &iVirtualID))

  00040	8d 45 bc	 lea	 eax, DWORD PTR _iVirtualID$[ebp]
  00043	50		 push	 eax
  00044	6a 01		 push	 1
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	84 c0		 test	 al, al
  00051	74 d4		 je	 SHORT $LN10@playerSetI

; 1942 : 		return Py_BuildException();
; 1943 : 
; 1944 : 	int iNum;
; 1945 : 	if (!PyTuple_GetInteger(poArgs, 2, &iNum))

  00053	8d 45 c4	 lea	 eax, DWORD PTR _iNum$[ebp]
  00056	50		 push	 eax
  00057	6a 02		 push	 2
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	84 c0		 test	 al, al
  00064	74 c1		 je	 SHORT $LN10@playerSetI

; 1946 : 		return Py_BuildException();
; 1947 : 
; 1948 : 	TItemData kItemInst;
; 1949 : 	ZeroMemory(&kItemInst, sizeof(kItemInst));

  00066	6a 2e		 push	 46			; 0000002eH
  00068	8d 45 cc	 lea	 eax, DWORD PTR _kItemInst$[ebp]
  0006b	6a 00		 push	 0
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _memset

; 1950 : 	kItemInst.vnum=iVirtualID;

  00073	8b 45 bc	 mov	 eax, DWORD PTR _iVirtualID$[ebp]
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1952 : 	CPythonPlayer::Instance().SetItemData(TItemPos(INVENTORY, iSlotIndex), kItemInst);

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0007f	89 45 cc	 mov	 DWORD PTR _kItemInst$[ebp], eax
  00082	83 c1 04	 add	 ecx, 4
  00085	8a 45 c4	 mov	 al, BYTE PTR _iNum$[ebp]
  00088	88 45 d0	 mov	 BYTE PTR _kItemInst$[ebp+4], al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  0008b	0f b7 45 c0	 movzx	 eax, WORD PTR _iSlotIndex$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1952 : 	CPythonPlayer::Instance().SetItemData(TItemPos(INVENTORY, iSlotIndex), kItemInst);

  0008f	8b 31		 mov	 esi, DWORD PTR [ecx]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  00091	66 89 45 ca	 mov	 WORD PTR $T1[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1952 : 	CPythonPlayer::Instance().SetItemData(TItemPos(INVENTORY, iSlotIndex), kItemInst);

  00095	8d 45 cc	 lea	 eax, DWORD PTR _kItemInst$[ebp]
  00098	50		 push	 eax
  00099	51		 push	 ecx
  0009a	8b d4		 mov	 edx, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 191  :         window_type = _window_type;

  0009c	c6 45 c9 01	 mov	 BYTE PTR $T1[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1952 : 	CPythonPlayer::Instance().SetItemData(TItemPos(INVENTORY, iSlotIndex), kItemInst);

  000a0	0f b7 45 c9	 movzx	 eax, WORD PTR $T1[ebp]
  000a4	66 89 02	 mov	 WORD PTR [edx], ax
  000a7	8a 45 cb	 mov	 al, BYTE PTR $T1[ebp+2]
  000aa	88 42 02	 mov	 BYTE PTR [edx+2], al
  000ad	ff 56 30	 call	 DWORD PTR [esi+48]

; 1953 : 	return Py_BuildNone();

  000b0	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1954 : }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	33 cd		 xor	 ecx, ebp
  000ba	5e		 pop	 esi
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?playerSetItemData@@YAPAU_object@@PAU1@0@Z ENDP		; playerSetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetItemMetinSocket@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iMetinSocketNumber$ = -12				; size = 4
_iNum$ = -8						; size = 4
_ItemPos$ = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetItemMetinSocket@@YAPAU_object@@PAU1@0@Z PROC	; playerSetItemMetinSocket, COMDAT

; 1957 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1962 : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1962 : 	switch (PyTuple_Size(poArgs))

  0000f	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00010	c6 45 fc 01	 mov	 BYTE PTR _ItemPos$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00014	66 89 45 fd	 mov	 WORD PTR _ItemPos$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 1962 : 	switch (PyTuple_Size(poArgs))

  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001e	83 c4 04	 add	 esp, 4
  00021	83 e8 03	 sub	 eax, 3
  00024	74 5e		 je	 SHORT $LN10@playerSetI
  00026	48		 dec	 eax
  00027	75 4c		 jne	 SHORT $LN19@playerSetI

; 1972 : 			return Py_BuildException();
; 1973 : 
; 1974 : 		break;
; 1975 : 	case 4:
; 1976 : 		if (!PyTuple_GetInteger(poArgs, 0, &ItemPos.window_type))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _ItemPos$[ebp]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	84 c0		 test	 al, al
  0003a	74 39		 je	 SHORT $LN19@playerSetI

; 1977 : 			return Py_BuildException();
; 1978 : 		if (!PyTuple_GetInteger(poArgs, 1, &ItemPos.cell))

  0003c	8d 45 fd	 lea	 eax, DWORD PTR _ItemPos$[ebp+1]
  0003f	50		 push	 eax
  00040	6a 01		 push	 1
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	84 c0		 test	 al, al
  0004d	74 26		 je	 SHORT $LN19@playerSetI

; 1979 : 			return Py_BuildException();
; 1980 : 		if (!PyTuple_GetInteger(poArgs, 2, &iMetinSocketNumber))

  0004f	8d 45 f4	 lea	 eax, DWORD PTR _iMetinSocketNumber$[ebp]
  00052	50		 push	 eax
  00053	6a 02		 push	 2
  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	84 c0		 test	 al, al
  00060	74 13		 je	 SHORT $LN19@playerSetI

; 1981 : 			return Py_BuildException();
; 1982 : 		if (!PyTuple_GetInteger(poArgs, 3, &iNum))

  00062	8d 45 f8	 lea	 eax, DWORD PTR _iNum$[ebp]
  00065	50		 push	 eax
  00066	6a 03		 push	 3
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	84 c0		 test	 al, al
  00073	75 48		 jne	 SHORT $LN7@playerSetI
$LN19@playerSetI:

; 1983 : 			return Py_BuildException();

  00075	6a 00		 push	 0
  00077	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0007c	83 c4 04	 add	 esp, 4

; 1992 : }

  0007f	5e		 pop	 esi
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN10@playerSetI:

; 1963 : 	{
; 1964 : 	case 3:
; 1965 : 		if (!PyTuple_GetInteger(poArgs, 0, &ItemPos.cell))

  00084	8d 45 fd	 lea	 eax, DWORD PTR _ItemPos$[ebp+1]
  00087	50		 push	 eax
  00088	6a 00		 push	 0
  0008a	56		 push	 esi
  0008b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	84 c0		 test	 al, al
  00095	74 de		 je	 SHORT $LN19@playerSetI

; 1966 : 			return Py_BuildException();
; 1967 : 
; 1968 : 		if (!PyTuple_GetInteger(poArgs, 1, &iMetinSocketNumber))

  00097	8d 45 f4	 lea	 eax, DWORD PTR _iMetinSocketNumber$[ebp]
  0009a	50		 push	 eax
  0009b	6a 01		 push	 1
  0009d	56		 push	 esi
  0009e	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	84 c0		 test	 al, al
  000a8	74 cb		 je	 SHORT $LN19@playerSetI

; 1969 : 			return Py_BuildException();
; 1970 : 
; 1971 : 		if (!PyTuple_GetInteger(poArgs, 2, &iNum))

  000aa	8d 45 f8	 lea	 eax, DWORD PTR _iNum$[ebp]
  000ad	50		 push	 eax
  000ae	6a 02		 push	 2
  000b0	56		 push	 esi
  000b1	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b9	84 c0		 test	 al, al
  000bb	74 b8		 je	 SHORT $LN19@playerSetI
$LN7@playerSetI:

; 1984 : 
; 1985 : 		break;
; 1986 : 	default:
; 1987 : 		return Py_BuildException();
; 1988 : 	}
; 1989 : 
; 1990 : 	CPythonPlayer::Instance().SetItemMetinSocket(ItemPos, iMetinSocketNumber, iNum);

  000bd	ff 75 f8	 push	 DWORD PTR _iNum$[ebp]
  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000c6	ff 75 f4	 push	 DWORD PTR _iMetinSocketNumber$[ebp]
  000c9	66 8b 45 fc	 mov	 ax, WORD PTR _ItemPos$[ebp]
  000cd	83 c1 04	 add	 ecx, 4
  000d0	51		 push	 ecx
  000d1	8b d4		 mov	 edx, esp
  000d3	8b 31		 mov	 esi, DWORD PTR [ecx]
  000d5	66 89 02	 mov	 WORD PTR [edx], ax
  000d8	8a 45 fe	 mov	 al, BYTE PTR _ItemPos$[ebp+2]
  000db	88 42 02	 mov	 BYTE PTR [edx+2], al
  000de	ff 56 38	 call	 DWORD PTR [esi+56]

; 1991 : 	return Py_BuildNone();

  000e1	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1992 : }

  000e6	5e		 pop	 esi
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
?playerSetItemMetinSocket@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetItemMetinSocket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetItemAttribute@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iAttributeSlotIndex$ = -16				; size = 4
_iAttributeType$ = -12					; size = 4
_iAttributeValue$ = -8					; size = 4
_ItemPos$ = -4						; size = 3
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetItemAttribute@@YAPAU_object@@PAU1@0@Z PROC	; playerSetItemAttribute, COMDAT

; 1995 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 2001 : 	switch (PyTuple_Size(poArgs))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 187  : 		cell = WORD_MAX;

  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 2001 : 	switch (PyTuple_Size(poArgs))

  0000f	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00010	c6 45 fc 01	 mov	 BYTE PTR _ItemPos$[ebp], 1

; 187  : 		cell = WORD_MAX;

  00014	66 89 45 fd	 mov	 WORD PTR _ItemPos$[ebp+1], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 2001 : 	switch (PyTuple_Size(poArgs))

  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0001e	83 c4 04	 add	 esp, 4
  00021	83 e8 04	 sub	 eax, 4
  00024	74 75		 je	 SHORT $LN11@playerSetI
  00026	48		 dec	 eax
  00027	0f 85 ba 00 00
	00		 jne	 $LN7@playerSetI

; 2014 : 			return Py_BuildException();
; 2015 : 		break;
; 2016 : 	case 5:
; 2017 : 		if (!PyTuple_GetInteger(poArgs, 0, &ItemPos.window_type))

  0002d	8d 45 fc	 lea	 eax, DWORD PTR _ItemPos$[ebp]
  00030	50		 push	 eax
  00031	6a 00		 push	 0
  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	84 c0		 test	 al, al
  0003e	74 4c		 je	 SHORT $LN20@playerSetI

; 2018 : 			return Py_BuildException();
; 2019 : 
; 2020 : 		if (!PyTuple_GetInteger(poArgs, 1, &ItemPos.cell))

  00040	8d 45 fd	 lea	 eax, DWORD PTR _ItemPos$[ebp+1]
  00043	50		 push	 eax
  00044	6a 01		 push	 1
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	84 c0		 test	 al, al
  00051	74 39		 je	 SHORT $LN20@playerSetI

; 2021 : 			return Py_BuildException();
; 2022 : 
; 2023 : 		if (!PyTuple_GetInteger(poArgs, 2, &iAttributeSlotIndex))

  00053	8d 45 f0	 lea	 eax, DWORD PTR _iAttributeSlotIndex$[ebp]
  00056	50		 push	 eax
  00057	6a 02		 push	 2
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	84 c0		 test	 al, al
  00064	74 26		 je	 SHORT $LN20@playerSetI

; 2024 : 			return Py_BuildException();
; 2025 : 
; 2026 : 		if (!PyTuple_GetInteger(poArgs, 3, &iAttributeType))

  00066	8d 45 f4	 lea	 eax, DWORD PTR _iAttributeType$[ebp]
  00069	50		 push	 eax
  0006a	6a 03		 push	 3
  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	84 c0		 test	 al, al
  00077	74 13		 je	 SHORT $LN20@playerSetI

; 2027 : 			return Py_BuildException();
; 2028 : 
; 2029 : 		if (!PyTuple_GetInteger(poArgs, 4, &iAttributeValue))

  00079	8d 45 f8	 lea	 eax, DWORD PTR _iAttributeValue$[ebp]
  0007c	50		 push	 eax
  0007d	6a 04		 push	 4
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	84 c0		 test	 al, al
  0008a	75 5b		 jne	 SHORT $LN7@playerSetI
$LN20@playerSetI:

; 2030 : 			return Py_BuildException();

  0008c	6a 00		 push	 0
  0008e	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00093	83 c4 04	 add	 esp, 4

; 2035 : }

  00096	5e		 pop	 esi
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN11@playerSetI:

; 2002 : 	{
; 2003 : 	case 4:
; 2004 : 		if (!PyTuple_GetInteger(poArgs, 0, &ItemPos.cell))

  0009b	8d 45 fd	 lea	 eax, DWORD PTR _ItemPos$[ebp+1]
  0009e	50		 push	 eax
  0009f	6a 00		 push	 0
  000a1	56		 push	 esi
  000a2	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	84 c0		 test	 al, al
  000ac	74 de		 je	 SHORT $LN20@playerSetI

; 2005 : 			return Py_BuildException();
; 2006 : 
; 2007 : 		if (!PyTuple_GetInteger(poArgs, 1, &iAttributeSlotIndex))

  000ae	8d 45 f0	 lea	 eax, DWORD PTR _iAttributeSlotIndex$[ebp]
  000b1	50		 push	 eax
  000b2	6a 01		 push	 1
  000b4	56		 push	 esi
  000b5	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	84 c0		 test	 al, al
  000bf	74 cb		 je	 SHORT $LN20@playerSetI

; 2008 : 			return Py_BuildException();
; 2009 : 
; 2010 : 		if (!PyTuple_GetInteger(poArgs, 2, &iAttributeType))

  000c1	8d 45 f4	 lea	 eax, DWORD PTR _iAttributeType$[ebp]
  000c4	50		 push	 eax
  000c5	6a 02		 push	 2
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	84 c0		 test	 al, al
  000d2	74 b8		 je	 SHORT $LN20@playerSetI

; 2011 : 			return Py_BuildException();
; 2012 : 
; 2013 : 		if (!PyTuple_GetInteger(poArgs, 3, &iAttributeValue))

  000d4	8d 45 f8	 lea	 eax, DWORD PTR _iAttributeValue$[ebp]
  000d7	50		 push	 eax
  000d8	6a 03		 push	 3
  000da	56		 push	 esi
  000db	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e3	84 c0		 test	 al, al
  000e5	74 a5		 je	 SHORT $LN20@playerSetI
$LN7@playerSetI:

; 2031 : 		break;
; 2032 : 	}
; 2033 : 	CPythonPlayer::Instance().SetItemAttribute(ItemPos, iAttributeSlotIndex, iAttributeType, iAttributeValue);

  000e7	ff 75 f8	 push	 DWORD PTR _iAttributeValue$[ebp]
  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  000f0	ff 75 f4	 push	 DWORD PTR _iAttributeType$[ebp]
  000f3	66 8b 45 fc	 mov	 ax, WORD PTR _ItemPos$[ebp]
  000f7	83 c1 04	 add	 ecx, 4
  000fa	ff 75 f0	 push	 DWORD PTR _iAttributeSlotIndex$[ebp]
  000fd	51		 push	 ecx
  000fe	8b 31		 mov	 esi, DWORD PTR [ecx]
  00100	8b d4		 mov	 edx, esp
  00102	66 89 02	 mov	 WORD PTR [edx], ax
  00105	8a 45 fe	 mov	 al, BYTE PTR _ItemPos$[ebp+2]
  00108	88 42 02	 mov	 BYTE PTR [edx+2], al
  0010b	ff 56 3c	 call	 DWORD PTR [esi+60]

; 2034 : 	return Py_BuildNone();

  0010e	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 2035 : }

  00113	5e		 pop	 esi
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
?playerSetItemAttribute@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetItemAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_potionType$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z PROC	; playerSetAutoPotionInfo, COMDAT

; 2038 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2039 : 	int potionType = 0;
; 2040 : 	if (!PyTuple_GetInteger(poArgs, 0, &potionType))

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _poArgs$[ebp]
  00008	8d 45 fc	 lea	 eax, DWORD PTR _potionType$[ebp]
  0000b	50		 push	 eax
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _potionType$[ebp], 0
  00016	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	84 c0		 test	 al, al
  00020	75 0a		 jne	 SHORT $LN5@playerSetA

; 2041 : 		return Py_BadArgument();

  00022	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument
  00027	5f		 pop	 edi

; 2060 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN5@playerSetA:
  0002c	56		 push	 esi

; 2042 : 
; 2043 : 	CPythonPlayer* player = CPythonPlayer::InstancePtr();
; 2044 : 
; 2045 : 	CPythonPlayer::SAutoPotionInfo& potionInfo = player->GetAutoPotionInfo(potionType);

  0002d	8b 75 fc	 mov	 esi, DWORD PTR _potionType$[ebp]
  00030	8d b6 a2 10 00
	00		 lea	 esi, DWORD PTR [esi+4258]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 427  : 		__inline		SAutoPotionInfo& GetAutoPotionInfo(int type)		{ return m_kAutoPotionInfo[type]; }

  00036	c1 e6 04	 shl	 esi, 4
  00039	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 2047 : 	if (!PyTuple_GetBoolean(poArgs, 1, &potionInfo.bActivated))

  0003f	56		 push	 esi
  00040	6a 01		 push	 1
  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 ?PyTuple_GetBoolean@@YA_NPAU_object@@HPA_N@Z ; PyTuple_GetBoolean
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	84 c0		 test	 al, al
  0004d	74 39		 je	 SHORT $LN13@playerSetA

; 2048 : 		return Py_BadArgument();
; 2049 : 
; 2050 : 	if (!PyTuple_GetLong(poArgs, 2, &potionInfo.currentAmount))

  0004f	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00052	50		 push	 eax
  00053	6a 02		 push	 2
  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 ?PyTuple_GetLong@@YA_NPAU_object@@HPAJ@Z ; PyTuple_GetLong
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	84 c0		 test	 al, al
  00060	74 26		 je	 SHORT $LN13@playerSetA

; 2051 : 		return Py_BadArgument();
; 2052 : 
; 2053 : 	if (!PyTuple_GetLong(poArgs, 3, &potionInfo.totalAmount))

  00062	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00065	50		 push	 eax
  00066	6a 03		 push	 3
  00068	57		 push	 edi
  00069	e8 00 00 00 00	 call	 ?PyTuple_GetLong@@YA_NPAU_object@@HPAJ@Z ; PyTuple_GetLong
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	84 c0		 test	 al, al
  00073	74 13		 je	 SHORT $LN13@playerSetA

; 2054 : 		return Py_BadArgument();
; 2055 : 
; 2056 : 	if (!PyTuple_GetLong(poArgs, 4, &potionInfo.inventorySlotIndex))

  00075	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00078	50		 push	 eax
  00079	6a 04		 push	 4
  0007b	57		 push	 edi
  0007c	e8 00 00 00 00	 call	 ?PyTuple_GetLong@@YA_NPAU_object@@HPAJ@Z ; PyTuple_GetLong
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	84 c0		 test	 al, al
  00086	75 0b		 jne	 SHORT $LN1@playerSetA
$LN13@playerSetA:

; 2057 : 		return Py_BadArgument();

  00088	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument
  0008d	5e		 pop	 esi
  0008e	5f		 pop	 edi

; 2060 : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN1@playerSetA:

; 2058 : 
; 2059 : 	return Py_BuildNone();

  00093	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  00098	5e		 pop	 esi
  00099	5f		 pop	 edi

; 2060 : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?playerSetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z ENDP	; playerSetAutoPotionInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerGetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_potionType$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerGetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z PROC	; playerGetAutoPotionInfo, COMDAT

; 2063 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2064 : 	CPythonPlayer* player = CPythonPlayer::InstancePtr();

  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 2065 : 
; 2066 : 	int potionType = 0;
; 2067 : 	if (!PyTuple_GetInteger(poArgs, 0, &potionType))

  0000b	8d 45 fc	 lea	 eax, DWORD PTR _potionType$[ebp]
  0000e	50		 push	 eax
  0000f	6a 00		 push	 0
  00011	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _potionType$[ebp], 0
  0001b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	84 c0		 test	 al, al
  00025	75 0a		 jne	 SHORT $LN1@playerGetA

; 2068 : 		return Py_BadArgument();

  00027	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument
  0002c	5e		 pop	 esi

; 2073 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN1@playerGetA:

; 2069 : 
; 2070 : 	CPythonPlayer::SAutoPotionInfo& potionInfo = player->GetAutoPotionInfo(potionType);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _potionType$[ebp]
  00034	05 a2 10 00 00	 add	 eax, 4258		; 000010a2H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 427  : 		__inline		SAutoPotionInfo& GetAutoPotionInfo(int type)		{ return m_kAutoPotionInfo[type]; }

  00039	c1 e0 04	 shl	 eax, 4
  0003c	03 c6		 add	 eax, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 2072 : 	return Py_BuildValue("biii", potionInfo.bActivated, int(potionInfo.currentAmount), int(potionInfo.totalAmount), int(potionInfo.inventorySlotIndex));

  0003e	ff 70 0c	 push	 DWORD PTR [eax+12]
  00041	ff 70 08	 push	 DWORD PTR [eax+8]
  00044	ff 70 04	 push	 DWORD PTR [eax+4]
  00047	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_04GPDILEAH@biii?$AA@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00056	83 c4 14	 add	 esp, 20			; 00000014H
  00059	5e		 pop	 esi

; 2073 : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?playerGetAutoPotionInfo@@YAPAU_object@@PAU1@0@Z ENDP	; playerGetAutoPotionInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSlotTypeToInvenType@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_slotType$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSlotTypeToInvenType@@YAPAU_object@@PAU1@0@Z PROC	; playerSlotTypeToInvenType, COMDAT

; 2076 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2077 : 	int slotType = 0;
; 2078 : 	if (!PyTuple_GetInteger(poArgs, 0, &slotType))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _slotType$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _slotType$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 00		 push	 0
  00011	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00014	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	84 c0		 test	 al, al
  0001e	75 09		 jne	 SHORT $LN1@playerSlot

; 2079 : 		return Py_BadArgument();

  00020	e8 00 00 00 00	 call	 ?Py_BadArgument@@YAPAU_object@@XZ ; Py_BadArgument

; 2082 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN1@playerSlot:

; 2080 : 
; 2081 : 	return Py_BuildValue("i", SlotTypeToInvenType((BYTE)slotType));

  00029	8a 4d fc	 mov	 cl, BYTE PTR _slotType$[ebp]
  0002c	e8 00 00 00 00	 call	 ?SlotTypeToInvenType@@YAEE@Z ; SlotTypeToInvenType
  00031	0f b6 c0	 movzx	 eax, al
  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00040	83 c4 08	 add	 esp, 8

; 2082 : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?playerSlotTypeToInvenType@@YAPAU_object@@PAU1@0@Z ENDP	; playerSlotTypeToInvenType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?playerSendDragonSoulRefine@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_pos$1 = -72						; size = 4
_bSubHeader$ = -68					; size = 1
_key$2 = -64						; size = 4
_value$3 = -60						; size = 4
_pDic$ = -56						; size = 4
_RefineItemPoses$ = -52					; size = 45
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?playerSendDragonSoulRefine@@YAPAU_object@@PAU1@0@Z PROC ; playerSendDragonSoulRefine, COMDAT

; 2126 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]

; 2127 : 	BYTE bSubHeader;
; 2128 : 	PyObject* pDic;
; 2129 : 	TItemPos RefineItemPoses[DS_REFINE_WINDOW_MAX_NUM];

  00014	8d 45 cc	 lea	 eax, DWORD PTR _RefineItemPoses$[ebp]
  00017	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0001c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$LL15@playerSend:
  00021	49		 dec	 ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 186  : 		window_type =     INVENTORY;

  00022	c6 00 01	 mov	 BYTE PTR [eax], 1

; 187  : 		cell = WORD_MAX;

  00025	66 89 50 01	 mov	 WORD PTR [eax+1], dx
  00029	8d 40 03	 lea	 eax, DWORD PTR [eax+3]
  0002c	79 f3		 jns	 SHORT $LL15@playerSend
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp

; 2130 : 	if (!PyTuple_GetByte(poArgs, 0, &bSubHeader))

  0002e	8d 45 bc	 lea	 eax, DWORD PTR _bSubHeader$[ebp]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	84 c0		 test	 al, al
  0003f	75 19		 jne	 SHORT $LN11@playerSend

; 2131 : 		return Py_BuildException();

  00041	6a 00		 push	 0
  00043	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00048	83 c4 04	 add	 esp, 4
  0004b	5e		 pop	 esi

; 2166 : }

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	33 cd		 xor	 ecx, ebp
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN11@playerSend:

; 2132 : 	switch (bSubHeader)

  0005a	8a 45 bc	 mov	 al, BYTE PTR _bSubHeader$[ebp]
  0005d	2c 02		 sub	 al, 2
  0005f	53		 push	 ebx
  00060	57		 push	 edi
  00061	3c 02		 cmp	 al, 2
  00063	0f 87 a1 00 00
	00		 ja	 $LN31@playerSend

; 2133 : 	{
; 2134 : 	case DS_SUB_HEADER_CLOSE:
; 2135 : 		break;
; 2136 : 	case DS_SUB_HEADER_DO_UPGRADE:
; 2137 : 	case DS_SUB_HEADER_DO_IMPROVEMENT:
; 2138 : 	case DS_SUB_HEADER_DO_REFINE:
; 2139 : 		{
; 2140 : 			if (!PyTuple_GetObject(poArgs, 1, &pDic))

  00069	8d 45 c8	 lea	 eax, DWORD PTR _pDic$[ebp]
  0006c	50		 push	 eax
  0006d	6a 01		 push	 1
  0006f	56		 push	 esi
  00070	e8 00 00 00 00	 call	 ?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z ; PyTuple_GetObject
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	84 c0		 test	 al, al
  0007a	0f 84 b2 00 00
	00		 je	 $LN24@playerSend

; 2141 : 				return Py_BuildException();
; 2142 : 			int pos = 0;
; 2143 : 			PyObject* key, *value;
; 2144 : 			int size = PyDict_Size(pDic);

  00080	ff 75 c8	 push	 DWORD PTR _pDic$[ebp]
  00083	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _pos$1[ebp], 0
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_Size

; 2145 : 
; 2146 : 			while (PyDict_Next(pDic, &pos, &key, &value))

  00090	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__PyDict_Next
  00096	8d 45 c4	 lea	 eax, DWORD PTR _value$3[ebp]
  00099	50		 push	 eax
  0009a	8d 45 c0	 lea	 eax, DWORD PTR _key$2[ebp]
  0009d	50		 push	 eax
  0009e	8d 45 b8	 lea	 eax, DWORD PTR _pos$1[ebp]
  000a1	50		 push	 eax
  000a2	ff 75 c8	 push	 DWORD PTR _pDic$[ebp]
  000a5	ff d3		 call	 ebx
  000a7	83 c4 14	 add	 esp, 20			; 00000014H
  000aa	85 c0		 test	 eax, eax
  000ac	74 5c		 je	 SHORT $LN31@playerSend
  000ae	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PyInt_AsLong
$LL5@playerSend:

; 2147 : 			{
; 2148 : 				int i = PyInt_AsLong(key);

  000b4	ff 75 c0	 push	 DWORD PTR _key$2[ebp]
  000b7	ff d7		 call	 edi
  000b9	83 c4 04	 add	 esp, 4

; 2149 : 				if (i > DS_REFINE_WINDOW_MAX_NUM)

  000bc	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000bf	7f 71		 jg	 SHORT $LN24@playerSend

; 2151 : 
; 2152 : 				if (!PyTuple_GetByte(value, 0, &RefineItemPoses[i].window_type) 
; 2153 : 					|| !PyTuple_GetInteger(value, 1, &RefineItemPoses[i].cell))

  000c1	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  000c4	8d 45 cc	 lea	 eax, DWORD PTR _RefineItemPoses$[ebp]
  000c7	03 c6		 add	 eax, esi
  000c9	50		 push	 eax
  000ca	6a 00		 push	 0
  000cc	ff 75 c4	 push	 DWORD PTR _value$3[ebp]
  000cf	e8 00 00 00 00	 call	 ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetByte
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	84 c0		 test	 al, al
  000d9	74 57		 je	 SHORT $LN24@playerSend
  000db	8d 45 cd	 lea	 eax, DWORD PTR _RefineItemPoses$[ebp+1]
  000de	03 c6		 add	 eax, esi
  000e0	50		 push	 eax
  000e1	6a 01		 push	 1
  000e3	ff 75 c4	 push	 DWORD PTR _value$3[ebp]
  000e6	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	84 c0		 test	 al, al
  000f0	74 40		 je	 SHORT $LN24@playerSend

; 2145 : 
; 2146 : 			while (PyDict_Next(pDic, &pos, &key, &value))

  000f2	8d 45 c4	 lea	 eax, DWORD PTR _value$3[ebp]
  000f5	50		 push	 eax
  000f6	8d 45 c0	 lea	 eax, DWORD PTR _key$2[ebp]
  000f9	50		 push	 eax
  000fa	8d 45 b8	 lea	 eax, DWORD PTR _pos$1[ebp]
  000fd	50		 push	 eax
  000fe	ff 75 c8	 push	 DWORD PTR _pDic$[ebp]
  00101	ff d3		 call	 ebx
  00103	83 c4 10	 add	 esp, 16			; 00000010H
  00106	85 c0		 test	 eax, eax
  00108	75 aa		 jne	 SHORT $LL5@playerSend
$LN31@playerSend:

; 2154 : 				{
; 2155 : 					return Py_BuildException();
; 2156 : 				}
; 2157 : 			}
; 2158 : 		}
; 2159 : 		break;
; 2160 : 	}
; 2161 : 
; 2162 : 	CPythonNetworkStream& rns=CPythonNetworkStream::Instance();
; 2163 : 	rns.SendDragonSoulRefinePacket(bSubHeader, RefineItemPoses);

  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00110	8d 45 cc	 lea	 eax, DWORD PTR _RefineItemPoses$[ebp]
  00113	50		 push	 eax
  00114	ff 75 bc	 push	 DWORD PTR _bSubHeader$[ebp]
  00117	e8 00 00 00 00	 call	 ?SendDragonSoulRefinePacket@CPythonNetworkStream@@QAE_NEPAUSItemPos@@@Z ; CPythonNetworkStream::SendDragonSoulRefinePacket

; 2164 : 	
; 2165 : 	return Py_BuildNone();

  0011c	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  00121	5f		 pop	 edi
  00122	5b		 pop	 ebx
  00123	5e		 pop	 esi

; 2166 : }

  00124	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00127	33 cd		 xor	 ecx, ebp
  00129	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
$LN24@playerSend:

; 2150 : 					return Py_BuildException();

  00132	6a 00		 push	 0
  00134	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException

; 2166 : }

  00139	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013c	83 c4 04	 add	 esp, 4
  0013f	33 cd		 xor	 ecx, ebp
  00141	5f		 pop	 edi
  00142	5b		 pop	 ebx
  00143	5e		 pop	 esi
  00144	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
?playerSendDragonSoulRefine@@YAPAU_object@@PAU1@0@Z ENDP ; playerSendDragonSoulRefine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayermodule.cpp
;	COMDAT ?initPlayer@@YAXXZ
_TEXT	SEGMENT
?initPlayer@@YAXXZ PROC					; initPlayer, COMDAT

; 2168 : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 2169 : 	static PyMethodDef s_methods[] =
; 2170 : 	{
; 2171 : 		{ "GetAutoPotionInfo",			playerGetAutoPotionInfo,			METH_VARARGS },
; 2172 : 		{ "SetAutoPotionInfo",			playerSetAutoPotionInfo,			METH_VARARGS },
; 2173 : 
; 2174 : 		{ "PickCloseItem",				playerPickCloseItem,				METH_VARARGS },
; 2175 : 		{ "SetGameWindow",				playerSetGameWindow,				METH_VARARGS },
; 2176 : 		{ "RegisterEffect",				playerRegisterEffect,				METH_VARARGS },
; 2177 : 		{ "RegisterCacheEffect",		playerRegisterCacheEffect,			METH_VARARGS },
; 2178 : 		{ "SetMouseState",				playerSetMouseState,				METH_VARARGS },
; 2179 : 		{ "SetMouseFunc",				playerSetMouseFunc,					METH_VARARGS },
; 2180 : 		{ "GetMouseFunc",				playerGetMouseFunc,					METH_VARARGS },
; 2181 : 		{ "SetMouseMiddleButtonState",	playerSetMouseMiddleButtonState,	METH_VARARGS },
; 2182 : 		{ "SetMainCharacterIndex",		playerSetMainCharacterIndex,		METH_VARARGS },
; 2183 : 		{ "GetMainCharacterIndex",		playerGetMainCharacterIndex,		METH_VARARGS },
; 2184 : 		{ "GetMainCharacterName",		playerGetMainCharacterName,			METH_VARARGS },
; 2185 : 		{ "GetMainCharacterPosition",	playerGetMainCharacterPosition,		METH_VARARGS },
; 2186 : 		{ "IsMainCharacterIndex",		playerIsMainCharacterIndex,			METH_VARARGS },
; 2187 : 		{ "CanAttackInstance",			playerCanAttackInstance,			METH_VARARGS },
; 2188 : 		{ "IsActingEmotion",			playerIsActingEmotion,				METH_VARARGS },
; 2189 : 		{ "IsPVPInstance",				playerIsPVPInstance,				METH_VARARGS },
; 2190 : 		{ "IsSameEmpire",				playerIsSameEmpire,					METH_VARARGS },
; 2191 : 		{ "IsChallengeInstance",		playerIsChallengeInstance,			METH_VARARGS },
; 2192 : 		{ "IsRevengeInstance",			playerIsRevengeInstance,			METH_VARARGS },
; 2193 : 		{ "IsCantFightInstance",		playerIsCantFightInstance,			METH_VARARGS },
; 2194 : 		{ "GetCharacterDistance",		playerGetCharacterDistance,			METH_VARARGS },
; 2195 : 		{ "IsInSafeArea",				playerIsInSafeArea,					METH_VARARGS },
; 2196 : 		{ "IsMountingHorse",			playerIsMountingHorse,				METH_VARARGS },
; 2197 : 		{ "IsObserverMode",				playerIsObserverMode,				METH_VARARGS },
; 2198 : 		{ "ActEmotion",					playerActEmotion,					METH_VARARGS },
; 2199 : 
; 2200 : 		{ "ShowPlayer",					playerShowPlayer,					METH_VARARGS },
; 2201 : 		{ "HidePlayer",					playerHidePlayer,					METH_VARARGS },
; 2202 : 
; 2203 : 		{ "ComboAttack",				playerComboAttack,					METH_VARARGS },
; 2204 : 
; 2205 : 		{ "SetAutoCameraRotationSpeed",	playerSetAutoCameraRotationSpeed,	METH_VARARGS },
; 2206 : 		{ "SetAttackKeyState",			playerSetAttackKeyState,			METH_VARARGS },
; 2207 : 		{ "SetSingleDIKKeyState",		playerSetSingleDIKKeyState,			METH_VARARGS },
; 2208 : 		{ "EndKeyWalkingImmediately",	playerEndKeyWalkingImmediately,		METH_VARARGS },
; 2209 : 		{ "StartMouseWalking",			playerStartMouseWalking,			METH_VARARGS },
; 2210 : 		{ "EndMouseWalking",			playerEndMouseWalking,				METH_VARARGS },
; 2211 : 		{ "ResetCameraRotation",		playerResetCameraRotation,			METH_VARARGS },
; 2212 : 		{ "SetQuickCameraMode",			playerSetQuickCameraMode,			METH_VARARGS },
; 2213 : 
; 2214 : 		///////////////////////////////////////////////////////////////////////////////////////////
; 2215 : 
; 2216 : 		{ "SetSkill",							playerSetSkill,								METH_VARARGS },
; 2217 : 		{ "GetSkillIndex",						playerGetSkillIndex,						METH_VARARGS },
; 2218 : 		{ "GetSkillSlotIndex",					playerGetSkillSlotIndex,					METH_VARARGS },
; 2219 : 		{ "GetSkillGrade",						playerGetSkillGrade,						METH_VARARGS },
; 2220 : 		{ "GetSkillLevel",						playerGetSkillLevel,						METH_VARARGS },
; 2221 : 		{ "GetSkillCurrentEfficientPercentage",	playerGetSkillCurrentEfficientPercentage,	METH_VARARGS },
; 2222 : 		{ "GetSkillNextEfficientPercentage",	playerGetSkillNextEfficientPercentage,		METH_VARARGS },
; 2223 : 		{ "ClickSkillSlot",						playerClickSkillSlot,						METH_VARARGS },
; 2224 : 		{ "ChangeCurrentSkillNumberOnly",		playerChangeCurrentSkillNumberOnly,			METH_VARARGS },
; 2225 : 		{ "ClearSkillDict",						playerClearSkillDict,						METH_VARARGS },
; 2226 : 
; 2227 : 		{ "GetItemIndex",						playerGetItemIndex,							METH_VARARGS },
; 2228 : 		{ "GetItemFlags",						playerGetItemFlags,							METH_VARARGS },
; 2229 : 		{ "GetItemCount",						playerGetItemCount,							METH_VARARGS },
; 2230 : 		{ "GetItemCountByVnum",					playerGetItemCountByVnum,					METH_VARARGS },
; 2231 : 		{ "GetItemMetinSocket",					playerGetItemMetinSocket,					METH_VARARGS },
; 2232 : 		{ "GetItemAttribute",					playerGetItemAttribute,						METH_VARARGS },
; 2233 : #if defined(GAIDEN)
; 2234 : 		{ "GetItemUnbindTime",					playerGetItemUnbindTime,					METH_VARARGS },
; 2235 : #endif
; 2236 : 		{ "GetISellItemPrice",					playerGetISellItemPrice,					METH_VARARGS },
; 2237 : 		{ "MoveItem",							playerMoveItem,								METH_VARARGS },
; 2238 : 		{ "SendClickItemPacket",				playerSendClickItemPacket,					METH_VARARGS },
; 2239 : 
; 2240 : 		///////////////////////////////////////////////////////////////////////////////////////////
; 2241 : 
; 2242 : 		{ "GetName",					playerGetName,						METH_VARARGS },
; 2243 : 		{ "GetJob",						playerGetJob,						METH_VARARGS },
; 2244 : 		{ "GetRace",					playerGetRace,						METH_VARARGS },
; 2245 : 		{ "GetPlayTime",				playerGetPlayTime,					METH_VARARGS },
; 2246 : 		{ "SetPlayTime",				playerSetPlayTime,					METH_VARARGS },
; 2247 : 
; 2248 : 		{ "IsSkillCoolTime",			playerIsSkillCoolTime,				METH_VARARGS },
; 2249 : 		{ "GetSkillCoolTime",			playerGetSkillCoolTime,				METH_VARARGS },
; 2250 : 		{ "IsSkillActive",				playerIsSkillActive,				METH_VARARGS },
; 2251 : 		{ "UseGuildSkill",				playerUseGuildSkill,				METH_VARARGS },
; 2252 : 		{ "AffectIndexToSkillIndex",	playerAffectIndexToSkillIndex,		METH_VARARGS },
; 2253 : 		{ "GetEXP",						playerGetEXP,						METH_VARARGS },
; 2254 : 		{ "GetStatus",					playerGetStatus,					METH_VARARGS },
; 2255 : 		{ "SetStatus",					playerSetStatus,					METH_VARARGS },
; 2256 : 		{ "GetElk",						playerGetElk,						METH_VARARGS },
; 2257 : 		{ "GetMoney",					playerGetElk,						METH_VARARGS },
; 2258 : 		{ "GetGuildID",					playerGetGuildID,					METH_VARARGS },
; 2259 : 		{ "GetGuildName",				playerGetGuildName,					METH_VARARGS },
; 2260 : 		{ "GetAlignmentData",			playerGetAlignmentData,				METH_VARARGS },
; 2261 : 		{ "RequestAddLocalQuickSlot",					playerRequestAddLocalQuickSlot,						METH_VARARGS },
; 2262 : 		{ "RequestAddToEmptyLocalQuickSlot",			playerRequestAddToEmptyLocalQuickSlot,				METH_VARARGS },
; 2263 : 		{ "RequestDeleteGlobalQuickSlot",				playerRequestDeleteGlobalQuickSlot,					METH_VARARGS },
; 2264 : 		{ "RequestMoveGlobalQuickSlotToLocalQuickSlot",	playerRequestMoveGlobalQuickSlotToLocalQuickSlot,	METH_VARARGS },
; 2265 : 		{ "RequestUseLocalQuickSlot",					playerRequestUseLocalQuickSlot,						METH_VARARGS },
; 2266 : 		{ "LocalQuickSlotIndexToGlobalQuickSlotIndex",	playerLocalQuickSlotIndexToGlobalQuickSlotIndex,	METH_VARARGS },
; 2267 : 
; 2268 : 		{ "GetQuickPage",				playerGetQuickPage,					METH_VARARGS },
; 2269 : 		{ "SetQuickPage",				playerSetQuickPage,					METH_VARARGS },
; 2270 : 		{ "GetLocalQuickSlot",			playerGetLocalQuickSlot,			METH_VARARGS },
; 2271 : 		{ "GetGlobalQuickSlot",			playerGetGlobalQuickSlot,			METH_VARARGS },
; 2272 : 		{ "RemoveQuickSlotByValue",		playerRemoveQuickSlotByValue,		METH_VARARGS },
; 2273 : 
; 2274 : 		{ "isItem",						playerisItem,						METH_VARARGS },
; 2275 : 		{ "IsEquipmentSlot",			playerIsEquipmentSlot,				METH_VARARGS },
; 2276 : 		{ "IsDSEquipmentSlot",			playerIsDSEquipmentSlot,			METH_VARARGS },
; 2277 : 		{ "IsCostumeSlot",				playerIsCostumeSlot,				METH_VARARGS },
; 2278 : 		{ "IsValuableItem",				playerIsValuableItem,				METH_VARARGS },
; 2279 : 		{ "IsOpenPrivateShop",			playerIsOpenPrivateShop,			METH_VARARGS },
; 2280 : 
; 2281 : #ifdef ENABLE_NEW_EQUIPMENT_SYSTEM
; 2282 : 		{ "IsBeltInventorySlot",			playerIsBeltInventorySlot,			METH_VARARGS },
; 2283 : 		{ "IsEquippingBelt",				playerIsEquippingBelt,				METH_VARARGS },		
; 2284 : 		{ "IsAvailableBeltInventoryCell",	playerIsAvailableBeltInventoryCell,	METH_VARARGS },		
; 2285 : #endif
; 2286 : 
; 2287 : 		// Refine
; 2288 : 		{ "GetItemGrade",				playerGetItemGrade,					METH_VARARGS },
; 2289 : 		{ "CanRefine",					playerCanRefine,					METH_VARARGS },
; 2290 : 		{ "CanDetach",					playerCanDetach,					METH_VARARGS },
; 2291 : 		{ "CanUnlock",					playerCanUnlock,					METH_VARARGS },
; 2292 : 		{ "CanAttachMetin",				playerCanAttachMetin,				METH_VARARGS },
; 2293 : 		{ "IsRefineGradeScroll",		playerIsRefineGradeScroll,			METH_VARARGS },
; 2294 : 
; 2295 : 		{ "ClearTarget",				playerClearTarget,					METH_VARARGS },
; 2296 : 		{ "SetTarget",					playerSetTarget,					METH_VARARGS },
; 2297 : 		{ "OpenCharacterMenu",			playerOpenCharacterMenu,			METH_VARARGS },
; 2298 : 
; 2299 : 		{ "Update",						playerUpdate,						METH_VARARGS },
; 2300 : 		{ "Render",						playerRender,						METH_VARARGS },
; 2301 : 		{ "Clear",						playerClear,						METH_VARARGS },
; 2302 : 
; 2303 : 		// Party
; 2304 : 		{ "IsPartyMember",				playerIsPartyMember,				METH_VARARGS },
; 2305 : 		{ "IsPartyLeader",				playerIsPartyLeader,				METH_VARARGS },
; 2306 : 		{ "IsPartyLeaderByPID",			playerIsPartyLeaderByPID,			METH_VARARGS },
; 2307 : 		{ "GetPartyMemberHPPercentage",	playerGetPartyMemberHPPercentage,	METH_VARARGS },
; 2308 : 		{ "GetPartyMemberState",		playerGetPartyMemberState,			METH_VARARGS },
; 2309 : 		{ "GetPartyMemberAffects",		playerGetPartyMemberAffects,		METH_VARARGS },
; 2310 : 		{ "RemovePartyMember",			playerRemovePartyMember,			METH_VARARGS },
; 2311 : 		{ "ExitParty",					playerExitParty,					METH_VARARGS },
; 2312 : 
; 2313 : 		// PK Mode
; 2314 : 		{ "GetPKMode",					playerGetPKMode,					METH_VARARGS },
; 2315 : 
; 2316 : 		// Mobile
; 2317 : 		{ "HasMobilePhoneNumber",		playerHasMobilePhoneNumber,			METH_VARARGS },
; 2318 : 
; 2319 : 		// Emotion
; 2320 : 		{ "RegisterEmotionIcon",		playerRegisterEmotionIcon,			METH_VARARGS },
; 2321 : 		{ "GetEmotionIconImage",		playerGetEmotionIconImage,			METH_VARARGS },
; 2322 : 
; 2323 : 		// For System
; 2324 : 		{ "SetWeaponAttackBonusFlag",	playerSetWeaponAttackBonusFlag,		METH_VARARGS },
; 2325 : 		{ "ToggleCoolTime",				playerToggleCoolTime,				METH_VARARGS },
; 2326 : 		{ "ToggleLevelLimit",			playerToggleLevelLimit,				METH_VARARGS },
; 2327 : 		{ "GetTargetVID",				playerGetTargetVID,					METH_VARARGS },
; 2328 : 
; 2329 : 		{ "SetItemData",				playerSetItemData,					METH_VARARGS },
; 2330 : 		{ "SetItemMetinSocket",			playerSetItemMetinSocket,			METH_VARARGS },
; 2331 : 		{ "SetItemAttribute",			playerSetItemAttribute,				METH_VARARGS },
; 2332 : 		{ "SetItemCount",				playerSetItemCount,					METH_VARARGS },
; 2333 : 
; 2334 : 		{ "GetItemLink",				playerGetItemLink,					METH_VARARGS },
; 2335 : 		{ "SlotTypeToInvenType",		playerSlotTypeToInvenType,			METH_VARARGS },
; 2336 : 		{ "SendDragonSoulRefine",		playerSendDragonSoulRefine,			METH_VARARGS },
; 2337 : 
; 2338 : 		{ NULL,							NULL,								NULL },
; 2339 : 	};
; 2340 : 
; 2341 : 	PyObject* poModule = Py_InitModule("player", s_methods);

  00002	68 f5 03 00 00	 push	 1013			; 000003f5H
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	68 00 00 00 00	 push	 OFFSET ?s_methods@?1??initPlayer@@YAXXZ@4PAUPyMethodDef@@A
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_06BALNJMNP@player?$AA@
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_InitModule4

; 2342 :     PyModule_AddIntConstant(poModule, "LEVEL",					POINT_LEVEL);

  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PyModule_AddIntConstant
  00021	8b f8		 mov	 edi, eax
  00023	6a 01		 push	 1
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_05GCEPFMCO@LEVEL?$AA@
  0002a	57		 push	 edi
  0002b	ff d6		 call	 esi

; 2343 :     PyModule_AddIntConstant(poModule, "VOICE",					POINT_VOICE);

  0002d	6a 02		 push	 2
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_05FHIHOFEA@VOICE?$AA@
  00034	57		 push	 edi
  00035	ff d6		 call	 esi

; 2344 :     PyModule_AddIntConstant(poModule, "EXP",					POINT_EXP);

  00037	6a 03		 push	 3
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_03KKGFKKLA@EXP?$AA@
  0003e	57		 push	 edi
  0003f	ff d6		 call	 esi

; 2345 :     PyModule_AddIntConstant(poModule, "NEXT_EXP",				POINT_NEXT_EXP);

  00041	6a 04		 push	 4
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_08CHGDMADF@NEXT_EXP?$AA@
  00048	57		 push	 edi
  00049	ff d6		 call	 esi
  0004b	83 c4 44	 add	 esp, 68			; 00000044H

; 2346 :     PyModule_AddIntConstant(poModule, "HP",						POINT_HP);

  0004e	6a 05		 push	 5
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_02MEIMKHMB@HP?$AA@
  00055	57		 push	 edi
  00056	ff d6		 call	 esi

; 2347 :     PyModule_AddIntConstant(poModule, "MAX_HP",					POINT_MAX_HP);

  00058	6a 06		 push	 6
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_06NMHEPHCD@MAX_HP?$AA@
  0005f	57		 push	 edi
  00060	ff d6		 call	 esi

; 2348 :     PyModule_AddIntConstant(poModule, "SP",						POINT_SP);

  00062	6a 07		 push	 7
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_02NEPPOLFA@SP?$AA@
  00069	57		 push	 edi
  0006a	ff d6		 call	 esi

; 2349 :     PyModule_AddIntConstant(poModule, "MAX_SP",					POINT_MAX_SP);

  0006c	6a 08		 push	 8
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_06MMAHLLLC@MAX_SP?$AA@
  00073	57		 push	 edi
  00074	ff d6		 call	 esi

; 2350 :     PyModule_AddIntConstant(poModule, "STAMINA",				POINT_STAMINA);

  00076	6a 09		 push	 9
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_07IHPDJFBP@STAMINA?$AA@
  0007d	57		 push	 edi
  0007e	ff d6		 call	 esi

; 2351 :     PyModule_AddIntConstant(poModule, "MAX_STAMINA",			POINT_MAX_STAMINA);

  00080	6a 0a		 push	 10			; 0000000aH
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CHCGLEDD@MAX_STAMINA?$AA@
  00087	57		 push	 edi
  00088	ff d6		 call	 esi
  0008a	83 c4 48	 add	 esp, 72			; 00000048H

; 2352 :     PyModule_AddIntConstant(poModule, "ELK",					POINT_GOLD);

  0008d	6a 0b		 push	 11			; 0000000bH
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_03BIHMGKIG@ELK?$AA@
  00094	57		 push	 edi
  00095	ff d6		 call	 esi

; 2353 :     PyModule_AddIntConstant(poModule, "ST",						POINT_ST);

  00097	6a 0c		 push	 12			; 0000000cH
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_02LAJDCOFE@ST?$AA@
  0009e	57		 push	 edi
  0009f	ff d6		 call	 esi

; 2354 :     PyModule_AddIntConstant(poModule, "HT",						POINT_HT);

  000a1	6a 0d		 push	 13			; 0000000dH
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_02KAOAGCMF@HT?$AA@
  000a8	57		 push	 edi
  000a9	ff d6		 call	 esi

; 2355 :     PyModule_AddIntConstant(poModule, "DX",						POINT_DX);

  000ab	6a 0e		 push	 14			; 0000000eH
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_02FEPNEKN@DX?$AA@
  000b2	57		 push	 edi
  000b3	ff d6		 call	 esi

; 2356 :     PyModule_AddIntConstant(poModule, "IQ",						POINT_IQ);

  000b5	6a 0f		 push	 15			; 0000000fH
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_02NMFFPMLH@IQ?$AA@
  000bc	57		 push	 edi
  000bd	ff d6		 call	 esi

; 2357 :     PyModule_AddIntConstant(poModule, "ATT_POWER",				POINT_ATT_POWER);

  000bf	6a 10		 push	 16			; 00000010H
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_09DIGJAPIG@ATT_POWER?$AA@
  000c6	57		 push	 edi
  000c7	ff d6		 call	 esi
  000c9	83 c4 48	 add	 esp, 72			; 00000048H

; 2358 : 	PyModule_AddIntConstant(poModule, "ATT_MIN",				POINT_MIN_ATK);

  000cc	6a 1d		 push	 29			; 0000001dH
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_07PNODGJJO@ATT_MIN?$AA@
  000d3	57		 push	 edi
  000d4	ff d6		 call	 esi

; 2359 : 	PyModule_AddIntConstant(poModule, "ATT_MAX",				POINT_MAX_ATK);

  000d6	6a 1e		 push	 30			; 0000001eH
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_07OPGIINPB@ATT_MAX?$AA@
  000dd	57		 push	 edi
  000de	ff d6		 call	 esi

; 2360 : 	PyModule_AddIntConstant(poModule, "MIN_MAGIC_WEP",			POINT_MIN_MAGIC_WEP);

  000e0	68 ca 00 00 00	 push	 202			; 000000caH
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CJNCLCGL@MIN_MAGIC_WEP?$AA@
  000ea	57		 push	 edi
  000eb	ff d6		 call	 esi

; 2361 : 	PyModule_AddIntConstant(poModule, "MAX_MAGIC_WEP",			POINT_MAX_MAGIC_WEP);

  000ed	68 cb 00 00 00	 push	 203			; 000000cbH
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JAPECJBK@MAX_MAGIC_WEP?$AA@
  000f7	57		 push	 edi
  000f8	ff d6		 call	 esi

; 2362 :     PyModule_AddIntConstant(poModule, "ATT_SPEED",				POINT_ATT_SPEED);

  000fa	6a 11		 push	 17			; 00000011H
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_09LKMFFHLI@ATT_SPEED?$AA@
  00101	57		 push	 edi
  00102	ff d6		 call	 esi

; 2363 : 	PyModule_AddIntConstant(poModule, "ATT_BONUS",				POINT_ATT_GRADE_BONUS);

  00104	6a 5f		 push	 95			; 0000005fH
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_09FOFLCGDC@ATT_BONUS?$AA@
  0010b	57		 push	 edi
  0010c	ff d6		 call	 esi
  0010e	83 c4 48	 add	 esp, 72			; 00000048H

; 2364 :     PyModule_AddIntConstant(poModule, "EVADE_RATE",				POINT_EVADE_RATE);

  00111	6a 12		 push	 18			; 00000012H
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IPHIKIMB@EVADE_RATE?$AA@
  00118	57		 push	 edi
  00119	ff d6		 call	 esi

; 2365 :     PyModule_AddIntConstant(poModule, "MOVING_SPEED",			POINT_MOV_SPEED);

  0011b	6a 13		 push	 19			; 00000013H
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KGGLAJKM@MOVING_SPEED?$AA@
  00122	57		 push	 edi
  00123	ff d6		 call	 esi

; 2366 :     PyModule_AddIntConstant(poModule, "DEF_GRADE",				POINT_DEF_GRADE);

  00125	6a 14		 push	 20			; 00000014H
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_09KMPFCDFE@DEF_GRADE?$AA@
  0012c	57		 push	 edi
  0012d	ff d6		 call	 esi

; 2367 :     PyModule_AddIntConstant(poModule, "DEF_BONUS",				POINT_DEF_GRADE_BONUS);

  0012f	6a 60		 push	 96			; 00000060H
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_09DNFHINBC@DEF_BONUS?$AA@
  00136	57		 push	 edi
  00137	ff d6		 call	 esi

; 2368 :     PyModule_AddIntConstant(poModule, "CASTING_SPEED",			POINT_CASTING_SPEED);

  00139	6a 15		 push	 21			; 00000015H
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IOLIEEIE@CASTING_SPEED?$AA@
  00140	57		 push	 edi
  00141	ff d6		 call	 esi

; 2369 :     PyModule_AddIntConstant(poModule, "MAG_ATT",				POINT_MAGIC_ATT_GRADE);

  00143	6a 16		 push	 22			; 00000016H
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_07PEONMKMN@MAG_ATT?$AA@
  0014a	57		 push	 edi
  0014b	ff d6		 call	 esi
  0014d	83 c4 48	 add	 esp, 72			; 00000048H

; 2370 :     PyModule_AddIntConstant(poModule, "MAG_DEF",				POINT_MAGIC_DEF_GRADE);

  00150	6a 17		 push	 23			; 00000017H
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_07KGCDIDGL@MAG_DEF?$AA@
  00157	57		 push	 edi
  00158	ff d6		 call	 esi

; 2371 :     PyModule_AddIntConstant(poModule, "EMPIRE_POINT",			POINT_EMPIRE_POINT);

  0015a	6a 18		 push	 24			; 00000018H
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JIFCAIPA@EMPIRE_POINT?$AA@
  00161	57		 push	 edi
  00162	ff d6		 call	 esi

; 2372 : 	PyModule_AddIntConstant(poModule, "STAT",					POINT_STAT);

  00164	6a 1a		 push	 26			; 0000001aH
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_04KNIOFKKL@STAT?$AA@
  0016b	57		 push	 edi
  0016c	ff d6		 call	 esi

; 2373 : 	PyModule_AddIntConstant(poModule, "SKILL_PASSIVE",			POINT_SUB_SKILL);

  0016e	6a 1b		 push	 27			; 0000001bH
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DGEPJFAK@SKILL_PASSIVE?$AA@
  00175	57		 push	 edi
  00176	ff d6		 call	 esi

; 2374 : 	PyModule_AddIntConstant(poModule, "SKILL_SUPPORT",			POINT_SUB_SKILL);

  00178	6a 1b		 push	 27			; 0000001bH
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JLNOPGFK@SKILL_SUPPORT?$AA@
  0017f	57		 push	 edi
  00180	ff d6		 call	 esi

; 2375 : 	PyModule_AddIntConstant(poModule, "SKILL_ACTIVE",			POINT_SKILL);

  00182	6a 1c		 push	 28			; 0000001cH
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DNBJLBPA@SKILL_ACTIVE?$AA@
  00189	57		 push	 edi
  0018a	ff d6		 call	 esi
  0018c	83 c4 48	 add	 esp, 72			; 00000048H

; 2376 : 	PyModule_AddIntConstant(poModule, "SKILL_HORSE",			POINT_HORSE_SKILL);

  0018f	6a 71		 push	 113			; 00000071H
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HAFIBGFL@SKILL_HORSE?$AA@
  00196	57		 push	 edi
  00197	ff d6		 call	 esi

; 2377 : 	PyModule_AddIntConstant(poModule, "PLAYTIME",				POINT_PLAYTIME);

  00199	6a 1f		 push	 31			; 0000001fH
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_08CKIIBBI@PLAYTIME?$AA@
  001a0	57		 push	 edi
  001a1	ff d6		 call	 esi

; 2378 : 	PyModule_AddIntConstant(poModule, "BOW_DISTANCE",			POINT_BOW_DISTANCE);

  001a3	6a 22		 push	 34			; 00000022H
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KHDDEEFG@BOW_DISTANCE?$AA@
  001aa	57		 push	 edi
  001ab	ff d6		 call	 esi

; 2379 : 	PyModule_AddIntConstant(poModule, "HP_RECOVERY",			POINT_HP_RECOVERY);

  001ad	6a 23		 push	 35			; 00000023H
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CLAIAEPM@HP_RECOVERY?$AA@
  001b4	57		 push	 edi
  001b5	ff d6		 call	 esi

; 2380 : 	PyModule_AddIntConstant(poModule, "SP_RECOVERY",			POINT_SP_RECOVERY);

  001b7	6a 24		 push	 36			; 00000024H
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FGICENAO@SP_RECOVERY?$AA@
  001be	57		 push	 edi
  001bf	ff d6		 call	 esi

; 2381 : 	PyModule_AddIntConstant(poModule, "ATTACKER_BONUS",			POINT_PARTY_ATT_GRADE);

  001c1	6a 5b		 push	 91			; 0000005bH
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAAMLPFK@ATTACKER_BONUS?$AA@
  001c8	57		 push	 edi
  001c9	ff d6		 call	 esi
  001cb	83 c4 48	 add	 esp, 72			; 00000048H

; 2382 :     PyModule_AddIntConstant(poModule, "MAX_NUM",				POINT_MAX_NUM);

  001ce	68 ff 00 00 00	 push	 255			; 000000ffH
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_07MEMMKJPK@MAX_NUM?$AA@
  001d8	57		 push	 edi
  001d9	ff d6		 call	 esi

; 2383 : 	////
; 2384 : 	PyModule_AddIntConstant(poModule, "POINT_CRITICAL_PCT",		POINT_CRITICAL_PCT);

  001db	6a 28		 push	 40			; 00000028H
  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CPEECKKP@POINT_CRITICAL_PCT?$AA@
  001e2	57		 push	 edi
  001e3	ff d6		 call	 esi

; 2385 : 	PyModule_AddIntConstant(poModule, "POINT_PENETRATE_PCT",	POINT_PENETRATE_PCT);

  001e5	6a 29		 push	 41			; 00000029H
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BGNEFMNJ@POINT_PENETRATE_PCT?$AA@
  001ec	57		 push	 edi
  001ed	ff d6		 call	 esi

; 2386 : 	PyModule_AddIntConstant(poModule, "POINT_MALL_ATTBONUS",	POINT_MALL_ATTBONUS);

  001ef	6a 72		 push	 114			; 00000072H
  001f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FDGMKOPN@POINT_MALL_ATTBONUS?$AA@
  001f6	57		 push	 edi
  001f7	ff d6		 call	 esi

; 2387 : 	PyModule_AddIntConstant(poModule, "POINT_MALL_DEFBONUS",	POINT_MALL_DEFBONUS);

  001f9	6a 73		 push	 115			; 00000073H
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FJKLFHOA@POINT_MALL_DEFBONUS?$AA@
  00200	57		 push	 edi
  00201	ff d6		 call	 esi

; 2388 : 	PyModule_AddIntConstant(poModule, "POINT_MALL_EXPBONUS",	POINT_MALL_EXPBONUS);

  00203	6a 74		 push	 116			; 00000074H
  00205	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KNGAMOKN@POINT_MALL_EXPBONUS?$AA@
  0020a	57		 push	 edi
  0020b	ff d6		 call	 esi
  0020d	83 c4 48	 add	 esp, 72			; 00000048H

; 2389 : 	PyModule_AddIntConstant(poModule, "POINT_MALL_ITEMBONUS",	POINT_MALL_ITEMBONUS);

  00210	6a 75		 push	 117			; 00000075H
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FCMHLHC@POINT_MALL_ITEMBONUS?$AA@
  00217	57		 push	 edi
  00218	ff d6		 call	 esi

; 2390 : 	PyModule_AddIntConstant(poModule, "POINT_MALL_GOLDBONUS",	POINT_MALL_GOLDBONUS);

  0021a	6a 76		 push	 118			; 00000076H
  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@LPKHMJJF@POINT_MALL_GOLDBONUS?$AA@
  00221	57		 push	 edi
  00222	ff d6		 call	 esi

; 2391 : 	PyModule_AddIntConstant(poModule, "POINT_MAX_HP_PCT",		POINT_MAX_HP_PCT);

  00224	6a 77		 push	 119			; 00000077H
  00226	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OCODMABI@POINT_MAX_HP_PCT?$AA@
  0022b	57		 push	 edi
  0022c	ff d6		 call	 esi

; 2392 : 	PyModule_AddIntConstant(poModule, "POINT_MAX_SP_PCT",		POINT_MAX_SP_PCT);

  0022e	6a 78		 push	 120			; 00000078H
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IHDKAICM@POINT_MAX_SP_PCT?$AA@
  00235	57		 push	 edi
  00236	ff d6		 call	 esi

; 2393 : 
; 2394 : 	PyModule_AddIntConstant(poModule, "POINT_SKILL_DAMAGE_BONUS",		POINT_SKILL_DAMAGE_BONUS);

  00238	6a 79		 push	 121			; 00000079H
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PGEFOCDG@POINT_SKILL_DAMAGE_BONUS?$AA@
  0023f	57		 push	 edi
  00240	ff d6		 call	 esi

; 2395 : 	PyModule_AddIntConstant(poModule, "POINT_NORMAL_HIT_DAMAGE_BONUS",		POINT_NORMAL_HIT_DAMAGE_BONUS);

  00242	6a 7a		 push	 122			; 0000007aH
  00244	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GNDIKOOF@POINT_NORMAL_HIT_DAMAGE_BONUS?$AA@
  00249	57		 push	 edi
  0024a	ff d6		 call	 esi
  0024c	83 c4 48	 add	 esp, 72			; 00000048H

; 2396 : 	PyModule_AddIntConstant(poModule, "POINT_SKILL_DEFEND_BONUS",		POINT_SKILL_DEFEND_BONUS);

  0024f	6a 7b		 push	 123			; 0000007bH
  00251	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LPIAEILC@POINT_SKILL_DEFEND_BONUS?$AA@
  00256	57		 push	 edi
  00257	ff d6		 call	 esi

; 2397 : 	PyModule_AddIntConstant(poModule, "POINT_NORMAL_HIT_DEFEND_BONUS",		POINT_NORMAL_HIT_DEFEND_BONUS);

  00259	6a 7c		 push	 124			; 0000007cH
  0025b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CEPNAEGB@POINT_NORMAL_HIT_DEFEND_BONUS?$AA@
  00260	57		 push	 edi
  00261	ff d6		 call	 esi

; 2398 : 	PyModule_AddIntConstant(poModule, "POINT_PC_BANG_EXP_BONUS",		POINT_PC_BANG_EXP_BONUS);

  00263	6a 7d		 push	 125			; 0000007dH
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BAKJJELL@POINT_PC_BANG_EXP_BONUS?$AA@
  0026a	57		 push	 edi
  0026b	ff d6		 call	 esi

; 2399 : 	PyModule_AddIntConstant(poModule, "POINT_PC_BANG_DROP_BONUS",		POINT_PC_BANG_DROP_BONUS);

  0026d	6a 7e		 push	 126			; 0000007eH
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LFKCHGEO@POINT_PC_BANG_DROP_BONUS?$AA@
  00274	57		 push	 edi
  00275	ff d6		 call	 esi

; 2400 : 
; 2401 : 	PyModule_AddIntConstant(poModule, "ENERGY",		POINT_ENERGY);

  00277	68 80 00 00 00	 push	 128			; 00000080H
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_06KOEJHMAL@ENERGY?$AA@
  00281	57		 push	 edi
  00282	ff d6		 call	 esi

; 2402 : 	PyModule_AddIntConstant(poModule, "ENERGY_END_TIME",		POINT_ENERGY_END_TIME);

  00284	68 81 00 00 00	 push	 129			; 00000081H
  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIHNCBED@ENERGY_END_TIME?$AA@
  0028e	57		 push	 edi
  0028f	ff d6		 call	 esi
  00291	83 c4 48	 add	 esp, 72			; 00000048H

; 2403 : 
; 2404 :     PyModule_AddIntConstant(poModule, "SKILL_GRADE_NORMAL",			CPythonPlayer::SKILL_NORMAL);

  00294	6a 00		 push	 0
  00296	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LAKFNFGD@SKILL_GRADE_NORMAL?$AA@
  0029b	57		 push	 edi
  0029c	ff d6		 call	 esi

; 2405 :     PyModule_AddIntConstant(poModule, "SKILL_GRADE_MASTER",			CPythonPlayer::SKILL_MASTER);

  0029e	6a 01		 push	 1
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HIHOAICI@SKILL_GRADE_MASTER?$AA@
  002a5	57		 push	 edi
  002a6	ff d6		 call	 esi

; 2406 :     PyModule_AddIntConstant(poModule, "SKILL_GRADE_GRAND_MASTER",	CPythonPlayer::SKILL_GRAND_MASTER);

  002a8	6a 02		 push	 2
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CFOEIGCN@SKILL_GRADE_GRAND_MASTER?$AA@
  002af	57		 push	 edi
  002b0	ff d6		 call	 esi

; 2407 :     PyModule_AddIntConstant(poModule, "SKILL_GRADE_PERFECT_MASTER",	CPythonPlayer::SKILL_PERFECT_MASTER);

  002b2	6a 03		 push	 3
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DCIPLDCA@SKILL_GRADE_PERFECT_MASTER?$AA@
  002b9	57		 push	 edi
  002ba	ff d6		 call	 esi

; 2408 : 
; 2409 : 	PyModule_AddIntConstant(poModule, "CATEGORY_ACTIVE",		CPythonPlayer::CATEGORY_ACTIVE);

  002bc	6a 01		 push	 1
  002be	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LCKKFCJM@CATEGORY_ACTIVE?$AA@
  002c3	57		 push	 edi
  002c4	ff d6		 call	 esi

; 2410 : 	PyModule_AddIntConstant(poModule, "CATEGORY_PASSIVE",		CPythonPlayer::CATEGORY_PASSIVE);

  002c6	6a 02		 push	 2
  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HCMEALJK@CATEGORY_PASSIVE?$AA@
  002cd	57		 push	 edi
  002ce	ff d6		 call	 esi
  002d0	83 c4 48	 add	 esp, 72			; 00000048H

; 2411 : 
; 2412 : 	PyModule_AddIntConstant(poModule, "INVENTORY_PAGE_SIZE",	c_Inventory_Page_Size);

  002d3	6a 2d		 push	 45			; 0000002dH
  002d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CEBDMLGH@INVENTORY_PAGE_SIZE?$AA@
  002da	57		 push	 edi
  002db	ff d6		 call	 esi

; 2413 : 	PyModule_AddIntConstant(poModule, "INVENTORY_PAGE_COUNT",	c_Inventory_Page_Count);

  002dd	6a 05		 push	 5
  002df	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NFIFHHOM@INVENTORY_PAGE_COUNT?$AA@
  002e4	57		 push	 edi
  002e5	ff d6		 call	 esi

; 2414 : 	PyModule_AddIntConstant(poModule, "INVENTORY_SLOT_COUNT",	c_Inventory_Count);

  002e7	68 0d 01 00 00	 push	 269			; 0000010dH
  002ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@LCFAAJPA@INVENTORY_SLOT_COUNT?$AA@
  002f1	57		 push	 edi
  002f2	ff d6		 call	 esi

; 2415 : 	PyModule_AddIntConstant(poModule, "EQUIPMENT_SLOT_START",	c_Equipment_Start);

  002f4	68 e1 00 00 00	 push	 225			; 000000e1H
  002f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HJEBPPMM@EQUIPMENT_SLOT_START?$AA@
  002fe	57		 push	 edi
  002ff	ff d6		 call	 esi

; 2416 : 	PyModule_AddIntConstant(poModule, "EQUIPMENT_PAGE_COUNT",	c_Equipment_Count);

  00301	6a 0c		 push	 12			; 0000000cH
  00303	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MADFLPAE@EQUIPMENT_PAGE_COUNT?$AA@
  00308	57		 push	 edi
  00309	ff d6		 call	 esi

; 2417 : 
; 2418 : #ifdef ENABLE_NEW_EQUIPMENT_SYSTEM
; 2419 : 	PyModule_AddIntConstant(poModule, "NEW_EQUIPMENT_SLOT_START",	c_New_Equipment_Start);
; 2420 : 	PyModule_AddIntConstant(poModule, "NEW_EQUIPMENT_SLOT_COUNT",	c_New_Equipment_Count);
; 2421 : #endif
; 2422 : 
; 2423 : 	PyModule_AddIntConstant(poModule, "MBF_SKILL",	CPythonPlayer::MBF_SKILL);

  0030b	6a 04		 push	 4
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_09NLFDBCDH@MBF_SKILL?$AA@
  00312	57		 push	 edi
  00313	ff d6		 call	 esi
  00315	83 c4 48	 add	 esp, 72			; 00000048H

; 2424 : 	PyModule_AddIntConstant(poModule, "MBF_ATTACK",	CPythonPlayer::MBF_ATTACK);

  00318	6a 03		 push	 3
  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MIGMJBKJ@MBF_ATTACK?$AA@
  0031f	57		 push	 edi
  00320	ff d6		 call	 esi

; 2425 : 	PyModule_AddIntConstant(poModule, "MBF_CAMERA",	CPythonPlayer::MBF_CAMERA);

  00322	6a 02		 push	 2
  00324	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JHBFAMB@MBF_CAMERA?$AA@
  00329	57		 push	 edi
  0032a	ff d6		 call	 esi

; 2426 : 	PyModule_AddIntConstant(poModule, "MBF_SMART",	CPythonPlayer::MBF_SMART);

  0032c	6a 00		 push	 0
  0032e	68 00 00 00 00	 push	 OFFSET ??_C@_09FAENJFL@MBF_SMART?$AA@
  00333	57		 push	 edi
  00334	ff d6		 call	 esi

; 2427 : 	PyModule_AddIntConstant(poModule, "MBF_MOVE",	CPythonPlayer::MBF_MOVE);

  00336	6a 01		 push	 1
  00338	68 00 00 00 00	 push	 OFFSET ??_C@_08BLLANCB@MBF_MOVE?$AA@
  0033d	57		 push	 edi
  0033e	ff d6		 call	 esi

; 2428 : 	PyModule_AddIntConstant(poModule, "MBF_AUTO",	CPythonPlayer::MBF_AUTO);

  00340	6a 05		 push	 5
  00342	68 00 00 00 00	 push	 OFFSET ??_C@_08CIEGLDP@MBF_AUTO?$AA@
  00347	57		 push	 edi
  00348	ff d6		 call	 esi

; 2429 : 	PyModule_AddIntConstant(poModule, "MBS_PRESS",	CPythonPlayer::MBS_PRESS);

  0034a	6a 01		 push	 1
  0034c	68 00 00 00 00	 push	 OFFSET ??_C@_09JEJKPPEO@MBS_PRESS?$AA@
  00351	57		 push	 edi
  00352	ff d6		 call	 esi
  00354	83 c4 48	 add	 esp, 72			; 00000048H

; 2430 : 	PyModule_AddIntConstant(poModule, "MBS_CLICK",	CPythonPlayer::MBS_CLICK);

  00357	6a 00		 push	 0
  00359	68 00 00 00 00	 push	 OFFSET ??_C@_09BKODCCAJ@MBS_CLICK?$AA@
  0035e	57		 push	 edi
  0035f	ff d6		 call	 esi

; 2431 : 	PyModule_AddIntConstant(poModule, "MBT_RIGHT",	CPythonPlayer::MBT_RIGHT);

  00361	6a 01		 push	 1
  00363	68 00 00 00 00	 push	 OFFSET ??_C@_09DBJMODBC@MBT_RIGHT?$AA@
  00368	57		 push	 edi
  00369	ff d6		 call	 esi

; 2432 : 	PyModule_AddIntConstant(poModule, "MBT_LEFT",	CPythonPlayer::MBT_LEFT);

  0036b	6a 00		 push	 0
  0036d	68 00 00 00 00	 push	 OFFSET ??_C@_08OMNIMJHC@MBT_LEFT?$AA@
  00372	57		 push	 edi
  00373	ff d6		 call	 esi

; 2433 : 
; 2434 : 	// Public code with server
; 2435 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_NONE",						SLOT_TYPE_NONE);

  00375	6a 00		 push	 0
  00377	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JBDPGPGM@SLOT_TYPE_NONE?$AA@
  0037c	57		 push	 edi
  0037d	ff d6		 call	 esi

; 2436 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_INVENTORY",				SLOT_TYPE_INVENTORY);

  0037f	6a 01		 push	 1
  00381	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BNOEBHPE@SLOT_TYPE_INVENTORY?$AA@
  00386	57		 push	 edi
  00387	ff d6		 call	 esi

; 2437 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_SKILL",					SLOT_TYPE_SKILL);

  00389	6a 02		 push	 2
  0038b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MAJHKGKG@SLOT_TYPE_SKILL?$AA@
  00390	57		 push	 edi
  00391	ff d6		 call	 esi
  00393	83 c4 48	 add	 esp, 72			; 00000048H

; 2438 : 	// Special indecies for client
; 2439 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_SHOP",						SLOT_TYPE_SHOP);

  00396	6a 04		 push	 4
  00398	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KCOPIIMF@SLOT_TYPE_SHOP?$AA@
  0039d	57		 push	 edi
  0039e	ff d6		 call	 esi

; 2440 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_EXCHANGE_OWNER",			SLOT_TYPE_EXCHANGE_OWNER);

  003a0	6a 05		 push	 5
  003a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBNHPJKE@SLOT_TYPE_EXCHANGE_OWNER?$AA@
  003a7	57		 push	 edi
  003a8	ff d6		 call	 esi

; 2441 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_EXCHANGE_TARGET",			SLOT_TYPE_EXCHANGE_TARGET);

  003aa	6a 06		 push	 6
  003ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KJHLAGBH@SLOT_TYPE_EXCHANGE_TARGET?$AA@
  003b1	57		 push	 edi
  003b2	ff d6		 call	 esi

; 2442 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_QUICK_SLOT",				SLOT_TYPE_QUICK_SLOT);

  003b4	6a 07		 push	 7
  003b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CPPFMLHN@SLOT_TYPE_QUICK_SLOT?$AA@
  003bb	57		 push	 edi
  003bc	ff d6		 call	 esi

; 2443 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_SAFEBOX",					SLOT_TYPE_SAFEBOX);

  003be	6a 08		 push	 8
  003c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HGKFDIFN@SLOT_TYPE_SAFEBOX?$AA@
  003c5	57		 push	 edi
  003c6	ff d6		 call	 esi

; 2444 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_PRIVATE_SHOP",				SLOT_TYPE_PRIVATE_SHOP);

  003c8	6a 09		 push	 9
  003ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MJAEADNE@SLOT_TYPE_PRIVATE_SHOP?$AA@
  003cf	57		 push	 edi
  003d0	ff d6		 call	 esi
  003d2	83 c4 48	 add	 esp, 72			; 00000048H

; 2445 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_MALL",						SLOT_TYPE_MALL);

  003d5	6a 0a		 push	 10			; 0000000aH
  003d7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OEAGANKI@SLOT_TYPE_MALL?$AA@
  003dc	57		 push	 edi
  003dd	ff d6		 call	 esi

; 2446 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_EMOTION",					SLOT_TYPE_EMOTION);

  003df	6a 03		 push	 3
  003e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LKMHLHKJ@SLOT_TYPE_EMOTION?$AA@
  003e6	57		 push	 edi
  003e7	ff d6		 call	 esi

; 2447 : 	PyModule_AddIntConstant(poModule, "SLOT_TYPE_DRAGON_SOUL_INVENTORY",	SLOT_TYPE_DRAGON_SOUL_INVENTORY);

  003e9	6a 0b		 push	 11			; 0000000bH
  003eb	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FHKIPOOP@SLOT_TYPE_DRAGON_SOUL_INVENTORY?$AA@
  003f0	57		 push	 edi
  003f1	ff d6		 call	 esi

; 2448 : 
; 2449 : 	PyModule_AddIntConstant(poModule, "RESERVED_WINDOW",					RESERVED_WINDOW);

  003f3	6a 00		 push	 0
  003f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NKAFFIGF@RESERVED_WINDOW?$AA@
  003fa	57		 push	 edi
  003fb	ff d6		 call	 esi

; 2450 : 	PyModule_AddIntConstant(poModule, "INVENTORY",							INVENTORY);

  003fd	6a 01		 push	 1
  003ff	68 00 00 00 00	 push	 OFFSET ??_C@_09NCAHJFFG@INVENTORY?$AA@
  00404	57		 push	 edi
  00405	ff d6		 call	 esi

; 2451 : 	PyModule_AddIntConstant(poModule, "EQUIPMENT",							EQUIPMENT);

  00407	6a 02		 push	 2
  00409	68 00 00 00 00	 push	 OFFSET ??_C@_09GJGOMHMK@EQUIPMENT?$AA@
  0040e	57		 push	 edi
  0040f	ff d6		 call	 esi
  00411	83 c4 48	 add	 esp, 72			; 00000048H

; 2452 : 	PyModule_AddIntConstant(poModule, "SAFEBOX",							SAFEBOX);

  00414	6a 03		 push	 3
  00416	68 00 00 00 00	 push	 OFFSET ??_C@_07NCKDBJCB@SAFEBOX?$AA@
  0041b	57		 push	 edi
  0041c	ff d6		 call	 esi

; 2453 : 	PyModule_AddIntConstant(poModule, "MALL",								MALL);

  0041e	6a 04		 push	 4
  00420	68 00 00 00 00	 push	 OFFSET ??_C@_04JPFKNPOP@MALL?$AA@
  00425	57		 push	 edi
  00426	ff d6		 call	 esi

; 2454 : 	PyModule_AddIntConstant(poModule, "DRAGON_SOUL_INVENTORY",				DRAGON_SOUL_INVENTORY);

  00428	6a 05		 push	 5
  0042a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FHEDCCNN@DRAGON_SOUL_INVENTORY?$AA@
  0042f	57		 push	 edi
  00430	ff d6		 call	 esi

; 2455 : 	PyModule_AddIntConstant(poModule, "GROUND",								GROUND);

  00432	6a 06		 push	 6
  00434	68 00 00 00 00	 push	 OFFSET ??_C@_06GKBINIEJ@GROUND?$AA@
  00439	57		 push	 edi
  0043a	ff d6		 call	 esi

; 2456 : 
; 2457 : 	PyModule_AddIntConstant(poModule, "ITEM_MONEY",					-1);

  0043c	6a ff		 push	 -1
  0043e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HFAEBHHD@ITEM_MONEY?$AA@
  00443	57		 push	 edi
  00444	ff d6		 call	 esi

; 2458 : 
; 2459 : 	PyModule_AddIntConstant(poModule, "SKILL_SLOT_COUNT",			SKILL_MAX_NUM);

  00446	68 ff 00 00 00	 push	 255			; 000000ffH
  0044b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IOEKBHAE@SKILL_SLOT_COUNT?$AA@
  00450	57		 push	 edi
  00451	ff d6		 call	 esi
  00453	83 c4 48	 add	 esp, 72			; 00000048H

; 2460 : 
; 2461 : 	PyModule_AddIntConstant(poModule, "EFFECT_PICK",				CPythonPlayer::EFFECT_PICK);

  00456	6a 00		 push	 0
  00458	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CHLINENA@EFFECT_PICK?$AA@
  0045d	57		 push	 edi
  0045e	ff d6		 call	 esi

; 2462 : 
; 2463 : 	PyModule_AddIntConstant(poModule, "METIN_SOCKET_TYPE_NONE",					CPythonPlayer::METIN_SOCKET_TYPE_NONE);

  00460	6a 00		 push	 0
  00462	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FCKCIMBH@METIN_SOCKET_TYPE_NONE?$AA@
  00467	57		 push	 edi
  00468	ff d6		 call	 esi

; 2464 : 	PyModule_AddIntConstant(poModule, "METIN_SOCKET_TYPE_SILVER",				CPythonPlayer::METIN_SOCKET_TYPE_SILVER);

  0046a	6a 01		 push	 1
  0046c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PHGNNMMA@METIN_SOCKET_TYPE_SILVER?$AA@
  00471	57		 push	 edi
  00472	ff d6		 call	 esi

; 2465 : 	PyModule_AddIntConstant(poModule, "METIN_SOCKET_TYPE_GOLD",					CPythonPlayer::METIN_SOCKET_TYPE_GOLD);

  00474	6a 02		 push	 2
  00476	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EFCNALEJ@METIN_SOCKET_TYPE_GOLD?$AA@
  0047b	57		 push	 edi
  0047c	ff d6		 call	 esi

; 2466 : 	PyModule_AddIntConstant(poModule, "METIN_SOCKET_MAX_NUM",					ITEM_SOCKET_SLOT_MAX_NUM);

  0047e	6a 03		 push	 3
  00480	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HOKBLOCN@METIN_SOCKET_MAX_NUM?$AA@
  00485	57		 push	 edi
  00486	ff d6		 call	 esi

; 2467 : 	PyModule_AddIntConstant(poModule, "ATTRIBUTE_SLOT_MAX_NUM",					ITEM_ATTRIBUTE_SLOT_MAX_NUM);

  00488	6a 07		 push	 7
  0048a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BPEONNLD@ATTRIBUTE_SLOT_MAX_NUM?$AA@
  0048f	57		 push	 edi
  00490	ff d6		 call	 esi
  00492	83 c4 48	 add	 esp, 72			; 00000048H

; 2468 : 
; 2469 : 	PyModule_AddIntConstant(poModule, "REFINE_CANT",							REFINE_CANT);

  00495	6a 00		 push	 0
  00497	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FNDEJPGN@REFINE_CANT?$AA@
  0049c	57		 push	 edi
  0049d	ff d6		 call	 esi

; 2470 : 	PyModule_AddIntConstant(poModule, "REFINE_OK",								REFINE_OK);

  0049f	6a 01		 push	 1
  004a1	68 00 00 00 00	 push	 OFFSET ??_C@_09FFJEIDJG@REFINE_OK?$AA@
  004a6	57		 push	 edi
  004a7	ff d6		 call	 esi

; 2471 : 	PyModule_AddIntConstant(poModule, "REFINE_ALREADY_MAX_SOCKET_COUNT",		REFINE_ALREADY_MAX_SOCKET_COUNT);

  004a9	6a 02		 push	 2
  004ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CPLGFHBD@REFINE_ALREADY_MAX_SOCKET_COUNT?$AA@
  004b0	57		 push	 edi
  004b1	ff d6		 call	 esi

; 2472 : 	PyModule_AddIntConstant(poModule, "REFINE_NEED_MORE_GOOD_SCROLL",			REFINE_NEED_MORE_GOOD_SCROLL);

  004b3	6a 03		 push	 3
  004b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FMBLMMOD@REFINE_NEED_MORE_GOOD_SCROLL?$AA@
  004ba	57		 push	 edi
  004bb	ff d6		 call	 esi

; 2473 : 	PyModule_AddIntConstant(poModule, "REFINE_CANT_MAKE_SOCKET_ITEM",			REFINE_CANT_MAKE_SOCKET_ITEM);

  004bd	6a 04		 push	 4
  004bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JPDLJDPD@REFINE_CANT_MAKE_SOCKET_ITEM?$AA@
  004c4	57		 push	 edi
  004c5	ff d6		 call	 esi

; 2474 : 	PyModule_AddIntConstant(poModule, "REFINE_NOT_NEXT_GRADE_ITEM",				REFINE_NOT_NEXT_GRADE_ITEM);

  004c7	6a 05		 push	 5
  004c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@EILCCEPE@REFINE_NOT_NEXT_GRADE_ITEM?$AA@
  004ce	57		 push	 edi
  004cf	ff d6		 call	 esi
  004d1	83 c4 48	 add	 esp, 72			; 00000048H

; 2475 : 	PyModule_AddIntConstant(poModule, "REFINE_CANT_REFINE_METIN_TO_EQUIPMENT",	REFINE_CANT_REFINE_METIN_TO_EQUIPMENT);

  004d4	6a 06		 push	 6
  004d6	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LFLLDFCE@REFINE_CANT_REFINE_METIN_TO_EQUI@
  004db	57		 push	 edi
  004dc	ff d6		 call	 esi

; 2476 : 	PyModule_AddIntConstant(poModule, "REFINE_CANT_REFINE_ROD",					REFINE_CANT_REFINE_ROD);

  004de	6a 07		 push	 7
  004e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@OENPPLJB@REFINE_CANT_REFINE_ROD?$AA@
  004e5	57		 push	 edi
  004e6	ff d6		 call	 esi

; 2477 : 	PyModule_AddIntConstant(poModule, "ATTACH_METIN_CANT",						ATTACH_METIN_CANT);

  004e8	6a 00		 push	 0
  004ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CBCJMHP@ATTACH_METIN_CANT?$AA@
  004ef	57		 push	 edi
  004f0	ff d6		 call	 esi

; 2478 : 	PyModule_AddIntConstant(poModule, "ATTACH_METIN_OK",						ATTACH_METIN_OK);

  004f2	6a 01		 push	 1
  004f4	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HOJAFGB@ATTACH_METIN_OK?$AA@
  004f9	57		 push	 edi
  004fa	ff d6		 call	 esi

; 2479 : 	PyModule_AddIntConstant(poModule, "ATTACH_METIN_NOT_MATCHABLE_ITEM",		ATTACH_METIN_NOT_MATCHABLE_ITEM);

  004fc	6a 02		 push	 2
  004fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OFAKGLFM@ATTACH_METIN_NOT_MATCHABLE_ITEM?$AA@
  00503	57		 push	 edi
  00504	ff d6		 call	 esi

; 2480 : 	PyModule_AddIntConstant(poModule, "ATTACH_METIN_NO_MATCHABLE_SOCKET",		ATTACH_METIN_NO_MATCHABLE_SOCKET);

  00506	6a 03		 push	 3
  00508	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MAILDNNI@ATTACH_METIN_NO_MATCHABLE_SOCKET@
  0050d	57		 push	 edi
  0050e	ff d6		 call	 esi
  00510	83 c4 48	 add	 esp, 72			; 00000048H

; 2481 : 	PyModule_AddIntConstant(poModule, "ATTACH_METIN_NOT_EXIST_GOLD_SOCKET",		ATTACH_METIN_NOT_EXIST_GOLD_SOCKET);

  00513	6a 04		 push	 4
  00515	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JNOPKOFJ@ATTACH_METIN_NOT_EXIST_GOLD_SOCK@
  0051a	57		 push	 edi
  0051b	ff d6		 call	 esi

; 2482 : 	PyModule_AddIntConstant(poModule, "ATTACH_METIN_CANT_ATTACH_TO_EQUIPMENT",	ATTACH_METIN_CANT_ATTACH_TO_EQUIPMENT);

  0051d	6a 05		 push	 5
  0051f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BCIFDNEM@ATTACH_METIN_CANT_ATTACH_TO_EQUI@
  00524	57		 push	 edi
  00525	ff d6		 call	 esi

; 2483 : 	PyModule_AddIntConstant(poModule, "DETACH_METIN_CANT",						DETACH_METIN_CANT);

  00527	6a 00		 push	 0
  00529	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HGBPKPKG@DETACH_METIN_CANT?$AA@
  0052e	57		 push	 edi
  0052f	ff d6		 call	 esi

; 2484 : 	PyModule_AddIntConstant(poModule, "DETACH_METIN_OK",						DETACH_METIN_OK);

  00531	6a 01		 push	 1
  00533	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IACJJMNA@DETACH_METIN_OK?$AA@
  00538	57		 push	 edi
  00539	ff d6		 call	 esi

; 2485 : 
; 2486 : 	// Party
; 2487 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_NORMAL",						CPythonPlayer::PARTY_ROLE_NORMAL);

  0053b	6a 00		 push	 0
  0053d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PNFBHDHD@PARTY_STATE_NORMAL?$AA@
  00542	57		 push	 edi
  00543	ff d6		 call	 esi

; 2488 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_LEADER",						CPythonPlayer::PARTY_ROLE_LEADER);

  00545	6a 01		 push	 1
  00547	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ECFFHEOH@PARTY_STATE_LEADER?$AA@
  0054c	57		 push	 edi
  0054d	ff d6		 call	 esi
  0054f	83 c4 48	 add	 esp, 72			; 00000048H

; 2489 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_ATTACKER",					CPythonPlayer::PARTY_ROLE_ATTACKER);

  00552	6a 02		 push	 2
  00554	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DOKPPLCL@PARTY_STATE_ATTACKER?$AA@
  00559	57		 push	 edi
  0055a	ff d6		 call	 esi

; 2490 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_TANKER",						CPythonPlayer::PARTY_ROLE_TANKER);

  0055c	6a 03		 push	 3
  0055e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FHMGGDNP@PARTY_STATE_TANKER?$AA@
  00563	57		 push	 edi
  00564	ff d6		 call	 esi

; 2491 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_BUFFER",						CPythonPlayer::PARTY_ROLE_BUFFER);

  00566	6a 04		 push	 4
  00568	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JJFBJLK@PARTY_STATE_BUFFER?$AA@
  0056d	57		 push	 edi
  0056e	ff d6		 call	 esi

; 2492 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_SKILL_MASTER",				CPythonPlayer::PARTY_ROLE_SKILL_MASTER);

  00570	6a 05		 push	 5
  00572	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EIPCPJKC@PARTY_STATE_SKILL_MASTER?$AA@
  00577	57		 push	 edi
  00578	ff d6		 call	 esi

; 2493 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_BERSERKER",					CPythonPlayer::PARTY_ROLE_BERSERKER);

  0057a	6a 06		 push	 6
  0057c	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@LCNEBE@PARTY_STATE_BERSERKER?$AA@
  00581	57		 push	 edi
  00582	ff d6		 call	 esi

; 2494 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_DEFENDER",					CPythonPlayer::PARTY_ROLE_DEFENDER);

  00584	6a 07		 push	 7
  00586	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PAKJEMH@PARTY_STATE_DEFENDER?$AA@
  0058b	57		 push	 edi
  0058c	ff d6		 call	 esi
  0058e	83 c4 48	 add	 esp, 72			; 00000048H

; 2495 : 	PyModule_AddIntConstant(poModule, "PARTY_STATE_MAX_NUM",					CPythonPlayer::PARTY_ROLE_MAX_NUM);

  00591	6a 08		 push	 8
  00593	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KCLJFDCO@PARTY_STATE_MAX_NUM?$AA@
  00598	57		 push	 edi
  00599	ff d6		 call	 esi

; 2496 : 
; 2497 : 	// Skill Index
; 2498 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_TONGSOL",		c_iSkillIndex_Tongsol);

  0059b	6a 79		 push	 121			; 00000079H
  0059d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MNBFKLPI@SKILL_INDEX_TONGSOL?$AA@
  005a2	57		 push	 edi
  005a3	ff d6		 call	 esi

; 2499 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_FISHING",		c_iSkillIndex_Fishing);

  005a5	6a 7b		 push	 123			; 0000007bH
  005a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HANBCKAH@SKILL_INDEX_FISHING?$AA@
  005ac	57		 push	 edi
  005ad	ff d6		 call	 esi

; 2500 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_MINING",			c_iSkillIndex_Mining);

  005af	6a 7c		 push	 124			; 0000007cH
  005b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KFCAJBFG@SKILL_INDEX_MINING?$AA@
  005b6	57		 push	 edi
  005b7	ff d6		 call	 esi

; 2501 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_MAKING",			c_iSkillIndex_Making);

  005b9	6a 7d		 push	 125			; 0000007dH
  005bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IBJDJMEL@SKILL_INDEX_MAKING?$AA@
  005c0	57		 push	 edi
  005c1	ff d6		 call	 esi

; 2502 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_COMBO",			c_iSkillIndex_Combo);

  005c3	6a 7a		 push	 122			; 0000007aH
  005c5	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HACNAMIK@SKILL_INDEX_COMBO?$AA@
  005ca	57		 push	 edi
  005cb	ff d6		 call	 esi
  005cd	83 c4 48	 add	 esp, 72			; 00000048H

; 2503 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_LANGUAGE1",		c_iSkillIndex_Language1);

  005d0	6a 7e		 push	 126			; 0000007eH
  005d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GPLOFEKK@SKILL_INDEX_LANGUAGE1?$AA@
  005d7	57		 push	 edi
  005d8	ff d6		 call	 esi

; 2504 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_LANGUAGE2",		c_iSkillIndex_Language2);

  005da	6a 7f		 push	 127			; 0000007fH
  005dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EEJDAHGJ@SKILL_INDEX_LANGUAGE2?$AA@
  005e1	57		 push	 edi
  005e2	ff d6		 call	 esi

; 2505 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_LANGUAGE3",		c_iSkillIndex_Language3);

  005e4	68 80 00 00 00	 push	 128			; 00000080H
  005e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FNIIDGCI@SKILL_INDEX_LANGUAGE3?$AA@
  005ee	57		 push	 edi
  005ef	ff d6		 call	 esi

; 2506 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_POLYMORPH",		c_iSkillIndex_Polymorph);

  005f1	68 81 00 00 00	 push	 129			; 00000081H
  005f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DMEIDEKO@SKILL_INDEX_POLYMORPH?$AA@
  005fb	57		 push	 edi
  005fc	ff d6		 call	 esi

; 2507 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_RIDING",			c_iSkillIndex_Riding);

  005fe	68 82 00 00 00	 push	 130			; 00000082H
  00603	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HOAGGFNA@SKILL_INDEX_RIDING?$AA@
  00608	57		 push	 edi
  00609	ff d6		 call	 esi

; 2508 : 	PyModule_AddIntConstant(poModule, "SKILL_INDEX_SUMMON",			c_iSkillIndex_Summon);

  0060b	68 83 00 00 00	 push	 131			; 00000083H
  00610	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@POBHIINM@SKILL_INDEX_SUMMON?$AA@
  00615	57		 push	 edi
  00616	ff d6		 call	 esi
  00618	83 c4 48	 add	 esp, 72			; 00000048H

; 2509 : 
; 2510 : 	// PK Mode
; 2511 : 	PyModule_AddIntConstant(poModule, "PK_MODE_PEACE",				PK_MODE_PEACE);

  0061b	6a 00		 push	 0
  0061d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BIPAMBIG@PK_MODE_PEACE?$AA@
  00622	57		 push	 edi
  00623	ff d6		 call	 esi

; 2512 : 	PyModule_AddIntConstant(poModule, "PK_MODE_REVENGE",			PK_MODE_REVENGE);

  00625	6a 01		 push	 1
  00627	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HNNGLCOB@PK_MODE_REVENGE?$AA@
  0062c	57		 push	 edi
  0062d	ff d6		 call	 esi

; 2513 : 	PyModule_AddIntConstant(poModule, "PK_MODE_FREE",				PK_MODE_FREE);

  0062f	6a 02		 push	 2
  00631	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DCANEGJG@PK_MODE_FREE?$AA@
  00636	57		 push	 edi
  00637	ff d6		 call	 esi

; 2514 : 	PyModule_AddIntConstant(poModule, "PK_MODE_PROTECT",			PK_MODE_PROTECT);

  00639	6a 03		 push	 3
  0063b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GHACPGHA@PK_MODE_PROTECT?$AA@
  00640	57		 push	 edi
  00641	ff d6		 call	 esi

; 2515 : 	PyModule_AddIntConstant(poModule, "PK_MODE_GUILD",				PK_MODE_GUILD);

  00643	6a 04		 push	 4
  00645	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LBDADKLE@PK_MODE_GUILD?$AA@
  0064a	57		 push	 edi
  0064b	ff d6		 call	 esi

; 2516 : 	PyModule_AddIntConstant(poModule, "PK_MODE_MAX_NUM",			PK_MODE_MAX_NUM);

  0064d	6a 05		 push	 5
  0064f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OLCDKGDA@PK_MODE_MAX_NUM?$AA@
  00654	57		 push	 edi
  00655	ff d6		 call	 esi
  00657	83 c4 48	 add	 esp, 72			; 00000048H

; 2517 : 
; 2518 : 	// Block Mode
; 2519 : 	PyModule_AddIntConstant(poModule, "BLOCK_EXCHANGE",				BLOCK_EXCHANGE);

  0065a	6a 01		 push	 1
  0065c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CDMGAFPE@BLOCK_EXCHANGE?$AA@
  00661	57		 push	 edi
  00662	ff d6		 call	 esi

; 2520 : 	PyModule_AddIntConstant(poModule, "BLOCK_PARTY",				BLOCK_PARTY_INVITE);

  00664	6a 02		 push	 2
  00666	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KFDBGBIL@BLOCK_PARTY?$AA@
  0066b	57		 push	 edi
  0066c	ff d6		 call	 esi

; 2521 : 	PyModule_AddIntConstant(poModule, "BLOCK_GUILD",				BLOCK_GUILD_INVITE);

  0066e	6a 04		 push	 4
  00670	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EEMDCMKA@BLOCK_GUILD?$AA@
  00675	57		 push	 edi
  00676	ff d6		 call	 esi

; 2522 : 	PyModule_AddIntConstant(poModule, "BLOCK_WHISPER",				BLOCK_WHISPER);

  00678	6a 08		 push	 8
  0067a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CFHKOIIK@BLOCK_WHISPER?$AA@
  0067f	57		 push	 edi
  00680	ff d6		 call	 esi

; 2523 : 	PyModule_AddIntConstant(poModule, "BLOCK_FRIEND",				BLOCK_MESSENGER_INVITE);

  00682	6a 10		 push	 16			; 00000010H
  00684	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IJGKBLJF@BLOCK_FRIEND?$AA@
  00689	57		 push	 edi
  0068a	ff d6		 call	 esi

; 2524 : 	PyModule_AddIntConstant(poModule, "BLOCK_PARTY_REQUEST",		BLOCK_PARTY_REQUEST);

  0068c	6a 20		 push	 32			; 00000020H
  0068e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NDGMABKO@BLOCK_PARTY_REQUEST?$AA@
  00693	57		 push	 edi
  00694	ff d6		 call	 esi
  00696	83 c4 48	 add	 esp, 72			; 00000048H

; 2525 : 
; 2526 : 	// Party
; 2527 : 	PyModule_AddIntConstant(poModule, "PARTY_EXP_NON_DISTRIBUTION",		PARTY_EXP_DISTRIBUTION_NON_PARITY);

  00699	6a 00		 push	 0
  0069b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OELLICOI@PARTY_EXP_NON_DISTRIBUTION?$AA@
  006a0	57		 push	 edi
  006a1	ff d6		 call	 esi

; 2528 : 	PyModule_AddIntConstant(poModule, "PARTY_EXP_DISTRIBUTION_PARITY",	PARTY_EXP_DISTRIBUTION_PARITY);

  006a3	6a 01		 push	 1
  006a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CBJBDFJC@PARTY_EXP_DISTRIBUTION_PARITY?$AA@
  006aa	57		 push	 edi
  006ab	ff d6		 call	 esi

; 2529 : 
; 2530 : 	// Emotion
; 2531 : 	PyModule_AddIntConstant(poModule, "EMOTION_CLAP",			EMOTION_CLAP);

  006ad	6a 01		 push	 1
  006af	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GFLIEIGE@EMOTION_CLAP?$AA@
  006b4	57		 push	 edi
  006b5	ff d6		 call	 esi

; 2532 : 	PyModule_AddIntConstant(poModule, "EMOTION_CHEERS_1",		EMOTION_CHEERS_1);

  006b7	6a 02		 push	 2
  006b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MCMBOGFC@EMOTION_CHEERS_1?$AA@
  006be	57		 push	 edi
  006bf	ff d6		 call	 esi

; 2533 : 	PyModule_AddIntConstant(poModule, "EMOTION_CHEERS_2",		EMOTION_CHEERS_2);

  006c1	6a 03		 push	 3
  006c3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OJOMLFJB@EMOTION_CHEERS_2?$AA@
  006c8	57		 push	 edi
  006c9	ff d6		 call	 esi

; 2534 : 	PyModule_AddIntConstant(poModule, "EMOTION_DANCE_1",		EMOTION_DANCE_1);

  006cb	6a 04		 push	 4
  006cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CLHGMEE@EMOTION_DANCE_1?$AA@
  006d2	57		 push	 edi
  006d3	ff d6		 call	 esi
  006d5	83 c4 48	 add	 esp, 72			; 00000048H

; 2535 : 	PyModule_AddIntConstant(poModule, "EMOTION_DANCE_2",		EMOTION_DANCE_2);

  006d8	6a 05		 push	 5
  006da	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CJJKDPIH@EMOTION_DANCE_2?$AA@
  006df	57		 push	 edi
  006e0	ff d6		 call	 esi

; 2536 : 	PyModule_AddIntConstant(poModule, "EMOTION_DANCE_3",		EMOTION_DANCE_3);

  006e2	6a 06		 push	 6
  006e4	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DAIBAOMG@EMOTION_DANCE_3?$AA@
  006e9	57		 push	 edi
  006ea	ff d6		 call	 esi

; 2537 : 	PyModule_AddIntConstant(poModule, "EMOTION_DANCE_4",		EMOTION_DANCE_4);

  006ec	6a 07		 push	 7
  006ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HPMAJIAB@EMOTION_DANCE_4?$AA@
  006f3	57		 push	 edi
  006f4	ff d6		 call	 esi

; 2538 : 	PyModule_AddIntConstant(poModule, "EMOTION_DANCE_5",		EMOTION_DANCE_5);

  006f6	6a 08		 push	 8
  006f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GGNLKJEA@EMOTION_DANCE_5?$AA@
  006fd	57		 push	 edi
  006fe	ff d6		 call	 esi

; 2539 : 	PyModule_AddIntConstant(poModule, "EMOTION_DANCE_6",		EMOTION_DANCE_6);				// PSY 

  00700	6a 09		 push	 9
  00702	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ENPGPKID@EMOTION_DANCE_6?$AA@
  00707	57		 push	 edi
  00708	ff d6		 call	 esi

; 2540 : 	PyModule_AddIntConstant(poModule, "EMOTION_CONGRATULATION",	EMOTION_CONGRATULATION);

  0070a	6a 0a		 push	 10			; 0000000aH
  0070c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FIIEKKHF@EMOTION_CONGRATULATION?$AA@
  00711	57		 push	 edi
  00712	ff d6		 call	 esi
  00714	83 c4 48	 add	 esp, 72			; 00000048H

; 2541 : 	PyModule_AddIntConstant(poModule, "EMOTION_FORGIVE",		EMOTION_FORGIVE);

  00717	6a 0b		 push	 11			; 0000000bH
  00719	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JPGNEMIB@EMOTION_FORGIVE?$AA@
  0071e	57		 push	 edi
  0071f	ff d6		 call	 esi

; 2542 : 	PyModule_AddIntConstant(poModule, "EMOTION_ANGRY",			EMOTION_ANGRY);

  00721	6a 0c		 push	 12			; 0000000cH
  00723	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DACEICMN@EMOTION_ANGRY?$AA@
  00728	57		 push	 edi
  00729	ff d6		 call	 esi

; 2543 : 	PyModule_AddIntConstant(poModule, "EMOTION_ATTRACTIVE",		EMOTION_ATTRACTIVE);

  0072b	6a 0d		 push	 13			; 0000000dH
  0072d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FLNIBF@EMOTION_ATTRACTIVE?$AA@
  00732	57		 push	 edi
  00733	ff d6		 call	 esi

; 2544 : 	PyModule_AddIntConstant(poModule, "EMOTION_SAD",			EMOTION_SAD);

  00735	6a 0e		 push	 14			; 0000000eH
  00737	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EGEMMDCF@EMOTION_SAD?$AA@
  0073c	57		 push	 edi
  0073d	ff d6		 call	 esi

; 2545 : 	PyModule_AddIntConstant(poModule, "EMOTION_SHY",			EMOTION_SHY);

  0073f	6a 0f		 push	 15			; 0000000fH
  00741	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LGPBJELG@EMOTION_SHY?$AA@
  00746	57		 push	 edi
  00747	ff d6		 call	 esi

; 2546 : 	PyModule_AddIntConstant(poModule, "EMOTION_CHEERUP",		EMOTION_CHEERUP);

  00749	6a 10		 push	 16			; 00000010H
  0074b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MENCJFPL@EMOTION_CHEERUP?$AA@
  00750	57		 push	 edi
  00751	ff d6		 call	 esi
  00753	83 c4 48	 add	 esp, 72			; 00000048H

; 2547 : 	PyModule_AddIntConstant(poModule, "EMOTION_BANTER",			EMOTION_BANTER);

  00756	6a 11		 push	 17			; 00000011H
  00758	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JAJBGKKI@EMOTION_BANTER?$AA@
  0075d	57		 push	 edi
  0075e	ff d6		 call	 esi

; 2548 : 	PyModule_AddIntConstant(poModule, "EMOTION_JOY",			EMOTION_JOY);

  00760	6a 12		 push	 18			; 00000012H
  00762	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JOKPJKCG@EMOTION_JOY?$AA@
  00767	57		 push	 edi
  00768	ff d6		 call	 esi

; 2549 : 
; 2550 : 	PyModule_AddIntConstant(poModule, "EMOTION_KISS",			EMOTION_KISS);

  0076a	6a 33		 push	 51			; 00000033H
  0076c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FGJJNHEK@EMOTION_KISS?$AA@
  00771	57		 push	 edi
  00772	ff d6		 call	 esi

; 2551 : 	PyModule_AddIntConstant(poModule, "EMOTION_FRENCH_KISS",	EMOTION_FRENCH_KISS);

  00774	6a 34		 push	 52			; 00000034H
  00776	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KCAKKBPE@EMOTION_FRENCH_KISS?$AA@
  0077b	57		 push	 edi
  0077c	ff d6		 call	 esi

; 2552 : 	PyModule_AddIntConstant(poModule, "EMOTION_SLAP",			EMOTION_SLAP);

  0077e	6a 35		 push	 53			; 00000035H
  00780	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FFINPOG@EMOTION_SLAP?$AA@
  00785	57		 push	 edi
  00786	ff d6		 call	 esi

; 2553 : 
; 2554 : 	////  
; 2555 : 	PyModule_AddIntConstant(poModule, "AUTO_POTION_TYPE_HP",	CPythonPlayer::AUTO_POTION_TYPE_HP);

  00788	6a 00		 push	 0
  0078a	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LLABJENL@AUTO_POTION_TYPE_HP?$AA@
  0078f	57		 push	 edi
  00790	ff d6		 call	 esi
  00792	83 c4 48	 add	 esp, 72			; 00000048H

; 2556 : 	PyModule_AddIntConstant(poModule, "AUTO_POTION_TYPE_SP",	CPythonPlayer::AUTO_POTION_TYPE_SP);

  00795	6a 01		 push	 1
  00797	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KLHCNIEK@AUTO_POTION_TYPE_SP?$AA@
  0079c	57		 push	 edi
  0079d	ff d6		 call	 esi

; 2557 : 
; 2558 : 	// 
; 2559 : 	PyModule_AddIntConstant(poModule, "DRAGON_SOUL_PAGE_SIZE",	c_DragonSoul_Inventory_Box_Size);

  0079f	6a 20		 push	 32			; 00000020H
  007a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FEPFCIIM@DRAGON_SOUL_PAGE_SIZE?$AA@
  007a6	57		 push	 edi
  007a7	ff d6		 call	 esi

; 2560 : 	PyModule_AddIntConstant(poModule, "DRAGON_SOUL_PAGE_COUNT",	DRAGON_SOUL_GRADE_MAX);

  007a9	6a 05		 push	 5
  007ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@OCCNKKPP@DRAGON_SOUL_PAGE_COUNT?$AA@
  007b0	57		 push	 edi
  007b1	ff d6		 call	 esi

; 2561 : 	PyModule_AddIntConstant(poModule, "DRAGON_SOUL_SLOT_COUNT",	c_DragonSoul_Inventory_Count);

  007b3	68 c0 03 00 00	 push	 960			; 000003c0H
  007b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IFPINEOD@DRAGON_SOUL_SLOT_COUNT?$AA@
  007bd	57		 push	 edi
  007be	ff d6		 call	 esi

; 2562 : 	PyModule_AddIntConstant(poModule, "DRAGON_SOUL_EQUIPMENT_SLOT_START",	c_DragonSoul_Equip_Start);

  007c0	68 01 01 00 00	 push	 257			; 00000101H
  007c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NJAOAEOC@DRAGON_SOUL_EQUIPMENT_SLOT_START@
  007ca	57		 push	 edi
  007cb	ff d6		 call	 esi

; 2563 : 	PyModule_AddIntConstant(poModule, "DRAGON_SOUL_EQUIPMENT_PAGE_COUNT",	DS_DECK_MAX_NUM);

  007cd	6a 02		 push	 2
  007cf	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GAHKEECK@DRAGON_SOUL_EQUIPMENT_PAGE_COUNT@
  007d4	57		 push	 edi
  007d5	ff d6		 call	 esi
  007d7	83 c4 48	 add	 esp, 72			; 00000048H

; 2564 : 	PyModule_AddIntConstant(poModule, "DRAGON_SOUL_EQUIPMENT_FIRST_SIZE",	c_DragonSoul_Equip_Slot_Max);

  007da	6a 06		 push	 6
  007dc	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OIFHBJMG@DRAGON_SOUL_EQUIPMENT_FIRST_SIZE@
  007e1	57		 push	 edi
  007e2	ff d6		 call	 esi

; 2565 : 
; 2566 : 	//  
; 2567 : 	PyModule_AddIntConstant(poModule, "DRAGON_SOUL_REFINE_CLOSE",	DS_SUB_HEADER_CLOSE);

  007e4	6a 01		 push	 1
  007e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MMGGGOHJ@DRAGON_SOUL_REFINE_CLOSE?$AA@
  007eb	57		 push	 edi
  007ec	ff d6		 call	 esi

; 2568 : 	PyModule_AddIntConstant(poModule, "DS_SUB_HEADER_DO_UPGRADE",	DS_SUB_HEADER_DO_UPGRADE);

  007ee	6a 02		 push	 2
  007f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JKFAJIJN@DS_SUB_HEADER_DO_UPGRADE?$AA@
  007f5	57		 push	 edi
  007f6	ff d6		 call	 esi

; 2569 : 	PyModule_AddIntConstant(poModule, "DS_SUB_HEADER_DO_IMPROVEMENT",	DS_SUB_HEADER_DO_IMPROVEMENT);

  007f8	6a 03		 push	 3
  007fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PCPINHKH@DS_SUB_HEADER_DO_IMPROVEMENT?$AA@
  007ff	57		 push	 edi
  00800	ff d6		 call	 esi

; 2570 : 	PyModule_AddIntConstant(poModule, "DS_SUB_HEADER_DO_REFINE",	DS_SUB_HEADER_DO_REFINE);

  00802	6a 04		 push	 4
  00804	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NHBOLMGK@DS_SUB_HEADER_DO_REFINE?$AA@
  00809	57		 push	 edi
  0080a	ff d6		 call	 esi
  0080c	83 c4 3c	 add	 esp, 60			; 0000003cH
  0080f	5f		 pop	 edi
  00810	5e		 pop	 esi

; 2571 : 
; 2572 : }

  00811	c3		 ret	 0
?initPlayer@@YAXXZ ENDP					; initPlayer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?InstancePtr@?$CSingleton@VCPythonPlayer@@@@SAPAVCPythonPlayer@@XZ
_TEXT	SEGMENT
?InstancePtr@?$CSingleton@VCPythonPlayer@@@@SAPAVCPythonPlayer@@XZ PROC ; CSingleton<CPythonPlayer>::InstancePtr, COMDAT

; 32   : 		return (ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 33   : 	}

  00005	c3		 ret	 0
?InstancePtr@?$CSingleton@VCPythonPlayer@@@@SAPAVCPythonPlayer@@XZ ENDP ; CSingleton<CPythonPlayer>::InstancePtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??0?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, 0

; 570  : 		this->_Mysize = 0;

  0000a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00014	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode
  00019	a3 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 96   : 		}

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A ; m_kMap_iEmotionIndex_pkIconImage
  00023	c3		 ret	 0
??0?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??A?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAEAAPAVCGraphicImage@@ABH@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAEAAPAVCGraphicImage@@ABH@Z PROC ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::operator[], COMDAT
; _this$dead$ = ecx

; 225  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2106 : 		_Nodeptr _Pnode = _Root();

  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0000b	8b 7d 08	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0000e	8b f2		 mov	 esi, edx
  00010	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00013	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00017	75 1b		 jne	 SHORT $LN9@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00019	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0001b	eb 03 8d 49 00	 npad	 5
$LL10@operator:
  00020	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	7d 05		 jge	 SHORT $LN8@operator

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN7@operator
$LN8@operator:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b f0		 mov	 esi, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@operator:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL10@operator
$LN9@operator:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b f2		 cmp	 esi, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 228  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  00036	74 10		 je	 SHORT $LN1@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00038	8b 07		 mov	 eax, DWORD PTR [edi]
  0003a	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 228  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  0003d	7c 09		 jl	 SHORT $LN1@operator

; 234  : 
; 235  : 
; 236  : 		return (_Where->second);

  0003f	5f		 pop	 edi
  00040	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00043	5e		 pop	 esi

; 237  : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN1@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00048	51		 push	 ecx
  00049	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0004c	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  0004f	50		 push	 eax
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00056	50		 push	 eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00057	83 c0 10	 add	 eax, 16			; 00000010H

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  0005a	50		 push	 eax
  0005b	56		 push	 esi
  0005c	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_hint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 233  : 				tuple<>());

  00065	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  00068	5f		 pop	 edi

; 234  : 
; 235  : 
; 236  : 		return (_Where->second);

  00069	83 c0 14	 add	 eax, 20			; 00000014H
  0006c	5e		 pop	 esi

; 237  : 		}

  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
??A?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@QAEAAPAVCGraphicImage@@ABH@Z ENDP ; std::map<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::~_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >, COMDAT
; _this$dead$ = ecx

; 1191 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1193 : 		}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::~_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::end, COMDAT
; _this$dead$ = ecx

; 1221 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0000c	89 08		 mov	 DWORD PTR [eax], ecx

; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::find, COMDAT
; _this$dead$ = ecx

; 1548 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();

  00004	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000a	8b d6		 mov	 edx, esi
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0000f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00013	75 2b		 jne	 SHORT $LN3@find
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL10@find:
  00020	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	7d 05		 jge	 SHORT $LN8@find

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find:

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL10@find

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b d6		 cmp	 edx, esi

; 1553 : 					? end() : _Where);

  00036	74 08		 je	 SHORT $LN3@find
  00038	89 55 0c	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0003b	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  0003e	7d 03		 jge	 SHORT $LN82@find
$LN3@find:

; 44   : 		{	// construct with node pointer _Pnode

  00040	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
$LN82@find:

; 1553 : 					? end() : _Where);

  00043	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00046	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]
  00049	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004b	5e		 pop	 esi
  0004c	89 08		 mov	 DWORD PTR [eax], ecx

; 1554 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 337  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::~_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >, COMDAT
; _this$dead$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::~_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::~_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >, COMDAT
; _this$dead$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
??1?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::~_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >, COMDAT
; _this$dead$ = ecx

; 569  : 		this->_Myhead = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, 0

; 570  : 		this->_Mysize = 0;

  0000a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00014	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode
  00019	a3 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, eax

; 1067 : 		}

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A ; m_kMap_iEmotionIndex_pkIconImage
  00023	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::lower_bound, COMDAT
; _this$dead$ = ecx

; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();

  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00009	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0000c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00010	75 19		 jne	 SHORT $LN42@lower_boun
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL6@lower_boun:
  00017	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  0001a	7d 05		 jge	 SHORT $LN4@lower_boun

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001f	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  00021	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00025	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00029	74 ec		 je	 SHORT $LL6@lower_boun
$LN42@lower_boun:

; 44   : 		{	// construct with node pointer _Pnode

  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tidy, COMDAT
; _this$dead$ = ecx

; 2229 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2230 : 		erase(begin(), end());

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase

; 2231 : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Key, COMDAT
; _this$dead$ = ecx

; 2239 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2241 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Getcomp, COMDAT
; _this$dead$ = ecx

; 1006 : 		{	// get ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 		return (key_compare());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,CGraphicImage *> >::allocator<std::pair<int const ,CGraphicImage *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,CGraphicImage *> >::allocator<std::pair<int const ,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 779  : 		}

  0000c	c3		 ret	 0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 385  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAVCGraphicImage@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAVCGraphicImage@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator->, COMDAT
; _this$ = ecx

; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAVCGraphicImage@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::begin, COMDAT
; _this$dead$ = ecx

; 1211 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase, COMDAT
; _this$dead$ = ecx

; 1511 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00004	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 1512 : 		if (_First == begin() && _Last == end())

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00010	3b 02		 cmp	 eax, DWORD PTR [edx]

; 1512 : 		if (_First == begin() && _Last == end())

  00012	75 1b		 jne	 SHORT $LN97@erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00014	3b ca		 cmp	 ecx, edx

; 1512 : 		if (_First == begin() && _Last == end())

  00016	75 17		 jne	 SHORT $LN97@erase

; 1513 : 			{	// erase all
; 1514 : 			clear();

  00018	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::clear

; 44   : 		{	// construct with node pointer _Pnode

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00027	89 08		 mov	 DWORD PTR [eax], ecx

; 1522 : 			}
; 1523 : 		}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
$LN97@erase:

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0002f	3b c1		 cmp	 eax, ecx

; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  00031	74 5a		 je	 SHORT $LN1@erase
$LL2@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00033	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;

  00037	8b c8		 mov	 ecx, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00039	75 40		 jne	 SHORT $LN59@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0003b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0003e	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00042	75 18		 jne	 SHORT $LN99@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00044	8b 02		 mov	 eax, DWORD PTR [edx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00046	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004a	75 2c		 jne	 SHORT $LN57@erase
  0004c	8d 64 24 00	 npad	 4
$LL74@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00050	8b d0		 mov	 edx, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00052	8b 02		 mov	 eax, DWORD PTR [edx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00054	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00058	74 f6		 je	 SHORT $LL74@erase

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else

  0005a	eb 1c		 jmp	 SHORT $LN57@erase
$LN99@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0005c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00063	75 13		 jne	 SHORT $LN57@erase
$LL58@erase:
  00065	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00068	75 0e		 jne	 SHORT $LN57@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0006a	8b c2		 mov	 eax, edx
  0006c	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  0006f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00072	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00076	74 ed		 je	 SHORT $LL58@erase
$LN57@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00078	89 55 0c	 mov	 DWORD PTR __First$[ebp], edx
$LN59@erase:

; 1520 : 				erase(_First++);

  0007b	51		 push	 ecx
  0007c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00085	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00088	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]

; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  0008b	75 a6		 jne	 SHORT $LL2@erase
$LN1@erase:

; 44   : 		{	// construct with node pointer _Pnode

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00090	89 01		 mov	 DWORD PTR [ecx], eax

; 1521 : 			return (iterator(_First._Ptr, this));

  00092	8b c1		 mov	 eax, ecx

; 1522 : 			}
; 1523 : 		}

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lbound, COMDAT
; _this$dead$ = ecx

; 2105 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2106 : 		_Nodeptr _Pnode = _Root();

  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00009	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0000c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00010	75 19		 jne	 SHORT $LN32@Lbound
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL4@Lbound:
  00017	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  0001a	7d 05		 jge	 SHORT $LN2@Lbound

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001f	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  00021	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Lbound:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00025	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00029	74 ec		 je	 SHORT $LL4@Lbound
$LN32@Lbound:

; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate

  0002b	8b c2		 mov	 eax, edx

; 2119 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHPAVCGraphicImage@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHPAVCGraphicImage@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Kfn, COMDAT
; _this$dead$ = ecx

; 2234 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2235 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2236 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHPAVCGraphicImage@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >, COMDAT
; _this$dead$ = ecx

; 569  : 		this->_Myhead = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, 0

; 570  : 		this->_Mysize = 0;

  0000a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00014	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode
  00019	a3 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, eax

; 1003 : 		}

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A ; m_kMap_iEmotionIndex_pkIconImage
  00023	c2 08 00	 ret	 8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Tree_comp<0,std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Freeheadnode, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 865  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAU?$pair@$$CBHPAVCGraphicImage@@@2@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAU?$pair@$$CBHPAVCGraphicImage@@@2@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Myval, COMDAT
; __Pnode$ = ecx

; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 605  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAU?$pair@$$CBHPAVCGraphicImage@@@2@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAVCGraphicImage@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAVCGraphicImage@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator*, COMDAT
; _this$ = ecx

; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAVCGraphicImage@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@SAPAU?$pair@$$CBHPAVCGraphicImage@@@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@SAPAU?$pair@$$CBHPAVCGraphicImage@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<int const ,CGraphicImage *> *>::pointer_to, COMDAT
; __Val$ = ecx

; 234  : 		return (_STD addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 235  : 		}

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@SAPAU?$pair@$$CBHPAVCGraphicImage@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<int const ,CGraphicImage *> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv814 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase, COMDAT
; _this$dead$ = ecx

; 1328 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	74 05		 je	 SHORT $LN39@erase

; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  0001a	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  0001d	eb 1b		 jmp	 SHORT $LN308@erase
$LN39@erase:
  0001f	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00022	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00026	74 04		 je	 SHORT $LN37@erase

; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00028	8b f9		 mov	 edi, ecx

; 1349 : 		else

  0002a	eb 0e		 jmp	 SHORT $LN308@erase
$LN37@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]

; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  0002f	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]

; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)

  00032	3b d3		 cmp	 edx, ebx
  00034	0f 85 8a 00 00
	00		 jne	 $LN35@erase
$LN308@erase:

; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))

  0003a	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0003e	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00041	75 03		 jne	 SHORT $LN34@erase

; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00043	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)

  0004b	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0004e	75 05		 jne	 SHORT $LN33@erase

; 1362 : 				_Root() = _Fixnode;	// link down from root

  00050	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00053	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  00055	39 1e		 cmp	 DWORD PTR [esi], ebx
  00057	75 04		 jne	 SHORT $LN31@erase

; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00059	89 3e		 mov	 DWORD PTR [esi], edi

; 1365 : 			else

  0005b	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right

  0005d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00065	39 18		 cmp	 DWORD PTR [eax], ebx
  00067	75 28		 jne	 SHORT $LN29@erase

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  00069	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0006d	74 04		 je	 SHORT $LN42@erase
  0006f	8b ce		 mov	 ecx, esi
  00071	eb 17		 jmp	 SHORT $LN92@erase
$LN42@erase:

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00073	8b 07		 mov	 eax, DWORD PTR [edi]

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  00075	8b cf		 mov	 ecx, edi

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00077	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0007b	75 0d		 jne	 SHORT $LN92@erase
  0007d	8d 49 00	 npad	 3
$LL93@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00080	8b c8		 mov	 ecx, eax

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00082	8b 01		 mov	 eax, DWORD PTR [ecx]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00084	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00088	74 f6		 je	 SHORT $LL93@erase
$LN92@erase:

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0008f	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)

  00096	39 58 08	 cmp	 DWORD PTR [eax+8], ebx
  00099	0f 85 7e 00 00
	00		 jne	 $LN170@erase

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  0009f	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000a3	74 0d		 je	 SHORT $LN44@erase
  000a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  000ab	8b c6		 mov	 eax, esi
  000ad	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1378 : 			}
; 1379 : 		else

  000b0	eb 6b		 jmp	 SHORT $LN170@erase
$LN44@erase:

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000b2	8b cf		 mov	 ecx, edi
  000b4	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Max
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  000bf	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1378 : 			}
; 1379 : 		else

  000c2	eb 59		 jmp	 SHORT $LN170@erase
$LN35@erase:

; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up

  000c4	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down

  000c7	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c9	89 02		 mov	 DWORD PTR [edx], eax

; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))

  000cb	3b 53 08	 cmp	 edx, DWORD PTR [ebx+8]
  000ce	75 04		 jne	 SHORT $LN26@erase

; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000d0	8b f2		 mov	 esi, edx

; 1388 : 			else

  000d2	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))

  000d4	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000d8	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  000db	75 03		 jne	 SHORT $LN24@erase

; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000dd	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000e0	89 3e		 mov	 DWORD PTR [esi], edi

; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down

  000e2	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000e5	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up

  000e8	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000eb	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN25@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)

  000f3	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  000f6	75 05		 jne	 SHORT $LN23@erase

; 1402 : 				_Root() = _Pnode;	// link down from root

  000f8	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000fb	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000fd	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  00100	39 18		 cmp	 DWORD PTR [eax], ebx
  00102	75 04		 jne	 SHORT $LN21@erase

; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left

  00104	89 10		 mov	 DWORD PTR [eax], edx

; 1406 : 			else

  00106	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right

  00108	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN20@erase:

; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up

  0010b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0010e	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00111	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  00114	8a 4a 0c	 mov	 cl, BYTE PTR [edx+12]
  00117	88 42 0c	 mov	 BYTE PTR [edx+12], al

; 54   : 	_Right = _Move(_Tmp);

  0011a	88 4b 0c	 mov	 BYTE PTR [ebx+12], cl
$LN170@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011d	80 7b 0c 01	 cmp	 BYTE PTR [ebx+12], 1
  00121	0f 85 03 01 00
	00		 jne	 $LN19@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00127	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0012c	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  0012f	0f 84 f1 00 00
	00		 je	 $LN16@erase
$LL18@erase:
  00135	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  00139	0f 85 e7 00 00
	00		 jne	 $LN16@erase

; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  0013f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00141	3b f9		 cmp	 edi, ecx
  00143	75 6a		 jne	 SHORT $LN15@erase

; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);

  00145	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1424 : 					if (this->_Color(_Pnode) == this->_Red)

  00148	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0014c	75 11		 jne	 SHORT $LN14@erase

; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;

  0014e	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lrotate

; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN14@erase:

; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))

  0015f	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00163	0f 85 77 00 00
	00		 jne	 $LN311@erase

; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00169	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016b	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0016f	75 09		 jne	 SHORT $LN11@erase
  00171	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00174	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00178	74 62		 je	 SHORT $LN312@erase
$LN11@erase:

; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)

  0017a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0017d	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00181	75 13		 jne	 SHORT $LN9@erase

; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  00183	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);

  00185	51		 push	 ecx
  00186	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0018a	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  0018e	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rrotate

; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);

  00193	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN9@erase:

; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00196	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00199	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019c	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  001a0	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1454 : 						_Lrotate(_Fixnodeparent);

  001a3	56		 push	 esi
  001a4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001a8	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lrotate

; 1455 : 						break;	// tree now recolored/rebalanced

  001ad	eb 77		 jmp	 SHORT $LN16@erase
$LN15@erase:

; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)

  001af	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001b3	75 10		 jne	 SHORT $LN7@erase

; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;

  001b5	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);

  001b9	56		 push	 esi
  001ba	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  001be	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rrotate

; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);

  001c3	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN7@erase:

; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))

  001c5	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001c9	75 15		 jne	 SHORT $LN311@erase

; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001cb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001ce	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001d2	75 21		 jne	 SHORT $LN4@erase
  001d4	8b 01		 mov	 eax, DWORD PTR [ecx]
  001d6	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001da	75 19		 jne	 SHORT $LN4@erase
$LN312@erase:

; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;

  001dc	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN311@erase:

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 1476 : 						_Fixnode = _Fixnodeparent;

  001e5	8b fe		 mov	 edi, esi
  001e7	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001ea	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001ed	0f 85 42 ff ff
	ff		 jne	 $LL18@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001f3	eb 31		 jmp	 SHORT $LN16@erase
$LN4@erase:

; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001f5	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f7	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001fb	75 13		 jne	 SHORT $LN2@erase

; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);

  00200	51		 push	 ecx
  00201	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00205	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00209	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lrotate

; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);

  0020e	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN2@erase:

; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00210	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00213	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00216	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  0021a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1491 : 						_Rrotate(_Fixnodeparent);

  0021c	56		 push	 esi
  0021d	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00221	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rrotate
$LN16@erase:

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00226	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
$LN19@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0022a	53		 push	 ebx
  0022b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1504 : 		if (0 < this->_Mysize)

  00230	a1 04 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00235	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  00238	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0023b	5f		 pop	 edi
  0023c	5e		 pop	 esi
  0023d	5b		 pop	 ebx

; 1504 : 		if (0 < this->_Mysize)

  0023e	85 c0		 test	 eax, eax
  00240	74 06		 je	 SHORT $LN310@erase

; 1505 : 			--this->_Mysize;

  00242	48		 dec	 eax
  00243	a3 04 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, eax
$LN310@erase:

; 44   : 		{	// construct with node pointer _Pnode

  00248	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0024b	89 08		 mov	 DWORD PTR [eax], ecx

; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}

  0024d	8b e5		 mov	 esp, ebp
  0024f	5d		 pop	 ebp
  00250	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::clear, COMDAT
; _this$dead$ = ecx

; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000a	8b f7		 mov	 esi, edi

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000c	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00010	75 25		 jne	 SHORT $LN7@clear
$LL9@clear:

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

  00012	ff 76 08	 push	 DWORD PTR [esi+8]
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A ; m_kMap_iEmotionIndex_pkIconImage
  0001a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Erase

; 2079 : 			_Pnode = this->_Left(_Pnode);

  0001f	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00021	57		 push	 edi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0002a	8b fe		 mov	 edi, esi
  0002c	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00030	74 e0		 je	 SHORT $LL9@clear
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
$LN7@clear:

; 1541 : 		_Root() = this->_Myhead;

  00037	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	89 00		 mov	 DWORD PTR [eax], eax

; 1543 : 		_Rmost() = this->_Myhead;

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00048	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1544 : 		this->_Mysize = 0;

  0004b	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, 0

; 1545 : 		}

  00055	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lmost, COMDAT
; _this$dead$ = ecx

; 2123 : 		return (this->_Left(this->_Myhead));

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 2124 : 		}

  00005	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Root, COMDAT
; _this$dead$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00005	83 c0 04	 add	 eax, 4

; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}

  00008	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >, COMDAT
; _this$dead$ = ecx

; 569  : 		this->_Myhead = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, 0

; 570  : 		this->_Mysize = 0;

  0000a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00014	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode
  00019	a3 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, eax

; 890  : 		}

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A ; m_kMap_iEmotionIndex_pkIconImage
  00023	c2 04 00	 ret	 4
??0?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Getal, COMDAT
; _this$dead$ = ecx

; 868  : 		{	// get allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 870  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Isnil, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8d 41 0d	 lea	 eax, DWORD PTR [ecx+13]

; 585  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Left, COMDAT
; __Pnode$ = ecx

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00000	8b c1		 mov	 eax, ecx

; 590  : 		}

  00002	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Parent, COMDAT
; __Pnode$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 595  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Right, COMDAT
; __Pnode$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 600  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAVCGraphicImage@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAVCGraphicImage@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator*, COMDAT
; _this$ = ecx

; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAVCGraphicImage@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 277  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 271  : 		++(*(_Mybase *)this);

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator++

; 278  : 		++*this;
; 279  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 280  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 342  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2074 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	8b f7		 mov	 esi, edi

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 1d		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

  00013	ff 76 08	 push	 DWORD PTR [esi+8]
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Erase

; 2079 : 			_Pnode = this->_Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00028	8b fe		 mov	 edi, esi
  0002a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002e	74 e3		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx

; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lrotate, COMDAT
; _this$dead$ = ecx

; 2127 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]

; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00006	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000e	8b 02		 mov	 eax, DWORD PTR [edx]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00010	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00014	75 03		 jne	 SHORT $LN5@Lrotate

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@Lrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00019	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  00024	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate

; 2136 : 			_Root() = _Pnode;

  00029	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 0a		 mov	 DWORD PTR [edx], ecx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2144 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00035	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00038	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 10		 mov	 DWORD PTR [eax], edx

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 0a		 mov	 DWORD PTR [edx], ecx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2144 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 0a		 mov	 DWORD PTR [edx], ecx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2144 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rmost, COMDAT
; _this$dead$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00005	83 c0 08	 add	 eax, 8

; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}

  00008	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rrotate, COMDAT
; _this$dead$ = ecx

; 2157 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00008	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00010	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00014	75 03		 jne	 SHORT $LN5@Rrotate

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@Rrotate:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00019	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00024	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate

; 2166 : 			_Root() = _Pnode;

  00029	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2174 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00036	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00039	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2174 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 10		 mov	 DWORD PTR [eax], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2174 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >, COMDAT
; _this$dead$ = ecx

; 569  : 		this->_Myhead = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, 0

; 570  : 		this->_Mysize = 0;

  0000a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, 0

; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00014	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode
  00019	a3 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, eax

; 774  : 		}

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A ; m_kMap_iEmotionIndex_pkIconImage
  00023	c2 04 00	 ret	 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Color, COMDAT
; __Pnode$ = ecx

; 579  : 		return ((char&)_Pnode->_Color);

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]

; 580  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Max, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00003	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00007	75 12		 jne	 SHORT $LN15@Max
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Max:

; 610  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN15@Max:

; 611  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 612  : 		}

  0001d	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Min, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00002	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00006	75 0a		 jne	 SHORT $LN15@Min
$LL2@Min:

; 617  : 			_Pnode = _Left(_Pnode);

  00008	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0000c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00010	74 f6		 je	 SHORT $LL2@Min
$LN15@Min:

; 618  : 		return (_Pnode);

  00012	8b c1		 mov	 eax, ecx

; 619  : 		}

  00014	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 273  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 00 00 00
	00		 je	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00012	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	85 c9		 test	 ecx, ecx
  00019	74 02		 je	 SHORT $LN61@Buyheadnod
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0001d	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00020	85 c9		 test	 ecx, ecx
  00022	74 02		 je	 SHORT $LN83@Buyheadnod
  00024	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 851  : 		this->_Color(_Pnode) = this->_Black;

  00026	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}

  0002c	c3		 ret	 0
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >, COMDAT
; _this$dead$ = ecx

; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A, 0

; 570  : 		this->_Mysize = 0;
; 571  : 		}

  0000a	b8 00 00 00 00	 mov	 eax, OFFSET ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A ; m_kMap_iEmotionIndex_pkIconImage
  0000f	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, 0
  00019	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

  00000	8b d1		 mov	 edx, ecx

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	75 42		 jne	 SHORT $LN41@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00011	75 1c		 jne	 SHORT $LN34@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:

; 617  : 			_Pnode = _Left(_Pnode);

  00020	8b c8		 mov	 ecx, eax

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

  0002c	8b c2		 mov	 eax, edx

; 74   : 		}

  0002e	c3		 ret	 0
$LN34@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00038	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003d	75 0b		 jne	 SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003f	89 02		 mov	 DWORD PTR [edx], eax
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0004a	89 02		 mov	 DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

  0004c	8b c2		 mov	 eax, edx

; 74   : 		}

  0004e	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN15@allocate

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

  0000e	c2 04 00	 ret	 4
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN17@allocate:
$LN14@allocate:
  00016	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN12@allocate

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

  0000e	c2 04 00	 ret	 4
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN14@allocate:
$LN11@allocate:
  00016	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$make_pair@AAHAAPAVCGraphicImage@@@std@@YA?AU?$pair@HPAVCGraphicImage@@@0@AAHAAPAVCGraphicImage@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@AAHAAPAVCGraphicImage@@@std@@YA?AU?$pair@HPAVCGraphicImage@@@0@AAHAAPAVCGraphicImage@@@Z PROC ; std::make_pair<int &,CGraphicImage * &>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val1$ = edx

; 268  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 144  : 		{	// construct from moved values

  00003	8b 02		 mov	 eax, DWORD PTR [edx]
  00005	89 01		 mov	 DWORD PTR [ecx], eax
  00007	8b 45 08	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 269  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 270  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 271  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  0000f	8b c1		 mov	 eax, ecx

; 272  : 		_STD forward<_Ty2>(_Val2)));
; 273  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$make_pair@AAHAAPAVCGraphicImage@@@std@@YA?AU?$pair@HPAVCGraphicImage@@@0@AAHAAPAVCGraphicImage@@@Z ENDP ; std::make_pair<int &,CGraphicImage * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::insert<std::pair<int,CGraphicImage *> >, COMDAT
; _this$dead$ = ecx

; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00003	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::pair<int,CGraphicImage *> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0000b	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000c	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_nohint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1161 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??$insert@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::insert<std::pair<int,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z PROC ; std::forward_as_tuple<int const &>, COMDAT

; 628  : 	{	// forward arguments in a tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 		{	// construct with argument

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z ENDP ; std::forward_as_tuple<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$dead$ = 16					; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$dead$ = 24					; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00003	51		 push	 ecx
  00004	ff 75 14	 push	 DWORD PTR _<_Val_1>$[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  0000d	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000e	83 c0 10	 add	 eax, 16			; 00000010H

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00011	50		 push	 eax
  00012	ff 75 0c	 push	 DWORD PTR __Where$[ebp]
  00015	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_hint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1187 : 		}

  00020	5d		 pop	 ebp
  00021	c2 14 00	 ret	 20			; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBHPAVCGraphicImage@@@?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBHPAVCGraphicImage@@@?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVCGraphicImage@@@1@@Z PROC ; std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0>::_Kfn<int const ,CGraphicImage *>, COMDAT
; __Val$ = ecx

; 58   : 		{	// extract key from element value
; 59   : 		return (_Val.first);

  00000	8b c1		 mov	 eax, ecx

; 60   : 		}

  00002	c3		 ret	 0
??$_Kfn@$$CBHPAVCGraphicImage@@@?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ENDP ; std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0>::_Kfn<int const ,CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@YAPAU?$pair@$$CBHPAVCGraphicImage@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@YAPAU?$pair@$$CBHPAVCGraphicImage@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,CGraphicImage *> >, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@YAPAU?$pair@$$CBHPAVCGraphicImage@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::pair<int const ,CGraphicImage *> >, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::pair<int const ,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
??$_Allocate@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 aa aa aa
	0a		 cmp	 ecx, 178956970		; 0aaaaaaaH
  00006	77 13		 ja	 SHORT $LN1@Allocate
  00008	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0000b	c1 e0 03	 shl	 eax, 3
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001b	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00020	c3		 ret	 0
??$_Allocate@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??0?$tuple@ABH@std@@QAE@ABH@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
??0?$tuple@ABH@std@@QAE@ABH@Z PROC			; std::tuple<int const &>::tuple<int const &>, COMDAT
; _this$ = ecx

; 215  : 		{	// construct from one or more copied elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 		{	// construct with argument

  00003	8b 45 08	 mov	 eax, DWORD PTR __This_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 216  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$tuple@ABH@std@@QAE@ABH@Z ENDP			; std::tuple<int const &>::tuple<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCGraphicImage@@@std@@YAAAPAVCGraphicImage@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCGraphicImage@@@std@@YAAAPAVCGraphicImage@@AAPAV1@@Z PROC ; std::forward<CGraphicImage * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCGraphicImage@@@std@@YAAAPAVCGraphicImage@@AAPAV1@@Z ENDP ; std::forward<CGraphicImage * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAHAAPAVCGraphicImage@@X@?$pair@HPAVCGraphicImage@@@std@@QAE@AAHAAPAVCGraphicImage@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAPAVCGraphicImage@@X@?$pair@HPAVCGraphicImage@@@std@@QAE@AAHAAPAVCGraphicImage@@@Z PROC ; std::pair<int,CGraphicImage *>::pair<int,CGraphicImage *><int &,CGraphicImage * &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAHAAPAVCGraphicImage@@X@?$pair@HPAVCGraphicImage@@@std@@QAE@AAHAAPAVCGraphicImage@@@Z ENDP ; std::pair<int,CGraphicImage *>::pair<int,CGraphicImage *><int &,CGraphicImage * &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@HPAVCGraphicImage@@@std@@@std@@YA$$QAU?$pair@HPAVCGraphicImage@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@HPAVCGraphicImage@@@std@@@std@@YA$$QAU?$pair@HPAVCGraphicImage@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,CGraphicImage *> >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@U?$pair@HPAVCGraphicImage@@@std@@@std@@YA$$QAU?$pair@HPAVCGraphicImage@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z PROC ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::pair<int,CGraphicImage *> >, COMDAT
; _this$dead$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode0
  00009	8b d0		 mov	 edx, eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000b	8d 72 10	 lea	 esi, DWORD PTR [edx+16]

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

  0000e	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00014	85 f6		 test	 esi, esi
  00016	74 0f		 je	 SHORT $LN30@Buynode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	89 0e		 mov	 DWORD PTR [esi], ecx
  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 939  : 		return (_Pnode);

  00025	8b c2		 mov	 eax, edx
$LN30@Buynode:
  00027	5e		 pop	 esi

; 940  : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$_Buynode@U?$pair@HPAVCGraphicImage@@@std@@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ENDP ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::pair<int,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Addleft$2 = -24					; size = 1
__Where$3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$dead$ = 12					; size = 1
$T4 = 16						; size = 4
$T5 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_nohint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>, COMDAT
; _this$dead$ = ecx

; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

  00032	b1 01		 mov	 cl, 1
  00034	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0003a	8b fb		 mov	 edi, ebx
  0003c	88 4d e8	 mov	 BYTE PTR __Addleft$2[ebp], cl
  0003f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00042	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00046	75 24		 jne	 SHORT $LN11@Insert_noh
  00048	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0004b	8b 12		 mov	 edx, DWORD PTR [edx]
  0004d	8d 49 00	 npad	 3
$LL12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00050	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1787 : 			_Wherenode = _Trynode;

  00053	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00055	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

  00058	88 4d e8	 mov	 BYTE PTR __Addleft$2[ebp], cl

; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);

  0005b	84 c9		 test	 cl, cl
  0005d	74 04		 je	 SHORT $LN16@Insert_noh
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	eb 03		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  00063	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00066	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0006a	74 e4		 je	 SHORT $LL12@Insert_noh
$LN11@Insert_noh:

; 44   : 		{	// construct with node pointer _Pnode

  0006c	8b f7		 mov	 esi, edi
  0006e	89 75 ec	 mov	 DWORD PTR __Where$3[ebp], esi

; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)

  00071	84 c9		 test	 cl, cl
  00073	74 3e		 je	 SHORT $LN106@Insert_noh

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00075	3b 3b		 cmp	 edi, DWORD PTR [ebx]

; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())

  00077	75 2f		 jne	 SHORT $LN4@Insert_noh

; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  00079	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0007c	8d 45 10	 lea	 eax, DWORD PTR $T5[ebp]
  0007f	51		 push	 ecx
  00080	57		 push	 edi
  00081	6a 01		 push	 1
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008e	89 08		 mov	 DWORD PTR [eax], ecx
  00090	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1829 : 		}

  00094	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00097	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009e	59		 pop	 ecx
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 10 00	 ret	 16			; 00000010H
$LN4@Insert_noh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000a8	8d 4d ec	 lea	 ecx, DWORD PTR __Where$3[ebp]
  000ab	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator--
  000b0	8b 75 ec	 mov	 esi, DWORD PTR __Where$3[ebp]
$LN106@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000b3	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  000b6	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000b9	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000bc	3b 01		 cmp	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  000be	7d 41		 jge	 SHORT $LN2@Insert_noh

; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000c0	51		 push	 ecx
  000c1	57		 push	 edi
  000c2	ff 75 e8	 push	 DWORD PTR __Addleft$2[ebp]
  000c5	8d 45 10	 lea	 eax, DWORD PTR $T4[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d3	89 08		 mov	 DWORD PTR [eax], ecx
  000d5	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1829 : 		}

  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 10 00	 ret	 16			; 00000010H
__catch$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000ed	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000f0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f5	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1827 : 		_RERAISE;

  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN175@Insert_noh:
$LN2@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00101	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00106	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00109	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0010c	89 30		 mov	 DWORD PTR [eax], esi
  0010e	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1829 : 		}

  00112	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011c	59		 pop	 ecx
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 10 00	 ret	 16			; 00000010H
$LN174@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_nohint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z PROC ; std::forward<std::tuple<int const &> >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ENDP ; std::forward<std::tuple<int const &> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$dead$ = 8					; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$dead$ = 16					; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

  00003	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode0

; 604  : 		return ((reference)_Pnode->_Myval);

  00008	8d 50 10	 lea	 edx, DWORD PTR [eax+16]

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

  0000b	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 d2		 test	 edx, edx
  00013	74 10		 je	 SHORT $LN42@Buynode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_1>$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001c	89 0a		 mov	 DWORD PTR [edx], ecx
  0001e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN42@Buynode:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 940  : 		}

  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 8
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_hint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>, COMDAT
; _this$dead$ = ecx

; 1661 : 		iterator _Insert_hint(const_iterator _Where,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)

  00032	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, 0
  00039	75 2b		 jne	 SHORT $LN33@Insert_hin

; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree

  0003b	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0003e	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00041	51		 push	 ecx
  00042	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00048	6a 01		 push	 1
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  00050	8b c6		 mov	 eax, esi

; 1773 : 		}

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 10 00	 ret	 16			; 00000010H
$LN33@Insert_hin:

; 44   : 		{	// construct with node pointer _Pnode

  00066	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0006c	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0006f	8b 7d 10	 mov	 edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00072	3b 33		 cmp	 esi, DWORD PTR [ebx]

; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())

  00074	75 31		 jne	 SHORT $LN14@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00076	8b 07		 mov	 eax, DWORD PTR [edi]
  00078	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  0007b	0f 8d 36 01 00
	00		 jge	 $LN1@Insert_hin

; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));

  00081	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00084	51		 push	 ecx
$LN7@Insert_hin:
  00085	56		 push	 esi
  00086	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00089	6a 01		 push	 1
  0008b	56		 push	 esi
  0008c	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  00091	8b c6		 mov	 eax, esi

; 1773 : 		}

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 10 00	 ret	 16			; 00000010H
$LN14@Insert_hin:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  000a7	3b f3		 cmp	 esi, ebx

; 1731 : 				}
; 1732 : 			else if (_Where == end())

  000a9	75 34		 jne	 SHORT $LN11@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  000ab	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000ae	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  000b1	3b 07		 cmp	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  000b3	0f 8d fe 00 00
	00		 jge	 $LN1@Insert_hin

; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));

  000b9	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000bc	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	51		 push	 ecx
  000c0	51		 push	 ecx
  000c1	6a 00		 push	 0
  000c3	56		 push	 esi
  000c4	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  000c9	8b c6		 mov	 eax, esi

; 1773 : 		}

  000cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d5	59		 pop	 ecx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 10 00	 ret	 16			; 00000010H
$LN11@Insert_hin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000df	8b 07		 mov	 eax, DWORD PTR [edi]
  000e1	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000e4	3b c8		 cmp	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  000e6	7e 4f		 jle	 SHORT $LN452@Insert_hin

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000e8	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  000eb	89 75 10	 mov	 DWORD PTR __Next$[ebp], esi

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000ee	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator--
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000f3	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  000f6	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000f8	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  000fb	7d 33		 jge	 SHORT $LN449@Insert_hin

; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000fd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));

  00100	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00103	51		 push	 ecx
  00104	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00108	0f 84 77 ff ff
	ff		 je	 $LN7@Insert_hin
  0010e	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00111	50		 push	 eax
  00112	6a 00		 push	 0
  00114	56		 push	 esi
  00115	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  0011a	8b c6		 mov	 eax, esi

; 1773 : 		}

  0011c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00126	59		 pop	 ecx
  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 10 00	 ret	 16			; 00000010H
$LN449@Insert_hin:
  00130	8b c1		 mov	 eax, ecx
  00132	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00135	3b c8		 cmp	 ecx, eax
$LN452@Insert_hin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  00137	7d 7e		 jge	 SHORT $LN1@Insert_hin

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00139	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  0013c	89 75 10	 mov	 DWORD PTR __Next$[ebp], esi

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  0013f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator++

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00144	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  00147	3b c3		 cmp	 eax, ebx

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  00149	74 07		 je	 SHORT $LN3@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0014b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0014d	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  00150	7d 65		 jge	 SHORT $LN1@Insert_hin
$LN3@Insert_hin:

; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  00152	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));

  00155	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00158	51		 push	 ecx
  00159	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0015d	74 22		 je	 SHORT $LN2@Insert_hin
  0015f	56		 push	 esi
  00160	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00163	6a 00		 push	 0
  00165	56		 push	 esi
  00166	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  0016b	8b c6		 mov	 eax, esi

; 1773 : 		}

  0016d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00170	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00177	59		 pop	 ecx
  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 10 00	 ret	 16			; 00000010H
$LN2@Insert_hin:

; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));

  00181	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00184	50		 push	 eax
  00185	6a 01		 push	 1
  00187	56		 push	 esi
  00188	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  0018d	8b c6		 mov	 eax, esi

; 1773 : 		}

  0018f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00192	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00199	59		 pop	 ecx
  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	5b		 pop	 ebx
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c2 10 00	 ret	 16			; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001a3	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  001a6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ab	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1768 : 		_RERAISE;

  001ae	6a 00		 push	 0
  001b0	6a 00		 push	 0
  001b2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN453@Insert_hin:
$LN1@Insert_hin:

; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);

  001b7	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  001ba	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  001bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001c4	57		 push	 edi
  001c5	51		 push	 ecx
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_nohint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
  001cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ce	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001d1	89 08		 mov	 DWORD PTR [eax], ecx

; 1773 : 		}

  001d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001dd	59		 pop	 ecx
  001de	5f		 pop	 edi
  001df	5e		 pop	 esi
  001e0	5b		 pop	 ebx
  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	c2 10 00	 ret	 16			; 00000010H
$LN451@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_hint<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::pair<int const ,CGraphicImage *> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::destroy<std::pair<int const ,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z PROC		; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>, COMDAT
; _this$ = ecx

; 80   : 		{	// construct with argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 81   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z ENDP		; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::size, COMDAT
; _this$dead$ = ecx

; 1272 : 		return (this->_Mysize);

  00000	a1 04 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4

; 1273 : 		}

  00005	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$dead$ = ecx

; 1648 : 		{	// node exists, destroy it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Newnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1653 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ PROC ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode0, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	8b c8		 mov	 ecx, eax
  00009	83 c4 04	 add	 esp, 4
  0000c	85 c9		 test	 ecx, ecx
  0000e	0f 84 00 00 00
	00		 je	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00019	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001c	89 01		 mov	 DWORD PTR [ecx], eax
  0001e	85 d2		 test	 edx, edx
  00020	74 07		 je	 SHORT $LN61@Buynode0
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00027	89 02		 mov	 DWORD PTR [edx], eax
$LN61@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00029	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002c	85 d2		 test	 edx, edx
  0002e	74 07		 je	 SHORT $LN83@Buynode0
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00035	89 02		 mov	 DWORD PTR [edx], eax
$LN83@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 908  : 		return (_Pnode);

  00037	8b c1		 mov	 eax, ecx

; 909  : 		}

  00039	c3		 ret	 0
?_Buynode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@XZ ENDP ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z PROC ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Freenode0, COMDAT
; _this$dead$ = ecx

; 912  : 		{	// free non-value node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 920  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBHPAVCGraphicImage@@@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ENDP ; std::_Tree_buy<std::pair<int const ,CGraphicImage *>,std::allocator<std::pair<int const ,CGraphicImage *> > >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator--

; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 427  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 210  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 312  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

  00000	8b d1		 mov	 edx, ecx

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	74 08		 je	 SHORT $LN8@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	89 02		 mov	 DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

  0000f	8b c2		 mov	 eax, edx

; 102  : 		}

  00011	c3		 ret	 0
$LN8@operator:

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	75 19		 jne	 SHORT $LN40@operator

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  0001d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00021	75 36		 jne	 SHORT $LN21@operator
$LL22@operator:

; 610  : 			_Pnode = _Right(_Pnode);

  00023	8b c8		 mov	 ecx, eax

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00028	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002c	74 f5		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

  00030	8b c2		 mov	 eax, edx

; 102  : 		}

  00032	c3		 ret	 0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003a	75 15		 jne	 SHORT $LN3@operator
  0003c	8d 64 24 00	 npad	 4
$LL4@operator:
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00044	75 0b		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 0a		 mov	 DWORD PTR [edx], ecx
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004f	74 ef		 je	 SHORT $LL4@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00057	75 02		 jne	 SHORT $LN47@operator
$LN21@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  00059	89 0a		 mov	 DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

  0005b	8b c2		 mov	 eax, edx

; 102  : 		}

  0005d	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@YAAAU?$pair@$$CBHPAVCGraphicImage@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@YAAAU?$pair@$$CBHPAVCGraphicImage@@@0@AAU10@@Z PROC ; std::forward<std::pair<int const ,CGraphicImage *> &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@YAAAU?$pair@$$CBHPAVCGraphicImage@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int const ,CGraphicImage *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$dead$ = 20					; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>, COMDAT
; _this$dead$ = ecx

; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)

  00003	a1 04 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4
  00008	3d a9 aa aa 0a	 cmp	 eax, 178956969		; 0aaaaaa9H
  0000d	0f 83 88 01 00
	00		 jae	 $LN298@Insert_at

; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;

  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 18	 mov	 edi, DWORD PTR __Node$[ebp]
  00018	40		 inc	 eax
  00019	a3 04 00 00 00	 mov	 DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A+4, eax
  0001e	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00021	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)

  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0002a	3b c1		 cmp	 eax, ecx
  0002c	75 14		 jne	 SHORT $LN16@Insert_at

; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;

  0002e	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 1850 : 			_Lmost() = _Newnode;

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00036	89 38		 mov	 DWORD PTR [eax], edi

; 1851 : 			_Rmost() = _Newnode;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  0003d	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00040	eb 27		 jmp	 SHORT $LN11@Insert_at
$LN16@Insert_at:

; 1852 : 			}
; 1853 : 		else if (_Addleft)

  00042	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00046	74 10		 je	 SHORT $LN14@Insert_at

; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;

  00048	89 38		 mov	 DWORD PTR [eax], edi

; 1856 : 			if (_Wherenode == _Lmost())

  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00050	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00052	75 15		 jne	 SHORT $LN11@Insert_at

; 1857 : 				_Lmost() = _Newnode;

  00054	89 39		 mov	 DWORD PTR [ecx], edi

; 1858 : 			}
; 1859 : 		else

  00056	eb 11		 jmp	 SHORT $LN11@Insert_at
$LN14@Insert_at:

; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;

  00058	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 1862 : 			if (_Wherenode == _Rmost())

  00061	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00064	75 03		 jne	 SHORT $LN11@Insert_at

; 1863 : 				_Rmost() = _Newnode;

  00066	89 79 08	 mov	 DWORD PTR [ecx+8], edi
$LN11@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00069	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006c	8b f7		 mov	 esi, edi
  0006e	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00072	0f 85 0c 01 00
	00		 jne	 $LN9@Insert_at
$LL10@Insert_at:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00078	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0007b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  0007e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00080	3b c1		 cmp	 eax, ecx
  00082	75 75		 jne	 SHORT $LN8@Insert_at

; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00084	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]

; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)

  00087	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0008b	74 72		 je	 SHORT $LN297@Insert_at

; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0008d	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00090	75 08		 jne	 SHORT $LN5@Insert_at

; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);

  00092	8b f0		 mov	 esi, eax

; 1886 : 						_Lrotate(_Pnode);

  00094	56		 push	 esi
  00095	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Lrotate
$LN5@Insert_at:

; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up

  0009a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009d	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;

  000a1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a7	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  000b1	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  000b3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b6	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  000b8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  000bb	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000bf	75 03		 jne	 SHORT $LN140@Insert_at

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  000c1	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN140@Insert_at:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000c4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000c7	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  000cf	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000d2	75 0b		 jne	 SHORT $LN139@Insert_at

; 2166 : 			_Root() = _Pnode;

  000d4	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  000d7	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  000da	e9 95 00 00 00	 jmp	 $LN296@Insert_at
$LN139@Insert_at:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  000df	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000e2	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000e5	75 0b		 jne	 SHORT $LN137@Insert_at

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000e7	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  000ea	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  000ed	e9 82 00 00 00	 jmp	 $LN296@Insert_at
$LN137@Insert_at:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000f2	89 10		 mov	 DWORD PTR [eax], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  000f4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  000f7	eb 7b		 jmp	 SHORT $LN296@Insert_at
$LN8@Insert_at:

; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)

  000f9	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  000fd	75 1a		 jne	 SHORT $LN3@Insert_at
$LN297@Insert_at:

; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  000ff	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1902 : 					this->_Color(_Wherenode) = this->_Black;

  00103	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;

  00107	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0010a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0010d	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00111	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00114	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1906 : 					}
; 1907 : 				else

  00117	eb 5e		 jmp	 SHORT $LN234@Insert_at
$LN3@Insert_at:

; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00119	3b 30		 cmp	 esi, DWORD PTR [eax]
  0011b	75 08		 jne	 SHORT $LN1@Insert_at

; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);

  0011d	8b f0		 mov	 esi, eax

; 1912 : 						_Rrotate(_Pnode);

  0011f	56		 push	 esi
  00120	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Rrotate
$LN1@Insert_at:

; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up

  00125	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00128	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;

  0012c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0012f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00132	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  00136	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00139	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0013c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0013f	8b 02		 mov	 eax, DWORD PTR [edx]
  00141	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00144	8b 02		 mov	 eax, DWORD PTR [edx]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00146	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0014a	75 03		 jne	 SHORT $LN233@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  0014c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN233@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0014f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00152	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00155	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  0015a	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0015d	75 05		 jne	 SHORT $LN232@Insert_at

; 2136 : 			_Root() = _Pnode;

  0015f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00162	eb 0e		 jmp	 SHORT $LN229@Insert_at
$LN232@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00164	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00167	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00169	75 04		 jne	 SHORT $LN230@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0016b	89 10		 mov	 DWORD PTR [eax], edx

; 2139 : 		else

  0016d	eb 03		 jmp	 SHORT $LN229@Insert_at
$LN230@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0016f	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN229@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  00172	89 0a		 mov	 DWORD PTR [edx], ecx
$LN296@Insert_at:

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  00174	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN234@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00177	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0017a	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0017e	0f 84 f4 fe ff
	ff		 je	 $LL10@Insert_at
$LN9@Insert_at:

; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_kMap_iEmotionIndex_pkIconImage@@3V?$map@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@@std@@A
  00189	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 44   : 		{	// construct with node pointer _Pnode

  00190	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00193	89 38		 mov	 DWORD PTR [eax], edi
  00195	5f		 pop	 edi
  00196	5e		 pop	 esi

; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}

  00197	5d		 pop	 ebp
  00198	c2 14 00	 ret	 20			; 00000014H
$LN298@Insert_at:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0019b	ff 75 18	 push	 DWORD PTR __Node$[ebp]
  0019e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001a3	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1839 : 			_Xlength_error("map/set<T> too long");

  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  001ab	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN300@Insert_at:
$LN295@Insert_at:
  001b0	cc		 int	 3
??$_Insert_at@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAU?$pair@$$CBHPAVCGraphicImage@@@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Insert_at<std::pair<int const ,CGraphicImage *> &,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > &,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > &,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 10		 je	 SHORT $LN19@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN19@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 873  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::destroy<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::destroy<std::pair<int const ,CGraphicImage *> >, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBHPAVCGraphicImage@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::destroy<std::pair<int const ,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> *,std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1277 : 		return (this->_Getal().max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1278 : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 735  : 		return (_Al.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 0d		 je	 SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
  0000e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00011	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 724  : 		}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PAU21@AAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PAU21@AAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Buynode_if_nil<std::pair<int const ,CGraphicImage *> &>, COMDAT
; _this$dead$ = ecx

; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Node$[ebp]

; 1639 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
??$_Buynode_if_nil@AAU?$pair@$$CBHPAVCGraphicImage@@@std@@@?$_Tree@V?$_Tmap_traits@HPAVCGraphicImage@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVCGraphicImage@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@1@PAU21@AAU?$pair@$$CBHPAVCGraphicImage@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,CGraphicImage *,std::less<int>,std::allocator<std::pair<int const ,CGraphicImage *> >,0> >::_Buynode_if_nil<std::pair<int const ,CGraphicImage *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAVCGraphicImage@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,CGraphicImage *> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
_<_Args_0>$dead$ = 8					; size = 4
_<_Args_1>$ = 12					; size = 4
_<_Args_2>$dead$ = 16					; size = 4
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 10		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  00007	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@1@PAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> > >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 601  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@U?$pair@HPAVCGraphicImage@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::pair<int const ,CGraphicImage *>,std::pair<int,CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 10		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 601  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
??$construct@U?$pair@$$CBHPAVCGraphicImage@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAVCGraphicImage@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAVCGraphicImage@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,CGraphicImage *>,void *> >::construct<std::pair<int const ,CGraphicImage *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0HPAVCGraphicImage@@X@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HPAVCGraphicImage@@X@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z PROC ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><int,CGraphicImage *,void>, COMDAT
; _this$ = ecx

; 157  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 158  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??$?0HPAVCGraphicImage@@X@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@$$QAU?$pair@HPAVCGraphicImage@@@1@@Z ENDP ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><int,CGraphicImage *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0ABHPAPAX@?$tuple@ABH@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABHPAPAX@?$tuple@ABH@std@@QAE@$$QAV01@@Z PROC	; std::tuple<int const &>::tuple<int const &><int const &,void * *>, COMDAT
; _this$ = ecx

; 258  : 		{	// construct by moving same size tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 		{	// construct with argument

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 259  : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0ABHPAPAX@?$tuple@ABH@std@@QAE@$$QAV01@@Z ENDP	; std::tuple<int const &>::tuple<int const &><int const &,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0ABH$$$V@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0ABH$$$V@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$$V@1@@Z PROC ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><int const &>, COMDAT
; _this$ = ecx

; 762  : 		{	// construct from pair of tuples

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 746  : 		{	// construct from pair of tuples

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 763  : 		}

  0000a	8b c1		 mov	 eax, ecx

; 746  : 		{	// construct from pair of tuples

  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 763  : 		}

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABH$$$V@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$$V@1@@Z ENDP ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@ABH@std@@QAEAAV?$tuple@$$$V@2@XZ
_TEXT	SEGMENT
?_Get_rest@?$tuple@ABH@std@@QAEAAV?$tuple@$$$V@2@XZ PROC ; std::tuple<int const &>::_Get_rest, COMDAT
; _this$ = ecx

; 439  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 440  : 		}

  00002	c3		 ret	 0
?_Get_rest@?$tuple@ABH@std@@QAEAAV?$tuple@$$$V@2@XZ ENDP ; std::tuple<int const &>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PAVCGraphicImage@@@std@@YA$$QAPAVCGraphicImage@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVCGraphicImage@@@std@@YA$$QAPAVCGraphicImage@@AAPAV1@@Z PROC ; std::forward<CGraphicImage *>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@PAVCGraphicImage@@@std@@YA$$QAPAVCGraphicImage@@AAPAV1@@Z ENDP ; std::forward<CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0V?$tuple@ABH@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@ABH@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z PROC ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><std::tuple<int const &>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 746  : 		{	// construct from pair of tuples

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 746  : 		{	// construct from pair of tuples

  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	89 01		 mov	 DWORD PTR [ecx], eax

; 747  : 		}

  0000c	8b c1		 mov	 eax, ecx
  0000e	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00015	5d		 pop	 ebp
  00016	c2 10 00	 ret	 16			; 00000010H
??$?0V?$tuple@ABH@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBHPAVCGraphicImage@@@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z ENDP ; std::pair<int const ,CGraphicImage *>::pair<int const ,CGraphicImage *><std::tuple<int const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z PROC ; std::move<std::tuple<int const &> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ENDP ; std::move<std::tuple<int const &> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z PROC	; std::get<0,int const &>, COMDAT

; 596  : 	{	// get rvalue reference to _Index element of tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 602  : 	}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z ENDP	; std::get<0,int const &>
_TEXT	ENDS
END
