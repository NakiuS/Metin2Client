; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\Locale.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_04JCGGKMCB@YMIR?$AA@			; `string'
PUBLIC	??_C@_05FBMCIMHB@JAPAN?$AA@			; `string'
PUBLIC	??_C@_07NAIMCPPE@ENGLISH?$AA@			; `string'
PUBLIC	??_C@_08KDAAPGME@HONGKONG?$AA@			; `string'
PUBLIC	??_C@_06GNJGLMLD@TAIWAN?$AA@			; `string'
PUBLIC	??_C@_07EFNJJMND@NEWCIBN?$AA@			; `string'
PUBLIC	??_C@_06EIPFKCCL@EUROPE?$AA@			; `string'
PUBLIC	??_C@_06FNIPBJLB@GLOBAL?$AA@			; `string'
PUBLIC	??_C@_0BB@LBLBLFFM@testtesttesttest?$AA@	; `string'
PUBLIC	??_C@_02BMJICGCB@rt?$AA@			; `string'
PUBLIC	??_C@_08OLPJPPGI@?$CFd?5?$CFd?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_09MLPAPLEB@locale?1?$CFs?$AA@		; `string'
PUBLIC	??_C@_04FOFMEOFJ@ymir?$AA@			; `string'
PUBLIC	??_C@_08EKDPFGPD@we_korea?$AA@			; `string'
PUBLIC	??_C@_0BB@JKKAAGON@1234abcd5678efgh?$AA@	; `string'
PUBLIC	??_C@_05JKFEGLDP@japan?$AA@			; `string'
PUBLIC	?MULTI_LOCALE_REPORT_PORT@@3HA			; MULTI_LOCALE_REPORT_PORT
PUBLIC	?MULTI_LOCALE_CODE@@3HA				; MULTI_LOCALE_CODE
PUBLIC	?MULTI_LOCALE_NAME@@3PADA			; MULTI_LOCALE_NAME
PUBLIC	?MULTI_LOCALE_PATH@@3PADA			; MULTI_LOCALE_PATH
PUBLIC	?LSS_EUROPE@@3PBDB				; LSS_EUROPE
PUBLIC	?LSS_TAIWAN@@3PBDB				; LSS_TAIWAN
PUBLIC	?LSS_HONGKONG@@3PBDB				; LSS_HONGKONG
PUBLIC	?LSS_YMIR@@3PBDB				; LSS_YMIR
EXTRN	__strnicmp:PROC
EXTRN	__stricmp:PROC
EXTRN	_sscanf:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_fgets:PROC
_IS_CHEONMA DB	01H DUP (?)
_BSS	ENDS
;	COMDAT ?GUILD_LEVEL_MAX@?1??LocaleService_GetLastExp@@YAIH@Z@4HB
CONST	SEGMENT
?GUILD_LEVEL_MAX@?1??LocaleService_GetLastExp@@YAIH@Z@4HB DD 014H ; `LocaleService_GetLastExp'::`2'::GUILD_LEVEL_MAX
CONST	ENDS
;	COMDAT ?CHEONMA_GUILDEXP_LIST@?4??LocaleService_GetLastExp@@YAIH@Z@4PAKA
CONST	SEGMENT
?CHEONMA_GUILDEXP_LIST@?4??LocaleService_GetLastExp@@YAIH@Z@4PAKA DD 00H ; `LocaleService_GetLastExp'::`5'::CHEONMA_GUILDEXP_LIST
	DD	03a98H
	DD	0afc8H
	DD	015f90H
	DD	027100H
	DD	0395f8H
	DD	04f588H
	DD	068fb0H
	DD	086470H
	DD	0a73c8H
	DD	0cbdb8H
	DD	0f4240H
	DD	016e360H
	DD	0200b20H
	DD	02ab980H
	DD	036ee80H
	DD	044aa20H
	DD	0632ea0H
	DD	07a1200H
	DD	0989680H
	DD	0280de80H
CONST	ENDS
;	COMDAT ?INTERNATIONAL_GUILDEXP_LIST@?6??LocaleService_GetLastExp@@YAIH@Z@4PAKA
CONST	SEGMENT
?INTERNATIONAL_GUILDEXP_LIST@?6??LocaleService_GetLastExp@@YAIH@Z@4PAKA DD 00H ; `LocaleService_GetLastExp'::`7'::INTERNATIONAL_GUILDEXP_LIST
	DD	01770H
	DD	04650H
	DD	08ca0H
	DD	0fa00H
	DD	016f30H
	DD	01fbd0H
	DD	029fe0H
	DD	035b60H
	DD	042e50H
	DD	0518b0H
	DD	061a80H
	DD	0927c0H
	DD	0cd140H
	DD	0111700H
	DD	015f900H
	DD	01b7740H
	DD	027ac40H
	DD	030d400H
	DD	03d0900H
	DD	01005900H
CONST	ENDS
;	COMDAT ?SKILL_POWER_NUM@?1??LocaleService_GetSkillPower@@YAHI@Z@4IB
CONST	SEGMENT
?SKILL_POWER_NUM@?1??LocaleService_GetSkillPower@@YAHI@Z@4IB DD 032H ; `LocaleService_GetSkillPower'::`2'::SKILL_POWER_NUM
CONST	ENDS
;	COMDAT ?CHEONMA_SKILL_POWERS@?6??LocaleService_GetSkillPower@@YAHI@Z@4PAIA
CONST	SEGMENT
?CHEONMA_SKILL_POWERS@?6??LocaleService_GetSkillPower@@YAHI@Z@4PAIA DD 00H ; `LocaleService_GetSkillPower'::`7'::CHEONMA_SKILL_POWERS
	DD	05H
	DD	07H
	DD	09H
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	014H
	DD	016H
	DD	018H
	DD	01aH
	DD	01cH
	DD	01eH
	DD	020H
	DD	022H
	DD	024H
	DD	026H
	DD	028H
	DD	032H
	DD	034H
	DD	037H
	DD	03aH
	DD	03dH
	DD	03fH
	DD	042H
	DD	045H
	DD	048H
	DD	04bH
	DD	050H
	DD	052H
	DD	054H
	DD	057H
	DD	05aH
	DD	05fH
	DD	064H
	DD	06eH
	DD	078H
	DD	082H
	DD	096H
	DD	096H
	ORG $+32
CONST	ENDS
;	COMDAT ?INTERNATIONAL_SKILL_POWERS@?6??LocaleService_GetSkillPower@@YAHI@Z@4PAIA
CONST	SEGMENT
?INTERNATIONAL_SKILL_POWERS@?6??LocaleService_GetSkillPower@@YAHI@Z@4PAIA DD 00H ; `LocaleService_GetSkillPower'::`7'::INTERNATIONAL_SKILL_POWERS
	DD	05H
	DD	06H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	012H
	DD	014H
	DD	016H
	DD	018H
	DD	01aH
	DD	01cH
	DD	01eH
	DD	020H
	DD	022H
	DD	024H
	DD	026H
	DD	028H
	DD	032H
	DD	034H
	DD	036H
	DD	038H
	DD	03aH
	DD	03cH
	DD	03fH
	DD	042H
	DD	045H
	DD	048H
	DD	052H
	DD	055H
	DD	058H
	DD	05bH
	DD	05eH
	DD	062H
	DD	066H
	DD	06aH
	DD	06eH
	DD	073H
	DD	07dH
	DD	07dH
	ORG $+32
CONST	ENDS
;	COMDAT ??_C@_05JKFEGLDP@japan?$AA@
CONST	SEGMENT
??_C@_05JKFEGLDP@japan?$AA@ DB 'japan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JKKAAGON@1234abcd5678efgh?$AA@
CONST	SEGMENT
??_C@_0BB@JKKAAGON@1234abcd5678efgh?$AA@ DB '1234abcd5678efgh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EKDPFGPD@we_korea?$AA@
CONST	SEGMENT
??_C@_08EKDPFGPD@we_korea?$AA@ DB 'we_korea', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FOFMEOFJ@ymir?$AA@
CONST	SEGMENT
??_C@_04FOFMEOFJ@ymir?$AA@ DB 'ymir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLPAPLEB@locale?1?$CFs?$AA@
CONST	SEGMENT
??_C@_09MLPAPLEB@locale?1?$CFs?$AA@ DB 'locale/%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OLPJPPGI@?$CFd?5?$CFd?5?$CFs?$AA@
CONST	SEGMENT
??_C@_08OLPJPPGI@?$CFd?5?$CFd?5?$CFs?$AA@ DB '%d %d %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02BMJICGCB@rt?$AA@
CONST	SEGMENT
??_C@_02BMJICGCB@rt?$AA@ DB 'rt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBLBLFFM@testtesttesttest?$AA@
CONST	SEGMENT
??_C@_0BB@LBLBLFFM@testtesttesttest?$AA@ DB 'testtesttesttest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNIPBJLB@GLOBAL?$AA@
CONST	SEGMENT
??_C@_06FNIPBJLB@GLOBAL?$AA@ DB 'GLOBAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EIPFKCCL@EUROPE?$AA@
CONST	SEGMENT
??_C@_06EIPFKCCL@EUROPE?$AA@ DB 'EUROPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFNJJMND@NEWCIBN?$AA@
CONST	SEGMENT
??_C@_07EFNJJMND@NEWCIBN?$AA@ DB 'NEWCIBN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GNJGLMLD@TAIWAN?$AA@
CONST	SEGMENT
??_C@_06GNJGLMLD@TAIWAN?$AA@ DB 'TAIWAN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDAAPGME@HONGKONG?$AA@
CONST	SEGMENT
??_C@_08KDAAPGME@HONGKONG?$AA@ DB 'HONGKONG', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAIMCPPE@ENGLISH?$AA@
CONST	SEGMENT
??_C@_07NAIMCPPE@ENGLISH?$AA@ DB 'ENGLISH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBMCIMHB@JAPAN?$AA@
CONST	SEGMENT
??_C@_05FBMCIMHB@JAPAN?$AA@ DB 'JAPAN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JCGGKMCB@YMIR?$AA@
CONST	SEGMENT
??_C@_04JCGGKMCB@YMIR?$AA@ DB 'YMIR', 00H		; `string'
?LSS_EUROPE@@3PBDB DD FLAT:??_C@_06EIPFKCCL@EUROPE?$AA@	; LSS_EUROPE
?LSS_TAIWAN@@3PBDB DD FLAT:??_C@_06GNJGLMLD@TAIWAN?$AA@	; LSS_TAIWAN
?LSS_HONGKONG@@3PBDB DD FLAT:??_C@_08KDAAPGME@HONGKONG?$AA@ ; LSS_HONGKONG
?LSS_YMIR@@3PBDB DD FLAT:??_C@_04JCGGKMCB@YMIR?$AA@	; LSS_YMIR
?MULTI_LOCALE_REPORT_PORT@@3HA DD 02710H		; MULTI_LOCALE_REPORT_PORT
?MULTI_LOCALE_CODE@@3HA DD 03b5H			; MULTI_LOCALE_CODE
?MULTI_LOCALE_NAME@@3PADA DB 'ymir', 00H		; MULTI_LOCALE_NAME
	ORG $+251
?MULTI_LOCALE_PATH@@3PADA DB 'locale/ymir', 00H		; MULTI_LOCALE_PATH
	ORG $+244
PUBLIC	?LocaleService_IsTAIWAN@@YA_NXZ			; LocaleService_IsTAIWAN
PUBLIC	?LocaleService_IsHONGKONG@@YA_NXZ		; LocaleService_IsHONGKONG
PUBLIC	?LocaleService_IsEUROPE@@YA_NXZ			; LocaleService_IsEUROPE
PUBLIC	?LocaleService_LoadGlobal@@YA_NPAUHINSTANCE__@@@Z ; LocaleService_LoadGlobal
PUBLIC	?LocaleService_ForceSetLocale@@YAXPBD0@Z	; LocaleService_ForceSetLocale
PUBLIC	?LocaleService_GetLocalePath@@YAPBDXZ		; LocaleService_GetLocalePath
PUBLIC	?LocaleService_GetLocaleName@@YAPBDXZ		; LocaleService_GetLocaleName
PUBLIC	?LocaleService_GetCodePage@@YAIXZ		; LocaleService_GetCodePage
PUBLIC	?LocaleService_GetName@@YAPBDXZ			; LocaleService_GetName
PUBLIC	?LocaleService_IsCHEONMA@@YA_NXZ		; LocaleService_IsCHEONMA
PUBLIC	?LocaleService_SetCHEONMA@@YAX_N@Z		; LocaleService_SetCHEONMA
PUBLIC	?LocaleService_GetSecurityKey@@YAPBDXZ		; LocaleService_GetSecurityKey
PUBLIC	?LocaleService_GetSkillPower@@YAHI@Z		; LocaleService_GetSkillPower
PUBLIC	?LocaleService_GetLastExp@@YAIH@Z		; LocaleService_GetLastExp
PUBLIC	?LocaleService_LoadConfig@@YAXPBD@Z		; LocaleService_LoadConfig
PUBLIC	?LocaleService_StringCompareCI@@YAHPBD0I@Z	; LocaleService_StringCompareCI
PUBLIC	?LocaleService_IsLeadByte@@YAHD@Z		; LocaleService_IsLeadByte
PUBLIC	?LocaleService_IsYMIR@@YA_NXZ			; LocaleService_IsYMIR
PUBLIC	?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; __SECURITY_KEY_STRING__
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; __SECURITY_KEY_STRING__
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
___SECURITY_KEY_STRING__$initializer$ DD FLAT:??__E__SECURITY_KEY_STRING__@@YAXXZ
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_IsYMIR@@YA_NXZ
_TEXT	SEGMENT
?LocaleService_IsYMIR@@YA_NXZ PROC			; LocaleService_IsYMIR, COMDAT

; 393  : bool LocaleService_IsYMIR()		{ return (stricmp( LocaleService_GetName(), LSS_YMIR ) == 0) || (stricmp( LocaleService_GetLocaleName(), "ymir" ) == 0);	}

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_04JCGGKMCB@YMIR?$AA@
  00005	e8 00 00 00 00	 call	 ?LocaleService_GetName@@YAPBDXZ ; LocaleService_GetName
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 __stricmp
  00010	83 c4 08	 add	 esp, 8
  00013	85 c0		 test	 eax, eax
  00015	74 1a		 je	 SHORT $LN3@LocaleServ
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_04FOFMEOFJ@ymir?$AA@
  0001c	e8 00 00 00 00	 call	 ?LocaleService_GetLocaleName@@YAPBDXZ ; LocaleService_GetLocaleName
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 __stricmp
  00027	83 c4 08	 add	 esp, 8
  0002a	85 c0		 test	 eax, eax
  0002c	74 03		 je	 SHORT $LN3@LocaleServ
  0002e	32 c0		 xor	 al, al
  00030	c3		 ret	 0
$LN3@LocaleServ:
  00031	b0 01		 mov	 al, 1
  00033	c3		 ret	 0
?LocaleService_IsYMIR@@YA_NXZ ENDP			; LocaleService_IsYMIR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_IsLeadByte@@YAHD@Z
_TEXT	SEGMENT
?LocaleService_IsLeadByte@@YAHD@Z PROC			; LocaleService_IsLeadByte, COMDAT
; _chByte$ = cl

; 414  : 	return (((unsigned char) chByte) & 0x80) != 0;

  00000	0f b6 c1	 movzx	 eax, cl
  00003	c1 e8 07	 shr	 eax, 7

; 415  : }

  00006	c3		 ret	 0
?LocaleService_IsLeadByte@@YAHD@Z ENDP			; LocaleService_IsLeadByte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_StringCompareCI@@YAHPBD0I@Z
_TEXT	SEGMENT
_sizeLength$ = 8					; size = 4
?LocaleService_StringCompareCI@@YAHPBD0I@Z PROC		; LocaleService_StringCompareCI, COMDAT
; _szStringLeft$ = ecx
; _szStringRight$ = edx

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 419  : 	return strnicmp( szStringLeft, szStringRight, sizeLength );

  00003	ff 75 08	 push	 DWORD PTR _sizeLength$[ebp]
  00006	52		 push	 edx
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 __strnicmp
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 420  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?LocaleService_StringCompareCI@@YAHPBD0I@Z ENDP		; LocaleService_StringCompareCI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ??__E__SECURITY_KEY_STRING__@@YAXXZ
text$di	SEGMENT
??__E__SECURITY_KEY_STRING__@@YAXXZ PROC		; `dynamic initializer for '__SECURITY_KEY_STRING__'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00000	6a 10		 push	 16			; 00000010H
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBLBLFFM@testtesttesttest?$AA@
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; __SECURITY_KEY_STRING__
  0000c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp

; 25   : std::string __SECURITY_KEY_STRING__ = LSS_SECURITY_KEY;

  00011	68 00 00 00 00	 push	 OFFSET ??__F__SECURITY_KEY_STRING__@@YAXXZ ; `dynamic atexit destructor for '__SECURITY_KEY_STRING__''
  00016	e8 00 00 00 00	 call	 _atexit
  0001b	59		 pop	 ecx
  0001c	c3		 ret	 0
??__E__SECURITY_KEY_STRING__@@YAXXZ ENDP		; `dynamic initializer for '__SECURITY_KEY_STRING__''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__F__SECURITY_KEY_STRING__@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__F__SECURITY_KEY_STRING__@@YAXXZ PROC		; `dynamic atexit destructor for '__SECURITY_KEY_STRING__'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
  0000b	72 2e		 jb	 SHORT $LN23@dynamic
  0000d	56		 push	 esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

  0000e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 684  : 		return (_Alty());

  00014	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

  0001c	68 00 00 00 00	 push	 OFFSET ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; __SECURITY_KEY_STRING__
  00021	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00024	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

  00029	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00037	83 c4 04	 add	 esp, 4
  0003a	5e		 pop	 esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003b	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00045	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0004f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??__F__SECURITY_KEY_STRING__@@YAXXZ ENDP		; `dynamic atexit destructor for '__SECURITY_KEY_STRING__''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_LoadConfig@@YAXPBD@Z
_TEXT	SEGMENT
_id$1 = -524						; size = 4
_code$2 = -520						; size = 4
_name$3 = -516						; size = 256
_line$4 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
?LocaleService_LoadConfig@@YAXPBD@Z PROC		; LocaleService_LoadConfig, COMDAT
; _fileName$dead$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 35   : 	NANOBEGIN

  00014	eb		 DB	 -21			; ffffffebH
  00015	03		 DB	 3
  00016	d6		 DB	 -42			; ffffffd6H
  00017	d7		 DB	 -41			; ffffffd7H
  00018	01		 DB	 1

; 36   : 	FILE* fp = fopen(fileName, "rt");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_02BMJICGCB@rt?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LCFODDFH@locale?4cfg?$AA@
  00023	e8 00 00 00 00	 call	 _fopen
  00028	8b f0		 mov	 esi, eax
  0002a	83 c4 08	 add	 esp, 8

; 37   : 
; 38   : 	if (fp)

  0002d	85 f6		 test	 esi, esi
  0002f	0f 84 9f 00 00
	00		 je	 $LN2@LocaleServ

; 39   : 	{		
; 40   : 		char	line[256];			
; 41   : 		char	name[256];
; 42   : 		int		code;
; 43   : 		int		id;
; 44   : 		if (fgets(line, sizeof(line)-1, fp))

  00035	56		 push	 esi
  00036	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _line$4[ebp]
  0003c	68 ff 00 00 00	 push	 255			; 000000ffH
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _fgets
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	85 c0		 test	 eax, eax
  0004c	74 7d		 je	 SHORT $LN1@LocaleServ

; 45   : 		{
; 46   : 			line[sizeof(line)-1] = '\0';
; 47   : 			sscanf(line, "%d %d %s", &id, &code, name);

  0004e	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _name$3[ebp]
  00054	c6 45 fb 00	 mov	 BYTE PTR _line$4[ebp+255], 0
  00058	50		 push	 eax
  00059	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _code$2[ebp]
  0005f	50		 push	 eax
  00060	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _id$1[ebp]
  00066	50		 push	 eax
  00067	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _line$4[ebp]
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_08OLPJPPGI@?$CFd?5?$CFd?5?$CFs?$AA@
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _sscanf

; 48   : 
; 49   : 			MULTI_LOCALE_REPORT_PORT		= id;

  00078	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _id$1[ebp]
  0007e	83 c4 14	 add	 esp, 20			; 00000014H
  00081	a3 00 00 00 00	 mov	 DWORD PTR ?MULTI_LOCALE_REPORT_PORT@@3HA, eax ; MULTI_LOCALE_REPORT_PORT

; 50   : 			MULTI_LOCALE_CODE				= code;

  00086	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _code$2[ebp]
  0008c	a3 00 00 00 00	 mov	 DWORD PTR ?MULTI_LOCALE_CODE@@3HA, eax ; MULTI_LOCALE_CODE

; 51   : 			strcpy(MULTI_LOCALE_NAME, name);

  00091	33 c0		 xor	 eax, eax
  00093	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL7@LocaleServ:
  000a0	8a 8c 05 fc fd
	ff ff		 mov	 cl, BYTE PTR _name$3[ebp+eax]
  000a7	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000aa	88 88 ff ff ff
	ff		 mov	 BYTE PTR ?MULTI_LOCALE_NAME@@3PADA[eax-1], cl
  000b0	84 c9		 test	 cl, cl
  000b2	75 ec		 jne	 SHORT $LL7@LocaleServ

; 52   : 			sprintf(MULTI_LOCALE_PATH, "locale/%s", MULTI_LOCALE_NAME);

  000b4	68 00 00 00 00	 push	 OFFSET ?MULTI_LOCALE_NAME@@3PADA ; MULTI_LOCALE_NAME
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_09MLPAPLEB@locale?1?$CFs?$AA@
  000be	68 00 00 00 00	 push	 OFFSET ?MULTI_LOCALE_PATH@@3PADA ; MULTI_LOCALE_PATH
  000c3	e8 00 00 00 00	 call	 _sprintf
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@LocaleServ:

; 53   : 		}			
; 54   : 		fclose(fp);

  000cb	56		 push	 esi
  000cc	e8 00 00 00 00	 call	 _fclose
  000d1	83 c4 04	 add	 esp, 4
$LN2@LocaleServ:

; 55   : 	}
; 56   : 	NANOEND

  000d4	eb		 DB	 -21			; ffffffebH
  000d5	03		 DB	 3
  000d6	d6		 DB	 -42			; ffffffd6H
  000d7	d7		 DB	 -41			; ffffffd7H
  000d8	00		 DB	 0

; 57   : }

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	33 cd		 xor	 ecx, ebp
  000de	5e		 pop	 esi
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
?LocaleService_LoadConfig@@YAXPBD@Z ENDP		; LocaleService_LoadConfig
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_GetLastExp@@YAIH@Z
_TEXT	SEGMENT
?LocaleService_GetLastExp@@YAIH@Z PROC			; LocaleService_GetLastExp, COMDAT
; _level$ = ecx

; 60   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 61   : 	static const int GUILD_LEVEL_MAX = 20;
; 62   : 
; 63   : 	if (LocaleService_IsCHEONMA())

  00003	e8 00 00 00 00	 call	 ?LocaleService_IsCHEONMA@@YA_NXZ ; LocaleService_IsCHEONMA
  00008	84 c0		 test	 al, al
  0000a	74 09		 je	 SHORT $LN3@LocaleServ

; 64   : 	{
; 65   : 		static DWORD CHEONMA_GUILDEXP_LIST[GUILD_LEVEL_MAX+1] = 
; 66   : 		{
; 67   : 			0,			// 0
; 68   : 			15000ul,	// 1
; 69   : 			45000ul,	// 2
; 70   : 			90000ul,	// 3
; 71   : 			160000ul,	// 4
; 72   : 			235000ul,	// 5
; 73   : 			325000ul,	// 6
; 74   : 			430000ul,	// 7
; 75   : 			550000ul,	// 8
; 76   : 			685000ul,	// 9
; 77   : 			835000ul,	// 10
; 78   : 			1000000ul,	// 11
; 79   : 			1500000ul,	// 12
; 80   : 			2100000ul,	// 13
; 81   : 			2800000ul,	// 14
; 82   : 			3600000ul,	// 15
; 83   : 			4500000ul,	// 16
; 84   : 			6500000ul,	// 17
; 85   : 			8000000ul,	// 18
; 86   : 			10000000ul,	// 19			
; 87   : 			42000000UL	// 20
; 88   : 		};
; 89   : 		if (level < 0 && level >= GUILD_LEVEL_MAX)
; 90   : 			return 0;
; 91   : 		
; 92   : 		return CHEONMA_GUILDEXP_LIST[level];

  0000c	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR ?CHEONMA_GUILDEXP_LIST@?4??LocaleService_GetLastExp@@YAIH@Z@4PAKA[esi*4]
  00013	5e		 pop	 esi

; 124  : }

  00014	c3		 ret	 0
$LN3@LocaleServ:

; 93   : 	}
; 94   : 	
; 95   : 	static DWORD INTERNATIONAL_GUILDEXP_LIST[GUILD_LEVEL_MAX+1] = 
; 96   : 	{
; 97   : 		0,			// 0
; 98   : 		6000UL,		// 1
; 99   : 		18000UL,	// 2
; 100  : 		36000UL,	// 3
; 101  : 		64000UL,	// 4
; 102  : 		94000UL,	// 5
; 103  : 		130000UL,	// 6
; 104  : 		172000UL,	// 7
; 105  : 		220000UL,	// 8
; 106  : 		274000UL,	// 9
; 107  : 		334000UL,	// 10
; 108  : 		400000UL,	// 11
; 109  : 		600000UL,	// 12
; 110  : 		840000UL,	// 13
; 111  : 		1120000UL,	// 14
; 112  : 		1440000UL,	// 15
; 113  : 		1800000UL,	// 16
; 114  : 		2600000UL,	// 17
; 115  : 		3200000UL,	// 18
; 116  : 		4000000UL,	// 19		
; 117  : 		16800000UL	// 20		
; 118  : 	};
; 119  : 
; 120  : 	if (level < 0 && level >= GUILD_LEVEL_MAX)
; 121  : 		return 0;
; 122  : 	
; 123  : 	return INTERNATIONAL_GUILDEXP_LIST[level];	

  00015	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR ?INTERNATIONAL_GUILDEXP_LIST@?6??LocaleService_GetLastExp@@YAIH@Z@4PAKA[esi*4]
  0001c	5e		 pop	 esi

; 124  : }

  0001d	c3		 ret	 0
?LocaleService_GetLastExp@@YAIH@Z ENDP			; LocaleService_GetLastExp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_GetSkillPower@@YAHI@Z
_TEXT	SEGMENT
?LocaleService_GetSkillPower@@YAHI@Z PROC		; LocaleService_GetSkillPower, COMDAT
; _level$ = ecx

; 127  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 128  : 	static const unsigned SKILL_POWER_NUM = 50;
; 129  : 
; 130  : 	if (level >= SKILL_POWER_NUM)

  00003	83 fe 32	 cmp	 esi, 50			; 00000032H
  00006	72 04		 jb	 SHORT $LN2@LocaleServ

; 131  : 		return 0;

  00008	33 c0		 xor	 eax, eax
  0000a	5e		 pop	 esi

; 166  : }

  0000b	c3		 ret	 0
$LN2@LocaleServ:

; 132  : 
; 133  : 	if (LocaleService_IsCHEONMA())

  0000c	e8 00 00 00 00	 call	 ?LocaleService_IsCHEONMA@@YA_NXZ ; LocaleService_IsCHEONMA
  00011	84 c0		 test	 al, al
  00013	74 09		 je	 SHORT $LN1@LocaleServ

; 134  : 	{
; 135  : 		static unsigned CHEONMA_SKILL_POWERS[SKILL_POWER_NUM]=
; 136  : 		{
; 137  : 			0,  
; 138  : 				5,  7,  9, 11, 13, 
; 139  : 				15, 17, 19, 20, 22, 
; 140  : 				24, 26, 28, 30, 32, 
; 141  : 				34, 36, 38, 40, 50, // master
; 142  : 				52, 55, 58, 61, 63,
; 143  : 				66, 69, 72, 75, 80, // grand_master
; 144  : 				82, 84, 87, 90, 95,
; 145  : 				100,110,120,130,150,// perfect_master
; 146  : 				150,
; 147  : 		};
; 148  : 		return CHEONMA_SKILL_POWERS[level];		

  00015	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR ?CHEONMA_SKILL_POWERS@?6??LocaleService_GetSkillPower@@YAHI@Z@4PAIA[esi*4]
  0001c	5e		 pop	 esi

; 166  : }

  0001d	c3		 ret	 0
$LN1@LocaleServ:

; 149  : 	}
; 150  : 	
; 151  : 	// 0 5 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 50 52 54 56 58 60 63 66 69 72 82 85 88 91 94 98 102 106 110 115 125 125 125 125 125
; 152  : 	static unsigned INTERNATIONAL_SKILL_POWERS[SKILL_POWER_NUM]=
; 153  : 	{
; 154  : 		0, 
; 155  : 			5,  6,  8, 10, 12, 
; 156  : 			14, 16, 18, 20, 22, 
; 157  : 			24, 26, 28, 30, 32, 
; 158  : 			34, 36, 38, 40, 50, // master
; 159  : 			52, 54, 56, 58, 60, 
; 160  : 			63, 66, 69, 72, 82, // grand_master
; 161  : 			85, 88, 91, 94, 98, 
; 162  : 			102,106,110,115,125,// perfect_master
; 163  : 			125,	
; 164  : 	};
; 165  : 	return INTERNATIONAL_SKILL_POWERS[level];

  0001e	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR ?INTERNATIONAL_SKILL_POWERS@?6??LocaleService_GetSkillPower@@YAHI@Z@4PAIA[esi*4]
  00025	5e		 pop	 esi

; 166  : }

  00026	c3		 ret	 0
?LocaleService_GetSkillPower@@YAHI@Z ENDP		; LocaleService_GetSkillPower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_GetSecurityKey@@YAPBDXZ
_TEXT	SEGMENT
?LocaleService_GetSecurityKey@@YAPBDXZ PROC		; LocaleService_GetSecurityKey, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
  00007	b8 00 00 00 00	 mov	 eax, OFFSET ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; __SECURITY_KEY_STRING__
  0000c	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp

; 171  : }

  00013	c3		 ret	 0
?LocaleService_GetSecurityKey@@YAPBDXZ ENDP		; LocaleService_GetSecurityKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_SetCHEONMA@@YAX_N@Z
_TEXT	SEGMENT
?LocaleService_SetCHEONMA@@YAX_N@Z PROC			; LocaleService_SetCHEONMA, COMDAT
; _isEnable$ = cl

; 176  : 	IS_CHEONMA = isEnable;

  00000	88 0d 00 00 00
	00		 mov	 BYTE PTR _IS_CHEONMA, cl

; 177  : }

  00006	c3		 ret	 0
?LocaleService_SetCHEONMA@@YAX_N@Z ENDP			; LocaleService_SetCHEONMA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_IsCHEONMA@@YA_NXZ
_TEXT	SEGMENT
?LocaleService_IsCHEONMA@@YA_NXZ PROC			; LocaleService_IsCHEONMA, COMDAT

; 181  : 	return LocaleService_IsYMIR();

  00000	e9 00 00 00 00	 jmp	 ?LocaleService_IsYMIR@@YA_NXZ ; LocaleService_IsYMIR
?LocaleService_IsCHEONMA@@YA_NXZ ENDP			; LocaleService_IsCHEONMA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_GetName@@YAPBDXZ
_TEXT	SEGMENT
?LocaleService_GetName@@YAPBDXZ PROC			; LocaleService_GetName, COMDAT

; 228  : const char* LocaleService_GetName()				{ return _LSS_SERVICE_NAME;}

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06EIPFKCCL@EUROPE?$AA@
  00005	c3		 ret	 0
?LocaleService_GetName@@YAPBDXZ ENDP			; LocaleService_GetName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_GetCodePage@@YAIXZ
_TEXT	SEGMENT
?LocaleService_GetCodePage@@YAIXZ PROC			; LocaleService_GetCodePage, COMDAT

; 232  : unsigned int LocaleService_GetCodePage()		{ return MULTI_LOCALE_CODE; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MULTI_LOCALE_CODE@@3HA ; MULTI_LOCALE_CODE
  00005	c3		 ret	 0
?LocaleService_GetCodePage@@YAIXZ ENDP			; LocaleService_GetCodePage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_GetLocaleName@@YAPBDXZ
_TEXT	SEGMENT
?LocaleService_GetLocaleName@@YAPBDXZ PROC		; LocaleService_GetLocaleName, COMDAT

; 233  : const char*	LocaleService_GetLocaleName()		{ return MULTI_LOCALE_NAME; }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?MULTI_LOCALE_NAME@@3PADA ; MULTI_LOCALE_NAME
  00005	c3		 ret	 0
?LocaleService_GetLocaleName@@YAPBDXZ ENDP		; LocaleService_GetLocaleName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_GetLocalePath@@YAPBDXZ
_TEXT	SEGMENT
?LocaleService_GetLocalePath@@YAPBDXZ PROC		; LocaleService_GetLocalePath, COMDAT

; 234  : const char*	LocaleService_GetLocalePath()		{ return MULTI_LOCALE_PATH; }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?MULTI_LOCALE_PATH@@3PADA ; MULTI_LOCALE_PATH
  00005	c3		 ret	 0
?LocaleService_GetLocalePath@@YAPBDXZ ENDP		; LocaleService_GetLocalePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_ForceSetLocale@@YAXPBD0@Z
_TEXT	SEGMENT
?LocaleService_ForceSetLocale@@YAXPBD0@Z PROC		; LocaleService_ForceSetLocale, COMDAT
; _name$ = ecx
; _localePath$ = edx

; 243  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b d9		 mov	 ebx, ecx

; 244  : 	strcpy(MULTI_LOCALE_NAME, name);

  00005	bf 00 00 00 00	 mov	 edi, OFFSET ?MULTI_LOCALE_NAME@@3PADA ; MULTI_LOCALE_NAME
  0000a	8b f3		 mov	 esi, ebx
  0000c	2b fb		 sub	 edi, ebx
  0000e	8b ff		 npad	 2
$LL5@LocaleServ:
  00010	8a 06		 mov	 al, BYTE PTR [esi]
  00012	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00015	88 44 37 ff	 mov	 BYTE PTR [edi+esi-1], al
  00019	84 c0		 test	 al, al
  0001b	75 f3		 jne	 SHORT $LL5@LocaleServ

; 245  : 	strcpy(MULTI_LOCALE_PATH, localePath);

  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET ?MULTI_LOCALE_PATH@@3PADA ; MULTI_LOCALE_PATH
  00022	2b ca		 sub	 ecx, edx
$LL6@LocaleServ:
  00024	8a 02		 mov	 al, BYTE PTR [edx]
  00026	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00029	88 44 11 ff	 mov	 BYTE PTR [ecx+edx-1], al
  0002d	84 c0		 test	 al, al
  0002f	75 f3		 jne	 SHORT $LL6@LocaleServ

; 246  : 
; 247  : 	//     security key  (WE     )
; 248  : 	if (0 == stricmp(name, "ymir"))

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_04FOFMEOFJ@ymir?$AA@
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 __stricmp
  0003c	83 c4 08	 add	 esp, 8
  0003f	85 c0		 test	 eax, eax
  00041	75 11		 jne	 SHORT $LN7@LocaleServ
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00043	6a 10		 push	 16			; 00000010H
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBLBLFFM@testtesttesttest?$AA@
  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; __SECURITY_KEY_STRING__
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN7@LocaleServ:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp

; 250  : 	if (0 == stricmp(name, "we_korea"))

  00054	68 00 00 00 00	 push	 OFFSET ??_C@_08EKDPFGPD@we_korea?$AA@
  00059	53		 push	 ebx
  0005a	e8 00 00 00 00	 call	 __stricmp
  0005f	83 c4 08	 add	 esp, 8
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	85 c0		 test	 eax, eax
  00067	75 11		 jne	 SHORT $LN15@LocaleServ
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00069	6a 10		 push	 16			; 00000010H
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JKKAAGON@1234abcd5678efgh?$AA@
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?__SECURITY_KEY_STRING__@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; __SECURITY_KEY_STRING__
  00075	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN15@LocaleServ:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp

; 252  : }

  0007a	c3		 ret	 0
?LocaleService_ForceSetLocale@@YAXPBD0@Z ENDP		; LocaleService_ForceSetLocale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_LoadGlobal@@YA_NPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
?LocaleService_LoadGlobal@@YA_NPAUHINSTANCE__@@@Z PROC	; LocaleService_LoadGlobal, COMDAT
; _hInstance$dead$ = ecx

; 389  : 	return false;

  00000	32 c0		 xor	 al, al

; 390  : }

  00002	c3		 ret	 0
?LocaleService_LoadGlobal@@YA_NPAUHINSTANCE__@@@Z ENDP	; LocaleService_LoadGlobal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_IsEUROPE@@YA_NXZ
_TEXT	SEGMENT
?LocaleService_IsEUROPE@@YA_NXZ PROC			; LocaleService_IsEUROPE, COMDAT

; 396  : bool LocaleService_IsEUROPE()	{ return (stricmp( LocaleService_GetName(), LSS_EUROPE ) == 0);		}

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_06EIPFKCCL@EUROPE?$AA@
  00005	e8 00 00 00 00	 call	 ?LocaleService_GetName@@YAPBDXZ ; LocaleService_GetName
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 __stricmp
  00010	83 c4 08	 add	 esp, 8
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax
  00018	c3		 ret	 0
?LocaleService_IsEUROPE@@YA_NXZ ENDP			; LocaleService_IsEUROPE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_IsHONGKONG@@YA_NXZ
_TEXT	SEGMENT
?LocaleService_IsHONGKONG@@YA_NXZ PROC			; LocaleService_IsHONGKONG, COMDAT

; 397  : bool LocaleService_IsHONGKONG()	{ return (stricmp( LocaleService_GetName(), LSS_HONGKONG ) == 0);	}

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_08KDAAPGME@HONGKONG?$AA@
  00005	e8 00 00 00 00	 call	 ?LocaleService_GetName@@YAPBDXZ ; LocaleService_GetName
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 __stricmp
  00010	83 c4 08	 add	 esp, 8
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax
  00018	c3		 ret	 0
?LocaleService_IsHONGKONG@@YA_NXZ ENDP			; LocaleService_IsHONGKONG
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\locale.cpp
;	COMDAT ?LocaleService_IsTAIWAN@@YA_NXZ
_TEXT	SEGMENT
?LocaleService_IsTAIWAN@@YA_NXZ PROC			; LocaleService_IsTAIWAN, COMDAT

; 398  : bool LocaleService_IsTAIWAN()	{ return (stricmp( LocaleService_GetName(), LSS_TAIWAN ) == 0);		}

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_06GNJGLMLD@TAIWAN?$AA@
  00005	e8 00 00 00 00	 call	 ?LocaleService_GetName@@YAPBDXZ ; LocaleService_GetName
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 __stricmp
  00010	83 c4 08	 add	 esp, 8
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax
  00018	c3		 ret	 0
?LocaleService_IsTAIWAN@@YA_NXZ ENDP			; LocaleService_IsTAIWAN
_TEXT	ENDS
END
