; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonNetworkStreamPhaseHandShake.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CB@IOMBLCGI@?$CD?$CD?5Network?5?9?5Hand?5Shake?5Phase?5?$CD?$CD@ ; `string'
PUBLIC	??_C@_09JMFCPCNF@HandShake?$AA@			; `string'
PUBLIC	??_C@_0BI@JCCALMCB@HANDSHAKE?5OK?5RECV?5?$CFu?5?$CFu?$AA@ ; `string'
PUBLIC	??_C@_0M@EEFIMJHD@OnHandShake?$AA@		; `string'
PUBLIC	??_C@_0BD@DGLFIMMB@XTrap?3?5Recv?5failed?$AA@	; `string'
PUBLIC	??_C@_0BF@EDCCLJMF@HShield?3?5Recv?5failed?$AA@	; `string'
PUBLIC	??_C@_0BD@NKNICBOJ@XTrap?3?5Send?5failed?$AA@	; `string'
EXTRN	?SetBaseTime@CTimer@@QAEXXZ:PROC		; CTimer::SetBaseTime
;	COMDAT ??_C@_0BD@NKNICBOJ@XTrap?3?5Send?5failed?$AA@
CONST	SEGMENT
??_C@_0BD@NKNICBOJ@XTrap?3?5Send?5failed?$AA@ DB 'XTrap: Send failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EDCCLJMF@HShield?3?5Recv?5failed?$AA@
CONST	SEGMENT
??_C@_0BF@EDCCLJMF@HShield?3?5Recv?5failed?$AA@ DB 'HShield: Recv failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DGLFIMMB@XTrap?3?5Recv?5failed?$AA@
CONST	SEGMENT
??_C@_0BD@DGLFIMMB@XTrap?3?5Recv?5failed?$AA@ DB 'XTrap: Recv failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEFIMJHD@OnHandShake?$AA@
CONST	SEGMENT
??_C@_0M@EEFIMJHD@OnHandShake?$AA@ DB 'OnHandShake', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JCCALMCB@HANDSHAKE?5OK?5RECV?5?$CFu?5?$CFu?$AA@
CONST	SEGMENT
??_C@_0BI@JCCALMCB@HANDSHAKE?5OK?5RECV?5?$CFu?5?$CFu?$AA@ DB 'HANDSHAKE O'
	DB	'K RECV %u %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JMFCPCNF@HandShake?$AA@
CONST	SEGMENT
??_C@_09JMFCPCNF@HandShake?$AA@ DB 'HandShake', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IOMBLCGI@?$CD?$CD?5Network?5?9?5Hand?5Shake?5Phase?5?$CD?$CD@
CONST	SEGMENT
??_C@_0CB@IOMBLCGI@?$CD?$CD?5Network?5?9?5Hand?5Shake?5Phase?5?$CD?$CD@ DB '#'
	DB	'# Network - Hand Shake Phase ##', 00H	; `string'
PUBLIC	?HandShakePhase@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::HandShakePhase
PUBLIC	?__LeaveHandshakePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__LeaveHandshakePhase
PUBLIC	?RecvHandshakePacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHandshakePacket
PUBLIC	?RecvHandshakeOKPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHandshakeOKPacket
PUBLIC	?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptKeyPacket
PUBLIC	?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptSDBPacket
PUBLIC	?RecvKeyAgreementPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvKeyAgreementPacket
PUBLIC	?RecvKeyAgreementCompletedPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvKeyAgreementCompletedPacket
PUBLIC	?RecvHSCheckRequest@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvHSCheckRequest
PUBLIC	?RecvXTrapVerifyRequest@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvXTrapVerifyRequest
PUBLIC	?SetHandShakePhase@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::SetHandShakePhase
_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ$0
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?SetHandShakePhase@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?SetHandShakePhase@CPythonNetworkStream@@QAEXXZ PROC	; CPythonNetworkStream::SetHandShakePhase, COMDAT
; _this$ = ecx

; 98   : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  00005	6a 09		 push	 9
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_09JMFCPCNF@HandShake?$AA@
  0000c	ff b6 1c 01 00
	00		 push	 DWORD PTR [esi+284]
  00012	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  00018	6a 00		 push	 0
  0001a	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);

  0001f	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp

; 99   : 	if ("HandShake"!=m_strPhase)

  00021	74 1e		 je	 SHORT $LN16@SetHandSha
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 41   : 			if (m_pSelfObject)

  00023	8b 96 68 01 00
	00		 mov	 edx, DWORD PTR [esi+360]
  00029	85 d2		 test	 edx, edx
  0002b	74 14		 je	 SHORT $LN16@SetHandSha

; 42   : 				if (m_pFuncObject)

  0002d	8b 86 70 01 00
	00		 mov	 eax, DWORD PTR [esi+368]
  00033	85 c0		 test	 eax, eax
  00035	74 0a		 je	 SHORT $LN16@SetHandSha

; 43   : 					(m_pSelfObject->*m_pFuncObject)();

  00037	8b 8e 74 01 00
	00		 mov	 ecx, DWORD PTR [esi+372]
  0003d	03 ca		 add	 ecx, edx
  0003f	ff d0		 call	 eax
$LN16@SetHandSha:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp

; 102  : 	Tracen("");

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00046	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0004b	83 c4 04	 add	 esp, 4

; 103  : 	Tracen("## Network - Hand Shake Phase ##");

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@IOMBLCGI@?$CD?$CD?5Network?5?9?5Hand?5Shake?5Phase?5?$CD?$CD@
  00053	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00058	83 c4 04	 add	 esp, 4

; 104  : 	Tracen("");

  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00060	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00065	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00068	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  0006e	6a 09		 push	 9
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_09JMFCPCNF@HandShake?$AA@
  00075	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp

; 108  : 	m_dwChangingPhaseTime = ELTimer_GetMSec();

  0007a	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0007f	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 112  : 	SetGameOnline();

  00085	8b ce		 mov	 ecx, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 24   : 			m_pSelfObject = pSelfObject;

  00087	89 b6 50 01 00
	00		 mov	 DWORD PTR [esi+336], esi

; 25   : 			m_pFuncObject = pFuncObject;

  0008d	c7 86 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+344], OFFSET ?HandShakePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::HandShakePhase
  00097	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0

; 24   : 			m_pSelfObject = pSelfObject;

  000a1	89 b6 68 01 00
	00		 mov	 DWORD PTR [esi+360], esi

; 25   : 			m_pFuncObject = pFuncObject;

  000a7	c7 86 70 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+368], OFFSET ?__LeaveHandshakePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__LeaveHandshakePhase
  000b1	c7 86 74 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+372], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp

; 112  : 	SetGameOnline();

  000bb	e8 00 00 00 00	 call	 ?SetGameOnline@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::SetGameOnline

; 113  : 
; 114  : 	if (__DirectEnterMode_IsSet())

  000c0	e8 00 00 00 00	 call	 ?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ ; CPythonNetworkStream::__DirectEnterMode_IsSet
  000c5	84 c0		 test	 al, al
  000c7	75 22		 jne	 SHORT $LN1@SetHandSha

; 115  : 	{
; 116  : 		// None
; 117  : 	}
; 118  : 	else
; 119  : 	{
; 120  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOGIN], "OnHandShake", Py_BuildValue("()"));

  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000d4	83 c4 04	 add	 esp, 4
  000d7	50		 push	 eax
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EEFIMJHD@OnHandShake?$AA@
  000dd	ff b6 80 01 00
	00		 push	 DWORD PTR [esi+384]
  000e3	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SetHandSha:

; 121  : 	}
; 122  : }

  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	59		 pop	 ecx
  000ee	c3		 ret	 0
?SetHandShakePhase@CPythonNetworkStream@@QAEXXZ ENDP	; CPythonNetworkStream::SetHandShakePhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?RecvXTrapVerifyRequest@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_packet$ = -268						; size = 129
_packet_res$ = -136					; size = 129
__$ArrayPad$ = -4					; size = 4
?RecvXTrapVerifyRequest@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvXTrapVerifyRequest, COMDAT
; _this$ = ecx

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 310  : 	TPacketXTrapCSVerify packet;
; 311  : 
; 312  : 	if (!Recv(sizeof(packet), &packet))

  00014	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _packet$[ebp]
  0001a	8b f1		 mov	 esi, ecx
  0001c	50		 push	 eax
  0001d	68 81 00 00 00	 push	 129			; 00000081H
  00022	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00027	84 c0		 test	 al, al
  00029	75 1e		 jne	 SHORT $LN2@RecvXTrapV

; 313  : 	{
; 314  : 		TraceError("XTrap: Recv failed");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DGLFIMMB@XTrap?3?5Recv?5failed?$AA@
  00030	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00035	83 c4 04	 add	 esp, 4

; 315  : 
; 316  : 		return false;

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 328  : 	}
; 329  : 
; 330  : 	return true;
; 331  : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN2@RecvXTrapV:

; 317  : 	}
; 318  : 
; 319  : 	TPacketXTrapCSVerify packet_res;
; 320  : 	packet_res.bHeader = HEADER_CG_XTRAP_ACK;
; 321  : 
; 322  : 	XTrap_ValidateCheckStream( packet.bPacketData, packet_res.bPacketData );
; 323  : 
; 324  : 	if (!Send(sizeof(packet_res), &packet_res))

  00049	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _packet_res$[ebp]
  0004f	c6 85 78 ff ff
	ff cc		 mov	 BYTE PTR _packet_res$[ebp], 204 ; 000000ccH
  00056	50		 push	 eax
  00057	68 81 00 00 00	 push	 129			; 00000081H
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00063	84 c0		 test	 al, al
  00065	75 1e		 jne	 SHORT $LN1@RecvXTrapV

; 325  : 	{
; 326  : 		TraceError("XTrap: Send failed");

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NKNICBOJ@XTrap?3?5Send?5failed?$AA@
  0006c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00071	83 c4 04	 add	 esp, 4

; 327  : 		return false;

  00074	32 c0		 xor	 al, al
  00076	5e		 pop	 esi

; 328  : 	}
; 329  : 
; 330  : 	return true;
; 331  : }

  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN1@RecvXTrapV:
  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	b0 01		 mov	 al, 1
  0008a	33 cd		 xor	 ecx, ebp
  0008c	5e		 pop	 esi
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
?RecvXTrapVerifyRequest@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvXTrapVerifyRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?RecvHSCheckRequest@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_packet$ = -408						; size = 403
__$ArrayPad$ = -4					; size = 4
?RecvHSCheckRequest@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvHSCheckRequest, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 270  : 	TPacketHSCheck packet;
; 271  : 
; 272  : 	if (!Recv(sizeof(packet), &packet))

  00013	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _packet$[ebp]
  00019	50		 push	 eax
  0001a	68 93 01 00 00	 push	 403			; 00000193H
  0001f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00024	84 c0		 test	 al, al
  00026	75 0d		 jne	 SHORT $LN1@RecvHSChec

; 273  : 	{
; 274  : 		TraceError("HShield: Recv failed");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EDCCLJMF@HShield?3?5Recv?5failed?$AA@
  0002d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00032	83 c4 04	 add	 esp, 4
$LN1@RecvHSChec:

; 275  : 
; 276  : 		return false;
; 277  : 	}
; 278  : 
; 279  : #if defined(USE_AHNLAB_HACKSHIELD) || defined(LOCALE_SERVICE_GLOBAL)
; 280  : 	TPacketHSCheck pack_ret;
; 281  : 	memset(&pack_ret, 0, sizeof(pack_ret));
; 282  : 	pack_ret.bHeader = HEADER_CG_HS_ACK;
; 283  : 
; 284  : #if defined(USE_AHNLAB_HACKSHIELD)
; 285  : 	unsigned long ret = _AhnHS_MakeResponse( packet.Req.byBuffer, packet.Req.nLength, &pack_ret.Req );
; 286  : 
; 287  : 	if (ERROR_SUCCESS != ret)
; 288  : 	{
; 289  : 		TraceError("HShield: _AhnHS_MakeResponse return error(%u)", ret);
; 290  : 
; 291  : 		return false;
; 292  : 	}
; 293  : #endif
; 294  : 
; 295  : 	if (!Send(sizeof(pack_ret), &pack_ret))
; 296  : 	{
; 297  : 		TraceError("HShield: Send failed");
; 298  : 
; 299  : 		return false;
; 300  : 	}
; 301  : 
; 302  : 	return true;
; 303  : #else
; 304  : 	return false;
; 305  : #endif
; 306  : }

  00035	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00038	32 c0		 xor	 al, al
  0003a	33 cd		 xor	 ecx, ebp
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?RecvHSCheckRequest@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvHSCheckRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?RecvKeyAgreementCompletedPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_packet$ = -4						; size = 4
?RecvKeyAgreementCompletedPacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::RecvKeyAgreementCompletedPacket, COMDAT
; _this$ = ecx

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 254  : 	TPacketKeyAgreementCompleted packet;
; 255  : 	if (!Recv(sizeof(packet), &packet))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _packet$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 04		 push	 4
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 05		 jne	 SHORT $LN1@RecvKeyAgr
  00016	5e		 pop	 esi

; 265  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN1@RecvKeyAgr:

; 256  : 	{
; 257  : 		return false;
; 258  : 	}
; 259  : 
; 260  : 	Tracenf("KEY_AGREEMENT_COMPLETED RECV");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV?$AA@
  00020	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00025	83 c4 04	 add	 esp, 4

; 261  : 
; 262  : 	ActivateCipher();

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?ActivateCipher@CNetworkStream@@IAEXXZ ; CNetworkStream::ActivateCipher

; 263  : 
; 264  : 	return true;

  0002f	b0 01		 mov	 al, 1
  00031	5e		 pop	 esi

; 265  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?RecvKeyAgreementCompletedPacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::RecvKeyAgreementCompletedPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?RecvKeyAgreementPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_dataLength$ = -536					; size = 4
_packet$ = -532						; size = 261
_packetToSend$ = -268					; size = 261
__$ArrayPad$ = -4					; size = 4
?RecvKeyAgreementPacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::RecvKeyAgreementPacket, COMDAT
; _this$ = ecx

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 210  : 	TPacketKeyAgreement packet;
; 211  : 	if (!Recv(sizeof(packet), &packet))

  00014	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _packet$[ebp]
  0001a	8b f1		 mov	 esi, ecx
  0001c	50		 push	 eax
  0001d	68 05 01 00 00	 push	 261			; 00000105H
  00022	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00027	84 c0		 test	 al, al
  00029	75 0f		 jne	 SHORT $LN5@RecvKeyAgr
  0002b	5e		 pop	 esi

; 250  : }

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002f	33 cd		 xor	 ecx, ebp
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN5@RecvKeyAgr:

; 212  : 	{
; 213  : 		return false;
; 214  : 	}
; 215  : 
; 216  : 	Tracenf("KEY_AGREEMENT RECV %u", packet.wDataLength);

  0003a	0f b7 85 ef fd
	ff ff		 movzx	 eax, WORD PTR _packet$[ebp+3]
  00041	57		 push	 edi
  00042	50		 push	 eax
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu?$AA@
  00048	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0004d	83 c4 08	 add	 esp, 8

; 217  : 
; 218  : 	TPacketKeyAgreement packetToSend;
; 219  : 	size_t dataLength = TPacketKeyAgreement::MAX_DATA_LEN;

  00050	c7 85 e8 fd ff
	ff 00 01 00 00	 mov	 DWORD PTR _dataLength$[ebp], 256 ; 00000100H

; 220  : 	size_t agreedLength = Prepare(packetToSend.data, &dataLength);

  0005a	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _dataLength$[ebp]
  00060	8b ce		 mov	 ecx, esi
  00062	50		 push	 eax
  00063	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _packetToSend$[ebp+5]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?Prepare@CNetworkStream@@IAEIPAXPAI@Z ; CNetworkStream::Prepare
  0006f	8b f8		 mov	 edi, eax

; 221  : 	if (agreedLength == 0)
; 222  : 	{
; 223  : 		// 초기화 실패
; 224  : 		Disconnect();

  00071	8b ce		 mov	 ecx, esi
  00073	85 ff		 test	 edi, edi
  00075	74 7a		 je	 SHORT $LN9@RecvKeyAgr

; 225  : 		return false;
; 226  : 	}
; 227  : 	assert(dataLength <= TPacketKeyAgreement::MAX_DATA_LEN);
; 228  : 
; 229  : 	if (Activate(packet.wAgreedLength, packet.data, packet.wDataLength))

  00077	0f b7 85 ef fd
	ff ff		 movzx	 eax, WORD PTR _packet$[ebp+3]
  0007e	50		 push	 eax
  0007f	8d 85 f1 fd ff
	ff		 lea	 eax, DWORD PTR _packet$[ebp+5]
  00085	50		 push	 eax
  00086	0f b7 85 ed fd
	ff ff		 movzx	 eax, WORD PTR _packet$[ebp+1]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?Activate@CNetworkStream@@IAE_NIPBXI@Z ; CNetworkStream::Activate

; 235  : 
; 236  : 		if (!Send(sizeof(packetToSend), &packetToSend))

  00093	8b ce		 mov	 ecx, esi
  00095	84 c0		 test	 al, al
  00097	74 58		 je	 SHORT $LN9@RecvKeyAgr

; 230  : 	{
; 231  : 		// Key agreement 성공, 응답 전송
; 232  : 		packetToSend.bHeader = HEADER_CG_KEY_AGREEMENT;
; 233  : 		packetToSend.wAgreedLength = (WORD)agreedLength;
; 234  : 		packetToSend.wDataLength = (WORD)dataLength;

  00099	66 8b 85 e8 fd
	ff ff		 mov	 ax, WORD PTR _dataLength$[ebp]
  000a0	66 89 85 f7 fe
	ff ff		 mov	 WORD PTR _packetToSend$[ebp+3], ax

; 235  : 
; 236  : 		if (!Send(sizeof(packetToSend), &packetToSend))

  000a7	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _packetToSend$[ebp]
  000ad	50		 push	 eax
  000ae	68 05 01 00 00	 push	 261			; 00000105H
  000b3	c6 85 f4 fe ff
	ff fb		 mov	 BYTE PTR _packetToSend$[ebp], 251 ; 000000fbH
  000ba	66 89 bd f5 fe
	ff ff		 mov	 WORD PTR _packetToSend$[ebp+1], di
  000c1	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  000c6	84 c0		 test	 al, al
  000c8	74 2c		 je	 SHORT $LN10@RecvKeyAgr

; 237  : 		{
; 238  : 			assert(!"Failed Sending KeyAgreement");
; 239  : 			return false;
; 240  : 		}
; 241  : 		Tracenf("KEY_AGREEMENT SEND %u", packetToSend.wDataLength);

  000ca	0f b7 85 f7 fe
	ff ff		 movzx	 eax, WORD PTR _packetToSend$[ebp+3]
  000d1	50		 push	 eax
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu?$AA@
  000d7	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  000dc	83 c4 08	 add	 esp, 8

; 247  : 		return false;
; 248  : 	}
; 249  : 	return true;

  000df	b0 01		 mov	 al, 1
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi

; 250  : }

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e6	33 cd		 xor	 ecx, ebp
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
$LN9@RecvKeyAgr:

; 242  : 	}
; 243  : 	else
; 244  : 	{
; 245  : 		// 키 협상 실패
; 246  : 		Disconnect();

  000f1	e8 00 00 00 00	 call	 ?Disconnect@CNetworkStream@@QAEXXZ ; CNetworkStream::Disconnect
$LN10@RecvKeyAgr:

; 250  : }

  000f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	32 c0		 xor	 al, al
  000fb	5f		 pop	 edi
  000fc	33 cd		 xor	 ecx, ebp
  000fe	5e		 pop	 esi
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
?RecvKeyAgreementPacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::RecvKeyAgreementPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_kPacket$ = -28						; size = 11
_header$ = -16						; size = 3
__$EHRec$ = -12						; size = 12
?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::RecvHybridCryptSDBPacket, COMDAT
; _this$ = ecx

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 188  : 	int iFixedHeaderSize = TPacketGCHybridSDB::GetFixedHeaderSize();
; 189  : 
; 190  : 	TDynamicSizePacketHeader header;
; 191  : 	if( !Peek( sizeof(header), &header) )

  00029	8d 45 f0	 lea	 eax, DWORD PTR _header$[ebp]
  0002c	50		 push	 eax
  0002d	6a 03		 push	 3
  0002f	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  00034	84 c0		 test	 al, al
  00036	75 11		 jne	 SHORT $LN3@RecvHybrid

; 204  : }

  00038	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN3@RecvHybrid:

; 192  : 		return false;
; 193  : 
; 194  : 	TPacketGCHybridSDB kPacket(header.size-iFixedHeaderSize);

  00049	0f b7 45 f1	 movzx	 eax, WORD PTR _header$[ebp+1]
  0004d	83 e8 07	 sub	 eax, 7
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h

; 2666 : 		m_pStream = new BYTE[iStreamSize];

  00050	50		 push	 eax
  00051	89 45 e7	 mov	 DWORD PTR _kPacket$[ebp+3], eax
  00054	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 eb	 mov	 DWORD PTR _kPacket$[ebp+7], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp

; 196  : 	if (!Recv(iFixedHeaderSize, &kPacket))

  0005f	8d 45 e4	 lea	 eax, DWORD PTR _kPacket$[ebp]
  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00069	50		 push	 eax
  0006a	6a 07		 push	 7
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00073	84 c0		 test	 al, al
  00075	74 23		 je	 SHORT $LN7@RecvHybrid

; 197  : 		return false;
; 198  : 
; 199  : 	if (!Recv(kPacket.iSDBStreamLen, kPacket.m_pStream))

  00077	ff 75 eb	 push	 DWORD PTR _kPacket$[ebp+7]
  0007a	8b ce		 mov	 ecx, esi
  0007c	ff 75 e7	 push	 DWORD PTR _kPacket$[ebp+3]
  0007f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00084	84 c0		 test	 al, al
  00086	74 12		 je	 SHORT $LN7@RecvHybrid

; 200  : 		return false;
; 201  : 
; 202  : 	CEterPackManager::Instance().RetrieveHybridCryptPackSDB( kPacket.m_pStream ); 

  00088	ff 75 eb	 push	 DWORD PTR _kPacket$[ebp+7]
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00091	e8 00 00 00 00	 call	 ?RetrieveHybridCryptPackSDB@CEterPackManager@@QAEXPBE@Z ; CEterPackManager::RetrieveHybridCryptPackSDB

; 203  : 	return true;

  00096	b3 01		 mov	 bl, 1
  00098	eb 02		 jmp	 SHORT $LN8@RecvHybrid
$LN7@RecvHybrid:
  0009a	32 db		 xor	 bl, bl
$LN8@RecvHybrid:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h

; 2670 : 		delete[] m_pStream;

  0009c	ff 75 eb	 push	 DWORD PTR _kPacket$[ebp+7]
  0009f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000a4	83 c4 04	 add	 esp, 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp

; 203  : 	return true;

  000a7	8a c3		 mov	 al, bl

; 204  : }

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b3	59		 pop	 ecx
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SPacketGCHybridSDB@@QAE@XZ ; SPacketGCHybridSDB::~SPacketGCHybridSDB
__ehhandler$?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::RecvHybridCryptSDBPacket
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_kPacket$ = -28						; size = 11
_header$ = -16						; size = 3
__$EHRec$ = -12						; size = 12
?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::RecvHybridCryptKeyPacket, COMDAT
; _this$ = ecx

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 168  : 	int iFixedHeaderSize = TPacketGCHybridCryptKeys::GetFixedHeaderSize();
; 169  : 
; 170  : 	TDynamicSizePacketHeader header;
; 171  : 	if( !Peek( sizeof(header), &header) )

  00029	8d 45 f0	 lea	 eax, DWORD PTR _header$[ebp]
  0002c	50		 push	 eax
  0002d	6a 03		 push	 3
  0002f	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  00034	84 c0		 test	 al, al
  00036	75 11		 jne	 SHORT $LN3@RecvHybrid

; 184  : }

  00038	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN3@RecvHybrid:

; 172  : 		return false;
; 173  : 
; 174  : 	TPacketGCHybridCryptKeys kPacket(header.size-iFixedHeaderSize);

  00049	0f b7 45 f1	 movzx	 eax, WORD PTR _header$[ebp+1]
  0004d	83 e8 07	 sub	 eax, 7
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h

; 2635 : 		m_pStream = new BYTE[iStreamSize];

  00050	50		 push	 eax
  00051	89 45 e7	 mov	 DWORD PTR _kPacket$[ebp+3], eax
  00054	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 eb	 mov	 DWORD PTR _kPacket$[ebp+7], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp

; 176  : 	if (!Recv(iFixedHeaderSize, &kPacket))

  0005f	8d 45 e4	 lea	 eax, DWORD PTR _kPacket$[ebp]
  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00069	50		 push	 eax
  0006a	6a 07		 push	 7
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00073	84 c0		 test	 al, al
  00075	74 23		 je	 SHORT $LN7@RecvHybrid

; 177  : 		return false;
; 178  : 
; 179  : 	if (!Recv(kPacket.iKeyStreamLen, kPacket.m_pStream))

  00077	ff 75 eb	 push	 DWORD PTR _kPacket$[ebp+7]
  0007a	8b ce		 mov	 ecx, esi
  0007c	ff 75 e7	 push	 DWORD PTR _kPacket$[ebp+3]
  0007f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00084	84 c0		 test	 al, al
  00086	74 12		 je	 SHORT $LN7@RecvHybrid

; 180  : 		return false;
; 181  : 
; 182  : 	CEterPackManager::Instance().RetrieveHybridCryptPackKeys( kPacket.m_pStream ); 

  00088	ff 75 eb	 push	 DWORD PTR _kPacket$[ebp+7]
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00091	e8 00 00 00 00	 call	 ?RetrieveHybridCryptPackKeys@CEterPackManager@@QAEXPBE@Z ; CEterPackManager::RetrieveHybridCryptPackKeys

; 183  : 	return true;

  00096	b3 01		 mov	 bl, 1
  00098	eb 02		 jmp	 SHORT $LN8@RecvHybrid
$LN7@RecvHybrid:
  0009a	32 db		 xor	 bl, bl
$LN8@RecvHybrid:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\packet.h

; 2639 : 		if( m_pStream )

  0009c	8b 4d eb	 mov	 ecx, DWORD PTR _kPacket$[ebp+7]
  0009f	85 c9		 test	 ecx, ecx
  000a1	74 09		 je	 SHORT $LN15@RecvHybrid

; 2640 : 		{
; 2641 : 			delete[] m_pStream;

  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000a9	83 c4 04	 add	 esp, 4
$LN15@RecvHybrid:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp

; 183  : 	return true;

  000ac	8a c3		 mov	 al, bl

; 184  : }

  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b8	59		 pop	 ecx
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SPacketGCHybridCryptKeys@@QAE@XZ ; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys
__ehhandler$?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::RecvHybridCryptKeyPacket
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?RecvHandshakeOKPacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_kBlankPacket$ = -1					; size = 1
?RecvHandshakeOKPacket@CPythonNetworkStream@@QAE_NXZ PROC ; CPythonNetworkStream::RecvHandshakeOKPacket, COMDAT
; _this$ = ecx

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 154  : 	TPacketGCBlank kBlankPacket;
; 155  : 	if (!Recv(sizeof(TPacketGCBlank), &kBlankPacket))

  00005	8d 45 ff	 lea	 eax, DWORD PTR _kBlankPacket$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 05		 jne	 SHORT $LN1@RecvHandsh
  00016	5f		 pop	 edi

; 164  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN1@RecvHandsh:
  0001b	56		 push	 esi

; 156  : 		return false;
; 157  : 
; 158  : 	DWORD dwDelta=ELTimer_GetMSec()-m_kServerTimeSync.m_dwChangeClientTime;

  0001c	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 159  : 	ELTimer_SetServerMSec(m_kServerTimeSync.m_dwChangeServerTime+dwDelta);

  00021	8b 8f b8 00 00
	00		 mov	 ecx, DWORD PTR [edi+184]
  00027	8b f0		 mov	 esi, eax
  00029	2b b7 bc 00 00
	00		 sub	 esi, DWORD PTR [edi+188]
  0002f	03 ce		 add	 ecx, esi
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ?ELTimer_SetServerMSec@@YAXK@Z ; ELTimer_SetServerMSec

; 160  : 
; 161  : 	Tracenf("HANDSHAKE OK RECV %u %u", m_kServerTimeSync.m_dwChangeServerTime, dwDelta);

  00037	56		 push	 esi
  00038	ff b7 b8 00 00
	00		 push	 DWORD PTR [edi+184]
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JCCALMCB@HANDSHAKE?5OK?5RECV?5?$CFu?5?$CFu?$AA@
  00043	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 162  : 
; 163  : 	return true;

  0004b	b0 01		 mov	 al, 1
  0004d	5e		 pop	 esi
  0004e	5f		 pop	 edi

; 164  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?RecvHandshakeOKPacket@CPythonNetworkStream@@QAE_NXZ ENDP ; CPythonNetworkStream::RecvHandshakeOKPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?RecvHandshakePacket@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_kHandshakeData$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
?RecvHandshakePacket@CPythonNetworkStream@@QAE_NXZ PROC	; CPythonNetworkStream::RecvHandshakePacket, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 126  : 	TPacketGCHandshake kHandshakeData;
; 127  : 	if (!Recv(sizeof(TPacketGCHandshake), &kHandshakeData))

  00011	8d 45 ec	 lea	 eax, DWORD PTR _kHandshakeData$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 0d		 push	 13			; 0000000dH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 11		 jne	 SHORT $LN2@RecvHandsh
$LN5@RecvHandsh:

; 128  : 		return false;

  00022	32 c0		 xor	 al, al
  00024	5e		 pop	 esi

; 148  : 
; 149  : 	return true;
; 150  : }

  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	33 cd		 xor	 ecx, ebp
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN2@RecvHandsh:

; 129  : 
; 130  : 	Tracenf("HANDSHAKE RECV %u %d", kHandshakeData.dwTime, kHandshakeData.lDelta);

  00033	ff 75 f5	 push	 DWORD PTR _kHandshakeData$[ebp+9]
  00036	ff 75 f1	 push	 DWORD PTR _kHandshakeData$[ebp+5]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd?$AA@
  0003e	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf

; 131  : 
; 132  : 	m_kServerTimeSync.m_dwChangeServerTime = kHandshakeData.dwTime + kHandshakeData.lDelta;

  00043	8b 45 f1	 mov	 eax, DWORD PTR _kHandshakeData$[ebp+5]
  00046	03 45 f5	 add	 eax, DWORD PTR _kHandshakeData$[ebp+9]
  00049	89 86 b8 00 00
	00		 mov	 DWORD PTR [esi+184], eax

; 133  : 	m_kServerTimeSync.m_dwChangeClientTime = ELTimer_GetMSec();

  0004f	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 134  : 	
; 135  : 	kHandshakeData.dwTime = kHandshakeData.dwTime + kHandshakeData.lDelta + kHandshakeData.lDelta;

  00054	8b 4d f5	 mov	 ecx, DWORD PTR _kHandshakeData$[ebp+9]
  00057	89 86 bc 00 00
	00		 mov	 DWORD PTR [esi+188], eax
  0005d	8b 45 f1	 mov	 eax, DWORD PTR _kHandshakeData$[ebp+5]

; 136  : 	kHandshakeData.lDelta = 0;

  00060	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _kHandshakeData$[ebp+9], 0
  00067	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]

; 137  : 
; 138  : 	Tracenf("HANDSHAKE SEND %u", kHandshakeData.dwTime);

  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu?$AA@
  00070	89 45 f1	 mov	 DWORD PTR _kHandshakeData$[ebp+5], eax
  00073	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00078	83 c4 14	 add	 esp, 20			; 00000014H

; 139  : 
; 140  : 	kHandshakeData.header = HEADER_CG_TIME_SYNC;

  0007b	c6 45 ec fc	 mov	 BYTE PTR _kHandshakeData$[ebp], 252 ; 000000fcH

; 141  : 	if (!Send(sizeof(TPacketGCHandshake), &kHandshakeData))

  0007f	8d 45 ec	 lea	 eax, DWORD PTR _kHandshakeData$[ebp]
  00082	8b ce		 mov	 ecx, esi
  00084	50		 push	 eax
  00085	6a 0d		 push	 13			; 0000000dH
  00087	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0008c	84 c0		 test	 al, al
  0008e	74 92		 je	 SHORT $LN5@RecvHandsh

; 142  : 	{
; 143  : 		assert(!"Failed Sending Handshake");
; 144  : 		return false;
; 145  : 	}
; 146  : 
; 147  : 	SendSequence();

  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 148  : 
; 149  : 	return true;
; 150  : }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	b0 01		 mov	 al, 1
  0009c	33 cd		 xor	 ecx, ebp
  0009e	5e		 pop	 esi
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?RecvHandshakePacket@CPythonNetworkStream@@QAE_NXZ ENDP	; CPythonNetworkStream::RecvHandshakePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.h
;	COMDAT ?__LeaveHandshakePhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__LeaveHandshakePhase@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__LeaveHandshakePhase, COMDAT
; _this$ = ecx

; 590  : 		void __LeaveHandshakePhase() {}

  00000	c3		 ret	 0
?__LeaveHandshakePhase@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__LeaveHandshakePhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphasehandshake.cpp
;	COMDAT ?HandShakePhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
_BindUDP$1 = -12					; size = 7
_header$ = -1						; size = 1
?HandShakePhase@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::HandShakePhase, COMDAT
; _this$ = ecx

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 16   : 	TPacketHeader header;
; 17   : 
; 18   : 	if (!CheckPacket(&header))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _header$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	8b f1		 mov	 esi, ecx
  0000e	e8 00 00 00 00	 call	 ?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z ; CPythonNetworkStream::CheckPacket
  00013	84 c0		 test	 al, al
  00015	74 2f		 je	 SHORT $LN16@HandShakeP

; 19   : 		return;
; 20   : 
; 21   : 	switch (header)

  00017	0f b6 7d ff	 movzx	 edi, BYTE PTR _header$[ebp]
  0001b	8d 47 d4	 lea	 eax, DWORD PTR [edi-44]
  0001e	3d d3 00 00 00	 cmp	 eax, 211		; 000000d3H
  00023	77 19		 ja	 SHORT $LN13@HandShakeP
  00025	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN20@HandShakeP[eax]
  0002c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN22@HandShakeP[eax*4]
$LN12@HandShakeP:

; 22   : 	{
; 23   : 		case HEADER_GC_PHASE:
; 24   : 			if (RecvPhasePacket())

  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPhasePacket
  0003a	84 c0		 test	 al, al
  0003c	75 08		 jne	 SHORT $LN16@HandShakeP
$LN13@HandShakeP:

; 89   : 			return;
; 90   : 			break;
; 91   : #endif
; 92   : 	}
; 93   : 
; 94   : 	RecvErrorPacket(header);

  0003e	57		 push	 edi
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z ; CPythonNetworkStream::RecvErrorPacket
$LN16@HandShakeP:

; 95   : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN10@HandShakeP:

; 25   : 				return;
; 26   : 			break;
; 27   : 
; 28   : 		case HEADER_GC_BINDUDP:
; 29   : 			{
; 30   : 				TPacketGCBindUDP BindUDP;
; 31   : 				
; 32   : 				if (!Recv(sizeof(TPacketGCBindUDP), &BindUDP))

  0004c	8d 45 f4	 lea	 eax, DWORD PTR _BindUDP$1[ebp]
  0004f	8b ce		 mov	 ecx, esi
  00051	50		 push	 eax
  00052	6a 07		 push	 7
  00054	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv

; 95   : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN8@HandShakeP:

; 33   : 					return;
; 34   : 
; 35   : 				return;
; 36   : 			}
; 37   : 			break;
; 38   : 
; 39   : 		case HEADER_GC_HANDSHAKE:
; 40   : 			{
; 41   : 				if (!Recv(sizeof(TPacketGCHandshake), &m_HandshakeData))

  0005f	8d be 80 00 00
	00		 lea	 edi, DWORD PTR [esi+128]
  00065	8b ce		 mov	 ecx, esi
  00067	57		 push	 edi
  00068	6a 0d		 push	 13			; 0000000dH
  0006a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0006f	84 c0		 test	 al, al
  00071	74 d3		 je	 SHORT $LN16@HandShakeP

; 42   : 					return;
; 43   : 
; 44   : 				Tracenf("HANDSHAKE RECV %u %d", m_HandshakeData.dwTime, m_HandshakeData.lDelta);

  00073	ff b6 89 00 00
	00		 push	 DWORD PTR [esi+137]
  00079	ff b6 85 00 00
	00		 push	 DWORD PTR [esi+133]
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd?$AA@
  00084	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf

; 45   : 
; 46   : 				ELTimer_SetServerMSec(m_HandshakeData.dwTime+ m_HandshakeData.lDelta);

  00089	8b 86 85 00 00
	00		 mov	 eax, DWORD PTR [esi+133]
  0008f	03 86 89 00 00
	00		 add	 eax, DWORD PTR [esi+137]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?ELTimer_SetServerMSec@@YAXK@Z ; ELTimer_SetServerMSec

; 47   : 
; 48   : 				//m_dwBaseServerTime = m_HandshakeData.dwTime+ m_HandshakeData.lDelta;
; 49   : 				//m_dwBaseClientTime = ELTimer_GetMSec();
; 50   : 
; 51   : 				m_HandshakeData.dwTime = m_HandshakeData.dwTime + m_HandshakeData.lDelta + m_HandshakeData.lDelta;

  0009b	8b 86 89 00 00
	00		 mov	 eax, DWORD PTR [esi+137]
  000a1	03 c0		 add	 eax, eax

; 52   : 				m_HandshakeData.lDelta = 0;

  000a3	c7 86 89 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+137], 0
  000ad	01 86 85 00 00
	00		 add	 DWORD PTR [esi+133], eax

; 53   : 
; 54   : 				Tracenf("HANDSHAKE SEND %u", m_HandshakeData.dwTime);

  000b3	ff b6 85 00 00
	00		 push	 DWORD PTR [esi+133]
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu?$AA@
  000be	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  000c3	83 c4 18	 add	 esp, 24			; 00000018H

; 55   : 
; 56   : 				if (!Send(sizeof(TPacketGCHandshake), &m_HandshakeData))

  000c6	8b ce		 mov	 ecx, esi
  000c8	57		 push	 edi
  000c9	6a 0d		 push	 13			; 0000000dH
  000cb	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  000d0	84 c0		 test	 al, al
  000d2	0f 84 6e ff ff
	ff		 je	 $LN16@HandShakeP

; 57   : 				{
; 58   : 					assert(!"Failed Sending Handshake");
; 59   : 					return;
; 60   : 				}
; 61   : 
; 62   : 				CTimer::Instance().SetBaseTime();

  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  000de	e8 00 00 00 00	 call	 ?SetBaseTime@CTimer@@QAEXXZ ; CTimer::SetBaseTime

; 95   : }

  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
$LN5@HandShakeP:

; 63   : 				return;
; 64   : 			}
; 65   : 			break;
; 66   : 		case HEADER_GC_PING:
; 67   : 			RecvPingPacket();

  000e9	8b ce		 mov	 ecx, esi
  000eb	e8 00 00 00 00	 call	 ?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPingPacket

; 95   : }

  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
$LN4@HandShakeP:

; 68   : 			return;
; 69   : 			break;
; 70   : 
; 71   : 		case HEADER_GC_HYBRIDCRYPT_KEYS:
; 72   : 			RecvHybridCryptKeyPacket();

  000f6	8b ce		 mov	 ecx, esi
  000f8	e8 00 00 00 00	 call	 ?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptKeyPacket

; 95   : }

  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN3@HandShakeP:

; 73   : 			return;
; 74   : 			break;
; 75   : 
; 76   : 		case HEADER_GC_HYBRIDCRYPT_SDB:
; 77   : 			RecvHybridCryptSDBPacket();

  00103	8b ce		 mov	 ecx, esi
  00105	e8 00 00 00 00	 call	 ?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptSDBPacket

; 95   : }

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
$LN2@HandShakeP:

; 78   : 			return;
; 79   : 			break;
; 80   : 
; 81   : #ifdef _IMPROVED_PACKET_ENCRYPTION_
; 82   : 		case HEADER_GC_KEY_AGREEMENT:
; 83   : 			RecvKeyAgreementPacket();

  00110	8b ce		 mov	 ecx, esi
  00112	e8 00 00 00 00	 call	 ?RecvKeyAgreementPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvKeyAgreementPacket

; 95   : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
$LN1@HandShakeP:

; 84   : 			return;
; 85   : 			break;
; 86   : 
; 87   : 		case HEADER_GC_KEY_AGREEMENT_COMPLETED:
; 88   : 			RecvKeyAgreementCompletedPacket();

  0011d	8b ce		 mov	 ecx, esi
  0011f	e8 00 00 00 00	 call	 ?RecvKeyAgreementCompletedPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvKeyAgreementCompletedPacket

; 95   : }

  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
  0012a	8b ff		 npad	 2
$LN22@HandShakeP:
  0012c	00 00 00 00	 DD	 $LN5@HandShakeP
  00130	00 00 00 00	 DD	 $LN4@HandShakeP
  00134	00 00 00 00	 DD	 $LN3@HandShakeP
  00138	00 00 00 00	 DD	 $LN1@HandShakeP
  0013c	00 00 00 00	 DD	 $LN2@HandShakeP
  00140	00 00 00 00	 DD	 $LN12@HandShakeP
  00144	00 00 00 00	 DD	 $LN10@HandShakeP
  00148	00 00 00 00	 DD	 $LN8@HandShakeP
  0014c	00 00 00 00	 DD	 $LN13@HandShakeP
$LN20@HandShakeP:
  00150	00		 DB	 0
  00151	08		 DB	 8
  00152	08		 DB	 8
  00153	08		 DB	 8
  00154	08		 DB	 8
  00155	08		 DB	 8
  00156	08		 DB	 8
  00157	08		 DB	 8
  00158	08		 DB	 8
  00159	08		 DB	 8
  0015a	08		 DB	 8
  0015b	08		 DB	 8
  0015c	08		 DB	 8
  0015d	08		 DB	 8
  0015e	08		 DB	 8
  0015f	08		 DB	 8
  00160	08		 DB	 8
  00161	08		 DB	 8
  00162	08		 DB	 8
  00163	08		 DB	 8
  00164	08		 DB	 8
  00165	08		 DB	 8
  00166	08		 DB	 8
  00167	08		 DB	 8
  00168	08		 DB	 8
  00169	08		 DB	 8
  0016a	08		 DB	 8
  0016b	08		 DB	 8
  0016c	08		 DB	 8
  0016d	08		 DB	 8
  0016e	08		 DB	 8
  0016f	08		 DB	 8
  00170	08		 DB	 8
  00171	08		 DB	 8
  00172	08		 DB	 8
  00173	08		 DB	 8
  00174	08		 DB	 8
  00175	08		 DB	 8
  00176	08		 DB	 8
  00177	08		 DB	 8
  00178	08		 DB	 8
  00179	08		 DB	 8
  0017a	08		 DB	 8
  0017b	08		 DB	 8
  0017c	08		 DB	 8
  0017d	08		 DB	 8
  0017e	08		 DB	 8
  0017f	08		 DB	 8
  00180	08		 DB	 8
  00181	08		 DB	 8
  00182	08		 DB	 8
  00183	08		 DB	 8
  00184	08		 DB	 8
  00185	08		 DB	 8
  00186	08		 DB	 8
  00187	08		 DB	 8
  00188	08		 DB	 8
  00189	08		 DB	 8
  0018a	08		 DB	 8
  0018b	08		 DB	 8
  0018c	08		 DB	 8
  0018d	08		 DB	 8
  0018e	08		 DB	 8
  0018f	08		 DB	 8
  00190	08		 DB	 8
  00191	08		 DB	 8
  00192	08		 DB	 8
  00193	08		 DB	 8
  00194	08		 DB	 8
  00195	08		 DB	 8
  00196	08		 DB	 8
  00197	08		 DB	 8
  00198	08		 DB	 8
  00199	08		 DB	 8
  0019a	08		 DB	 8
  0019b	08		 DB	 8
  0019c	08		 DB	 8
  0019d	08		 DB	 8
  0019e	08		 DB	 8
  0019f	08		 DB	 8
  001a0	08		 DB	 8
  001a1	08		 DB	 8
  001a2	08		 DB	 8
  001a3	08		 DB	 8
  001a4	08		 DB	 8
  001a5	08		 DB	 8
  001a6	08		 DB	 8
  001a7	08		 DB	 8
  001a8	08		 DB	 8
  001a9	08		 DB	 8
  001aa	08		 DB	 8
  001ab	08		 DB	 8
  001ac	08		 DB	 8
  001ad	08		 DB	 8
  001ae	08		 DB	 8
  001af	08		 DB	 8
  001b0	08		 DB	 8
  001b1	08		 DB	 8
  001b2	08		 DB	 8
  001b3	08		 DB	 8
  001b4	08		 DB	 8
  001b5	08		 DB	 8
  001b6	08		 DB	 8
  001b7	08		 DB	 8
  001b8	08		 DB	 8
  001b9	08		 DB	 8
  001ba	08		 DB	 8
  001bb	08		 DB	 8
  001bc	01		 DB	 1
  001bd	02		 DB	 2
  001be	08		 DB	 8
  001bf	08		 DB	 8
  001c0	08		 DB	 8
  001c1	08		 DB	 8
  001c2	08		 DB	 8
  001c3	08		 DB	 8
  001c4	08		 DB	 8
  001c5	08		 DB	 8
  001c6	08		 DB	 8
  001c7	08		 DB	 8
  001c8	08		 DB	 8
  001c9	08		 DB	 8
  001ca	08		 DB	 8
  001cb	08		 DB	 8
  001cc	08		 DB	 8
  001cd	08		 DB	 8
  001ce	08		 DB	 8
  001cf	08		 DB	 8
  001d0	08		 DB	 8
  001d1	08		 DB	 8
  001d2	08		 DB	 8
  001d3	08		 DB	 8
  001d4	08		 DB	 8
  001d5	08		 DB	 8
  001d6	08		 DB	 8
  001d7	08		 DB	 8
  001d8	08		 DB	 8
  001d9	08		 DB	 8
  001da	08		 DB	 8
  001db	08		 DB	 8
  001dc	08		 DB	 8
  001dd	08		 DB	 8
  001de	08		 DB	 8
  001df	08		 DB	 8
  001e0	08		 DB	 8
  001e1	08		 DB	 8
  001e2	08		 DB	 8
  001e3	08		 DB	 8
  001e4	08		 DB	 8
  001e5	08		 DB	 8
  001e6	08		 DB	 8
  001e7	08		 DB	 8
  001e8	08		 DB	 8
  001e9	08		 DB	 8
  001ea	08		 DB	 8
  001eb	08		 DB	 8
  001ec	08		 DB	 8
  001ed	08		 DB	 8
  001ee	08		 DB	 8
  001ef	08		 DB	 8
  001f0	08		 DB	 8
  001f1	08		 DB	 8
  001f2	08		 DB	 8
  001f3	08		 DB	 8
  001f4	08		 DB	 8
  001f5	08		 DB	 8
  001f6	08		 DB	 8
  001f7	08		 DB	 8
  001f8	08		 DB	 8
  001f9	08		 DB	 8
  001fa	08		 DB	 8
  001fb	08		 DB	 8
  001fc	08		 DB	 8
  001fd	08		 DB	 8
  001fe	08		 DB	 8
  001ff	08		 DB	 8
  00200	08		 DB	 8
  00201	08		 DB	 8
  00202	08		 DB	 8
  00203	08		 DB	 8
  00204	08		 DB	 8
  00205	08		 DB	 8
  00206	08		 DB	 8
  00207	08		 DB	 8
  00208	08		 DB	 8
  00209	08		 DB	 8
  0020a	08		 DB	 8
  0020b	08		 DB	 8
  0020c	08		 DB	 8
  0020d	08		 DB	 8
  0020e	08		 DB	 8
  0020f	08		 DB	 8
  00210	08		 DB	 8
  00211	08		 DB	 8
  00212	08		 DB	 8
  00213	08		 DB	 8
  00214	08		 DB	 8
  00215	08		 DB	 8
  00216	08		 DB	 8
  00217	08		 DB	 8
  00218	08		 DB	 8
  00219	08		 DB	 8
  0021a	08		 DB	 8
  0021b	08		 DB	 8
  0021c	08		 DB	 8
  0021d	08		 DB	 8
  0021e	03		 DB	 3
  0021f	04		 DB	 4
  00220	08		 DB	 8
  00221	05		 DB	 5
  00222	06		 DB	 6
  00223	07		 DB	 7
?HandShakePhase@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::HandShakePhase
_TEXT	ENDS
END
