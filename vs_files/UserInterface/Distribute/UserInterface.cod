; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\UserInterface.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@CMMKLLC@UserDict?4pyc?$AA@		; `string'
PUBLIC	??_C@_0P@KBODAEKE@__future__?4pyc?$AA@		; `string'
PUBLIC	??_C@_0L@HJCEJGHC@ntpath?4pyc?$AA@		; `string'
PUBLIC	??_C@_06JCOFDJKA@os?4pyc?$AA@			; `string'
PUBLIC	??_C@_0N@GCNFBOJN@copy_reg?4pyc?$AA@		; `string'
PUBLIC	??_C@_0O@COBIIGAD@linecache?4pyc?$AA@		; `string'
PUBLIC	??_C@_0L@NDKNFNNI@string?4pyc?$AA@		; `string'
PUBLIC	??_C@_0O@PMKHJGGH@traceback?4pyc?$AA@		; `string'
PUBLIC	??_C@_08FPFMJPEC@site?4pyc?$AA@			; `string'
PUBLIC	??_C@_08EFIONJOP@stat?4pyc?$AA@			; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_0BB@FPBAACEA@metin2client?4dat?$AA@	; `string'
PUBLIC	??_C@_09EHIBBABK@types?4pyc?$AA@		; `string'
PUBLIC	??_C@_04HOGMCHDB@lib?2?$AA@			; `string'
PUBLIC	??_C@_05FNNGFGLF@Index?$AA@			; `string'
PUBLIC	??_C@_0CA@PJKENNIH@FATAL?5ERROR?$CB?5File?5not?5exist?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_07GHKFPDHK@locale?1?$AA@			; `string'
PUBLIC	??_C@_02LFNMGJAP@en?$AA@			; `string'
PUBLIC	??_C@_0ED@CBACJNDK@Pack?1Index?5has?5invalid?5syntax?4?5F@ ; `string'
PUBLIC	??_C@_0BG@FJMFFOHK@?$LO?K?$LI?$LC?3?5?F?Q?5?$LI?p?$LF?e?$MA?T?$LE?O?$LE?Y?4?6?$AA@ ; `string'
PUBLIC	??_C@_04PMPMHNFI@FILE?$AA@			; `string'
PUBLIC	??_C@_04EDDHFNCG@PACK?$AA@			; `string'
PUBLIC	??_C@_0O@GIEHGGHC@__DEBUG__?5?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0BI@JAFKHBD@RegisterDebugFlag?5Error?$AA@	; `string'
PUBLIC	??_C@_09ODEGJGJI@_texcache?$AA@			; `string'
PUBLIC	??_C@_04NBFCGMPH@root?$AA@			; `string'
PUBLIC	??_C@_0BE@FPKDPBJI@__COMMAND_LINE__?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BK@DPMNHJLC@RegisterCommandLine?5Error?$AA@ ; `string'
PUBLIC	??_C@_03MCGAAIEM@?9cs?$AA@			; `string'
PUBLIC	??_C@_04JFPGDMCL@?9ncs?$AA@			; `string'
PUBLIC	??_C@_09LEIJOBCA@system?4py?$AA@		; `string'
PUBLIC	??_C@_0O@BEEPKJML@RunMain?5Error?$AA@		; `string'
PUBLIC	??_C@_0BN@KIGJPBEF@?9?9pause?9before?9create?9window?$AA@ ; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	??_C@_0DB@BGMLOPGB@Pack?5Initialization?5failed?4?5Chec@ ; `string'
PUBLIC	??_C@_0M@PFDHIIAP@eter?4python?$AA@		; `string'
PUBLIC	??_C@_0N@JIKFFHPP@newpatch?4exe?$AA@		; `string'
PUBLIC	??_C@_0BB@LLCBDFGP@patchupdater?4exe?$AA@	; `string'
PUBLIC	??_C@_0L@HBFAHJLE@?1timestamp?$AA@		; `string'
PUBLIC	??_C@_0BJ@CPGCGJKO@Fri?5Sep?511?508?312?333?52015?$AA@ ; `string'
PUBLIC	??_C@_0BA@OEEELOKH@Metin2GameMutex?$AA@		; `string'
PUBLIC	??_C@_0CN@OHDPHKKH@FATAL?5ERROR?$CB?$CB?5Python?5Library?5fil@ ; `string'
PUBLIC	??_C@_08LJMAFCGB@?9?9locale?$AA@		; `string'
PUBLIC	??_C@_0BE@FJLABEAB@?9?9perforce?9revision?$AA@	; `string'
PUBLIC	??_C@_0DG@JFMPGIL@METIN2?5BINARY?5TEST?5VERSION?5?$CFs?5?5?$CI@ ; `string'
PUBLIC	??_C@_0DL@IHCMKBOK@METIN2?5BINARY?5DISTRIBUTE?5VERSION@ ; `string'
PUBLIC	??_C@_0L@IBAMLFBB@?$CFs?4version?$AA@		; `string'
PUBLIC	??_C@_04JIBCGPDH@r?$CFd?6?$AA@			; `string'
PUBLIC	??_C@_0N@FPLLJIDE@?9?9hackshield?$AA@		; `string'
PUBLIC	??_C@_0L@LCFODDFH@locale?4cfg?$AA@		; `string'
PUBLIC	??_C@_0BD@BMCCGKJE@?9?9force?9set?9locale?$AA@	; `string'
PUBLIC	??_C@_08GKBDCAOF@APP_NAME?$AA@			; `string'
PUBLIC	??_C@_0L@IMHJDJJ@locale?4txt?$AA@		; `string'
PUBLIC	??_C@_0BK@LJMCIPPN@service?$FL?$CFs?$FN?5code_page?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BC@PALKPJEA@Invalid?5arguments?$AA@	; `string'
PUBLIC	??_C@_0L@GNJGCFKN@GRANNY?3?5?$CFs?$AA@		; `string'
PUBLIC	?gs_szErrorString@@3PADA			; gs_szErrorString
PUBLIC	?__IS_TEST_SERVER_MODE__@@3_NA			; __IS_TEST_SERVER_MODE__
EXTRN	__imp__GrannySetLogCallback@4:PROC
EXTRN	__imp__timeBeginPeriod@4:PROC
EXTRN	?MINMAX@@YAHHHH@Z:PROC				; MINMAX
EXTRN	_WebBrowser_Cleanup:PROC
EXTRN	_WebBrowser_Startup:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__timeGetDevCaps@8:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	??1CLZO@@UAE@XZ:PROC				; CLZO::~CLZO
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	?CommandLineToArgv@@YAPAPADPADPAH@Z:PROC	; CommandLineToArgv
EXTRN	?Create@CPythonLauncher@@QAE_NPBD@Z:PROC	; CPythonLauncher::Create
EXTRN	?SetExceptionSender@@YAXPAVIPythonExceptionSender@@@Z:PROC ; SetExceptionSender
EXTRN	??1CPythonLauncher@@UAE@XZ:PROC			; CPythonLauncher::~CPythonLauncher
EXTRN	??0CPythonLauncher@@QAE@XZ:PROC			; CPythonLauncher::CPythonLauncher
EXTRN	??1CEterPackManager@@UAE@XZ:PROC		; CEterPackManager::~CEterPackManager
EXTRN	?Clear@CPythonLauncher@@QAEXXZ:PROC		; CPythonLauncher::Clear
EXTRN	__imp__timeEndPeriod@4:PROC
EXTRN	??0CEterPackManager@@QAE@XZ:PROC		; CEterPackManager::CEterPackManager
EXTRN	??0CLZO@@QAE@XZ:PROC				; CLZO::CLZO
EXTRN	?Initialize@CMSApplication@@QAEXPAUHINSTANCE__@@@Z:PROC ; CMSApplication::Initialize
EXTRN	?SetDefaultCodePage@@YA_NK@Z:PROC		; SetDefaultCodePage
EXTRN	__imp__ilInit@0:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	?SetLogLevel@@YAXI@Z:PROC			; SetLogLevel
EXTRN	?OpenLogFile@@YAX_N@Z:PROC			; OpenLogFile
EXTRN	_system:PROC
EXTRN	?base64_decode@@YAXPBDPAD@Z:PROC		; base64_decode
EXTRN	?SplitLine@@YA_NPBD0PAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:PROC ; SplitLine
EXTRN	_srand:PROC
EXTRN	?srandom@@YAXK@Z:PROC				; srandom
EXTRN	?initgrp@@YAXXZ:PROC				; initgrp
EXTRN	?initdbg@@YAXXZ:PROC				; initdbg
EXTRN	?RegisterRootPack@CEterPackManager@@QAEXPBD@Z:PROC ; CEterPackManager::RegisterRootPack
EXTRN	?SetPackMode@CSoundData@@SAXXZ:PROC		; CSoundData::SetPackMode
EXTRN	?RunLine@CPythonLauncher@@QAE_NPBD@Z:PROC	; CPythonLauncher::RunLine
EXTRN	?initwndMgr@@YAXXZ:PROC				; initwndMgr
EXTRN	?initgrpText@@YAXXZ:PROC			; initgrpText
EXTRN	?initgrpImage@@YAXXZ:PROC			; initgrpImage
EXTRN	?Create@CMappedFile@@QAEHPBDPAPBXHH@Z:PROC	; CMappedFile::Create
EXTRN	__imp__LoadStringA@16:PROC
EXTRN	?SetSearchMode@CEterPackManager@@QAEX_N@Z:PROC	; CEterPackManager::SetSearchMode
EXTRN	?SetCacheMode@CEterPackManager@@QAEXXZ:PROC	; CEterPackManager::SetCacheMode
EXTRN	?SetCacheMode@CTextFileLoader@@SAXXZ:PROC	; CTextFileLoader::SetCacheMode
EXTRN	?LogBoxf@@YAXPBDZZ:PROC				; LogBoxf
EXTRN	__imp__GetCurrentDirectoryA@8:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__fltused:DWORD
EXTRN	__imp__MoveFileA@8:PROC
?gs_szErrorString@@3PADA DB 0200H DUP (?)		; gs_szErrorString
?__IS_TEST_SERVER_MODE__@@3_NA DB 01H DUP (?)		; __IS_TEST_SERVER_MODE__
_BSS	ENDS
;	COMDAT ??_C@_0L@GNJGCFKN@GRANNY?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@GNJGCFKN@GRANNY?3?5?$CFs?$AA@ DB 'GRANNY: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PALKPJEA@Invalid?5arguments?$AA@
CONST	SEGMENT
??_C@_0BC@PALKPJEA@Invalid?5arguments?$AA@ DB 'Invalid arguments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LJMCIPPN@service?$FL?$CFs?$FN?5code_page?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BK@LJMCIPPN@service?$FL?$CFs?$FN?5code_page?$FL?$CFd?$FN?$AA@ DB 's'
	DB	'ervice[%s] code_page[%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IMHJDJJ@locale?4txt?$AA@
CONST	SEGMENT
??_C@_0L@IMHJDJJ@locale?4txt?$AA@ DB 'locale.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GKBDCAOF@APP_NAME?$AA@
CONST	SEGMENT
??_C@_08GKBDCAOF@APP_NAME?$AA@ DB 'APP_NAME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMCCGKJE@?9?9force?9set?9locale?$AA@
CONST	SEGMENT
??_C@_0BD@BMCCGKJE@?9?9force?9set?9locale?$AA@ DB '--force-set-locale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LCFODDFH@locale?4cfg?$AA@
CONST	SEGMENT
??_C@_0L@LCFODDFH@locale?4cfg?$AA@ DB 'locale.cfg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPLLJIDE@?9?9hackshield?$AA@
CONST	SEGMENT
??_C@_0N@FPLLJIDE@?9?9hackshield?$AA@ DB '--hackshield', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JIBCGPDH@r?$CFd?6?$AA@
CONST	SEGMENT
??_C@_04JIBCGPDH@r?$CFd?6?$AA@ DB 'r%d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IBAMLFBB@?$CFs?4version?$AA@
CONST	SEGMENT
??_C@_0L@IBAMLFBB@?$CFs?4version?$AA@ DB '%s.version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IHCMKBOK@METIN2?5BINARY?5DISTRIBUTE?5VERSION@
CONST	SEGMENT
??_C@_0DL@IHCMKBOK@METIN2?5BINARY?5DISTRIBUTE?5VERSION@ DB 'METIN2 BINARY'
	DB	' DISTRIBUTE VERSION %s ( MS C++ %d Compiled )', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JFMPGIL@METIN2?5BINARY?5TEST?5VERSION?5?$CFs?5?5?$CI@
CONST	SEGMENT
??_C@_0DG@JFMPGIL@METIN2?5BINARY?5TEST?5VERSION?5?$CFs?5?5?$CI@ DB 'METIN'
	DB	'2 BINARY TEST VERSION %s  ( MS C++ %d Compiled )', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FJLABEAB@?9?9perforce?9revision?$AA@
CONST	SEGMENT
??_C@_0BE@FJLABEAB@?9?9perforce?9revision?$AA@ DB '--perforce-revision', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJMAFCGB@?9?9locale?$AA@
CONST	SEGMENT
??_C@_08LJMAFCGB@?9?9locale?$AA@ DB '--locale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OHDPHKKH@FATAL?5ERROR?$CB?$CB?5Python?5Library?5fil@
CONST	SEGMENT
??_C@_0CN@OHDPHKKH@FATAL?5ERROR?$CB?$CB?5Python?5Library?5fil@ DB 'FATAL '
	DB	'ERROR!! Python Library file not exist!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEEELOKH@Metin2GameMutex?$AA@
CONST	SEGMENT
??_C@_0BA@OEEELOKH@Metin2GameMutex?$AA@ DB 'Metin2GameMutex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CPGCGJKO@Fri?5Sep?511?508?312?333?52015?$AA@
CONST	SEGMENT
??_C@_0BJ@CPGCGJKO@Fri?5Sep?511?508?312?333?52015?$AA@ DB 'Fri Sep 11 08:'
	DB	'12:33 2015', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HBFAHJLE@?1timestamp?$AA@
CONST	SEGMENT
??_C@_0L@HBFAHJLE@?1timestamp?$AA@ DB '/timestamp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LLCBDFGP@patchupdater?4exe?$AA@
CONST	SEGMENT
??_C@_0BB@LLCBDFGP@patchupdater?4exe?$AA@ DB 'patchupdater.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JIKFFHPP@newpatch?4exe?$AA@
CONST	SEGMENT
??_C@_0N@JIKFFHPP@newpatch?4exe?$AA@ DB 'newpatch.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PFDHIIAP@eter?4python?$AA@
CONST	SEGMENT
??_C@_0M@PFDHIIAP@eter?4python?$AA@ DB 'eter.python', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BGMLOPGB@Pack?5Initialization?5failed?4?5Chec@
CONST	SEGMENT
??_C@_0DB@BGMLOPGB@Pack?5Initialization?5failed?4?5Chec@ DB 'Pack Initial'
	DB	'ization failed. Check log.txt file..', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KIGJPBEF@?9?9pause?9before?9create?9window?$AA@
CONST	SEGMENT
??_C@_0BN@KIGJPBEF@?9?9pause?9before?9create?9window?$AA@ DB '--pause-bef'
	DB	'ore-create-window', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BEEPKJML@RunMain?5Error?$AA@
CONST	SEGMENT
??_C@_0O@BEEPKJML@RunMain?5Error?$AA@ DB 'RunMain Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LEIJOBCA@system?4py?$AA@
CONST	SEGMENT
??_C@_09LEIJOBCA@system?4py?$AA@ DB 'system.py', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFPGDMCL@?9ncs?$AA@
CONST	SEGMENT
??_C@_04JFPGDMCL@?9ncs?$AA@ DB '-ncs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCGAAIEM@?9cs?$AA@
CONST	SEGMENT
??_C@_03MCGAAIEM@?9cs?$AA@ DB '-cs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DPMNHJLC@RegisterCommandLine?5Error?$AA@
CONST	SEGMENT
??_C@_0BK@DPMNHJLC@RegisterCommandLine?5Error?$AA@ DB 'RegisterCommandLin'
	DB	'e Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FPKDPBJI@__COMMAND_LINE__?5?$DN?5?$AA@
CONST	SEGMENT
??_C@_0BE@FPKDPBJI@__COMMAND_LINE__?5?$DN?5?$AA@ DB '__COMMAND_LINE__ = ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBFCGMPH@root?$AA@
CONST	SEGMENT
??_C@_04NBFCGMPH@root?$AA@ DB 'root', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODEGJGJI@_texcache?$AA@
CONST	SEGMENT
??_C@_09ODEGJGJI@_texcache?$AA@ DB '_texcache', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JAFKHBD@RegisterDebugFlag?5Error?$AA@
CONST	SEGMENT
??_C@_0BI@JAFKHBD@RegisterDebugFlag?5Error?$AA@ DB 'RegisterDebugFlag Err'
	DB	'or', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GIEHGGHC@__DEBUG__?5?$DN?50?$AA@
CONST	SEGMENT
??_C@_0O@GIEHGGHC@__DEBUG__?5?$DN?50?$AA@ DB '__DEBUG__ = 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDDHFNCG@PACK?$AA@
CONST	SEGMENT
??_C@_04EDDHFNCG@PACK?$AA@ DB 'PACK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMPMHNFI@FILE?$AA@
CONST	SEGMENT
??_C@_04PMPMHNFI@FILE?$AA@ DB 'FILE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FJMFFOHK@?$LO?K?$LI?$LC?3?5?F?Q?5?$LI?p?$LF?e?$MA?T?$LE?O?$LE?Y?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@FJMFFOHK@?$LO?K?$LI?$LC?3?5?F?Q?5?$LI?p?$LF?e?$MA?T?$LE?O?$LE?Y?4?6?$AA@ DB 0beH
	DB	0cbH, 0b8H, 0b2H, ': ', 0c6H, 0d1H, ' ', 0b8H, 0f0H, 0b5H, 0e5H
	DB	0c0H, 0d4H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@CBACJNDK@Pack?1Index?5has?5invalid?5syntax?4?5F@
CONST	SEGMENT
??_C@_0ED@CBACJNDK@Pack?1Index?5has?5invalid?5syntax?4?5F@ DB 'Pack/Index'
	DB	' has invalid syntax. First line must be ''PACK'' or ''FILE''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFNMGJAP@en?$AA@
CONST	SEGMENT
??_C@_02LFNMGJAP@en?$AA@ DB 'en', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHKFPDHK@locale?1?$AA@
CONST	SEGMENT
??_C@_07GHKFPDHK@locale?1?$AA@ DB 'locale/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PJKENNIH@FATAL?5ERROR?$CB?5File?5not?5exist?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0CA@PJKENNIH@FATAL?5ERROR?$CB?5File?5not?5exist?3?5?$CFs?$AA@ DB 'F'
	DB	'ATAL ERROR! File not exist: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FNNGFGLF@Index?$AA@
CONST	SEGMENT
??_C@_05FNNGFGLF@Index?$AA@ DB 'Index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOGMCHDB@lib?2?$AA@
CONST	SEGMENT
??_C@_04HOGMCHDB@lib?2?$AA@ DB 'lib\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EHIBBABK@types?4pyc?$AA@
CONST	SEGMENT
??_C@_09EHIBBABK@types?4pyc?$AA@ DB 'types.pyc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPBAACEA@metin2client?4dat?$AA@
CONST	SEGMENT
??_C@_0BB@FPBAACEA@metin2client?4dat?$AA@ DB 'metin2client.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EFIONJOP@stat?4pyc?$AA@
CONST	SEGMENT
??_C@_08EFIONJOP@stat?4pyc?$AA@ DB 'stat.pyc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FPFMJPEC@site?4pyc?$AA@
CONST	SEGMENT
??_C@_08FPFMJPEC@site?4pyc?$AA@ DB 'site.pyc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PMKHJGGH@traceback?4pyc?$AA@
CONST	SEGMENT
??_C@_0O@PMKHJGGH@traceback?4pyc?$AA@ DB 'traceback.pyc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDKNFNNI@string?4pyc?$AA@
CONST	SEGMENT
??_C@_0L@NDKNFNNI@string?4pyc?$AA@ DB 'string.pyc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@COBIIGAD@linecache?4pyc?$AA@
CONST	SEGMENT
??_C@_0O@COBIIGAD@linecache?4pyc?$AA@ DB 'linecache.pyc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GCNFBOJN@copy_reg?4pyc?$AA@
CONST	SEGMENT
??_C@_0N@GCNFBOJN@copy_reg?4pyc?$AA@ DB 'copy_reg.pyc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JCOFDJKA@os?4pyc?$AA@
CONST	SEGMENT
??_C@_06JCOFDJKA@os?4pyc?$AA@ DB 'os.pyc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HJCEJGHC@ntpath?4pyc?$AA@
CONST	SEGMENT
??_C@_0L@HJCEJGHC@ntpath?4pyc?$AA@ DB 'ntpath.pyc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBODAEKE@__future__?4pyc?$AA@
CONST	SEGMENT
??_C@_0P@KBODAEKE@__future__?4pyc?$AA@ DB '__future__.pyc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CMMKLLC@UserDict?4pyc?$AA@
CONST	SEGMENT
??_C@_0N@CMMKLLC@UserDict?4pyc?$AA@ DB 'UserDict.pyc', 00H ; `string'
_sc_apszPythonLibraryFilenames DD FLAT:??_C@_0N@CMMKLLC@UserDict?4pyc?$AA@
	DD	FLAT:??_C@_0P@KBODAEKE@__future__?4pyc?$AA@
	DD	FLAT:??_C@_0N@GCNFBOJN@copy_reg?4pyc?$AA@
	DD	FLAT:??_C@_0O@COBIIGAD@linecache?4pyc?$AA@
	DD	FLAT:??_C@_0L@HJCEJGHC@ntpath?4pyc?$AA@
	DD	FLAT:??_C@_06JCOFDJKA@os?4pyc?$AA@
	DD	FLAT:??_C@_08FPFMJPEC@site?4pyc?$AA@
	DD	FLAT:??_C@_08EFIONJOP@stat?4pyc?$AA@
	DD	FLAT:??_C@_0L@NDKNFNNI@string?4pyc?$AA@
	DD	FLAT:??_C@_0O@PMKHJGGH@traceback?4pyc?$AA@
	DD	FLAT:??_C@_09EHIBBABK@types?4pyc?$AA@
	DD	FLAT:??_C@_01EEMJAFIK@?6?$AA@
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator--
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z ; string_join<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?Setup@@YAHPAD@Z				; Setup
PUBLIC	_WinMain@16
PUBLIC	?__IsLocaleVersion@@YA_NPAD@Z			; __IsLocaleVersion
PUBLIC	?__IsLocaleOption@@YA_NPAD@Z			; __IsLocaleOption
PUBLIC	?__PrintTimeStamp@@YAXXZ			; __PrintTimeStamp
PUBLIC	?__IsTimeStampOption@@YA_NPAD@Z			; __IsTimeStampOption
PUBLIC	?__ErrorPythonLibraryIsNotExist@@YAXXZ		; __ErrorPythonLibraryIsNotExist
PUBLIC	?Main@@YA_NPAUHINSTANCE__@@PAD@Z		; Main
PUBLIC	?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z	; RunMainScript
PUBLIC	?PackInitialize@@YA_NPBD@Z			; PackInitialize
PUBLIC	?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KPBD@Z ; ApplicationStringTable_GetString
PUBLIC	?ApplicationStringTable_Initialize@@YAXPAUHINSTANCE__@@@Z ; ApplicationStringTable_Initialize
PUBLIC	??1ApplicationStringTable@@QAE@XZ		; ApplicationStringTable::~ApplicationStringTable
PUBLIC	??0ApplicationStringTable@@QAE@XZ		; ApplicationStringTable::ApplicationStringTable
PUBLIC	?CheckPythonLibraryFilenames@@YA_NXZ		; CheckPythonLibraryFilenames
PUBLIC	?METIN2_GET_VERSION@@YAHXZ			; METIN2_GET_VERSION
PUBLIC	?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; ApplicationStringTable_GetString
PUBLIC	?ApplicationStringTable_GetStringz@@YAPBDKPBD@Z	; ApplicationStringTable_GetStringz
PUBLIC	__AVOID_FLOATING_POINT_LIBRARY_BUG
PUBLIC	?gs_kAppStrTable@@3UApplicationStringTable@@A	; gs_kAppStrTable
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
	ALIGN	4

__AVOID_FLOATING_POINT_LIBRARY_BUG DD 01H DUP (?)
?gs_kAppStrTable@@3UApplicationStringTable@@A DB 0cH DUP (?) ; gs_kAppStrTable
_BSS	ENDS
;	COMDAT ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA
_BSS	SEGMENT
?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA DD 01H DUP (?) ; S1<`template-parameter-10',in,A_NPAUHINSTANCE__,char *>
_BSS	ENDS
;	COMDAT ?lzo@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4VCLZO@@A
_BSS	SEGMENT
?lzo@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4VCLZO@@A DQ 01H DUP (?) ; `Main'::`10'::lzo
_BSS	ENDS
;	COMDAT ?EterPackManager@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4VCEterPackManager@@A
_BSS	SEGMENT
?EterPackManager@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4VCEterPackManager@@A DB 01478H DUP (?) ; `Main'::`10'::EterPackManager
_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CheckPythonLibraryFilenames@@YA_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckPythonLibraryFilenames@@YA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CheckPythonLibraryFilenames@@YA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckPythonLibraryFilenames@@YA_NXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?PackInitialize@@YA_NPBD@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?PackInitialize@@YA_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?PackInitialize@@YA_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PackInitialize@@YA_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PackInitialize@@YA_NPBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PackInitialize@@YA_NPBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PackInitialize@@YA_NPBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?PackInitialize@@YA_NPBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?PackInitialize@@YA_NPBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?PackInitialize@@YA_NPBD@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?PackInitialize@@YA_NPBD@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Main@@YA_NPAUHINSTANCE__@@PAD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Main@@YA_NPAUHINSTANCE__@@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Main@@YA_NPAUHINSTANCE__@@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z$0
	DD	00H
	DD	00H
	ORG $-96
__AVOID_FLOATING_POINT_LIBRARY_BUG$initializer$ DD FLAT:??__E_AVOID_FLOATING_POINT_LIBRARY_BUG@@YAXXZ
_gs_kAppStrTable$initializer$ DD FLAT:??__Egs_kAppStrTable@@YAXXZ
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?ApplicationStringTable_GetStringz@@YAPBDKPBD@Z
_TEXT	SEGMENT
?ApplicationStringTable_GetStringz@@YAPBDKPBD@Z PROC	; ApplicationStringTable_GetStringz, COMDAT
; _dwID$ = ecx
; _szKey$ = edx

; 150  : 	return ApplicationStringTable_GetString(dwID, szKey).c_str();

  00000	e8 00 00 00 00	 call	 ?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KPBD@Z ; ApplicationStringTable_GetString
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00005	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00009	72 02		 jb	 SHORT $LN8@Applicatio
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 150  : 	return ApplicationStringTable_GetString(dwID, szKey).c_str();

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN8@Applicatio:

; 151  : }

  0000d	c3		 ret	 0
?ApplicationStringTable_GetStringz@@YAPBDKPBD@Z ENDP	; ApplicationStringTable_GetStringz
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
_TEXT	SEGMENT
_dwID$ = -520						; size = 4
_szBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z PROC ; ApplicationStringTable_GetString, COMDAT
; _dwID$dead$ = ecx

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 139  : 	char szBuffer[512];
; 140  : 
; 141  : 	LoadString(gs_kAppStrTable.m_hInstance, dwID, szBuffer, sizeof(szBuffer)-1);

  00014	68 ff 01 00 00	 push	 511			; 000001ffH
  00019	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0001f	c7 85 f8 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _dwID$[ebp], 2
  00029	50		 push	 eax
  0002a	6a 02		 push	 2
  0002c	ff 35 00 00 00
	00		 push	 DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadStringA@16

; 142  : 	std::string& rstLocale=gs_kAppStrTable.m_kMap_dwID_stLocale[dwID];

  00038	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _dwID$[ebp]
  0003e	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_kAppStrTable@@3UApplicationStringTable@@A+4
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABK@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00049	80 bd fc fd ff
	ff 00		 cmp	 BYTE PTR _szBuffer$[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 142  : 	std::string& rstLocale=gs_kAppStrTable.m_kMap_dwID_stLocale[dwID];

  00050	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00052	75 04		 jne	 SHORT $LN9@Applicatio
  00054	33 c9		 xor	 ecx, ecx
  00056	eb 12		 jmp	 SHORT $LN10@Applicatio
$LN9@Applicatio:
  00058	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
  0005e	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL11@Applicatio:
  00061	8a 01		 mov	 al, BYTE PTR [ecx]
  00063	41		 inc	 ecx
  00064	84 c0		 test	 al, al
  00066	75 f9		 jne	 SHORT $LL11@Applicatio
  00068	2b ca		 sub	 ecx, edx
$LN10@Applicatio:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0006a	51		 push	 ecx
  0006b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00071	8b ce		 mov	 ecx, esi
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 146  : }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	8b c6		 mov	 eax, esi
  0007e	33 cd		 xor	 ecx, ebp
  00080	5e		 pop	 esi
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ENDP ; ApplicationStringTable_GetString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\version.h
;	COMDAT ?METIN2_GET_VERSION@@YAHXZ
_TEXT	SEGMENT
?METIN2_GET_VERSION@@YAHXZ PROC				; METIN2_GET_VERSION, COMDAT

; 3    : int METIN2_GET_VERSION() { return 28249; }

  00000	b8 59 6e 00 00	 mov	 eax, 28249		; 00006e59H
  00005	c3		 ret	 0
?METIN2_GET_VERSION@@YAHXZ ENDP				; METIN2_GET_VERSION
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ??__E_AVOID_FLOATING_POINT_LIBRARY_BUG@@YAXXZ
text$di	SEGMENT
??__E_AVOID_FLOATING_POINT_LIBRARY_BUG@@YAXXZ PROC	; `dynamic initializer for '_AVOID_FLOATING_POINT_LIBRARY_BUG'', COMDAT

; 25   : volatile int _AVOID_FLOATING_POINT_LIBRARY_BUG = _fltused;  

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __fltused
  00005	a3 00 00 00 00	 mov	 DWORD PTR __AVOID_FLOATING_POINT_LIBRARY_BUG, eax
  0000a	c3		 ret	 0
??__E_AVOID_FLOATING_POINT_LIBRARY_BUG@@YAXXZ ENDP	; `dynamic initializer for '_AVOID_FLOATING_POINT_LIBRARY_BUG''
text$di	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?CheckPythonLibraryFilenames@@YA_NXZ
_TEXT	SEGMENT
_stFilename$2 = -44					; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?CheckPythonLibraryFilenames@@YA_NXZ PROC		; CheckPythonLibraryFilenames, COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?CheckPythonLibraryFilenames@@YA_NXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 20	 sub	 esp, 32			; 00000020H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 18	 mov	 DWORD PTR __$ArrayPad$[esp+44], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 44 24 30	 lea	 eax, DWORD PTR __$EHRec$[esp+60]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 82   : 	for (int i = 0; *sc_apszPythonLibraryFilenames[i] != '\n'; ++i)

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _sc_apszPythonLibraryFilenames
  0003c	33 ff		 xor	 edi, edi
  0003e	80 38 0a	 cmp	 BYTE PTR [eax], 10	; 0000000aH
  00041	0f 84 c8 00 00
	00		 je	 $LN2@CheckPytho
  00047	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MoveFileA@8
  0004d	be 00 00 00 00	 mov	 esi, OFFSET _sc_apszPythonLibraryFilenames
$LL4@CheckPytho:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00052	6a 04		 push	 4
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_04HOGMCHDB@lib?2?$AA@
  00059	8d 4c 24 18	 lea	 ecx, DWORD PTR _stFilename$2[esp+68]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0005d	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR _stFilename$2[esp+88], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00065	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _stFilename$2[esp+84], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0006d	c6 44 24 18 00	 mov	 BYTE PTR _stFilename$2[esp+68], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00072	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 84   : 		std::string stFilename = "lib\\";

  00077	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+68], 0

; 85   : 		stFilename += sc_apszPythonLibraryFilenames[i];

  0007f	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00081	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00084	75 04		 jne	 SHORT $LN58@CheckPytho
  00086	33 c0		 xor	 eax, eax
  00088	eb 0f		 jmp	 SHORT $LN59@CheckPytho
$LN58@CheckPytho:
  0008a	8b c2		 mov	 eax, edx
  0008c	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0008f	90		 npad	 1
$LL153@CheckPytho:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $LL153@CheckPytho
  00097	2b c6		 sub	 eax, esi
$LN59@CheckPytho:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00099	50		 push	 eax
  0009a	52		 push	 edx
  0009b	8d 4c 24 18	 lea	 ecx, DWORD PTR _stFilename$2[esp+68]
  0009f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 520  : 			: this->_Bx._Buf);

  000a4	83 7c 24 24 10	 cmp	 DWORD PTR _stFilename$2[esp+80], 16 ; 00000010H
  000a9	8d 44 24 10	 lea	 eax, DWORD PTR _stFilename$2[esp+60]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 87   : 		if (_access(stFilename.c_str(), 0) != 0)

  000ad	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000af	0f 43 44 24 14	 cmovae	 eax, DWORD PTR _stFilename$2[esp+64]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 87   : 		if (_access(stFilename.c_str(), 0) != 0)

  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 __access
  000ba	83 c4 08	 add	 esp, 8
  000bd	85 c0		 test	 eax, eax
  000bf	75 6e		 jne	 SHORT $LN149@CheckPytho
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000c1	83 7c 24 24 10	 cmp	 DWORD PTR _stFilename$2[esp+80], 16 ; 00000010H
  000c6	8d 74 24 10	 lea	 esi, DWORD PTR _stFilename$2[esp+60]
  000ca	8d 4c 24 10	 lea	 ecx, DWORD PTR _stFilename$2[esp+60]
  000ce	0f 43 74 24 10	 cmovae	 esi, DWORD PTR _stFilename$2[esp+60]
  000d3	0f 43 4c 24 10	 cmovae	 ecx, DWORD PTR _stFilename$2[esp+60]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 92   : 		MoveFile(stFilename.c_str(), stFilename.c_str());

  000d8	56		 push	 esi
  000d9	51		 push	 ecx
  000da	ff d3		 call	 ebx

; 93   : 	}

  000dc	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+68], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000e4	83 7c 24 24 10	 cmp	 DWORD PTR _stFilename$2[esp+80], 16 ; 00000010H
  000e9	72 0c		 jb	 SHORT $LN136@CheckPytho
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000eb	ff 74 24 10	 push	 DWORD PTR _stFilename$2[esp+60]
  000ef	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f4	83 c4 04	 add	 esp, 4
$LN136@CheckPytho:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 82   : 	for (int i = 0; *sc_apszPythonLibraryFilenames[i] != '\n'; ++i)

  000f7	47		 inc	 edi
  000f8	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR _sc_apszPythonLibraryFilenames[edi*4]
  000ff	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR _sc_apszPythonLibraryFilenames[edi*4]
  00106	80 38 0a	 cmp	 BYTE PTR [eax], 10	; 0000000aH
  00109	0f 85 43 ff ff
	ff		 jne	 $LL4@CheckPytho
$LN2@CheckPytho:

; 94   : 
; 95   : 	return true;

  0010f	b0 01		 mov	 al, 1
$LN5@CheckPytho:

; 96   : }

  00111	8b 4c 24 30	 mov	 ecx, DWORD PTR __$EHRec$[esp+60]
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011c	59		 pop	 ecx
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+44]
  00124	33 cc		 xor	 ecx, esp
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
$LN149@CheckPytho:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0012f	83 7c 24 24 10	 cmp	 DWORD PTR _stFilename$2[esp+80], 16 ; 00000010H
  00134	72 0c		 jb	 SHORT $LN88@CheckPytho
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00136	ff 74 24 10	 push	 DWORD PTR _stFilename$2[esp+60]
  0013a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0013f	83 c4 04	 add	 esp, 4
$LN88@CheckPytho:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 89   : 			return false;

  00142	32 c0		 xor	 al, al
  00144	eb cb		 jmp	 SHORT $LN5@CheckPytho
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckPythonLibraryFilenames@@YA_NXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _stFilename$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?CheckPythonLibraryFilenames@@YA_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 d4	 lea	 eax, DWORD PTR [edx-44]
  0000f	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckPythonLibraryFilenames@@YA_NXZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckPythonLibraryFilenames@@YA_NXZ ENDP		; CheckPythonLibraryFilenames
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ??__Egs_kAppStrTable@@YAXXZ
text$di	SEGMENT
??__Egs_kAppStrTable@@YAXXZ PROC			; `dynamic initializer for 'gs_kAppStrTable'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  00000	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_kAppStrTable@@3UApplicationStringTable@@A+4
  00005	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Buyheadnode
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 102  : } gs_kAppStrTable;

  0000a	68 00 00 00 00	 push	 OFFSET ??__Fgs_kAppStrTable@@YAXXZ ; `dynamic atexit destructor for 'gs_kAppStrTable''
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  0000f	a3 04 00 00 00	 mov	 DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A+4, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 102  : } gs_kAppStrTable;

  00014	e8 00 00 00 00	 call	 _atexit
  00019	59		 pop	 ecx
  0001a	c3		 ret	 0
??__Egs_kAppStrTable@@YAXXZ ENDP			; `dynamic initializer for 'gs_kAppStrTable''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__Fgs_kAppStrTable@@YAXXZ
text$yd	SEGMENT
$T1 = -8						; size = 4
$T2 = -1						; size = 1
$T3 = -1						; size = 1
$T4 = -1						; size = 1
$T5 = -1						; size = 1
??__Fgs_kAppStrTable@@YAXXZ PROC			; `dynamic atexit destructor for 'gs_kAppStrTable'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00003	a1 04 00 00 00	 mov	 eax, DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A+4
  00008	83 ec 08	 sub	 esp, 8
  0000b	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_kAppStrTable@@3UApplicationStringTable@@A+4
  00010	56		 push	 esi
  00011	50		 push	 eax
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();
; 774  : 		}
; 775  : 
; 776  : 	~_Tree_alloc() _NOEXCEPT
; 777  : 		{	// destroy head node
; 778  : 		_Freeheadnode(this->_Myhead);

  0001d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A+4

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  00023	8d 4d ff	 lea	 ecx, DWORD PTR $T5[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 779  : 		}
; 780  : 
; 781  : 	void _Change_alloc(const _Alty&)
; 782  : 		{	// replace old allocator
; 783  : 		}
; 784  : 
; 785  : 	void _Swap_alloc(_Myt&)
; 786  : 		{	// swap allocators
; 787  : 		}
; 788  : 
; 789  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 790  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 791  : 		{	// construct allocators from _Al
; 792  : 		this->_Myhead = _Buyheadnode();
; 793  : 		_TRY_BEGIN
; 794  : 		_Alloc_proxy();
; 795  : 		_CATCH_ALL
; 796  : 		_Freeheadnode(this->_Myhead);
; 797  : 		_RERAISE;
; 798  : 		_CATCH_END
; 799  : 		}
; 800  : 
; 801  : 	~_Tree_alloc() _NOEXCEPT
; 802  : 		{	// destroy proxy
; 803  : 		_Freeheadnode(this->_Myhead);
; 804  : 		_Free_proxy();
; 805  : 		}
; 806  : 
; 807  : 	void _Change_alloc(const _Alty&)
; 808  : 		{	// replace old allocator
; 809  : 		}
; 810  : 
; 811  : 	void _Swap_alloc(_Myt&)
; 812  : 		{	// swap allocators
; 813  : 		}
; 814  : 
; 815  : 	void _Alloc_proxy()
; 816  : 		{	// construct proxy from _Alnod
; 817  : 		typename _Alty::template rebind<_Container_proxy>::other
; 818  : 			_Alproxy(_Getal());
; 819  : 		this->_Myproxy = _Alproxy.allocate(1);
; 820  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 821  : 		this->_Myproxy->_Mycont = this;
; 822  : 		}
; 823  : 
; 824  : 	void _Free_proxy()
; 825  : 		{	// destroy proxy
; 826  : 		typename _Alty::template rebind<_Container_proxy>::other
; 827  : 			_Alproxy(_Getal());
; 828  : 		this->_Orphan_all();
; 829  : 		_Alproxy.destroy(this->_Myproxy);
; 830  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 831  : 		this->_Myproxy = 0;
; 832  : 		}
; 833  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 834  : 
; 835  : 	_Nodeptr _Buyheadnode()
; 836  : 		{	// get head node using current allocator
; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 838  : 
; 839  : 		_TRY_BEGIN
; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);
; 848  : 		_RERAISE;
; 849  : 		_CATCH_END
; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;
; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}
; 855  : 
; 856  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 857  : 		{	// free head node using current allocator
; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));

  0002b	56		 push	 esi
  0002c	8d 4d ff	 lea	 ecx, DWORD PTR $T5[ebp]
  0002f	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  00034	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00037	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0003c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));

  0003f	50		 push	 eax
  00040	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  00048	8d 4d ff	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00050	8d 46 08	 lea	 eax, DWORD PTR [esi+8]

; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));

  00053	50		 push	 eax
  00054	8d 4d ff	 lea	 ecx, DWORD PTR $T4[ebp]
  00057	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  0005c	8d 4d ff	 lea	 ecx, DWORD PTR $T3[ebp]
  0005f	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00064	56		 push	 esi
  00065	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006a	83 c4 04	 add	 esp, 4
  0006d	5e		 pop	 esi
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
??__Fgs_kAppStrTable@@YAXXZ ENDP			; `dynamic atexit destructor for 'gs_kAppStrTable''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0ApplicationStringTable@@QAE@XZ
_TEXT	SEGMENT
??0ApplicationStringTable@@QAE@XZ PROC			; ApplicationStringTable::ApplicationStringTable, COMDAT
; _this$dead$ = ecx

; 773  : 		this->_Myhead = _Buyheadnode();

  00000	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_kAppStrTable@@3UApplicationStringTable@@A+4

; 569  : 		this->_Myhead = 0;

  00005	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A+4, 0

; 570  : 		this->_Mysize = 0;

  0000f	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A+8, 0

; 773  : 		this->_Myhead = _Buyheadnode();

  00019	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Buyheadnode
  0001e	a3 04 00 00 00	 mov	 DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A+4, eax
  00023	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_kAppStrTable@@3UApplicationStringTable@@A ; gs_kAppStrTable
  00028	c3		 ret	 0
??0ApplicationStringTable@@QAE@XZ ENDP			; ApplicationStringTable::ApplicationStringTable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1ApplicationStringTable@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1ApplicationStringTable@@QAE@XZ PROC			; ApplicationStringTable::~ApplicationStringTable, COMDAT
; _this$dead$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00004	a1 04 00 00 00	 mov	 eax, DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A+4
  00009	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_kAppStrTable@@3UApplicationStringTable@@A+4
  0000e	50		 push	 eax
  0000f	ff 30		 push	 DWORD PTR [eax]
  00011	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001a	ff 35 04 00 00
	00		 push	 DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A+4
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??1ApplicationStringTable@@QAE@XZ ENDP			; ApplicationStringTable::~ApplicationStringTable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?ApplicationStringTable_Initialize@@YAXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
?ApplicationStringTable_Initialize@@YAXPAUHINSTANCE__@@@Z PROC ; ApplicationStringTable_Initialize, COMDAT
; _hInstance$ = ecx

; 106  : 	gs_kAppStrTable.m_hInstance=hInstance;

  00000	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A, ecx

; 107  : }

  00006	c3		 ret	 0
?ApplicationStringTable_Initialize@@YAXPAUHINSTANCE__@@@Z ENDP ; ApplicationStringTable_Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KPBD@Z
_TEXT	SEGMENT
_dwID$ = -1032						; size = 4
_szLocale$ = -1028					; size = 256
_szBuffer$ = -772					; size = 512
_szIniFileName$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KPBD@Z PROC ; ApplicationStringTable_GetString, COMDAT
; _dwID$ = ecx
; _szKey$ = edx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi

; 111  : 	char szBuffer[512];
; 112  : 	char szIniFileName[256];
; 113  : 	char szLocale[256];
; 114  : 
; 115  : 	::GetCurrentDirectory(sizeof(szIniFileName), szIniFileName);

  00015	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szIniFileName$[ebp]
  0001b	89 8d f8 fb ff
	ff		 mov	 DWORD PTR _dwID$[ebp], ecx
  00021	50		 push	 eax
  00022	68 00 01 00 00	 push	 256			; 00000100H
  00027	8b f2		 mov	 esi, edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentDirectoryA@8

; 116  : 	if(szIniFileName[lstrlen(szIniFileName)-1] != '\\')

  0002f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szIniFileName$[ebp]
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0003c	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szIniFileName$[ebp]
  00042	80 7c 08 ff 5c	 cmp	 BYTE PTR [eax+ecx-1], 92 ; 0000005cH
  00047	74 1a		 je	 SHORT $LN5@Applicatio

; 117  : 		strcat(szIniFileName, "\\");

  00049	8b f9		 mov	 edi, ecx
  0004b	4f		 dec	 edi
  0004c	8d 64 24 00	 npad	 4
$LL28@Applicatio:
  00050	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00053	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00056	84 c0		 test	 al, al
  00058	75 f6		 jne	 SHORT $LL28@Applicatio
  0005a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
  00060	66 89 07	 mov	 WORD PTR [edi], ax
$LN5@Applicatio:

; 118  : 	strcat(szIniFileName, "metin2client.dat");

  00063	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szIniFileName$[ebp]
  00069	49		 dec	 ecx
  0006a	8d 9b 00 00 00
	00		 npad	 6
$LL29@Applicatio:
  00070	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00073	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00076	84 c0		 test	 al, al
  00078	75 f6		 jne	 SHORT $LL29@Applicatio
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BB@FPBAACEA@metin2client?4dat?$AA@
  0007f	89 01		 mov	 DWORD PTR [ecx], eax
  00081	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BB@FPBAACEA@metin2client?4dat?$AA@+4
  00086	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00089	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BB@FPBAACEA@metin2client?4dat?$AA@+8
  0008e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00091	a1 0c 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BB@FPBAACEA@metin2client?4dat?$AA@+12
  00096	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00099	a0 10 00 00 00	 mov	 al, BYTE PTR ??_C@_0BB@FPBAACEA@metin2client?4dat?$AA@+16
  0009e	53		 push	 ebx
  0009f	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 119  : 
; 120  : 	strcpy(szLocale, LocaleService_GetLocalePath());

  000a2	e8 00 00 00 00	 call	 ?LocaleService_GetLocalePath@@YAPBDXZ ; LocaleService_GetLocalePath
  000a7	8b d8		 mov	 ebx, eax
  000a9	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _szLocale$[ebp]
  000af	8b d3		 mov	 edx, ebx
  000b1	2b fb		 sub	 edi, ebx
$LL8@Applicatio:
  000b3	8a 0a		 mov	 cl, BYTE PTR [edx]
  000b5	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000b8	88 4c 17 ff	 mov	 BYTE PTR [edi+edx-1], cl
  000bc	84 c9		 test	 cl, cl
  000be	75 f3		 jne	 SHORT $LL8@Applicatio

; 121  : 	if(strnicmp(szLocale, "locale/", strlen("locale/")) == 0)

  000c0	6a 07		 push	 7
  000c2	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szLocale$[ebp]
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_07GHKFPDHK@locale?1?$AA@
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 __strnicmp
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	85 c0		 test	 eax, eax
  000d8	75 18		 jne	 SHORT $LN4@Applicatio

; 122  : 		strcpy(szLocale, LocaleService_GetLocalePath() + strlen("locale/"));

  000da	8d 4b 07	 lea	 ecx, DWORD PTR [ebx+7]
  000dd	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _szLocale$[ebp]
  000e3	2b d1		 sub	 edx, ecx
$LL9@Applicatio:
  000e5	8a 01		 mov	 al, BYTE PTR [ecx]
  000e7	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000ea	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  000ee	84 c0		 test	 al, al
  000f0	75 f3		 jne	 SHORT $LL9@Applicatio
$LN4@Applicatio:

; 123  : 	::GetPrivateProfileString(szLocale, szKey, NULL, szBuffer, sizeof(szBuffer)-1, szIniFileName);

  000f2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetPrivateProfileStringA@24
  000f8	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szIniFileName$[ebp]
  000fe	50		 push	 eax
  000ff	68 ff 01 00 00	 push	 511			; 000001ffH
  00104	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0010a	50		 push	 eax
  0010b	6a 00		 push	 0
  0010d	56		 push	 esi
  0010e	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szLocale$[ebp]
  00114	50		 push	 eax
  00115	ff d7		 call	 edi

; 124  : 	if(szBuffer[0] == '\0')

  00117	80 bd fc fc ff
	ff 00		 cmp	 BYTE PTR _szBuffer$[ebp], 0
  0011e	5b		 pop	 ebx
  0011f	75 62		 jne	 SHORT $LN1@Applicatio

; 125  : 		LoadString(gs_kAppStrTable.m_hInstance, dwID, szBuffer, sizeof(szBuffer)-1);

  00121	68 ff 01 00 00	 push	 511			; 000001ffH
  00126	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0012c	50		 push	 eax
  0012d	ff b5 f8 fb ff
	ff		 push	 DWORD PTR _dwID$[ebp]
  00133	ff 35 00 00 00
	00		 push	 DWORD PTR ?gs_kAppStrTable@@3UApplicationStringTable@@A
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadStringA@16

; 126  : 	if(szBuffer[0] == '\0')

  0013f	80 bd fc fc ff
	ff 00		 cmp	 BYTE PTR _szBuffer$[ebp], 0
  00146	75 3b		 jne	 SHORT $LN1@Applicatio

; 127  : 		::GetPrivateProfileString("en", szKey, NULL, szBuffer, sizeof(szBuffer)-1, szIniFileName);

  00148	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szIniFileName$[ebp]
  0014e	50		 push	 eax
  0014f	68 ff 01 00 00	 push	 511			; 000001ffH
  00154	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0015a	50		 push	 eax
  0015b	6a 00		 push	 0
  0015d	56		 push	 esi
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_02LFNMGJAP@en?$AA@
  00163	ff d7		 call	 edi

; 128  : 	if(szBuffer[0] == '\0')

  00165	80 bd fc fc ff
	ff 00		 cmp	 BYTE PTR _szBuffer$[ebp], 0
  0016c	75 15		 jne	 SHORT $LN1@Applicatio

; 129  : 		strcpy(szBuffer, szKey);

  0016e	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
  00174	2b ce		 sub	 ecx, esi
$LL10@Applicatio:
  00176	8a 06		 mov	 al, BYTE PTR [esi]
  00178	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0017b	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  0017f	84 c0		 test	 al, al
  00181	75 f3		 jne	 SHORT $LL10@Applicatio
$LN1@Applicatio:

; 131  : 	std::string& rstLocale=gs_kAppStrTable.m_kMap_dwID_stLocale[dwID];

  00183	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dwID$[ebp]
  00189	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_kAppStrTable@@3UApplicationStringTable@@A+4
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ??A?$map@KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@K@2@V?$allocator@U?$pair@$$CBKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABK@Z ; std::map<unsigned long,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00194	80 bd fc fc ff
	ff 00		 cmp	 BYTE PTR _szBuffer$[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 131  : 	std::string& rstLocale=gs_kAppStrTable.m_kMap_dwID_stLocale[dwID];

  0019b	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0019d	75 04		 jne	 SHORT $LN17@Applicatio
  0019f	33 c9		 xor	 ecx, ecx
  001a1	eb 16		 jmp	 SHORT $LN18@Applicatio
$LN17@Applicatio:
  001a3	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
  001a9	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  001ac	8d 64 24 00	 npad	 4
$LL30@Applicatio:
  001b0	8a 01		 mov	 al, BYTE PTR [ecx]
  001b2	41		 inc	 ecx
  001b3	84 c0		 test	 al, al
  001b5	75 f9		 jne	 SHORT $LL30@Applicatio
  001b7	2b ca		 sub	 ecx, edx
$LN18@Applicatio:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  001b9	51		 push	 ecx
  001ba	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  001c0	8b ce		 mov	 ecx, esi
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 135  : }

  001c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cb	8b c6		 mov	 eax, esi
  001cd	5f		 pop	 edi
  001ce	33 cd		 xor	 ecx, ebp
  001d0	5e		 pop	 esi
  001d1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d6	8b e5		 mov	 esp, ebp
  001d8	5d		 pop	 ebp
  001d9	c3		 ret	 0
?ApplicationStringTable_GetString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KPBD@Z ENDP ; ApplicationStringTable_GetString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?PackInitialize@@YA_NPBD@Z
_TEXT	SEGMENT
_TextLoader$ = -508					; size = 16
_pvData$ = -492						; size = 4
_file$ = -488						; size = 324
$T2 = -160						; size = 24
_stFolder$ = -136					; size = 24
$T3 = -112						; size = 24
$T4 = -112						; size = 24
$T5 = -112						; size = 24
_strTexCachePackName$ = -88				; size = 24
_strPackName$ = -64					; size = 24
_stFileName$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PackInitialize@@YA_NPBD@Z PROC				; PackInitialize, COMDAT
; _c_pszFolder$dead$ = ecx

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PackInitialize@@YA_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f4 01 00
	00		 sub	 esp, 500		; 000001f4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 164  : 	NANOBEGIN

  0002e	eb		 DB	 -21			; ffffffebH
  0002f	03		 DB	 3
  00030	d6		 DB	 -42			; ffffffd6H
  00031	d7		 DB	 -41			; ffffffd7H
  00032	01		 DB	 1

; 165  : 	if (_access(c_pszFolder, 0) != 0)

  00033	6a 00		 push	 0
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_04IPANLPFO@pack?$AA@
  0003a	e8 00 00 00 00	 call	 __access
  0003f	83 c4 08	 add	 esp, 8
  00042	85 c0		 test	 eax, eax
  00044	74 07		 je	 SHORT $LN6@PackInitia

; 166  : 		return true;

  00046	b0 01		 mov	 al, 1
  00048	e9 43 04 00 00	 jmp	 $LN7@PackInitia
$LN6@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0004d	6a 04		 push	 4
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_04IPANLPFO@pack?$AA@
  00054	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _stFolder$[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0005a	c7 45 8c 0f 00
	00 00		 mov	 DWORD PTR _stFolder$[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00061	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _stFolder$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00068	c6 85 78 ff ff
	ff 00		 mov	 BYTE PTR _stFolder$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00074	6a 01		 push	 1
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1?$AA@
  0007b	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _stFolder$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 168  : 	std::string stFolder(c_pszFolder);

  00081	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00088	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 726  : 		assign(_Right, 0, npos);

  0008d	6a ff		 push	 -1
  0008f	6a 00		 push	 0
  00091	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _stFolder$[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00097	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stFileName$[ebp+20], 15 ; 0000000fH

; 726  : 		assign(_Right, 0, npos);

  0009e	50		 push	 eax
  0009f	8d 4d d8	 lea	 ecx, DWORD PTR _stFileName$[ebp]

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000a2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stFileName$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000a9	c6 45 d8 00	 mov	 BYTE PTR _stFileName$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  000ad	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  000b2	6a 05		 push	 5
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_05FNNGFGLF@Index?$AA@
  000b9	8d 4d d8	 lea	 ecx, DWORD PTR _stFileName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 171  : 	std::string stFileName(stFolder);

  000bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  000c0	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 174  : 	CMappedFile file;

  000c5	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  000cb	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 177  : 	if (!file.Create(stFileName.c_str(), &pvData, 0, 0))

  000d0	6a 00		 push	 0
  000d2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000d6	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR _pvData$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000dc	83 7d ec 10	 cmp	 DWORD PTR _stFileName$[ebp+20], 16 ; 00000010H
  000e0	8d 45 d8	 lea	 eax, DWORD PTR _stFileName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 177  : 	if (!file.Create(stFileName.c_str(), &pvData, 0, 0))

  000e3	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000e5	0f 43 45 d8	 cmovae	 eax, DWORD PTR _stFileName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 177  : 	if (!file.Create(stFileName.c_str(), &pvData, 0, 0))

  000e9	51		 push	 ecx
  000ea	50		 push	 eax
  000eb	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  000f1	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  000f6	85 c0		 test	 eax, eax
  000f8	75 36		 jne	 SHORT $LN5@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000fa	83 7d ec 10	 cmp	 DWORD PTR _stFileName$[ebp+20], 16 ; 00000010H
  000fe	8d 45 d8	 lea	 eax, DWORD PTR _stFileName$[ebp]
  00101	0f 43 45 d8	 cmovae	 eax, DWORD PTR _stFileName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 179  : 		LogBoxf("FATAL ERROR! File not exist: %s", stFileName.c_str());

  00105	50		 push	 eax
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@PJKENNIH@FATAL?5ERROR?$CB?5File?5not?5exist?3?5?$CFs?$AA@
  0010b	e8 00 00 00 00	 call	 ?LogBoxf@@YAXPBDZZ	; LogBoxf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00110	83 7d ec 10	 cmp	 DWORD PTR _stFileName$[ebp+20], 16 ; 00000010H
  00114	8d 45 d8	 lea	 eax, DWORD PTR _stFileName$[ebp]
  00117	0f 43 45 d8	 cmovae	 eax, DWORD PTR _stFileName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 180  : 		TraceError("FATAL ERROR! File not exist: %s", stFileName.c_str());

  0011b	50		 push	 eax
  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@PJKENNIH@FATAL?5ERROR?$CB?5File?5not?5exist?3?5?$CFs?$AA@
  00121	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00126	83 c4 10	 add	 esp, 16			; 00000010H
  00129	b3 01		 mov	 bl, 1
  0012b	e9 18 03 00 00	 jmp	 $LN19@PackInitia
$LN5@PackInitia:

; 181  : 		return true;
; 182  : 	}
; 183  : 
; 184  : 	CMemoryTextFileLoader TextLoader;

  00130	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  00136	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader
  0013b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 185  : 	TextLoader.Bind(file.Size(), pvData);

  0013f	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00145	ff b5 14 fe ff
	ff		 push	 DWORD PTR _pvData$[ebp]
  0014b	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  00150	50		 push	 eax
  00151	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  00157	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind

; 186  : 
; 187  : 	bool bPackFirst = TRUE;
; 188  : 
; 189  : 	const std::string& strPackType = TextLoader.GetLineString(0);

  0015c	6a 00		 push	 0
  0015e	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  00164	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  00169	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  0016b	6a 04		 push	 4
  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_04PMPMHNFI@FILE?$AA@
  00172	8b ce		 mov	 ecx, esi
  00174	ff 76 10	 push	 DWORD PTR [esi+16]
  00177	6a 00		 push	 0
  00179	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 191  : 	if (strPackType.compare("FILE") && strPackType.compare("PACK"))

  0017e	85 c0		 test	 eax, eax
  00180	74 24		 je	 SHORT $LN4@PackInitia
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_04EDDHFNCG@PACK?$AA@
  00187	8b ce		 mov	 ecx, esi
  00189	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  0018e	85 c0		 test	 eax, eax
  00190	74 14		 je	 SHORT $LN4@PackInitia

; 192  : 	{
; 193  : 		TraceError("Pack/Index has invalid syntax. First line must be 'PACK' or 'FILE'");

  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@CBACJNDK@Pack?1Index?5has?5invalid?5syntax?4?5F@
  00197	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0019c	83 c4 04	 add	 esp, 4
  0019f	32 db		 xor	 bl, bl
  001a1	e9 93 02 00 00	 jmp	 $LN741@PackInitia
$LN4@PackInitia:

; 194  : 		return false;
; 195  : 	}
; 196  : 
; 197  : #ifdef _DISTRIBUTE
; 198  : 	Tracef(":  .\n");

  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FJMFFOHK@?$LO?K?$LI?$LC?3?5?F?Q?5?$LI?p?$LF?e?$MA?T?$LE?O?$LE?Y?4?6?$AA@
  001ab	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  001b0	83 c4 04	 add	 esp, 4

; 199  : 	
; 200  : 	//if (0 == strPackType.compare("FILE"))
; 201  : 	//{
; 202  : 	//	bPackFirst = FALSE;
; 203  : 	//	Tracef(":  .\n");
; 204  : 	//}
; 205  : 	//else
; 206  : 	//{
; 207  : 	//	Tracef(":  .\n");
; 208  : 	//}
; 209  : #else
; 210  : 	bPackFirst = FALSE;
; 211  : 	Tracef(":  .\n");
; 212  : #endif
; 213  : 
; 214  : 	CTextFileLoader::SetCacheMode();

  001b3	e8 00 00 00 00	 call	 ?SetCacheMode@CTextFileLoader@@SAXXZ ; CTextFileLoader::SetCacheMode

; 215  : #if defined(USE_RELATIVE_PATH)
; 216  : 	CEterPackManager::Instance().SetRelativePathMode();
; 217  : #endif
; 218  : 	CEterPackManager::Instance().SetCacheMode();

  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  001be	e8 00 00 00 00	 call	 ?SetCacheMode@CEterPackManager@@QAEXXZ ; CEterPackManager::SetCacheMode

; 219  : 	CEterPackManager::Instance().SetSearchMode(bPackFirst);

  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  001c9	6a 01		 push	 1
  001cb	e8 00 00 00 00	 call	 ?SetSearchMode@CEterPackManager@@QAEX_N@Z ; CEterPackManager::SetSearchMode

; 220  : 
; 221  : 	CSoundData::SetPackMode(); // Miles   

  001d0	e8 00 00 00 00	 call	 ?SetPackMode@CSoundData@@SAXXZ ; CSoundData::SetPackMode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  001d5	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPackName$[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001dc	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPackName$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001e3	c6 45 c0 00	 mov	 BYTE PTR _strPackName$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  001e7	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strTexCachePackName$[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001ee	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _strTexCachePackName$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001f5	c6 45 a8 00	 mov	 BYTE PTR _strTexCachePackName$[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 224  : 	for (DWORD i = 1; i < TextLoader.GetLineCount() - 1; i += 2)

  001f9	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  001ff	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00203	bb 01 00 00 00	 mov	 ebx, 1
  00208	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  0020d	48		 dec	 eax
  0020e	3b c3		 cmp	 eax, ebx
  00210	0f 86 3b 01 00
	00		 jbe	 $LN1@PackInitia
  00216	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL3@PackInitia:

; 225  : 	{
; 226  : 		const std::string & c_rstFolder = TextLoader.GetLineString(i);

  00220	53		 push	 ebx
  00221	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  00227	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  0022c	8b f0		 mov	 esi, eax

; 227  : 		const std::string & c_rstName = TextLoader.GetLineString(i + 1);

  0022e	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  00234	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString

; 228  : 
; 229  : 		strPackName = stFolder + c_rstName;

  0023d	50		 push	 eax
  0023e	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _stFolder$[ebp]
  00244	50		 push	 eax
  00245	8d 45 90	 lea	 eax, DWORD PTR $T5[ebp]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0024e	8b f8		 mov	 edi, eax
  00250	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 903  : 		if (this != &_Right)

  00253	8d 45 c0	 lea	 eax, DWORD PTR _strPackName$[ebp]
  00256	3b c7		 cmp	 eax, edi
  00258	74 2c		 je	 SHORT $LN233@PackInitia

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0025a	83 7d d4 10	 cmp	 DWORD PTR _strPackName$[ebp+20], 16 ; 00000010H
  0025e	72 0b		 jb	 SHORT $LN257@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00260	ff 75 c0	 push	 DWORD PTR _strPackName$[ebp]
  00263	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00268	83 c4 04	 add	 esp, 4
$LN257@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  0026b	57		 push	 edi
  0026c	8d 4d c0	 lea	 ecx, DWORD PTR _strPackName$[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0026f	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPackName$[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00276	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPackName$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0027d	c6 45 c0 00	 mov	 BYTE PTR _strPackName$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  00281	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN233@PackInitia:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00286	83 7d a4 10	 cmp	 DWORD PTR $T5[ebp+20], 16 ; 00000010H
  0028a	72 0b		 jb	 SHORT $LN367@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0028c	ff 75 90	 push	 DWORD PTR $T5[ebp]
  0028f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00294	83 c4 04	 add	 esp, 4
$LN367@PackInitia:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 230  : 		strTexCachePackName = strPackName + "_texcache";

  00297	68 00 00 00 00	 push	 OFFSET ??_C@_09ODEGJGJI@_texcache?$AA@
  0029c	8d 45 c0	 lea	 eax, DWORD PTR _strPackName$[ebp]
  0029f	50		 push	 eax
  002a0	8d 45 90	 lea	 eax, DWORD PTR $T4[ebp]
  002a3	50		 push	 eax
  002a4	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  002a9	8b f8		 mov	 edi, eax
  002ab	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 903  : 		if (this != &_Right)

  002ae	8d 45 a8	 lea	 eax, DWORD PTR _strTexCachePackName$[ebp]
  002b1	3b c7		 cmp	 eax, edi
  002b3	74 2c		 je	 SHORT $LN379@PackInitia

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  002b5	83 7d bc 10	 cmp	 DWORD PTR _strTexCachePackName$[ebp+20], 16 ; 00000010H
  002b9	72 0b		 jb	 SHORT $LN403@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  002bb	ff 75 a8	 push	 DWORD PTR _strTexCachePackName$[ebp]
  002be	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002c3	83 c4 04	 add	 esp, 4
$LN403@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  002c6	57		 push	 edi
  002c7	8d 4d a8	 lea	 ecx, DWORD PTR _strTexCachePackName$[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  002ca	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strTexCachePackName$[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  002d1	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _strTexCachePackName$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  002d8	c6 45 a8 00	 mov	 BYTE PTR _strTexCachePackName$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  002dc	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN379@PackInitia:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  002e1	83 7d a4 10	 cmp	 DWORD PTR $T4[ebp+20], 16 ; 00000010H
  002e5	72 0b		 jb	 SHORT $LN513@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  002e7	ff 75 90	 push	 DWORD PTR $T4[ebp]
  002ea	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002ef	83 c4 04	 add	 esp, 4
$LN513@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  002f2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  002f6	72 04		 jb	 SHORT $LN529@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  002f8	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  002fa	eb 02		 jmp	 SHORT $LN530@PackInitia
$LN529@PackInitia:
  002fc	8b ce		 mov	 ecx, esi
$LN530@PackInitia:
  002fe	83 7d d4 10	 cmp	 DWORD PTR _strPackName$[ebp+20], 16 ; 00000010H
  00302	8d 45 c0	 lea	 eax, DWORD PTR _strPackName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 232  : 		CEterPackManager::Instance().RegisterPack(strPackName.c_str(), c_rstFolder.c_str());

  00305	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00307	0f 43 45 c0	 cmovae	 eax, DWORD PTR _strPackName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 232  : 		CEterPackManager::Instance().RegisterPack(strPackName.c_str(), c_rstFolder.c_str());

  0030b	51		 push	 ecx
  0030c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 ?RegisterPack@CEterPackManager@@QAE_NPBD0PBE@Z ; CEterPackManager::RegisterPack
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00318	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0031c	72 02		 jb	 SHORT $LN548@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0031e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN548@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00320	83 7d bc 10	 cmp	 DWORD PTR _strTexCachePackName$[ebp+20], 16 ; 00000010H
  00324	8d 45 a8	 lea	 eax, DWORD PTR _strTexCachePackName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 233  : 		CEterPackManager::Instance().RegisterPack(strTexCachePackName.c_str(), c_rstFolder.c_str());

  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0032d	0f 43 45 a8	 cmovae	 eax, DWORD PTR _strTexCachePackName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 233  : 		CEterPackManager::Instance().RegisterPack(strTexCachePackName.c_str(), c_rstFolder.c_str());

  00331	6a 00		 push	 0
  00333	56		 push	 esi
  00334	50		 push	 eax
  00335	e8 00 00 00 00	 call	 ?RegisterPack@CEterPackManager@@QAE_NPBD0PBE@Z ; CEterPackManager::RegisterPack
  0033a	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  00340	83 c3 02	 add	 ebx, 2
  00343	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  00348	48		 dec	 eax
  00349	3b d8		 cmp	 ebx, eax
  0034b	0f 82 cf fe ff
	ff		 jb	 $LL3@PackInitia
$LN1@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00351	6a 04		 push	 4
  00353	68 00 00 00 00	 push	 OFFSET ??_C@_04NBFCGMPH@root?$AA@
  00358	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0035e	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00368	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00372	c6 85 60 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00379	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 236  : 	CEterPackManager::Instance().RegisterRootPack((stFolder + std::string("root")).c_str());

  0037e	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00384	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00388	50		 push	 eax
  00389	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _stFolder$[ebp]
  0038f	8d 4d 90	 lea	 ecx, DWORD PTR $T3[ebp]
  00392	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00397	83 c4 04	 add	 esp, 4
  0039a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0039e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  003a2	72 02		 jb	 SHORT $LN610@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  003a4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN610@PackInitia:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 236  : 	CEterPackManager::Instance().RegisterRootPack((stFolder + std::string("root")).c_str());

  003a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  003ac	50		 push	 eax
  003ad	e8 00 00 00 00	 call	 ?RegisterRootPack@CEterPackManager@@QAEXPBD@Z ; CEterPackManager::RegisterRootPack
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  003b2	83 7d a4 10	 cmp	 DWORD PTR $T3[ebp+20], 16 ; 00000010H
  003b6	72 0b		 jb	 SHORT $LN635@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  003b8	ff 75 90	 push	 DWORD PTR $T3[ebp]
  003bb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003c0	83 c4 04	 add	 esp, 4
$LN635@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  003c3	83 bd 74 ff ff
	ff 10		 cmp	 DWORD PTR $T2[ebp+20], 16 ; 00000010H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  003ca	c7 45 a4 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  003d1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  003d8	c6 45 90 00	 mov	 BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  003dc	72 0e		 jb	 SHORT $LN667@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  003de	ff b5 60 ff ff
	ff		 push	 DWORD PTR $T2[ebp]
  003e4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003e9	83 c4 04	 add	 esp, 4
$LN667@PackInitia:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 237  : 	NANOEND

  003ec	eb		 DB	 -21			; ffffffebH
  003ed	03		 DB	 3
  003ee	d6		 DB	 -42			; ffffffd6H
  003ef	d7		 DB	 -41			; ffffffd7H
  003f0	00		 DB	 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  003f1	83 7d bc 10	 cmp	 DWORD PTR _strTexCachePackName$[ebp+20], 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 238  : 	return true;

  003f5	b3 01		 mov	 bl, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  003f7	72 0b		 jb	 SHORT $LN699@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  003f9	ff 75 a8	 push	 DWORD PTR _strTexCachePackName$[ebp]
  003fc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00401	83 c4 04	 add	 esp, 4
$LN699@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00404	83 7d d4 10	 cmp	 DWORD PTR _strPackName$[ebp+20], 16 ; 00000010H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00408	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strTexCachePackName$[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0040f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _strTexCachePackName$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00416	c6 45 a8 00	 mov	 BYTE PTR _strTexCachePackName$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0041a	72 0b		 jb	 SHORT $LN731@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0041c	ff 75 c0	 push	 DWORD PTR _strPackName$[ebp]
  0041f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00424	83 c4 04	 add	 esp, 4
$LN731@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00427	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPackName$[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0042e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPackName$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00435	c6 45 c0 00	 mov	 BYTE PTR _strPackName$[ebp], 0
$LN741@PackInitia:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 238  : 	return true;

  00439	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  0043f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00443	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
$LN19@PackInitia:
  00448	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  0044e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00452	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00457	83 7d ec 10	 cmp	 DWORD PTR _stFileName$[ebp+20], 16 ; 00000010H
  0045b	72 0b		 jb	 SHORT $LN763@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0045d	ff 75 d8	 push	 DWORD PTR _stFileName$[ebp]
  00460	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00465	83 c4 04	 add	 esp, 4
$LN763@PackInitia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00468	83 7d 8c 10	 cmp	 DWORD PTR _stFolder$[ebp+20], 16 ; 00000010H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0046c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stFileName$[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00473	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stFileName$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0047a	c6 45 d8 00	 mov	 BYTE PTR _stFileName$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0047e	72 0e		 jb	 SHORT $LN795@PackInitia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00480	ff b5 78 ff ff
	ff		 push	 DWORD PTR _stFolder$[ebp]
  00486	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0048b	83 c4 04	 add	 esp, 4
$LN795@PackInitia:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 238  : 	return true;

  0048e	8a c3		 mov	 al, bl
$LN7@PackInitia:

; 239  : }

  00490	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00493	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0049a	59		 pop	 ecx
  0049b	5f		 pop	 edi
  0049c	5e		 pop	 esi
  0049d	5b		 pop	 ebx
  0049e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a1	33 cd		 xor	 ecx, ebp
  004a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a8	8b e5		 mov	 esp, ebp
  004aa	5d		 pop	 ebp
  004ab	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PackInitialize@@YA_NPBD@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _stFolder$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PackInitialize@@YA_NPBD@Z$1:
  0000b	8d 4d d8	 lea	 ecx, DWORD PTR _stFileName$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PackInitialize@@YA_NPBD@Z$2:
  00013	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?PackInitialize@@YA_NPBD@Z$3:
  0001e	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _TextLoader$[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__unwindfunclet$?PackInitialize@@YA_NPBD@Z$4:
  00029	8d 4d c0	 lea	 ecx, DWORD PTR _strPackName$[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PackInitialize@@YA_NPBD@Z$5:
  00031	8d 4d a8	 lea	 ecx, DWORD PTR _strTexCachePackName$[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PackInitialize@@YA_NPBD@Z$8:
  00039	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PackInitialize@@YA_NPBD@Z$9:
  00044	8d 4d 90	 lea	 ecx, DWORD PTR $T3[ebp]
  00047	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?PackInitialize@@YA_NPBD@Z:
  0004c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00050	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00053	8b 8a fc fd ff
	ff		 mov	 ecx, DWORD PTR [edx-516]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00063	33 c8		 xor	 ecx, eax
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PackInitialize@@YA_NPBD@Z
  0006f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PackInitialize@@YA_NPBD@Z ENDP				; PackInitialize
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z
_TEXT	SEGMENT
_pyLauncher$GSCopy$1$ = -372				; size = 4
__Cat$2 = -372						; size = 1
__Cat$3 = -372						; size = 1
__Alval$4 = -365					; size = 1
__Alval$5 = -365					; size = 1
_stVec$6 = -364						; size = 12
_stVec$7 = -364						; size = 12
$T8 = -352						; size = 24
$T9 = -352						; size = 24
_stCmdLine$10 = -328					; size = 24
_stRegisterCmdLine$11 = -304				; size = 24
_stRegisterDebugFlag$12 = -304				; size = 24
_buf$13 = -280						; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z PROC	; RunMainScript, COMDAT
; _pyLauncher$ = ecx
; _lpCmdLine$ = edx

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b da		 mov	 ebx, edx
  00030	8b f1		 mov	 esi, ecx
  00032	89 b5 8c fe ff
	ff		 mov	 DWORD PTR _pyLauncher$GSCopy$1$[ebp], esi

; 243  : 	initpack();

  00038	e8 00 00 00 00	 call	 ?initpack@@YAXXZ	; initpack

; 244  : 	initdbg();

  0003d	e8 00 00 00 00	 call	 ?initdbg@@YAXXZ		; initdbg

; 245  : 	initime();

  00042	e8 00 00 00 00	 call	 ?initime@@YAXXZ		; initime

; 246  : 	initgrp();

  00047	e8 00 00 00 00	 call	 ?initgrp@@YAXXZ		; initgrp

; 247  : 	initgrpImage();

  0004c	e8 00 00 00 00	 call	 ?initgrpImage@@YAXXZ	; initgrpImage

; 248  : 	initgrpText();

  00051	e8 00 00 00 00	 call	 ?initgrpText@@YAXXZ	; initgrpText

; 249  : 	initwndMgr();

  00056	e8 00 00 00 00	 call	 ?initwndMgr@@YAXXZ	; initwndMgr

; 250  : 	/////////////////////////////////////////////
; 251  : 	initudp();
; 252  : 	initapp();

  0005b	e8 00 00 00 00	 call	 ?initapp@@YAXXZ		; initapp

; 253  : 	initsystem();

  00060	e8 00 00 00 00	 call	 ?initsystem@@YAXXZ	; initsystem

; 254  : 	initchr();

  00065	e8 00 00 00 00	 call	 ?initchr@@YAXXZ		; initchr

; 255  : 	initchrmgr();

  0006a	e8 00 00 00 00	 call	 ?initchrmgr@@YAXXZ	; initchrmgr

; 256  : 	initPlayer();

  0006f	e8 00 00 00 00	 call	 ?initPlayer@@YAXXZ	; initPlayer

; 257  : 	initItem();

  00074	e8 00 00 00 00	 call	 ?initItem@@YAXXZ	; initItem

; 258  : 	initNonPlayer();

  00079	e8 00 00 00 00	 call	 ?initNonPlayer@@YAXXZ	; initNonPlayer

; 259  : 	initTrade();

  0007e	e8 00 00 00 00	 call	 ?initTrade@@YAXXZ	; initTrade

; 260  : 	initChat();

  00083	e8 00 00 00 00	 call	 ?initChat@@YAXXZ	; initChat

; 261  : 	initTextTail();

  00088	e8 00 00 00 00	 call	 ?initTextTail@@YAXXZ	; initTextTail

; 262  : 	initnet();

  0008d	e8 00 00 00 00	 call	 ?initnet@@YAXXZ		; initnet

; 263  : 	initMiniMap();

  00092	e8 00 00 00 00	 call	 ?initMiniMap@@YAXXZ	; initMiniMap

; 264  : 	initProfiler();

  00097	e8 00 00 00 00	 call	 ?initProfiler@@YAXXZ	; initProfiler

; 265  : 	initEvent();

  0009c	e8 00 00 00 00	 call	 ?initEvent@@YAXXZ	; initEvent

; 266  : 	initeffect();

  000a1	e8 00 00 00 00	 call	 ?initeffect@@YAXXZ	; initeffect

; 267  : 	initfly();

  000a6	e8 00 00 00 00	 call	 ?initfly@@YAXXZ		; initfly

; 268  : 	initsnd();

  000ab	e8 00 00 00 00	 call	 ?initsnd@@YAXXZ		; initsnd

; 269  : 	initeventmgr();

  000b0	e8 00 00 00 00	 call	 ?initeventmgr@@YAXXZ	; initeventmgr

; 270  : 	initshop();

  000b5	e8 00 00 00 00	 call	 ?initshop@@YAXXZ	; initshop

; 271  : 	initskill();

  000ba	e8 00 00 00 00	 call	 ?initskill@@YAXXZ	; initskill

; 272  : 	initquest();

  000bf	e8 00 00 00 00	 call	 ?initquest@@YAXXZ	; initquest

; 273  : 	initBackground();

  000c4	e8 00 00 00 00	 call	 ?initBackground@@YAXXZ	; initBackground

; 274  : 	initMessenger();

  000c9	e8 00 00 00 00	 call	 ?initMessenger@@YAXXZ	; initMessenger

; 275  : 	initsafebox();

  000ce	e8 00 00 00 00	 call	 ?initsafebox@@YAXXZ	; initsafebox

; 276  : 	initguild();

  000d3	e8 00 00 00 00	 call	 ?initguild@@YAXXZ	; initguild

; 277  : 	initServerStateChecker();

  000d8	e8 00 00 00 00	 call	 ?initServerStateChecker@@YAXXZ ; initServerStateChecker

; 278  : 
; 279  : 	NANOBEGIN

  000dd	eb		 DB	 -21			; ffffffebH
  000de	03		 DB	 3
  000df	d6		 DB	 -42			; ffffffd6H
  000e0	d7		 DB	 -41			; ffffffd7H
  000e1	01		 DB	 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000e2	c7 85 e4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _stRegisterDebugFlag$12[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000ec	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stRegisterDebugFlag$12[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000f6	c6 85 d0 fe ff
	ff 00		 mov	 BYTE PTR _stRegisterDebugFlag$12[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  000fd	6a 0d		 push	 13			; 0000000dH
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GIEHGGHC@__DEBUG__?5?$DN?50?$AA@
  00104	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _stRegisterDebugFlag$12[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 283  : 		std::string stRegisterDebugFlag;

  0010a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00111	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 520  : 			: this->_Bx._Buf);

  00116	83 bd e4 fe ff
	ff 10		 cmp	 DWORD PTR _stRegisterDebugFlag$12[ebp+20], 16 ; 00000010H
  0011d	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _stRegisterDebugFlag$12[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 291  : 		if (!pyLauncher.RunLine(stRegisterDebugFlag.c_str()))

  00123	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00125	0f 43 85 d0 fe
	ff ff		 cmovae	 eax, DWORD PTR _stRegisterDebugFlag$12[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 291  : 		if (!pyLauncher.RunLine(stRegisterDebugFlag.c_str()))

  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?RunLine@CPythonLauncher@@QAE_NPBD@Z ; CPythonLauncher::RunLine
  00132	84 c0		 test	 al, al
  00134	75 2b		 jne	 SHORT $LN8@RunMainScr

; 292  : 		{
; 293  : 			TraceError("RegisterDebugFlag Error");

  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JAFKHBD@RegisterDebugFlag?5Error?$AA@
  0013b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00140	83 c4 04	 add	 esp, 4
$LN545@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00143	83 bd e4 fe ff
	ff 10		 cmp	 DWORD PTR _stRegisterDebugFlag$12[ebp+20], 16 ; 00000010H
  0014a	72 0e		 jb	 SHORT $LN92@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0014c	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _stRegisterDebugFlag$12[ebp]
  00152	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00157	83 c4 04	 add	 esp, 4
$LN92@RunMainScr:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 294  : 			return false;

  0015a	32 c0		 xor	 al, al
  0015c	e9 58 04 00 00	 jmp	 $LN9@RunMainScr
$LN8@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00161	83 bd e4 fe ff
	ff 10		 cmp	 DWORD PTR _stRegisterDebugFlag$12[ebp+20], 16 ; 00000010H
  00168	72 0e		 jb	 SHORT $LN124@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0016a	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _stRegisterDebugFlag$12[ebp]
  00170	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00175	83 c4 04	 add	 esp, 4
$LN124@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00178	c7 85 e4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _stRegisterCmdLine$11[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00182	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stRegisterCmdLine$11[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0018c	c6 85 d0 fe ff
	ff 00		 mov	 BYTE PTR _stRegisterCmdLine$11[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 300  : 		std::string stRegisterCmdLine;

  00193	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0019a	c7 85 cc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _stCmdLine$10[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001a4	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stCmdLine$10[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001ae	c6 85 b8 fe ff
	ff 00		 mov	 BYTE PTR _stCmdLine$10[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  001b5	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp], 0

; 483  : 		_Mylast = pointer();

  001bf	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp+4], 0

; 484  : 		_Myend = pointer();

  001c9	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp+8], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 309  : 		SplitLine(lpCmdLine,seperator,&stVec);

  001d3	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _stVec$7[ebp]
  001d9	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  001dd	50		 push	 eax
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  001e3	53		 push	 ebx
  001e4	e8 00 00 00 00	 call	 ?SplitLine@@YA_NPBD0PAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SplitLine
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001e9	8b bd 98 fe ff
	ff		 mov	 edi, DWORD PTR _stVec$7[ebp+4]
  001ef	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  001f4	8b b5 94 fe ff
	ff		 mov	 esi, DWORD PTR _stVec$7[ebp]
  001fa	8b cf		 mov	 ecx, edi
  001fc	2b ce		 sub	 ecx, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 309  : 		SplitLine(lpCmdLine,seperator,&stVec);

  001fe	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00201	f7 e9		 imul	 ecx
  00203	c1 fa 02	 sar	 edx, 2
  00206	8b c2		 mov	 eax, edx
  00208	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0020b	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 310  : 		if (CmdSize == stVec.size() && stVec[0]==loginMark)

  0020d	83 f8 03	 cmp	 eax, 3
  00210	0f 85 d2 00 00
	00		 jne	 $LN7@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  00216	50		 push	 eax
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_03MCGAAIEM@?9cs?$AA@
  0021c	ff 76 10	 push	 DWORD PTR [esi+16]
  0021f	8b ce		 mov	 ecx, esi
  00221	6a 00		 push	 0
  00223	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);

  00228	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 310  : 		if (CmdSize == stVec.size() && stVec[0]==loginMark)

  0022a	0f 85 ac 00 00
	00		 jne	 $LN542@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00230	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _stVec$7[ebp]
  00236	83 c0 30	 add	 eax, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00239	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0023d	72 02		 jb	 SHORT $LN239@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0023f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN239@RunMainScr:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 313  : 			base64_decode(stVec[2].c_str(),buf);

  00241	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf$13[ebp]
  00247	51		 push	 ecx
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 ?base64_decode@@YAXPBDPAD@Z ; base64_decode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0024e	8b b5 94 fe ff
	ff		 mov	 esi, DWORD PTR _stVec$7[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 313  : 			base64_decode(stVec[2].c_str(),buf);

  00254	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00257	80 bd e8 fe ff
	ff 00		 cmp	 BYTE PTR _buf$13[ebp], 0
  0025e	75 04		 jne	 SHORT $LN250@RunMainScr
  00260	33 c9		 xor	 ecx, ecx
  00262	eb 15		 jmp	 SHORT $LN251@RunMainScr
$LN250@RunMainScr:
  00264	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf$13[ebp]
  0026a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0026d	8d 49 00	 npad	 3
$LL540@RunMainScr:
  00270	8a 01		 mov	 al, BYTE PTR [ecx]
  00272	41		 inc	 ecx
  00273	84 c0		 test	 al, al
  00275	75 f9		 jne	 SHORT $LL540@RunMainScr
  00277	2b ca		 sub	 ecx, edx
$LN251@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00279	51		 push	 ecx
  0027a	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _buf$13[ebp]
  00280	50		 push	 eax
  00281	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00284	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 315  : 			string_join(seperator,stVec,&stCmdLine);

  00289	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0028e	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00294	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00299	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
$LN544@RunMainScr:
  0029d	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _stCmdLine$10[ebp]
  002a3	50		 push	 eax
  002a4	8d 95 94 fe ff
	ff		 lea	 edx, DWORD PTR _stVec$7[ebp]
  002aa	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  002b0	e8 00 00 00 00	 call	 ??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z ; string_join<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
  002b5	83 c4 04	 add	 esp, 4
  002b8	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  002bc	83 bd b4 fe ff
	ff 10		 cmp	 DWORD PTR $T9[ebp+20], 16 ; 00000010H
  002c3	0f 82 9d 00 00
	00		 jb	 $LN344@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  002c9	ff b5 a0 fe ff
	ff		 push	 DWORD PTR $T9[ebp]
  002cf	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002d4	83 c4 04	 add	 esp, 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 317  : 		else if (CmdSize <= stVec.size() && stVec[0]==loginMark_NonEncode)

  002d7	e9 8a 00 00 00	 jmp	 $LN344@RunMainScr
$LN542@RunMainScr:
  002dc	8b bd 98 fe ff
	ff		 mov	 edi, DWORD PTR _stVec$7[ebp+4]
  002e2	8b b5 94 fe ff
	ff		 mov	 esi, DWORD PTR _stVec$7[ebp]
$LN7@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002e8	2b fe		 sub	 edi, esi
  002ea	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002ef	f7 ef		 imul	 edi
  002f1	c1 fa 02	 sar	 edx, 2
  002f4	8b c2		 mov	 eax, edx
  002f6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002f9	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 317  : 		else if (CmdSize <= stVec.size() && stVec[0]==loginMark_NonEncode)

  002fb	83 f8 03	 cmp	 eax, 3
  002fe	72 40		 jb	 SHORT $LN5@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  00300	6a 04		 push	 4
  00302	68 00 00 00 00	 push	 OFFSET ??_C@_04JFPGDMCL@?9ncs?$AA@
  00307	ff 76 10	 push	 DWORD PTR [esi+16]
  0030a	8b ce		 mov	 ecx, esi
  0030c	6a 00		 push	 0
  0030e	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);

  00313	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 317  : 		else if (CmdSize <= stVec.size() && stVec[0]==loginMark_NonEncode)

  00315	75 29		 jne	 SHORT $LN5@RunMainScr

; 318  : 		{
; 319  : 			stVec[0] = loginMark;

  00317	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _stVec$7[ebp]
  0031d	68 00 00 00 00	 push	 OFFSET ??_C@_03MCGAAIEM@?9cs?$AA@
  00322	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 320  : 			string_join(" ",stVec,&stCmdLine);

  00327	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0032c	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00332	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00337	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 321  : 		}
; 322  : 		else

  0033b	e9 5d ff ff ff	 jmp	 $LN544@RunMainScr
$LN5@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00340	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00343	75 04		 jne	 SHORT $LN336@RunMainScr
  00345	33 c9		 xor	 ecx, ecx
  00347	eb 10		 jmp	 SHORT $LN337@RunMainScr
$LN336@RunMainScr:
  00349	8b cb		 mov	 ecx, ebx
  0034b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0034e	8b ff		 npad	 2
$LL541@RunMainScr:
  00350	8a 01		 mov	 al, BYTE PTR [ecx]
  00352	41		 inc	 ecx
  00353	84 c0		 test	 al, al
  00355	75 f9		 jne	 SHORT $LL541@RunMainScr
  00357	2b ca		 sub	 ecx, edx
$LN337@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00359	51		 push	 ecx
  0035a	53		 push	 ebx
  0035b	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _stCmdLine$10[ebp]
  00361	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN344@RunMainScr:
  00366	6a 13		 push	 19			; 00000013H
  00368	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FPKDPBJI@__COMMAND_LINE__?5?$DN?5?$AA@
  0036d	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _stRegisterCmdLine$11[ebp]
  00373	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));

  00378	6a 22		 push	 34			; 00000022H
  0037a	6a 01		 push	 1
  0037c	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _stRegisterCmdLine$11[ebp]
  00382	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));

  00387	6a ff		 push	 -1
  00389	6a 00		 push	 0
  0038b	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _stCmdLine$10[ebp]
  00391	50		 push	 eax
  00392	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _stRegisterCmdLine$11[ebp]
  00398	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));

  0039d	6a 22		 push	 34			; 00000022H
  0039f	6a 01		 push	 1
  003a1	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _stRegisterCmdLine$11[ebp]
  003a7	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 520  : 			: this->_Bx._Buf);

  003ac	83 bd e4 fe ff
	ff 10		 cmp	 DWORD PTR _stRegisterCmdLine$11[ebp+20], 16 ; 00000010H
  003b3	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _stRegisterCmdLine$11[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 331  : 		if (!pyLauncher.RunLine(c_szRegisterCmdLine))

  003b9	8b bd 8c fe ff
	ff		 mov	 edi, DWORD PTR _pyLauncher$GSCopy$1$[ebp]
  003bf	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  003c1	0f 43 85 d0 fe
	ff ff		 cmovae	 eax, DWORD PTR _stRegisterCmdLine$11[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 331  : 		if (!pyLauncher.RunLine(c_szRegisterCmdLine))

  003c8	50		 push	 eax
  003c9	e8 00 00 00 00	 call	 ?RunLine@CPythonLauncher@@QAE_NPBD@Z ; CPythonLauncher::RunLine
  003ce	84 c0		 test	 al, al
  003d0	0f 85 93 00 00
	00		 jne	 $LN3@RunMainScr

; 333  : 			TraceError("RegisterCommandLine Error");

  003d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DPMNHJLC@RegisterCommandLine?5Error?$AA@
  003db	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  003e0	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _stVec$7[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 333  : 			TraceError("RegisterCommandLine Error");

  003e6	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  003e9	85 c0		 test	 eax, eax
  003eb	74 45		 je	 SHORT $LN364@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  003ed	ff b5 8c fe ff
	ff		 push	 DWORD PTR __Cat$3[ebp]
  003f3	8d 8d 93 fe ff
	ff		 lea	 ecx, DWORD PTR __Alval$5[ebp]
  003f9	51		 push	 ecx
  003fa	ff b5 98 fe ff
	ff		 push	 DWORD PTR _stVec$7[ebp+4]
  00400	50		 push	 eax
  00401	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 573  : 		::operator delete(_Ptr);

  00406	ff b5 94 fe ff
	ff		 push	 DWORD PTR _stVec$7[ebp]
  0040c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00411	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00414	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp], 0

; 1630 : 			this->_Mylast = pointer();

  0041e	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp+4], 0

; 1631 : 			this->_Myend = pointer();

  00428	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp+8], 0
$LN364@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00432	83 bd cc fe ff
	ff 10		 cmp	 DWORD PTR _stCmdLine$10[ebp+20], 16 ; 00000010H
  00439	72 0e		 jb	 SHORT $LN401@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0043b	ff b5 b8 fe ff
	ff		 push	 DWORD PTR _stCmdLine$10[ebp]
  00441	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00446	83 c4 04	 add	 esp, 4
$LN401@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00449	c7 85 cc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _stCmdLine$10[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00453	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stCmdLine$10[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0045d	c6 85 b8 fe ff
	ff 00		 mov	 BYTE PTR _stCmdLine$10[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 334  : 			return false;

  00464	e9 da fc ff ff	 jmp	 $LN545@RunMainScr
$LN3@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00469	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _stVec$7[ebp]
  0046f	85 c0		 test	 eax, eax
  00471	74 45		 je	 SHORT $LN447@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00473	ff b5 8c fe ff
	ff		 push	 DWORD PTR __Cat$2[ebp]
  00479	8d 8d 93 fe ff
	ff		 lea	 ecx, DWORD PTR __Alval$4[ebp]
  0047f	51		 push	 ecx
  00480	ff b5 98 fe ff
	ff		 push	 DWORD PTR _stVec$7[ebp+4]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 573  : 		::operator delete(_Ptr);

  0048c	ff b5 94 fe ff
	ff		 push	 DWORD PTR _stVec$7[ebp]
  00492	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00497	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0049a	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp], 0

; 1630 : 			this->_Mylast = pointer();

  004a4	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp+4], 0

; 1631 : 			this->_Myend = pointer();

  004ae	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$7[ebp+8], 0
$LN447@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  004b8	83 bd cc fe ff
	ff 10		 cmp	 DWORD PTR _stCmdLine$10[ebp+20], 16 ; 00000010H
  004bf	72 0e		 jb	 SHORT $LN484@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  004c1	ff b5 b8 fe ff
	ff		 push	 DWORD PTR _stCmdLine$10[ebp]
  004c7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004cc	83 c4 04	 add	 esp, 4
$LN484@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  004cf	83 bd e4 fe ff
	ff 10		 cmp	 DWORD PTR _stRegisterCmdLine$11[ebp+20], 16 ; 00000010H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  004d6	c7 85 cc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _stCmdLine$10[ebp+20], 15 ; 0000000fH

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  004e0	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stCmdLine$10[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  004ea	c6 85 b8 fe ff
	ff 00		 mov	 BYTE PTR _stCmdLine$10[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  004f1	72 0e		 jb	 SHORT $LN516@RunMainScr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  004f3	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _stRegisterCmdLine$11[ebp]
  004f9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004fe	83 c4 04	 add	 esp, 4
$LN516@RunMainScr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00501	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$6[ebp], 0

; 483  : 		_Mylast = pointer();

  0050b	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$6[ebp+4], 0

; 484  : 		_Myend = pointer();

  00515	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stVec$6[ebp+8], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 339  : 		SplitLine(lpCmdLine," " ,&stVec);

  0051f	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _stVec$6[ebp]
  00525	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  0052c	51		 push	 ecx
  0052d	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  00532	53		 push	 ebx
  00533	e8 00 00 00 00	 call	 ?SplitLine@@YA_NPBD0PAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SplitLine
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00538	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _stVec$6[ebp+4]
  0053e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00543	8b b5 94 fe ff
	ff		 mov	 esi, DWORD PTR _stVec$6[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 339  : 		SplitLine(lpCmdLine," " ,&stVec);

  00549	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0054c	2b ce		 sub	 ecx, esi
  0054e	f7 e9		 imul	 ecx
  00550	c1 fa 02	 sar	 edx, 2
  00553	8b c2		 mov	 eax, edx
  00555	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00558	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 341  : 		if (stVec.size() != 0 && "--pause-before-create-window" == stVec[0])

  0055a	74 1f		 je	 SHORT $LN2@RunMainScr
  0055c	56		 push	 esi
  0055d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KIGJPBEF@?9?9pause?9before?9create?9window?$AA@
  00562	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00567	83 c4 08	 add	 esp, 8
  0056a	84 c0		 test	 al, al
  0056c	74 0d		 je	 SHORT $LN2@RunMainScr

; 342  : 		{
; 343  : #ifdef XTRAP_CLIENT_ENABLE
; 344  : 			if (!XTrap_CheckInit())
; 345  : 				return false;
; 346  : #endif
; 347  : 			system("pause");

  0056e	68 00 00 00 00	 push	 OFFSET ??_C@_05PDJBBECF@pause?$AA@
  00573	e8 00 00 00 00	 call	 _system
  00578	83 c4 04	 add	 esp, 4
$LN2@RunMainScr:

; 348  : 		}
; 349  : 		if (!pyLauncher.RunFile("system.py"))

  0057b	68 00 00 00 00	 push	 OFFSET ??_C@_09LEIJOBCA@system?4py?$AA@
  00580	8b cf		 mov	 ecx, edi
  00582	e8 00 00 00 00	 call	 ?RunFile@CPythonLauncher@@QAE_NPBD@Z ; CPythonLauncher::RunFile
  00587	84 c0		 test	 al, al
  00589	75 1c		 jne	 SHORT $LN1@RunMainScr

; 350  : 		{
; 351  : 			TraceError("RunMain Error");

  0058b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BEEPKJML@RunMain?5Error?$AA@
  00590	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00595	83 c4 04	 add	 esp, 4

; 352  : 			return false;

  00598	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _stVec$6[ebp]
  0059e	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  005a3	32 c0		 xor	 al, al
  005a5	eb 12		 jmp	 SHORT $LN9@RunMainScr
$LN1@RunMainScr:

; 353  : 		}
; 354  : 	}

  005a7	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _stVec$6[ebp]
  005ad	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 355  : 
; 356  : 	NANOEND

  005b2	eb		 DB	 -21			; ffffffebH
  005b3	03		 DB	 3
  005b4	d6		 DB	 -42			; ffffffd6H
  005b5	d7		 DB	 -41			; ffffffd7H
  005b6	00		 DB	 0

; 357  : 	return true;

  005b7	b0 01		 mov	 al, 1
$LN9@RunMainScr:

; 358  : }

  005b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005c3	59		 pop	 ecx
  005c4	5f		 pop	 edi
  005c5	5e		 pop	 esi
  005c6	5b		 pop	 ebx
  005c7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ca	33 cd		 xor	 ecx, ebp
  005cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d1	8b e5		 mov	 esp, ebp
  005d3	5d		 pop	 ebp
  005d4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$0:
  00000	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _stRegisterDebugFlag$12[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$1:
  0000b	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _stRegisterCmdLine$11[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$2:
  00016	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _stCmdLine$10[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$3:
  00021	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _stVec$7[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$4:
  0002c	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$5:
  00037	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z$6:
  00042	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _stVec$6[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z:
  0004d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00051	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00054	8b 8a 84 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-380]
  0005a	33 c8		 xor	 ecx, eax
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00064	33 c8		 xor	 ecx, eax
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z
  00070	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z ENDP	; RunMainScript
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?Main@@YA_NPAUHINSTANCE__@@PAD@Z
_TEXT	SEGMENT
_pyLauncher$2 = -72					; size = 12
$T3 = -60						; size = 4
_pyExceptionSender$4 = -56				; size = 36
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?Main@@YA_NPAUHINSTANCE__@@PAD@Z PROC			; Main, COMDAT
; _hInstance$ = ecx
; _lpCmdLine$ = edx

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?Main@@YA_NPAUHINSTANCE__@@PAD@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 40	 sub	 esp, 64			; 00000040H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 38	 mov	 DWORD PTR __$ArrayPad$[esp+76], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	8b fa		 mov	 edi, edx
  00039	8b d9		 mov	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl

; 79   :     return _time32(_Time);

  0003b	6a 00		 push	 0
  0003d	e8 00 00 00 00	 call	 __time32
  00042	83 c4 04	 add	 esp, 4
  00045	8b f0		 mov	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 367  : 	DWORD dwRandSeed=time(NULL)+DWORD(GetCurrentProcess());

  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  0004d	03 c6		 add	 eax, esi

; 368  : 	srandom(dwRandSeed);

  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?srandom@@YAXK@Z	; srandom
  00055	83 c4 04	 add	 esp, 4

; 369  : 	srand(random());

  00058	e8 00 00 00 00	 call	 ?random@@YAKXZ		; random
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _srand
  00063	83 c4 04	 add	 esp, 4

; 370  : 
; 371  : 	SetLogLevel(1);

  00066	6a 01		 push	 1
  00068	e8 00 00 00 00	 call	 ?SetLogLevel@@YAXI@Z	; SetLogLevel
  0006d	83 c4 04	 add	 esp, 4

; 372  : 
; 373  : #ifdef LOCALE_SERVICE_VIETNAM_MILD
; 374  : 	extern BOOL USE_VIETNAM_CONVERT_WEAPON_VNUM;
; 375  : 	USE_VIETNAM_CONVERT_WEAPON_VNUM = true;
; 376  : #endif
; 377  : 
; 378  : 	if (_access("perf_game_update.txt", 0)==0)

  00070	6a 00		 push	 0
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NHIIGIH@perf_game_update?4txt?$AA@
  00077	e8 00 00 00 00	 call	 __access
  0007c	83 c4 08	 add	 esp, 8
  0007f	85 c0		 test	 eax, eax
  00081	75 0b		 jne	 SHORT $LN8@Main

; 379  : 	{
; 380  : 		DeleteFile("perf_game_update.txt");

  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NHIIGIH@perf_game_update?4txt?$AA@
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
$LN8@Main:

; 381  : 	}
; 382  : 
; 383  : 	if (_access("newpatch.exe", 0)==0)

  0008e	6a 00		 push	 0
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JIKFFHPP@newpatch?4exe?$AA@
  00095	e8 00 00 00 00	 call	 __access
  0009a	83 c4 08	 add	 esp, 8
  0009d	85 c0		 test	 eax, eax
  0009f	75 14		 jne	 SHORT $LN7@Main

; 384  : 	{		
; 385  : 		system("patchupdater.exe");

  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LLCBDFGP@patchupdater?4exe?$AA@
  000a6	e8 00 00 00 00	 call	 _system
  000ab	83 c4 04	 add	 esp, 4
$LN23@Main:

; 386  : 		return false;

  000ae	32 c0		 xor	 al, al
  000b0	e9 8f 01 00 00	 jmp	 $LN9@Main
$LN7@Main:

; 387  : 	}
; 388  : #ifndef __VTUNE__
; 389  : 	ilInit();

  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilInit@0

; 390  : #endif
; 391  : 	if (!Setup(lpCmdLine))

  000bb	e8 00 00 00 00	 call	 ?Setup@@YAHPAD@Z	; Setup
  000c0	85 c0		 test	 eax, eax
  000c2	74 ea		 je	 SHORT $LN23@Main

; 392  : 		return false;
; 393  : 
; 394  : #ifdef _DEBUG
; 395  : 	OpenConsoleWindow();
; 396  : 	OpenLogFile(true); // true == uses syserr.txt and log.txt
; 397  : #else
; 398  : 	OpenLogFile(false); // false == uses syserr.txt only

  000c4	6a 00		 push	 0
  000c6	e8 00 00 00 00	 call	 ?OpenLogFile@@YAX_N@Z	; OpenLogFile

; 399  : #endif
; 400  : 
; 401  : 	static CLZO				lzo;

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA
  000d0	83 c4 04	 add	 esp, 4
  000d3	a8 01		 test	 al, 1
  000d5	75 34		 jne	 SHORT $LN5@Main
  000d7	83 c8 01	 or	 eax, 1
  000da	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA, eax
  000df	b9 00 00 00 00	 mov	 ecx, OFFSET ?lzo@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4VCLZO@@A
  000e4	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 0
  000ec	e8 00 00 00 00	 call	 ??0CLZO@@QAE@XZ		; CLZO::CLZO
  000f1	68 00 00 00 00	 push	 OFFSET ??__Flzo@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@YAXXZ ; `Main'::`10'::`dynamic atexit destructor for 'lzo''
  000f6	e8 00 00 00 00	 call	 _atexit
  000fb	c7 44 24 5c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+104], -1
  00103	83 c4 04	 add	 esp, 4
  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA
$LN5@Main:

; 402  : 	static CEterPackManager	EterPackManager;

  0010b	a8 02		 test	 al, 2
  0010d	75 2f		 jne	 SHORT $LN4@Main
  0010f	83 c8 02	 or	 eax, 2
  00112	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA, eax
  00117	b9 00 00 00 00	 mov	 ecx, OFFSET ?EterPackManager@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4VCEterPackManager@@A
  0011c	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 1
  00124	e8 00 00 00 00	 call	 ??0CEterPackManager@@QAE@XZ ; CEterPackManager::CEterPackManager
  00129	68 00 00 00 00	 push	 OFFSET ??__FEterPackManager@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@YAXXZ ; `Main'::`10'::`dynamic atexit destructor for 'EterPackManager''
  0012e	e8 00 00 00 00	 call	 _atexit
  00133	83 c4 04	 add	 esp, 4
  00136	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+100], -1
$LN4@Main:

; 403  : 
; 404  : 	if (!PackInitialize("pack"))

  0013e	e8 00 00 00 00	 call	 ?PackInitialize@@YA_NPBD@Z ; PackInitialize
  00143	84 c0		 test	 al, al
  00145	75 18		 jne	 SHORT $LN3@Main

; 405  : 	{
; 406  : 		LogBox("Pack Initialization failed. Check log.txt file..");

  00147	6a 00		 push	 0
  00149	6a 00		 push	 0
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@BGMLOPGB@Pack?5Initialization?5failed?4?5Chec@
  00150	e8 00 00 00 00	 call	 ?LogBox@@YAXPBD0PAUHWND__@@@Z ; LogBox
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH

; 407  : 		return false;

  00158	32 c0		 xor	 al, al
  0015a	e9 e5 00 00 00	 jmp	 $LN9@Main
$LN3@Main:

; 408  : 	}
; 409  : 
; 410  : 	if(LocaleService_LoadGlobal(hInstance))

  0015f	e8 00 00 00 00	 call	 ?LocaleService_LoadGlobal@@YA_NPAUHINSTANCE__@@@Z ; LocaleService_LoadGlobal
  00164	84 c0		 test	 al, al
  00166	74 0e		 je	 SHORT $LN2@Main

; 411  : 		SetDefaultCodePage(LocaleService_GetCodePage());

  00168	e8 00 00 00 00	 call	 ?LocaleService_GetCodePage@@YAIXZ ; LocaleService_GetCodePage
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?SetDefaultCodePage@@YA_NK@Z ; SetDefaultCodePage
  00173	83 c4 04	 add	 esp, 4
$LN2@Main:

; 412  : 
; 413  : 	CPythonApplication * app = new CPythonApplication;

  00176	68 d0 00 02 00	 push	 131280			; 000200d0H
  0017b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00180	83 c4 04	 add	 esp, 4
  00183	89 44 24 20	 mov	 DWORD PTR $T3[esp+92], eax
  00187	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 2
  0018f	85 c0		 test	 eax, eax
  00191	74 0b		 je	 SHORT $LN11@Main
  00193	8b c8		 mov	 ecx, eax
  00195	e8 00 00 00 00	 call	 ??0CPythonApplication@@QAE@XZ ; CPythonApplication::CPythonApplication
  0019a	8b f0		 mov	 esi, eax
  0019c	eb 02		 jmp	 SHORT $LN12@Main
$LN11@Main:
  0019e	33 f6		 xor	 esi, esi
$LN12@Main:

; 414  : 
; 415  : 	app->Initialize(hInstance);

  001a0	53		 push	 ebx
  001a1	8b ce		 mov	 ecx, esi
  001a3	c7 44 24 5c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+104], -1
  001ab	e8 00 00 00 00	 call	 ?Initialize@CMSApplication@@QAEXPAUHINSTANCE__@@@Z ; CMSApplication::Initialize

; 416  : 
; 417  : 	bool ret=false;
; 418  : 	{
; 419  : 		CPythonLauncher pyLauncher;

  001b0	8d 4c 24 14	 lea	 ecx, DWORD PTR _pyLauncher$2[esp+92]
  001b4	32 db		 xor	 bl, bl
  001b6	e8 00 00 00 00	 call	 ??0CPythonLauncher@@QAE@XZ ; CPythonLauncher::CPythonLauncher

; 420  : 		CPythonExceptionSender pyExceptionSender;

  001bb	8d 4c 24 24	 lea	 ecx, DWORD PTR _pyExceptionSender$4[esp+92]
  001bf	c7 44 24 58 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 3
  001c7	e8 00 00 00 00	 call	 ??0CPythonExceptionSender@@QAE@XZ ; CPythonExceptionSender::CPythonExceptionSender

; 421  : 		SetExceptionSender(&pyExceptionSender);

  001cc	8d 44 24 24	 lea	 eax, DWORD PTR _pyExceptionSender$4[esp+92]
  001d0	c6 44 24 58 04	 mov	 BYTE PTR __$EHRec$[esp+100], 4
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 ?SetExceptionSender@@YAXPAVIPythonExceptionSender@@@Z ; SetExceptionSender
  001db	83 c4 04	 add	 esp, 4

; 422  : 
; 423  : 		if (pyLauncher.Create())

  001de	8d 4c 24 14	 lea	 ecx, DWORD PTR _pyLauncher$2[esp+92]
  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PFDHIIAP@eter?4python?$AA@
  001e7	e8 00 00 00 00	 call	 ?Create@CPythonLauncher@@QAE_NPBD@Z ; CPythonLauncher::Create
  001ec	84 c0		 test	 al, al
  001ee	74 0d		 je	 SHORT $LN1@Main

; 424  : 		{
; 425  : 			ret=RunMainScript(pyLauncher, lpCmdLine);	//    .

  001f0	8b d7		 mov	 edx, edi
  001f2	8d 4c 24 14	 lea	 ecx, DWORD PTR _pyLauncher$2[esp+92]
  001f6	e8 00 00 00 00	 call	 ?RunMainScript@@YA_NAAVCPythonLauncher@@PBD@Z ; RunMainScript
  001fb	8a d8		 mov	 bl, al
$LN1@Main:

; 426  : 		}
; 427  : 
; 428  : 		//ProcessScanner_ReleaseQuitEvent();
; 429  : 		
; 430  : 		// .
; 431  : 		app->Clear();

  001fd	8b ce		 mov	 ecx, esi
  001ff	e8 00 00 00 00	 call	 ?Clear@CPythonApplication@@QAEXXZ ; CPythonApplication::Clear

; 432  : 
; 433  : 		timeEndPeriod(1);

  00204	6a 01		 push	 1
  00206	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeEndPeriod@4

; 434  : 		pyLauncher.Clear();

  0020c	8d 4c 24 14	 lea	 ecx, DWORD PTR _pyLauncher$2[esp+92]
  00210	e8 00 00 00 00	 call	 ?Clear@CPythonLauncher@@QAEXXZ ; CPythonLauncher::Clear

; 435  : 	}

  00215	8d 4c 24 24	 lea	 ecx, DWORD PTR _pyExceptionSender$4[esp+92]
  00219	e8 00 00 00 00	 call	 ??1CPythonExceptionSender@@UAE@XZ ; CPythonExceptionSender::~CPythonExceptionSender
  0021e	8d 4c 24 14	 lea	 ecx, DWORD PTR _pyLauncher$2[esp+92]
  00222	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+100], -1
  0022a	e8 00 00 00 00	 call	 ??1CPythonLauncher@@UAE@XZ ; CPythonLauncher::~CPythonLauncher

; 436  : 
; 437  : 	app->Destroy();

  0022f	8b ce		 mov	 ecx, esi
  00231	e8 00 00 00 00	 call	 ?Destroy@CPythonApplication@@QAEXXZ ; CPythonApplication::Destroy

; 438  : 	delete app;

  00236	85 f6		 test	 esi, esi
  00238	74 08		 je	 SHORT $LN13@Main
  0023a	8b 06		 mov	 eax, DWORD PTR [esi]
  0023c	8b ce		 mov	 ecx, esi
  0023e	6a 01		 push	 1
  00240	ff 10		 call	 DWORD PTR [eax]
$LN13@Main:

; 439  : 	
; 440  : 	return ret;

  00242	8a c3		 mov	 al, bl
$LN9@Main:

; 441  : }

  00244	8b 4c 24 50	 mov	 ecx, DWORD PTR __$EHRec$[esp+92]
  00248	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0024f	59		 pop	 ecx
  00250	5f		 pop	 edi
  00251	5e		 pop	 esi
  00252	5b		 pop	 ebx
  00253	8b 4c 24 38	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+76]
  00257	33 cc		 xor	 ecx, esp
  00259	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA, eax
  0000d	c3		 ret	 0
__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$1:
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA
  00013	83 e0 fd	 and	 eax, -3			; fffffffdH
  00016	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4IA, eax
  0001b	c3		 ret	 0
__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$2:
  0001c	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	59		 pop	 ecx
  00026	c3		 ret	 0
__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$3:
  00027	8d 4d b8	 lea	 ecx, DWORD PTR _pyLauncher$2[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1CPythonLauncher@@UAE@XZ ; CPythonLauncher::~CPythonLauncher
__unwindfunclet$?Main@@YA_NPAUHINSTANCE__@@PAD@Z$4:
  0002f	8d 4d c8	 lea	 ecx, DWORD PTR _pyExceptionSender$4[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1CPythonExceptionSender@@UAE@XZ ; CPythonExceptionSender::~CPythonExceptionSender
__ehhandler$?Main@@YA_NPAUHINSTANCE__@@PAD@Z:
  00037	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003b	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  0003e	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004b	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0004e	33 c8		 xor	 ecx, eax
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Main@@YA_NPAUHINSTANCE__@@PAD@Z
  0005a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Main@@YA_NPAUHINSTANCE__@@PAD@Z ENDP			; Main
; Function compile flags: /Ogtp
;	COMDAT ??__FEterPackManager@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@YAXXZ
text$yd	SEGMENT
??__FEterPackManager@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@YAXXZ PROC ; `Main'::`10'::`dynamic atexit destructor for 'EterPackManager'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?EterPackManager@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4VCEterPackManager@@A
  00005	e9 00 00 00 00	 jmp	 ??1CEterPackManager@@UAE@XZ ; CEterPackManager::~CEterPackManager
??__FEterPackManager@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@YAXXZ ENDP ; `Main'::`10'::`dynamic atexit destructor for 'EterPackManager''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Flzo@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@YAXXZ
text$yd	SEGMENT
??__Flzo@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@YAXXZ PROC	; `Main'::`10'::`dynamic atexit destructor for 'lzo'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?lzo@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@4VCLZO@@A
  00005	e9 00 00 00 00	 jmp	 ??1CLZO@@UAE@XZ		; CLZO::~CLZO
??__Flzo@?9??Main@@YA_NPAUHINSTANCE__@@PAD@Z@YAXXZ ENDP	; `Main'::`10'::`dynamic atexit destructor for 'lzo''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?__ErrorPythonLibraryIsNotExist@@YAXXZ
_TEXT	SEGMENT
?__ErrorPythonLibraryIsNotExist@@YAXXZ PROC		; __ErrorPythonLibraryIsNotExist, COMDAT

; 465  : 	LogBoxf("FATAL ERROR!! Python Library file not exist!");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@OHDPHKKH@FATAL?5ERROR?$CB?$CB?5Python?5Library?5fil@
  00005	e8 00 00 00 00	 call	 ?LogBoxf@@YAXPBDZZ	; LogBoxf
  0000a	59		 pop	 ecx

; 466  : }

  0000b	c3		 ret	 0
?__ErrorPythonLibraryIsNotExist@@YAXXZ ENDP		; __ErrorPythonLibraryIsNotExist
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?__IsTimeStampOption@@YA_NPAD@Z
_TEXT	SEGMENT
?__IsTimeStampOption@@YA_NPAD@Z PROC			; __IsTimeStampOption, COMDAT
; _lpCmdLine$ = ecx

; 470  : 	const char* TIMESTAMP = "/timestamp";
; 471  : 	return (strncmp(lpCmdLine, TIMESTAMP, strlen(TIMESTAMP))==0);

  00000	6a 0a		 push	 10			; 0000000aH
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HBFAHJLE@?1timestamp?$AA@
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _strncmp
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	f7 d8		 neg	 eax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax

; 472  : }

  00015	c3		 ret	 0
?__IsTimeStampOption@@YA_NPAD@Z ENDP			; __IsTimeStampOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?__PrintTimeStamp@@YAXXZ
_TEXT	SEGMENT
?__PrintTimeStamp@@YAXXZ PROC				; __PrintTimeStamp, COMDAT

; 476  : #ifdef	_DEBUG
; 477  : 	if (__IS_TEST_SERVER_MODE__)
; 478  : 		LogBoxf("METIN2 BINARY TEST DEBUG VERSION %s  ( MS C++ %d Compiled )", __TIMESTAMP__, _MSC_VER);
; 479  : 	else
; 480  : 		LogBoxf("METIN2 BINARY DEBUG VERSION %s ( MS C++ %d Compiled )", __TIMESTAMP__, _MSC_VER);
; 481  : 	
; 482  : #else
; 483  : 	if (__IS_TEST_SERVER_MODE__)

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?__IS_TEST_SERVER_MODE__@@3_NA, 0 ; __IS_TEST_SERVER_MODE__

; 484  : 		LogBoxf("METIN2 BINARY TEST VERSION %s  ( MS C++ %d Compiled )", __TIMESTAMP__, _MSC_VER);

  00007	68 08 07 00 00	 push	 1800			; 00000708H
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CPGCGJKO@Fri?5Sep?511?508?312?333?52015?$AA@
  00011	74 0e		 je	 SHORT $LN2@PrintTimeS
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JFMPGIL@METIN2?5BINARY?5TEST?5VERSION?5?$CFs?5?5?$CI@

; 485  : 	else
; 486  : 		LogBoxf("METIN2 BINARY DISTRIBUTE VERSION %s ( MS C++ %d Compiled )", __TIMESTAMP__, _MSC_VER);			

  00018	e8 00 00 00 00	 call	 ?LogBoxf@@YAXPBDZZ	; LogBoxf
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 487  : #endif			
; 488  : }

  00020	c3		 ret	 0
$LN2@PrintTimeS:

; 485  : 	else
; 486  : 		LogBoxf("METIN2 BINARY DISTRIBUTE VERSION %s ( MS C++ %d Compiled )", __TIMESTAMP__, _MSC_VER);			

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@IHCMKBOK@METIN2?5BINARY?5DISTRIBUTE?5VERSION@
  00026	e8 00 00 00 00	 call	 ?LogBoxf@@YAXPBDZZ	; LogBoxf
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 487  : #endif			
; 488  : }

  0002e	c3		 ret	 0
?__PrintTimeStamp@@YAXXZ ENDP				; __PrintTimeStamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?__IsLocaleOption@@YA_NPAD@Z
_TEXT	SEGMENT
?__IsLocaleOption@@YA_NPAD@Z PROC			; __IsLocaleOption, COMDAT
; _lpCmdLine$ = ecx

; 492  : 	return (strcmp(lpCmdLine, "--locale") == 0);

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LJMAFCGB@?9?9locale?$AA@
$LL3@IsLocaleOp:
  00005	8a 11		 mov	 dl, BYTE PTR [ecx]
  00007	3a 10		 cmp	 dl, BYTE PTR [eax]
  00009	75 20		 jne	 SHORT $LN4@IsLocaleOp
  0000b	84 d2		 test	 dl, dl
  0000d	74 12		 je	 SHORT $LN5@IsLocaleOp
  0000f	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00012	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00015	75 14		 jne	 SHORT $LN4@IsLocaleOp
  00017	83 c1 02	 add	 ecx, 2
  0001a	83 c0 02	 add	 eax, 2
  0001d	84 d2		 test	 dl, dl
  0001f	75 e4		 jne	 SHORT $LL3@IsLocaleOp
$LN5@IsLocaleOp:
  00021	33 c9		 xor	 ecx, ecx
  00023	33 c0		 xor	 eax, eax
  00025	85 c9		 test	 ecx, ecx
  00027	0f 94 c0	 sete	 al

; 493  : }

  0002a	c3		 ret	 0
$LN4@IsLocaleOp:

; 492  : 	return (strcmp(lpCmdLine, "--locale") == 0);

  0002b	1b c9		 sbb	 ecx, ecx
  0002d	33 c0		 xor	 eax, eax
  0002f	83 c9 01	 or	 ecx, 1
  00032	85 c9		 test	 ecx, ecx
  00034	0f 94 c0	 sete	 al

; 493  : }

  00037	c3		 ret	 0
?__IsLocaleOption@@YA_NPAD@Z ENDP			; __IsLocaleOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?__IsLocaleVersion@@YA_NPAD@Z
_TEXT	SEGMENT
?__IsLocaleVersion@@YA_NPAD@Z PROC			; __IsLocaleVersion, COMDAT
; _lpCmdLine$ = ecx

; 497  : 	return (strcmp(lpCmdLine, "--perforce-revision") == 0);

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BE@FJLABEAB@?9?9perforce?9revision?$AA@
$LL3@IsLocaleVe:
  00005	8a 11		 mov	 dl, BYTE PTR [ecx]
  00007	3a 10		 cmp	 dl, BYTE PTR [eax]
  00009	75 20		 jne	 SHORT $LN4@IsLocaleVe
  0000b	84 d2		 test	 dl, dl
  0000d	74 12		 je	 SHORT $LN5@IsLocaleVe
  0000f	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00012	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00015	75 14		 jne	 SHORT $LN4@IsLocaleVe
  00017	83 c1 02	 add	 ecx, 2
  0001a	83 c0 02	 add	 eax, 2
  0001d	84 d2		 test	 dl, dl
  0001f	75 e4		 jne	 SHORT $LL3@IsLocaleVe
$LN5@IsLocaleVe:
  00021	33 c9		 xor	 ecx, ecx
  00023	33 c0		 xor	 eax, eax
  00025	85 c9		 test	 ecx, ecx
  00027	0f 94 c0	 sete	 al

; 498  : }

  0002a	c3		 ret	 0
$LN4@IsLocaleVe:

; 497  : 	return (strcmp(lpCmdLine, "--perforce-revision") == 0);

  0002b	1b c9		 sbb	 ecx, ecx
  0002d	33 c0		 xor	 eax, eax
  0002f	83 c9 01	 or	 ecx, 1
  00032	85 c9		 test	 ecx, ecx
  00034	0f 94 c0	 sete	 al

; 498  : }

  00037	c3		 ret	 0
?__IsLocaleVersion@@YA_NPAD@Z ENDP			; __IsLocaleVersion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_hInstance$GSCopy$1$ = -544				; size = 4
_lpCmdLine$GSCopy$1$ = -540				; size = 4
_nArgc$ = -536						; size = 4
_szArgv$1$ = -532					; size = 4
_bQuit$1$ = -525					; size = 1
_szVersionPath$1 = -524					; size = 260
_szModuleName$2 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 10	 mov	 ebx, DWORD PTR _lpCmdLine$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _hInstance$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FPLLJIDE@?9?9hackshield?$AA@
  00020	53		 push	 ebx
  00021	89 b5 e0 fd ff
	ff		 mov	 DWORD PTR _hInstance$GSCopy$1$[ebp], esi
  00027	89 9d e4 fd ff
	ff		 mov	 DWORD PTR _lpCmdLine$GSCopy$1$[ebp], ebx
  0002d	e8 00 00 00 00	 call	 _strstr
  00032	83 c4 08	 add	 esp, 8
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp

; 516  : 	if (strstr(lpCmdLine, "--hackshield") != 0)

  00035	85 c0		 test	 eax, eax
  00037	0f 85 4d 02 00
	00		 jne	 $LN1@WinMain

; 517  : 		return 0;
; 518  : 
; 519  : #ifdef _DEBUG
; 520  : 	_CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_CHECK_CRT_DF | _CRTDBG_LEAK_CHECK_DF );
; 521  : 	//_CrtSetBreakAlloc( 110247 ); 
; 522  : #endif
; 523  : 
; 524  : 	ApplicationStringTable_Initialize(hInstance);

  0003d	57		 push	 edi
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?ApplicationStringTable_Initialize@@YAXPAUHINSTANCE__@@@Z ; ApplicationStringTable_Initialize

; 525  : 
; 526  : 	LocaleService_LoadConfig("locale.cfg");

  00045	e8 00 00 00 00	 call	 ?LocaleService_LoadConfig@@YAXPBD@Z ; LocaleService_LoadConfig

; 527  : 	SetDefaultCodePage(LocaleService_GetCodePage());	

  0004a	e8 00 00 00 00	 call	 ?LocaleService_GetCodePage@@YAIXZ ; LocaleService_GetCodePage
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?SetDefaultCodePage@@YA_NK@Z ; SetDefaultCodePage

; 528  : 
; 529  : #ifdef XTRAP_CLIENT_ENABLE
; 530  : 	if (!XTrap_Init())
; 531  : 		return 0;
; 532  : #endif
; 533  : 
; 534  : #ifdef USE_AHNLAB_HACKSHIELD
; 535  : 	if (!HackShield_Init())
; 536  : 		return 0;
; 537  : #endif
; 538  : 
; 539  : #ifdef USE_NPROTECT_GAMEGUARD
; 540  : 	if (!GameGuard_Init())
; 541  : 		return 0;
; 542  : #endif
; 543  : 
; 544  : #if defined(CHECK_LATEST_DATA_FILES)
; 545  : 	if (!CheckLatestFiles())
; 546  : 		return 0;
; 547  : #endif
; 548  : 
; 549  : 	bool bQuit = false;
; 550  : 	bool bAuthKeyChecked = false;	//OpenID      .
; 551  : 	int nArgc = 0;
; 552  : 	PCHAR* szArgv = CommandLineToArgv( lpCmdLine, &nArgc );

  00055	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _nArgc$[ebp]
  0005b	c6 85 f3 fd ff
	ff 00		 mov	 BYTE PTR _bQuit$1$[ebp], 0
  00062	50		 push	 eax
  00063	53		 push	 ebx
  00064	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _nArgc$[ebp], 0
  0006e	e8 00 00 00 00	 call	 ?CommandLineToArgv@@YAPAPADPADPAH@Z ; CommandLineToArgv

; 553  : 
; 554  : 	for( int i=0; i < nArgc; i++ ) {

  00073	33 ff		 xor	 edi, edi
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	8b f0		 mov	 esi, eax
  0007a	89 b5 ec fd ff
	ff		 mov	 DWORD PTR _szArgv$1$[ebp], esi
  00080	39 bd e8 fd ff
	ff		 cmp	 DWORD PTR _nArgc$[ebp], edi
  00086	0f 8e 7e 01 00
	00		 jle	 $LN31@WinMain

; 517  : 		return 0;
; 518  : 
; 519  : #ifdef _DEBUG
; 520  : 	_CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_CHECK_CRT_DF | _CRTDBG_LEAK_CHECK_DF );
; 521  : 	//_CrtSetBreakAlloc( 110247 ); 
; 522  : #endif
; 523  : 
; 524  : 	ApplicationStringTable_Initialize(hInstance);

  0008c	8d 5f 02	 lea	 ebx, DWORD PTR [edi+2]
  0008f	90		 npad	 1
$LL20@WinMain:

; 555  : 		if(szArgv[i] == 0)

  00090	8b 34 be	 mov	 esi, DWORD PTR [esi+edi*4]
  00093	85 f6		 test	 esi, esi
  00095	0f 84 4b 01 00
	00		 je	 $LN38@WinMain

; 556  : 			continue;
; 557  : 		if (__IsLocaleVersion(szArgv[i])) // #0000829: [M2EU]       

  0009b	8b ce		 mov	 ecx, esi
  0009d	e8 00 00 00 00	 call	 ?__IsLocaleVersion@@YA_NPAD@Z ; __IsLocaleVersion
  000a2	84 c0		 test	 al, al
  000a4	74 73		 je	 SHORT $LN16@WinMain

; 558  : 		{
; 559  : 			char szModuleName[MAX_PATH];
; 560  : 			char szVersionPath[MAX_PATH];
; 561  : 			GetModuleFileName(NULL, szModuleName, sizeof(szModuleName));

  000a6	68 04 01 00 00	 push	 260			; 00000104H
  000ab	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szModuleName$2[ebp]
  000b1	50		 push	 eax
  000b2	6a 00		 push	 0
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 562  : 			sprintf(szVersionPath, "%s.version", szModuleName);

  000ba	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szModuleName$2[ebp]
  000c0	50		 push	 eax
  000c1	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szVersionPath$1[ebp]
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IBAMLFBB@?$CFs?4version?$AA@
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _sprintf

; 563  : 			FILE* fp = fopen(szVersionPath, "wt");

  000d2	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szVersionPath$1[ebp]
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_02BKFDOEMK@wt?$AA@
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _fopen
  000e3	8b f0		 mov	 esi, eax
  000e5	83 c4 14	 add	 esp, 20			; 00000014H

; 564  : 			if (fp)

  000e8	85 f6		 test	 esi, esi
  000ea	74 1a		 je	 SHORT $LN15@WinMain

; 565  : 			{
; 566  : 				extern int METIN2_GET_VERSION();
; 567  : 				fprintf(fp, "r%d\n", METIN2_GET_VERSION());

  000ec	e8 00 00 00 00	 call	 ?METIN2_GET_VERSION@@YAHXZ ; METIN2_GET_VERSION
  000f1	50		 push	 eax
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_04JIBCGPDH@r?$CFd?6?$AA@
  000f7	56		 push	 esi
  000f8	e8 00 00 00 00	 call	 _fprintf

; 568  : 				fclose(fp);

  000fd	56		 push	 esi
  000fe	e8 00 00 00 00	 call	 _fclose
  00103	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@WinMain:

; 569  : 			}
; 570  : 			bQuit = true;

  00106	8b b5 ec fd ff
	ff		 mov	 esi, DWORD PTR _szArgv$1$[ebp]
  0010c	b0 01		 mov	 al, 1
  0010e	88 85 f3 fd ff
	ff		 mov	 BYTE PTR _bQuit$1$[ebp], al
  00114	e9 d9 00 00 00	 jmp	 $LN19@WinMain
$LN16@WinMain:

; 571  : 		} else if (__IsLocaleOption(szArgv[i]))

  00119	8b ce		 mov	 ecx, esi
  0011b	e8 00 00 00 00	 call	 ?__IsLocaleOption@@YA_NPAD@Z ; __IsLocaleOption
  00120	84 c0		 test	 al, al
  00122	74 47		 je	 SHORT $LN13@WinMain

; 572  : 		{
; 573  : 			FILE* fp=fopen("locale.txt", "wt");

  00124	68 00 00 00 00	 push	 OFFSET ??_C@_02BKFDOEMK@wt?$AA@
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IMHJDJJ@locale?4txt?$AA@
  0012e	e8 00 00 00 00	 call	 _fopen
  00133	83 c4 08	 add	 esp, 8
  00136	8b f0		 mov	 esi, eax

; 574  : 			fprintf(fp, "service[%s] code_page[%d]", 
; 575  : 				LocaleService_GetName(), LocaleService_GetCodePage());

  00138	e8 00 00 00 00	 call	 ?LocaleService_GetCodePage@@YAIXZ ; LocaleService_GetCodePage
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 ?LocaleService_GetName@@YAPBDXZ ; LocaleService_GetName
  00143	50		 push	 eax
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LJMCIPPN@service?$FL?$CFs?$FN?5code_page?$FL?$CFd?$FN?$AA@
  00149	56		 push	 esi
  0014a	e8 00 00 00 00	 call	 _fprintf

; 576  : 			fclose(fp);

  0014f	56		 push	 esi
  00150	e8 00 00 00 00	 call	 _fclose

; 577  : 			bQuit = true;

  00155	8b b5 ec fd ff
	ff		 mov	 esi, DWORD PTR _szArgv$1$[ebp]
  0015b	b0 01		 mov	 al, 1
  0015d	83 c4 14	 add	 esp, 20			; 00000014H
  00160	88 85 f3 fd ff
	ff		 mov	 BYTE PTR _bQuit$1$[ebp], al
  00166	e9 87 00 00 00	 jmp	 $LN19@WinMain
$LN13@WinMain:

; 578  : 		} else if (__IsTimeStampOption(szArgv[i]))

  0016b	8b ce		 mov	 ecx, esi
  0016d	e8 00 00 00 00	 call	 ?__IsTimeStampOption@@YA_NPAD@Z ; __IsTimeStampOption
  00172	84 c0		 test	 al, al
  00174	74 15		 je	 SHORT $LN11@WinMain

; 579  : 		{
; 580  : 			__PrintTimeStamp();

  00176	e8 00 00 00 00	 call	 ?__PrintTimeStamp@@YAXXZ ; __PrintTimeStamp

; 581  : 			bQuit = true;

  0017b	8b b5 ec fd ff
	ff		 mov	 esi, DWORD PTR _szArgv$1$[ebp]
  00181	b0 01		 mov	 al, 1
  00183	88 85 f3 fd ff
	ff		 mov	 BYTE PTR _bQuit$1$[ebp], al
  00189	eb 67		 jmp	 SHORT $LN19@WinMain
$LN11@WinMain:

; 582  : 		} else if ((strcmp(szArgv[i], "--force-set-locale") == 0))

  0018b	8b b5 ec fd ff
	ff		 mov	 esi, DWORD PTR _szArgv$1$[ebp]
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BD@BMCCGKJE@?9?9force?9set?9locale?$AA@
  00196	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]
  00199	8d a4 24 00 00
	00 00		 npad	 7
$LL33@WinMain:
  001a0	8a 10		 mov	 dl, BYTE PTR [eax]
  001a2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001a4	75 1a		 jne	 SHORT $LN34@WinMain
  001a6	84 d2		 test	 dl, dl
  001a8	74 12		 je	 SHORT $LN35@WinMain
  001aa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001ad	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001b0	75 0e		 jne	 SHORT $LN34@WinMain
  001b2	83 c0 02	 add	 eax, 2
  001b5	83 c1 02	 add	 ecx, 2
  001b8	84 d2		 test	 dl, dl
  001ba	75 e4		 jne	 SHORT $LL33@WinMain
$LN35@WinMain:
  001bc	33 c0		 xor	 eax, eax
  001be	eb 05		 jmp	 SHORT $LN36@WinMain
$LN34@WinMain:
  001c0	1b c0		 sbb	 eax, eax
  001c2	83 c8 01	 or	 eax, 1
$LN36@WinMain:
  001c5	85 c0		 test	 eax, eax
  001c7	75 23		 jne	 SHORT $LN39@WinMain

; 583  : 		{
; 584  : 			// locale       ( ,  )
; 585  : 			if (nArgc <= i + 2)

  001c9	39 9d e8 fd ff
	ff		 cmp	 DWORD PTR _nArgc$[ebp], ebx
  001cf	7e 58		 jle	 SHORT $LN27@WinMain

; 589  : 			}
; 590  : 
; 591  : 			const char* localeName = szArgv[++i];

  001d1	8b 4c be 04	 mov	 ecx, DWORD PTR [esi+edi*4+4]

; 592  : 			const char* localePath = szArgv[++i];

  001d5	83 c3 02	 add	 ebx, 2

; 593  : 
; 594  : 			LocaleService_ForceSetLocale(localeName, localePath);

  001d8	8b 54 be 08	 mov	 edx, DWORD PTR [esi+edi*4+8]
  001dc	83 c7 02	 add	 edi, 2
  001df	e8 00 00 00 00	 call	 ?LocaleService_ForceSetLocale@@YAXPBD0@Z ; LocaleService_ForceSetLocale
  001e4	eb 06		 jmp	 SHORT $LN39@WinMain
$LN38@WinMain:
  001e6	8b b5 ec fd ff
	ff		 mov	 esi, DWORD PTR _szArgv$1$[ebp]
$LN39@WinMain:
  001ec	8a 85 f3 fd ff
	ff		 mov	 al, BYTE PTR _bQuit$1$[ebp]
$LN19@WinMain:

; 553  : 
; 554  : 	for( int i=0; i < nArgc; i++ ) {

  001f2	47		 inc	 edi
  001f3	43		 inc	 ebx
  001f4	3b bd e8 fd ff
	ff		 cmp	 edi, DWORD PTR _nArgc$[ebp]
  001fa	0f 8c 90 fe ff
	ff		 jl	 $LL20@WinMain

; 595  : 		}
; 596  : #ifdef USE_OPENID
; 597  : 		else if (__IsOpenIDAuthKeyOption(szArgv[i]))	//2012.07.16 OpenID : 
; 598  : 		{
; 599  : 			//        ()
; 600  : 			if (nArgc <= i + 1)
; 601  : 			{
; 602  : 				MessageBox(NULL, "Invalid arguments", ApplicationStringTable_GetStringz(IDS_APP_NAME, "APP_NAME"), MB_ICONSTOP);
; 603  : 				goto Clean;
; 604  : 			}
; 605  : 
; 606  : 			const char* authKey = szArgv[++i];
; 607  : 
; 608  : 			//ongoing (2012.07.16)
; 609  : 			//  
; 610  : 			LocaleService_SetOpenIDAuthKey(authKey);
; 611  : 
; 612  : 			bAuthKeyChecked = true;
; 613  : 		}
; 614  : 		else if (__IsOpenIDTestOption(szArgv[i]))
; 615  : 		{
; 616  : 			openid_test = 1;
; 617  : 
; 618  : 		}
; 619  : #endif /* USE_OPENID */
; 620  : 	}
; 621  : 
; 622  : #ifdef USE_OPENID
; 623  : 	//OpenID
; 624  : 	//OpenID      (   )  .
; 625  : 	
; 626  : 	if (false == bAuthKeyChecked && !openid_test)
; 627  : 	{
; 628  : 		MessageBox(NULL, "Invalid execution", ApplicationStringTable_GetStringz(IDS_APP_NAME, "APP_NAME"), MB_ICONSTOP);
; 629  : 		goto Clean;
; 630  : 	}
; 631  : #endif /* USE_OPENID */
; 632  : 
; 633  : 
; 634  : 	if(bQuit)

  00200	84 c0		 test	 al, al
  00202	75 7a		 jne	 SHORT $Clean$42
  00204	8b 9d e4 fd ff
	ff		 mov	 ebx, DWORD PTR _lpCmdLine$GSCopy$1$[ebp]
$LN31@WinMain:

; 635  : 		goto Clean;
; 636  : 
; 637  : #if defined(NEEDED_COMMAND_ARGUMENT)
; 638  : 	//     ,  
; 639  : 	if (strstr(lpCmdLine, NEEDED_COMMAND_ARGUMENT) == 0) {
; 640  : 		MessageBox(NULL, ApplicationStringTable_GetStringz(IDS_ERR_MUST_LAUNCH_FROM_PATCHER, "ERR_MUST_LAUNCH_FROM_PATCHER"), ApplicationStringTable_GetStringz(IDS_APP_NAME, "APP_NAME"), MB_ICONSTOP);
; 641  : 			goto Clean;
; 642  : 	}
; 643  : #endif
; 644  : 
; 645  : #if defined(NEEDED_COMMAND_CLIPBOARD)
; 646  : 	{
; 647  : 		CHAR szSecKey[256];
; 648  : 		CPostIt cPostIt( "VOLUME1" );
; 649  : 
; 650  : 		if( cPostIt.Get( "SEC_KEY", szSecKey, sizeof(szSecKey) ) == FALSE ) {
; 651  : 			MessageBox(NULL, ApplicationStringTable_GetStringz(IDS_ERR_MUST_LAUNCH_FROM_PATCHER, "ERR_MUST_LAUNCH_FROM_PATCHER"), ApplicationStringTable_GetStringz(IDS_APP_NAME, "APP_NAME"), MB_ICONSTOP);
; 652  : 			goto Clean;
; 653  : 		}
; 654  : 		if( strstr(szSecKey, NEEDED_COMMAND_CLIPBOARD) == 0 ) {
; 655  : 			MessageBox(NULL, ApplicationStringTable_GetStringz(IDS_ERR_MUST_LAUNCH_FROM_PATCHER, "ERR_MUST_LAUNCH_FROM_PATCHER"), ApplicationStringTable_GetStringz(IDS_APP_NAME, "APP_NAME"), MB_ICONSTOP);
; 656  : 			goto Clean;
; 657  : 		}
; 658  : 		cPostIt.Empty();
; 659  : 	}
; 660  : #endif
; 661  : 
; 662  : 	WebBrowser_Startup(hInstance);

  0020a	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _hInstance$GSCopy$1$[ebp]
  00210	57		 push	 edi
  00211	e8 00 00 00 00	 call	 _WebBrowser_Startup
  00216	83 c4 04	 add	 esp, 4

; 663  : 
; 664  : 	if (!CheckPythonLibraryFilenames())

  00219	e8 00 00 00 00	 call	 ?CheckPythonLibraryFilenames@@YA_NXZ ; CheckPythonLibraryFilenames
  0021e	84 c0		 test	 al, al
  00220	75 20		 jne	 SHORT $LN4@WinMain

; 665  : 	{
; 666  : 		__ErrorPythonLibraryIsNotExist();

  00222	e8 00 00 00 00	 call	 ?__ErrorPythonLibraryIsNotExist@@YAXXZ ; __ErrorPythonLibraryIsNotExist

; 682  : 
; 683  : Clean:

  00227	eb 55		 jmp	 SHORT $Clean$42
$LN27@WinMain:

; 586  : 			{
; 587  : 				MessageBox(NULL, "Invalid arguments", ApplicationStringTable_GetStringz(IDS_APP_NAME, "APP_NAME"), MB_ICONSTOP);

  00229	6a 10		 push	 16			; 00000010H
  0022b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08GKBDCAOF@APP_NAME?$AA@
  00230	b9 01 00 00 00	 mov	 ecx, 1
  00235	e8 00 00 00 00	 call	 ?ApplicationStringTable_GetStringz@@YAPBDKPBD@Z ; ApplicationStringTable_GetStringz
  0023a	50		 push	 eax
  0023b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PALKPJEA@Invalid?5arguments?$AA@

; 588  : 				goto Clean;

  00240	eb 34		 jmp	 SHORT $LN40@WinMain
$LN4@WinMain:

; 667  : 		goto Clean;
; 668  : 	}
; 669  : 
; 670  : 	Main(hInstance, lpCmdLine);

  00242	8b d3		 mov	 edx, ebx
  00244	8b cf		 mov	 ecx, edi
  00246	e8 00 00 00 00	 call	 ?Main@@YA_NPAUHINSTANCE__@@PAD@Z ; Main

; 671  : 
; 672  : #ifdef USE_NPROTECT_GAMEGUARD
; 673  : 	GameGuard_NoticeMessage();
; 674  : #endif
; 675  : 
; 676  : 	WebBrowser_Cleanup();

  0024b	e8 00 00 00 00	 call	 _WebBrowser_Cleanup

; 677  : 
; 678  : 	::CoUninitialize();

  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0

; 679  : 
; 680  : 	if(gs_szErrorString[0])

  00256	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?gs_szErrorString@@3PADA, 0
  0025d	74 1f		 je	 SHORT $Clean$42

; 681  : 		MessageBox(NULL, gs_szErrorString, ApplicationStringTable_GetStringz(IDS_APP_NAME, "APP_NAME"), MB_ICONSTOP);

  0025f	6a 10		 push	 16			; 00000010H
  00261	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08GKBDCAOF@APP_NAME?$AA@
  00266	b9 01 00 00 00	 mov	 ecx, 1
  0026b	e8 00 00 00 00	 call	 ?ApplicationStringTable_GetStringz@@YAPBDKPBD@Z ; ApplicationStringTable_GetStringz
  00270	50		 push	 eax
  00271	68 00 00 00 00	 push	 OFFSET ?gs_szErrorString@@3PADA ; gs_szErrorString
$LN40@WinMain:
  00276	6a 00		 push	 0
  00278	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$Clean$42:

; 684  : #ifdef USE_AHNLAB_HACKSHIELD
; 685  : 	HackShield_Shutdown();
; 686  : #endif
; 687  : 	SAFE_FREE_GLOBAL(szArgv);

  0027e	5f		 pop	 edi
  0027f	85 f6		 test	 esi, esi
  00281	74 07		 je	 SHORT $LN1@WinMain
  00283	56		 push	 esi
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
$LN1@WinMain:

; 688  : 
; 689  : 	return 0;
; 690  : }

  0028a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028d	33 c0		 xor	 eax, eax
  0028f	5e		 pop	 esi
  00290	33 cd		 xor	 ecx, ebp
  00292	5b		 pop	 ebx
  00293	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00298	8b e5		 mov	 esp, ebp
  0029a	5d		 pop	 ebp
  0029b	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?GrannyError@@YAXW4granny_log_message_type@@W4granny_log_message_origin@@PBDPAX@Z
_TEXT	SEGMENT
_Type$ = 8						; size = 4
_Origin$ = 12						; size = 4
_Error$ = 16						; size = 4
_UserData$ = 20						; size = 4
?GrannyError@@YAXW4granny_log_message_type@@W4granny_log_message_origin@@PBDPAX@Z PROC ; GrannyError, COMDAT

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  :     TraceError("GRANNY: %s", Error);

  00003	ff 75 10	 push	 DWORD PTR _Error$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GNJGCFKN@GRANNY?3?5?$CFs?$AA@
  0000b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00010	83 c4 08	 add	 esp, 8

; 698  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GrannyError@@YAXW4granny_log_message_type@@W4granny_log_message_origin@@PBDPAX@Z ENDP ; GrannyError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\userinterface.cpp
;	COMDAT ?Setup@@YAHPAD@Z
_TEXT	SEGMENT
_Callback$ = -16					; size = 8
_tc$ = -8						; size = 8
?Setup@@YAHPAD@Z PROC					; Setup, COMDAT
; _lpCmdLine$dead$ = ecx

; 701  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 702  : 	/* 
; 703  : 	 *	  .
; 704  : 	 */
; 705  : 	TIMECAPS tc; 
; 706  : 	UINT wTimerRes; 
; 707  : 
; 708  : 	if (timeGetDevCaps(&tc, sizeof(TIMECAPS)) != TIMERR_NOERROR) 

  00006	8d 45 f8	 lea	 eax, DWORD PTR _tc$[ebp]
  00009	6a 08		 push	 8
  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetDevCaps@8
  00012	85 c0		 test	 eax, eax
  00014	74 06		 je	 SHORT $LN1@Setup

; 709  : 		return 0;

  00016	33 c0		 xor	 eax, eax

; 723  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN1@Setup:

; 710  : 
; 711  : 	wTimerRes = MINMAX(tc.wPeriodMin, 1, tc.wPeriodMax); 

  0001c	ff 75 fc	 push	 DWORD PTR _tc$[ebp+4]
  0001f	6a 01		 push	 1
  00021	ff 75 f8	 push	 DWORD PTR _tc$[ebp]
  00024	e8 00 00 00 00	 call	 ?MINMAX@@YAHHHH@Z	; MINMAX
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 712  : 	timeBeginPeriod(wTimerRes); 

  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeBeginPeriod@4

; 713  : 
; 714  : 	/*
; 715  : 	 *	  
; 716  : 	 */
; 717  : 
; 718  : 	granny_log_callback Callback;
; 719  :     Callback.Function = GrannyError;
; 720  :     Callback.UserData = 0;
; 721  :     GrannySetLogCallback(&Callback);

  00033	8d 45 f0	 lea	 eax, DWORD PTR _Callback$[ebp]
  00036	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Callback$[ebp], OFFSET ?GrannyError@@YAXW4granny_log_message_type@@W4granny_log_message_origin@@PBDPAX@Z ; GrannyError
  0003d	50		 push	 eax
  0003e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Callback$[ebp+4], 0
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GrannySetLogCallback@4

; 722  : 	return 1;

  0004b	b8 01 00 00 00	 mov	 eax, 1

; 723  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?Setup@@YAHPAD@Z ENDP					; Setup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1033 : 		{	// append 1 * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1034 : 		return (append((size_type)1, _Ch));

  00003	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1035 : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 2394 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1205 : 		return (insert(_Off, _Right, 0, npos));

  00005	6a ff		 push	 -1
  00007	6a 00		 push	 0
  00009	52		 push	 edx

; 2394 : 	{	// return string + string

  0000a	8b f1		 mov	 esi, ecx
  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 1205 : 		return (insert(_Off, _Right, 0, npos));

  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00016	6a 00		 push	 0
  00018	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 2395 : 	return (_STD move(_Right.insert(0, _Left)));

  0001d	50		 push	 eax
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi

; 2396 : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h
;	COMDAT ??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z
_TEXT	SEGMENT
_container$1$ = -56					; size = 4
_ret$GSCopy$1$ = -52					; size = 4
_sep$GSCopy$1$ = -48					; size = 4
_buf$ = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_ret$ = 8						; size = 4
??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z PROC ; string_join<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _sep$ = ecx
; _container$ = edx

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b c2		 mov	 eax, edx
  0002d	89 45 c8	 mov	 DWORD PTR _container$1$[ebp], eax
  00030	89 4d d0	 mov	 DWORD PTR _sep$GSCopy$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00033	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00036	8b d7		 mov	 edx, edi
  00038	8b 30		 mov	 esi, DWORD PTR [eax]
  0003a	2b d6		 sub	 edx, esi
  0003c	8b 5d 08	 mov	 ebx, DWORD PTR _ret$[ebp]
  0003f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00044	f7 ea		 imul	 edx
  00046	89 5d cc	 mov	 DWORD PTR _ret$GSCopy$1$[ebp], ebx
  00049	c1 fa 02	 sar	 edx, 2
  0004c	8b c2		 mov	 eax, edx
  0004e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00051	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h

; 118  : 	unsigned int capacity = sep.length() * container.size() - 1;

  00053	0f af 41 10	 imul	 eax, DWORD PTR [ecx+16]
  00057	48		 dec	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00058	3b f7		 cmp	 esi, edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h

; 122  :         for (C::const_iterator i = container.begin(); i != container.end(); ++i)

  0005a	74 0e		 je	 SHORT $LN3@string_joi
  0005c	8d 64 24 00	 npad	 4
$LL19@string_joi:

; 123  :             capacity += (*i).length();

  00060	03 46 10	 add	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

  00063	83 c6 18	 add	 esi, 24			; 00000018H

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00066	3b f7		 cmp	 esi, edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h

; 122  :         for (C::const_iterator i = container.begin(); i != container.end(); ++i)

  00068	75 f6		 jne	 SHORT $LL19@string_joi
$LN3@string_joi:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0006a	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _buf$[ebp+20], 15 ; 0000000fH

; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00071	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _buf$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00078	c6 45 d4 00	 mov	 BYTE PTR _buf$[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h

; 126  :     string buf;

  0007c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

  00083	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00086	74 24		 je	 SHORT $LN87@string_joi

; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))

  00088	6a 01		 push	 1
  0008a	50		 push	 eax
  0008b	8d 4d d4	 lea	 ecx, DWORD PTR _buf$[ebp]
  0008e	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00093	84 c0		 test	 al, al
  00095	74 15		 je	 SHORT $LN87@string_joi

; 513  : 			: this->_Bx._Buf);

  00097	83 7d e8 10	 cmp	 DWORD PTR _buf$[ebp+20], 16 ; 00000010H
  0009b	8d 45 d4	 lea	 eax, DWORD PTR _buf$[ebp]

; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0009e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _buf$[ebp+16], 0

; 513  : 			: this->_Bx._Buf);

  000a5	0f 43 45 d4	 cmovae	 eax, DWORD PTR _buf$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000a9	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN87@string_joi:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 141  : 		--this->_Ptr;

  000ac	8b 75 c8	 mov	 esi, DWORD PTR _container$1$[ebp]
  000af	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h

; 135  :         while (cur != end)

  000b2	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 141  : 		--this->_Ptr;

  000b4	83 ef 18	 sub	 edi, 24			; 00000018H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h

; 135  :         while (cur != end)

  000b7	3b f7		 cmp	 esi, edi
  000b9	74 29		 je	 SHORT $LN1@string_joi
  000bb	8b 5d d0	 mov	 ebx, DWORD PTR _sep$GSCopy$1$[ebp]
  000be	8b ff		 npad	 2
$LL2@string_joi:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

  000c0	6a ff		 push	 -1
  000c2	6a 00		 push	 0
  000c4	56		 push	 esi
  000c5	8d 4d d4	 lea	 ecx, DWORD PTR _buf$[ebp]
  000c8	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  000cd	6a ff		 push	 -1
  000cf	6a 00		 push	 0
  000d1	53		 push	 ebx
  000d2	8d 4d d4	 lea	 ecx, DWORD PTR _buf$[ebp]
  000d5	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

  000da	83 c6 18	 add	 esi, 24			; 00000018H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h

; 135  :         while (cur != end)

  000dd	3b f7		 cmp	 esi, edi
  000df	75 df		 jne	 SHORT $LL2@string_joi
  000e1	8b 5d cc	 mov	 ebx, DWORD PTR _ret$GSCopy$1$[ebp]
$LN1@string_joi:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

  000e4	6a ff		 push	 -1
  000e6	6a 00		 push	 0
  000e8	56		 push	 esi
  000e9	8d 4d d4	 lea	 ecx, DWORD PTR _buf$[ebp]
  000ec	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)

  000f1	8d 45 d4	 lea	 eax, DWORD PTR _buf$[ebp]
  000f4	3b d8		 cmp	 ebx, eax
  000f6	74 22		 je	 SHORT $LN412@string_joi

; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);

  000f8	50		 push	 eax
  000f9	8b cb		 mov	 ecx, ebx
  000fb	e8 00 00 00 00	 call	 ?_Swap_bx@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_bx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00100	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 53   : 	_Left = _Move(_Right);

  00103	8b 45 e4	 mov	 eax, DWORD PTR _buf$[ebp+16]
  00106	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00109	8b 45 e8	 mov	 eax, DWORD PTR _buf$[ebp+20]

; 54   : 	_Right = _Move(_Tmp);

  0010c	89 4d e4	 mov	 DWORD PTR _buf$[ebp+16], ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

  0010f	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]

; 53   : 	_Left = _Move(_Right);

  00112	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 54   : 	_Right = _Move(_Tmp);

  00115	89 4d e8	 mov	 DWORD PTR _buf$[ebp+20], ecx
  00118	eb 03		 jmp	 SHORT $LN370@string_joi
$LN412@string_joi:
  0011a	8b 4d e8	 mov	 ecx, DWORD PTR _buf$[ebp+20]
$LN370@string_joi:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0011d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00120	72 0b		 jb	 SHORT $LN392@string_joi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00122	ff 75 d4	 push	 DWORD PTR _buf$[ebp]
  00125	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0012a	83 c4 04	 add	 esp, 4
$LN392@string_joi:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\utils.h

; 144  : }

  0012d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00130	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00137	59		 pop	 ecx
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013e	33 cd		 xor	 ecx, ebp
  00140	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$string_join@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@PAV01@@Z ENDP ; string_join<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1204 : 		{	// insert _Right at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1205 : 		return (insert(_Off, _Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0000d	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1206 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++, COMDAT
; _this$ = ecx

; 117  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 		_Myiter _Tmp = *this;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 112  : 		++this->_Ptr;

  0000a	83 c2 18	 add	 edx, 24			; 00000018H
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator--, COMDAT
; _this$ = ecx

; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;

  00000	83 01 e8	 add	 DWORD PTR [ecx], -24	; ffffffe8H

; 142  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 143  : 		}

  00005	c3		 ret	 0
??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
tv359 = 12						; size = 4
__Right$ = 12						; size = 4
__Roff$ = 16						; size = 4
__Num$2$ = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)

  00008	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000b	3b 55 08	 cmp	 edx, DWORD PTR __Off$[ebp]
  0000e	0f 82 08 01 00
	00		 jb	 $LN6@insert
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR __Right$[ebp]
  00017	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  0001a	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0001d	3b c8		 cmp	 ecx, eax
  0001f	0f 82 f7 00 00
	00		 jb	 $LN6@insert

; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)

  00025	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  00028	2b c8		 sub	 ecx, eax
  0002a	3b cf		 cmp	 ecx, edi
  0002c	0f 42 f9	 cmovb	 edi, ecx

; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)

  0002f	83 c8 ff	 or	 eax, -1
  00032	2b c2		 sub	 eax, edx
  00034	3b c7		 cmp	 eax, edi
  00036	0f 86 d6 00 00
	00		 jbe	 $LN71@insert

; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  0003c	85 ff		 test	 edi, edi
  0003e	0f 84 c5 00 00
	00		 je	 $LN3@insert
  00044	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00047	8b ce		 mov	 ecx, esi
  00049	6a 00		 push	 0
  0004b	50		 push	 eax
  0004c	89 45 14	 mov	 DWORD PTR __Num$2$[ebp], eax
  0004f	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00054	84 c0		 test	 al, al
  00056	0f 84 ad 00 00
	00		 je	 $LN3@insert

; 513  : 			: this->_Bx._Buf);

  0005c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00062	72 07		 jb	 SHORT $LN23@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00064	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00066	89 4d 0c	 mov	 DWORD PTR tv359[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00069	eb 03		 jmp	 SHORT $LN24@insert
$LN23@insert:
  0006b	89 75 0c	 mov	 DWORD PTR tv359[ebp], esi
$LN24@insert:
  0006e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00071	72 04		 jb	 SHORT $LN29@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00073	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  00075	eb 02		 jmp	 SHORT $LN30@insert
$LN29@insert:
  00077	8b d6		 mov	 edx, esi
$LN30@insert:

; 1223 : 				this->_Mysize - _Off);	// empty out hole

  00079	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0007f	2b c1		 sub	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00081	74 18		 je	 SHORT $LN36@insert
  00083	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1223 : 				this->_Mysize - _Off);	// empty out hole

  00084	8b 45 0c	 mov	 eax, DWORD PTR tv359[ebp]
  00087	03 c1		 add	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00089	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1223 : 				this->_Mysize - _Off);	// empty out hole

  0008a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0008d	03 c7		 add	 eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _memmove
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@insert:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1224 : 			if (this == &_Right)

  0009b	3b f3		 cmp	 esi, ebx
  0009d	75 35		 jne	 SHORT $LN2@insert

; 1227 : 						_Count);	// substring

  0009f	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  000a2	3b c8		 cmp	 ecx, eax
  000a4	73 02		 jae	 SHORT $LN10@insert
  000a6	03 c7		 add	 eax, edi
$LN10@insert:

; 513  : 			: this->_Bx._Buf);

  000a8	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000ab	83 fa 10	 cmp	 edx, 16			; 00000010H
  000ae	72 04		 jb	 SHORT $LN39@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000b0	8b 1e		 mov	 ebx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000b2	eb 02		 jmp	 SHORT $LN40@insert
$LN39@insert:
  000b4	8b de		 mov	 ebx, esi
$LN40@insert:
  000b6	83 fa 10	 cmp	 edx, 16			; 00000010H
  000b9	72 04		 jb	 SHORT $LN45@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000bb	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000bd	eb 02		 jmp	 SHORT $LN46@insert
$LN45@insert:
  000bf	8b d6		 mov	 edx, esi
$LN46@insert:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000c1	85 ff		 test	 edi, edi
  000c3	74 3a		 je	 SHORT $LN68@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1227 : 						_Count);	// substring

  000c5	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000c7	57		 push	 edi
  000c8	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1227 : 						_Count);	// substring

  000c9	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1228 : 			else

  000d2	eb 28		 jmp	 SHORT $LN70@insert
$LN2@insert:

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

  000d4	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  000d8	72 02		 jb	 SHORT $LN55@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000da	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN55@insert:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000dc	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000e0	72 04		 jb	 SHORT $LN61@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000e2	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000e4	eb 02		 jmp	 SHORT $LN62@insert
$LN61@insert:
  000e6	8b d6		 mov	 edx, esi
$LN62@insert:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e8	85 ff		 test	 edi, edi
  000ea	74 13		 je	 SHORT $LN68@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole

  000ec	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  000ef	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000f1	57		 push	 edi
  000f2	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole

  000f3	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _memcpy
$LN70@insert:
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN68@insert:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1231 : 			_Eos(_Num);

  000ff	ff 75 14	 push	 DWORD PTR __Num$2$[ebp]
  00102	8b ce		 mov	 ecx, esi
  00104	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN3@insert:

; 1232 : 			}
; 1233 : 		return (*this);

  00109	5f		 pop	 edi
  0010a	8b c6		 mov	 eax, esi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 1234 : 		}

  0010e	5d		 pop	 ebp
  0010f	c2 10 00	 ret	 16			; 00000010H
$LN71@insert:

; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00117	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN73@insert:
$LN6@insert:

; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00121	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN74@insert:
$LN69@insert:
  00126	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$dead$ = ecx

; 79   :     return _time32(_Time);

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time32
  00007	83 c4 04	 add	 esp, 4

; 80   : }

  0000a	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
END
