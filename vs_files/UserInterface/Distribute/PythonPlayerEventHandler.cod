; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonPlayerEventHandler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CL@BHCKMNDC@Shoot?5?3?5?$LE?Y?$LI?$KF?5target?$LP?$KB?5?$LI?B?$LO?R?$LN?$MA?$LE?O?$LE?Y@ ; `string'
PUBLIC	??_R2CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8 ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`RTTI Base Class Array'
PUBLIC	??_R2CPythonPlayerEventHandler@@8		; CPythonPlayerEventHandler::`RTTI Base Class Array'
PUBLIC	??_R2IEventHandler@CActorInstance@@8		; CActorInstance::IEventHandler::`RTTI Base Class Array'
PUBLIC	??_R2IFlyEventHandler@@8			; IFlyEventHandler::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8 ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPythonPlayerEventHandler@@8	; CPythonPlayerEventHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IEventHandler@CActorInstance@@8	; CActorInstance::IEventHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IFlyEventHandler@@8		; IFlyEventHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@@8 ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear `RTTI Type Descriptor'
PUBLIC	??_R3CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8 ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCPythonPlayerEventHandler@@@8		; CPythonPlayerEventHandler `RTTI Type Descriptor'
PUBLIC	??_R3CPythonPlayerEventHandler@@8		; CPythonPlayerEventHandler::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVIEventHandler@CActorInstance@@@8	; CActorInstance::IEventHandler `RTTI Type Descriptor'
PUBLIC	??_R3IEventHandler@CActorInstance@@8		; CActorInstance::IEventHandler::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVIFlyEventHandler@@@8			; IFlyEventHandler `RTTI Type Descriptor'
PUBLIC	??_R3IFlyEventHandler@@8			; IFlyEventHandler::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonPlayerEventHandler@@6B@		; CPythonPlayerEventHandler::`RTTI Complete Object Locator'
PUBLIC	??_R4IEventHandler@CActorInstance@@6B@		; CActorInstance::IEventHandler::`RTTI Complete Object Locator'
PUBLIC	??_R4IFlyEventHandler@@6B@			; IFlyEventHandler::`RTTI Complete Object Locator'
PUBLIC	??_7CPythonPlayerEventHandler@@6B@		; CPythonPlayerEventHandler::`vftable'
PUBLIC	??_7CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`vftable'
PUBLIC	??_7IEventHandler@CActorInstance@@6B@		; CActorInstance::IEventHandler::`vftable'
PUBLIC	??_7IFlyEventHandler@@6B@			; IFlyEventHandler::`vftable'
EXTRN	?IS_HUGE_RACE@@YA_NI@Z:PROC			; IS_HUGE_RACE
;	COMDAT ??_7IFlyEventHandler@@6B@
CONST	SEGMENT
??_7IFlyEventHandler@@6B@ DD FLAT:??_R4IFlyEventHandler@@6B@ ; IFlyEventHandler::`vftable'
	DD	FLAT:??_EIFlyEventHandler@@UAEPAXI@Z
	DD	FLAT:?OnSetFlyTarget@IFlyEventHandler@@UAEXXZ
	DD	FLAT:?OnShoot@IFlyEventHandler@@UAEXK@Z
	DD	FLAT:?OnNoTarget@IFlyEventHandler@@UAEXXZ
	DD	FLAT:?OnNoArrow@IFlyEventHandler@@UAEXXZ
	DD	FLAT:?OnExplodingOutOfRange@IFlyEventHandler@@UAEXXZ
	DD	FLAT:?OnExplodingAtBackground@IFlyEventHandler@@UAEXXZ
	DD	FLAT:?OnExplodingAtAnotherTarget@IFlyEventHandler@@UAEXKK@Z
	DD	FLAT:?OnExplodingAtTarget@IFlyEventHandler@@UAEXK@Z
CONST	ENDS
;	COMDAT ??_7IEventHandler@CActorInstance@@6B@
CONST	SEGMENT
??_7IEventHandler@CActorInstance@@6B@ DD FLAT:??_R4IEventHandler@CActorInstance@@6B@ ; CActorInstance::IEventHandler::`vftable'
	DD	FLAT:??_EIEventHandler@CActorInstance@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@
CONST	SEGMENT
??_7CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@ DD FLAT:??_R4CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`vftable'
	DD	FLAT:??_ECNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEPAXI@Z
	DD	FLAT:?OnSetFlyTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ
	DD	FLAT:?OnShoot@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z
	DD	FLAT:?OnNoTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ
	DD	FLAT:?OnNoArrow@IFlyEventHandler@@UAEXXZ
	DD	FLAT:?OnExplodingOutOfRange@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ
	DD	FLAT:?OnExplodingAtBackground@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ
	DD	FLAT:?OnExplodingAtAnotherTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXKK@Z
	DD	FLAT:?OnExplodingAtTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z
CONST	ENDS
;	COMDAT ??_7CPythonPlayerEventHandler@@6B@
CONST	SEGMENT
??_7CPythonPlayerEventHandler@@6B@ DD FLAT:??_R4CPythonPlayerEventHandler@@6B@ ; CPythonPlayerEventHandler::`vftable'
	DD	FLAT:??_ECPythonPlayerEventHandler@@UAEPAXI@Z
	DD	FLAT:?OnSyncing@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
	DD	FLAT:?OnWaiting@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
	DD	FLAT:?OnMoving@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
	DD	FLAT:?OnMove@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
	DD	FLAT:?OnStop@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
	DD	FLAT:?OnWarp@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
	DD	FLAT:?OnSetAffect@CPythonPlayerEventHandler@@UAEXI@Z
	DD	FLAT:?OnResetAffect@CPythonPlayerEventHandler@@UAEXI@Z
	DD	FLAT:?OnClearAffects@CPythonPlayerEventHandler@@UAEXXZ
	DD	FLAT:?OnAttack@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@G@Z
	DD	FLAT:?OnUseSkill@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@II@Z
	DD	FLAT:?OnHit@CPythonPlayerEventHandler@@UAEXIAAVCActorInstance@@H@Z
	DD	FLAT:?OnChangeShape@CPythonPlayerEventHandler@@UAEXXZ
	DD	FLAT:?OnUpdate@CPythonPlayerEventHandler@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4IFlyEventHandler@@6B@
rdata$r	SEGMENT
??_R4IFlyEventHandler@@6B@ DD 00H			; IFlyEventHandler::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIFlyEventHandler@@@8
	DD	FLAT:??_R3IFlyEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R4IEventHandler@CActorInstance@@6B@
rdata$r	SEGMENT
??_R4IEventHandler@CActorInstance@@6B@ DD 00H		; CActorInstance::IEventHandler::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIEventHandler@CActorInstance@@@8
	DD	FLAT:??_R3IEventHandler@CActorInstance@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonPlayerEventHandler@@6B@
rdata$r	SEGMENT
??_R4CPythonPlayerEventHandler@@6B@ DD 00H		; CPythonPlayerEventHandler::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonPlayerEventHandler@@@8
	DD	FLAT:??_R3CPythonPlayerEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R4CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@
rdata$r	SEGMENT
??_R4CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@ DD 00H ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@@8
	DD	FLAT:??_R3CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R3IFlyEventHandler@@8
rdata$r	SEGMENT
??_R3IFlyEventHandler@@8 DD 00H				; IFlyEventHandler::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IFlyEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIFlyEventHandler@@@8
data$r	SEGMENT
??_R0?AVIFlyEventHandler@@@8 DD FLAT:??_7type_info@@6B@	; IFlyEventHandler `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIFlyEventHandler@@', 00H
data$r	ENDS
;	COMDAT ??_R3IEventHandler@CActorInstance@@8
rdata$r	SEGMENT
??_R3IEventHandler@CActorInstance@@8 DD 00H		; CActorInstance::IEventHandler::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IEventHandler@CActorInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIEventHandler@CActorInstance@@@8
data$r	SEGMENT
??_R0?AVIEventHandler@CActorInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CActorInstance::IEventHandler `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIEventHandler@CActorInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R3CPythonPlayerEventHandler@@8
rdata$r	SEGMENT
??_R3CPythonPlayerEventHandler@@8 DD 00H		; CPythonPlayerEventHandler::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPythonPlayerEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonPlayerEventHandler@@@8
data$r	SEGMENT
??_R0?AVCPythonPlayerEventHandler@@@8 DD FLAT:??_7type_info@@6B@ ; CPythonPlayerEventHandler `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonPlayerEventHandler@@', 00H
data$r	ENDS
;	COMDAT ??_R3CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8
rdata$r	SEGMENT
??_R3CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8 DD 00H ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@@8
data$r	SEGMENT
??_R0?AVCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@@8 DD FLAT:??_7type_info@@6B@ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPl'
	DB	'ayerEventHandler@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IFlyEventHandler@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IFlyEventHandler@@8 DD FLAT:??_R0?AVIFlyEventHandler@@@8 ; IFlyEventHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IFlyEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IEventHandler@CActorInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IEventHandler@CActorInstance@@8 DD FLAT:??_R0?AVIEventHandler@CActorInstance@@@8 ; CActorInstance::IEventHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IEventHandler@CActorInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonPlayerEventHandler@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonPlayerEventHandler@@8 DD FLAT:??_R0?AVCPythonPlayerEventHandler@@@8 ; CPythonPlayerEventHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonPlayerEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8 DD FLAT:??_R0?AVCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@@8 ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_R2IFlyEventHandler@@8
rdata$r	SEGMENT
??_R2IFlyEventHandler@@8 DD FLAT:??_R1A@?0A@EA@IFlyEventHandler@@8 ; IFlyEventHandler::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2IEventHandler@CActorInstance@@8
rdata$r	SEGMENT
??_R2IEventHandler@CActorInstance@@8 DD FLAT:??_R1A@?0A@EA@IEventHandler@CActorInstance@@8 ; CActorInstance::IEventHandler::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CPythonPlayerEventHandler@@8
rdata$r	SEGMENT
??_R2CPythonPlayerEventHandler@@8 DD FLAT:??_R1A@?0A@EA@CPythonPlayerEventHandler@@8 ; CPythonPlayerEventHandler::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IEventHandler@CActorInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8
rdata$r	SEGMENT
??_R2CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8 DD FLAT:??_R1A@?0A@EA@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@8 ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IFlyEventHandler@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CL@BHCKMNDC@Shoot?5?3?5?$LE?Y?$LI?$KF?5target?$LP?$KB?5?$LI?B?$LO?R?$LN?$MA?$LE?O?$LE?Y@
CONST	SEGMENT
??_C@_0CL@BHCKMNDC@Shoot?5?3?5?$LE?Y?$LI?$KF?5target?$LP?$KB?5?$LI?B?$LO?R?$LN?$MA?$LE?O?$LE?Y@ DB 'S'
	DB	'hoot : ', 0b4H, 0d9H, 0b8H, 0a5H, ' target', 0bfH, 0a1H, ' ', 0b8H
	DB	0c2H, 0beH, 0d2H, 0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, ' : %d, '
	DB	'%d', 0aH, 00H				; `string'
PUBLIC	??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@$$QAU23@@Z ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>
PUBLIC	??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@$$QAU34@@Z ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>
PUBLIC	??$forward@USVictim@CPythonPlayerEventHandler@@@std@@YA$$QAUSVictim@CPythonPlayerEventHandler@@AAU12@@Z ; std::forward<CPythonPlayerEventHandler::SVictim>
PUBLIC	??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@$$QAU23@@Z ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>
PUBLIC	??$destroy@USVictim@CPythonPlayerEventHandler@@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@@Z ; std::allocator<CPythonPlayerEventHandler::SVictim>::destroy<CPythonPlayerEventHandler::SVictim>
PUBLIC	??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@U12@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::allocator<CPythonPlayerEventHandler::SVictim>,CPythonPlayerEventHandler::SVictim>
PUBLIC	??$_Val_type@PAUSVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@@Z ; std::_Val_type<CPythonPlayerEventHandler::SVictim *>
PUBLIC	??$destroy@USVictim@CPythonPlayerEventHandler@@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@@Z ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::destroy<CPythonPlayerEventHandler::SVictim>
PUBLIC	??$_Rechecked@PAUSVictim@CPythonPlayerEventHandler@@PAU12@@std@@YAAAPAUSVictim@CPythonPlayerEventHandler@@AAPAU12@PAU12@@Z ; std::_Rechecked<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *>
PUBLIC	??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >
PUBLIC	??$_Unchecked@PAUSVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@@Z ; std::_Unchecked<CPythonPlayerEventHandler::SVictim *>
PUBLIC	??$destroy@USVictim@CPythonPlayerEventHandler@@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@@Z ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::destroy<CPythonPlayerEventHandler::SVictim>
PUBLIC	??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@AAU23@@Z ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>
PUBLIC	?construct@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@ABU34@@Z ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct
PUBLIC	??$_Uninitialized_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z ; std::_Uninitialized_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAXPAUSVictim@CPythonPlayerEventHandler@@0AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >
PUBLIC	??$_Ptr_cat@USVictim@CPythonPlayerEventHandler@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSVictim@CPythonPlayerEventHandler@@0@Z ; std::_Ptr_cat<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>
PUBLIC	??$construct@USVictim@CPythonPlayerEventHandler@@ABU12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@ABU34@@Z ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim const &>
PUBLIC	??$forward@ABUSVictim@CPythonPlayerEventHandler@@@std@@YAABUSVictim@CPythonPlayerEventHandler@@ABU12@@Z ; std::forward<CPythonPlayerEventHandler::SVictim const &>
PUBLIC	??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@AAU34@@Z ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>
PUBLIC	??$forward@AAUSVictim@CPythonPlayerEventHandler@@@std@@YAAAUSVictim@CPythonPlayerEventHandler@@AAU12@@Z ; std::forward<CPythonPlayerEventHandler::SVictim &>
PUBLIC	??$_Allocate@USVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@IPAU12@@Z ; std::_Allocate<CPythonPlayerEventHandler::SVictim>
PUBLIC	??$_Umove@PAUSVictim@CPythonPlayerEventHandler@@@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEPAUSVictim@CPythonPlayerEventHandler@@PAU23@00@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Umove<CPythonPlayerEventHandler::SVictim *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAXPAUSVictim@CPythonPlayerEventHandler@@0AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >
PUBLIC	??$construct@USVictim@CPythonPlayerEventHandler@@ABU12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@ABU23@@Z ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim const &>
PUBLIC	??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@AAU23@@Z ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>
PUBLIC	??$addressof@$$CBUSVictim@CPythonPlayerEventHandler@@@std@@YAPBUSVictim@CPythonPlayerEventHandler@@ABU12@@Z ; std::addressof<CPythonPlayerEventHandler::SVictim const >
PUBLIC	?max_size@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QBEIXZ ; std::allocator<CPythonPlayerEventHandler::SVictim>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAIABV?$allocator@USVictim@CPythonPlayerEventHandler@@@2@@Z ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size
PUBLIC	?allocate@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEPAUSVictim@CPythonPlayerEventHandler@@I@Z ; std::allocator<CPythonPlayerEventHandler::SVictim>::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEPAUSVictim@CPythonPlayerEventHandler@@I@Z ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::allocate
PUBLIC	?deallocate@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@I@Z ; std::allocator<CPythonPlayerEventHandler::SVictim>::deallocate
PUBLIC	?capacity@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::capacity
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPythonPlayerEventHandler::SVictim> >::_Vector_val<std::_Simple_types<CPythonPlayerEventHandler::SVictim> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@I@Z ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >
PUBLIC	?_Xlen@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEXXZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Xlen
PUBLIC	?_Reallocate@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEII@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Grow_to
PUBLIC	?max_size@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size
PUBLIC	?_Unused_capacity@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Unused_capacity
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@QAE@ABV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >
PUBLIC	??0?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAE@XZ ; std::allocator<CPythonPlayerEventHandler::SVictim>::allocator<CPythonPlayerEventHandler::SVictim>
PUBLIC	?_Orphan_range@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEXPAUSVictim@CPythonPlayerEventHandler@@0@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Orphan_range
PUBLIC	?_Tidy@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXXZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Tidy
PUBLIC	?_Reserve@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reserve
PUBLIC	?_Inside@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBE_NPBUSVictim@CPythonPlayerEventHandler@@@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Inside
PUBLIC	?_Destroy@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXPAUSVictim@CPythonPlayerEventHandler@@0@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Destroy
PUBLIC	?clear@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXXZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::clear
PUBLIC	?push_back@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXABUSVictim@CPythonPlayerEventHandler@@@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::push_back
PUBLIC	??A?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEAAUSVictim@CPythonPlayerEventHandler@@I@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::operator[]
PUBLIC	?empty@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBE_NXZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::empty
PUBLIC	?size@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::size
PUBLIC	??1?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::~vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >
PUBLIC	??0?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >
PUBLIC	?OnExplodingAtTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtTarget
PUBLIC	?OnExplodingAtAnotherTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXKK@Z ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtAnotherTarget
PUBLIC	?Set@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@QAEXPAV2@PAVCInstanceBase@@1@Z ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::Set
PUBLIC	?OnShoot@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnShoot
PUBLIC	??0SState@IEventHandler@CActorInstance@@QAE@XZ	; CActorInstance::IEventHandler::SState::SState
PUBLIC	?OnSetFlyTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnSetFlyTarget
PUBLIC	??0CPythonPlayerEventHandler@@IAE@XZ		; CPythonPlayerEventHandler::CPythonPlayerEventHandler
PUBLIC	?OnHit@CPythonPlayerEventHandler@@UAEXIAAVCActorInstance@@H@Z ; CPythonPlayerEventHandler::OnHit
PUBLIC	?OnChangeShape@CPythonPlayerEventHandler@@UAEXXZ ; CPythonPlayerEventHandler::OnChangeShape
PUBLIC	?OnUpdate@CPythonPlayerEventHandler@@UAEXXZ	; CPythonPlayerEventHandler::OnUpdate
PUBLIC	?OnUseSkill@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@II@Z ; CPythonPlayerEventHandler::OnUseSkill
PUBLIC	?OnAttack@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@G@Z ; CPythonPlayerEventHandler::OnAttack
PUBLIC	?OnWarp@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ; CPythonPlayerEventHandler::OnWarp
PUBLIC	?OnStop@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ; CPythonPlayerEventHandler::OnStop
PUBLIC	?OnMove@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ; CPythonPlayerEventHandler::OnMove
PUBLIC	?OnMoving@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ; CPythonPlayerEventHandler::OnMoving
PUBLIC	?OnWaiting@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ; CPythonPlayerEventHandler::OnWaiting
PUBLIC	?OnSyncing@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ; CPythonPlayerEventHandler::OnSyncing
PUBLIC	?OnResetAffect@CPythonPlayerEventHandler@@UAEXI@Z ; CPythonPlayerEventHandler::OnResetAffect
PUBLIC	?OnSetAffect@CPythonPlayerEventHandler@@UAEXI@Z	; CPythonPlayerEventHandler::OnSetAffect
PUBLIC	?OnClearAffects@CPythonPlayerEventHandler@@UAEXXZ ; CPythonPlayerEventHandler::OnClearAffects
PUBLIC	??_GCPythonPlayerEventHandler@@UAEPAXI@Z	; CPythonPlayerEventHandler::`scalar deleting destructor'
PUBLIC	??1CPythonPlayerEventHandler@@UAE@XZ		; CPythonPlayerEventHandler::~CPythonPlayerEventHandler
PUBLIC	??_GCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEPAXI@Z ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`scalar deleting destructor'
PUBLIC	?OnExplodingAtBackground@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtBackground
PUBLIC	?OnExplodingOutOfRange@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingOutOfRange
PUBLIC	?OnNoTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnNoTarget
PUBLIC	??1CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAE@XZ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::~CNormalBowAttack_FlyEventHandler_AutoClear
PUBLIC	??0CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@QAE@XZ ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::CNormalBowAttack_FlyEventHandler_AutoClear
PUBLIC	??_GIFlyEventHandler@@UAEPAXI@Z			; IFlyEventHandler::`scalar deleting destructor'
PUBLIC	?OnExplodingAtTarget@IFlyEventHandler@@UAEXK@Z	; IFlyEventHandler::OnExplodingAtTarget
PUBLIC	?OnExplodingAtAnotherTarget@IFlyEventHandler@@UAEXKK@Z ; IFlyEventHandler::OnExplodingAtAnotherTarget
PUBLIC	?OnExplodingAtBackground@IFlyEventHandler@@UAEXXZ ; IFlyEventHandler::OnExplodingAtBackground
PUBLIC	?OnExplodingOutOfRange@IFlyEventHandler@@UAEXXZ	; IFlyEventHandler::OnExplodingOutOfRange
PUBLIC	?OnNoArrow@IFlyEventHandler@@UAEXXZ		; IFlyEventHandler::OnNoArrow
PUBLIC	?OnNoTarget@IFlyEventHandler@@UAEXXZ		; IFlyEventHandler::OnNoTarget
PUBLIC	?OnShoot@IFlyEventHandler@@UAEXK@Z		; IFlyEventHandler::OnShoot
PUBLIC	?OnSetFlyTarget@IFlyEventHandler@@UAEXXZ	; IFlyEventHandler::OnSetFlyTarget
PUBLIC	??1IFlyEventHandler@@UAE@XZ			; IFlyEventHandler::~IFlyEventHandler
PUBLIC	??0IFlyEventHandler@@QAE@XZ			; IFlyEventHandler::IFlyEventHandler
PUBLIC	??_GIEventHandler@CActorInstance@@UAEPAXI@Z	; CActorInstance::IEventHandler::`scalar deleting destructor'
PUBLIC	??1IEventHandler@CActorInstance@@UAE@XZ		; CActorInstance::IEventHandler::~IEventHandler
PUBLIC	??0IEventHandler@CActorInstance@@QAE@XZ		; CActorInstance::IEventHandler::IEventHandler
PUBLIC	?GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ ; CPythonPlayerEventHandler::GetSingleton
PUBLIC	?FlushVictimList@CPythonPlayerEventHandler@@QAEXXZ ; CPythonPlayerEventHandler::FlushVictimList
EXTRN	??_EIFlyEventHandler@@UAEPAXI@Z:PROC		; IFlyEventHandler::`vector deleting destructor'
EXTRN	??_EIEventHandler@CActorInstance@@UAEPAXI@Z:PROC ; CActorInstance::IEventHandler::`vector deleting destructor'
EXTRN	??_ECPythonPlayerEventHandler@@UAEPAXI@Z:PROC	; CPythonPlayerEventHandler::`vector deleting destructor'
EXTRN	??_ECNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEPAXI@Z:PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`vector deleting destructor'
;	COMDAT ?$S1@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4IA
_BSS	SEGMENT
?$S1@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4IA DD 01H DUP (?) ; S1<`template-parameter-2',CPythonPlayerEventHandler::tSingleton, ?? :: ?? ::IA::XZ::XZ::AV2 * const volatile>
_BSS	ENDS
;	COMDAT ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A
_BSS	SEGMENT
?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A DB 038H DUP (?) ; `CPythonPlayerEventHandler::GetSingleton'::`2'::s_kPlayerEventHandler
_BSS	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?FlushVictimList@CPythonPlayerEventHandler@@QAEXXZ
_TEXT	SEGMENT
_rkStream$1$ = -8					; size = 4
_kPacketSyncPos$ = -4					; size = 3
?FlushVictimList@CPythonPlayerEventHandler@@QAEXXZ PROC	; CPythonPlayerEventHandler::FlushVictimList, COMDAT
; _this$ = ecx

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00009	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000c	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 196  : 	if (m_kVctkVictim.empty())

  0000f	74 6f		 je	 SHORT $LN15@FlushVicti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00011	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00014	2b d0		 sub	 edx, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 203  : 	CPythonNetworkStream& rkStream=CPythonNetworkStream::Instance();

  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0001c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 203  : 	CPythonNetworkStream& rkStream=CPythonNetworkStream::Instance();

  00021	89 4d f8	 mov	 DWORD PTR _rkStream$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00024	f7 ea		 imul	 edx
  00026	53		 push	 ebx
  00027	d1 fa		 sar	 edx, 1
  00029	8b da		 mov	 ebx, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 206  : 	kPacketSyncPos.bHeader=HEADER_CG_SYNC_POSITION;

  0002b	c6 45 fc 08	 mov	 BYTE PTR _kPacketSyncPos$[ebp], 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0002f	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00032	03 da		 add	 ebx, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 207  : 	kPacketSyncPos.wSize=sizeof(kPacketSyncPos)+sizeof(TPacketCGSyncPositionElement) * uiVictimCount;

  00034	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00037	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [eax*4+3]
  0003e	66 89 45 fd	 mov	 WORD PTR _kPacketSyncPos$[ebp+1], ax

; 208  : 
; 209  : 	rkStream.Send(sizeof(kPacketSyncPos), &kPacketSyncPos);

  00042	8d 45 fc	 lea	 eax, DWORD PTR _kPacketSyncPos$[ebp]
  00045	50		 push	 eax
  00046	6a 03		 push	 3
  00048	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send

; 210  : 
; 211  : 	for (unsigned int i = 0; i < uiVictimCount; ++i)

  0004d	85 db		 test	 ebx, ebx
  0004f	74 20		 je	 SHORT $LN1@FlushVicti

; 197  : 		return;
; 198  : 
; 199  : 	// #0000682: [M2EU] ´ëÁø°¢ ½ºÅ³ »ç¿ë½Ã Æ¨±è 
; 200  : 	unsigned int SYNC_POSITION_COUNT_LIMIT = 16;
; 201  : 	unsigned int uiVictimCount = m_kVctkVictim.size();

  00051	56		 push	 esi
  00052	33 f6		 xor	 esi, esi
$LL3@FlushVicti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00054	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 214  : 		rkStream.SendSyncPositionElementPacket(rkVictim.m_dwVID, rkVictim.m_lPixelX, rkVictim.m_lPixelY);		

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _rkStream$1$[ebp]
  0005a	ff 74 30 08	 push	 DWORD PTR [eax+esi+8]
  0005e	ff 74 30 04	 push	 DWORD PTR [eax+esi+4]
  00062	ff 34 30	 push	 DWORD PTR [eax+esi]
  00065	e8 00 00 00 00	 call	 ?SendSyncPositionElementPacket@CPythonNetworkStream@@QAE_NKKK@Z ; CPythonNetworkStream::SendSyncPositionElementPacket
  0006a	8d 76 0c	 lea	 esi, DWORD PTR [esi+12]
  0006d	4b		 dec	 ebx
  0006e	75 e4		 jne	 SHORT $LL3@FlushVicti
  00070	5e		 pop	 esi
$LN1@FlushVicti:

; 215  : 	}
; 216  : 
; 217  : 	rkStream.SendSequence();

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _rkStream$1$[ebp]
  00074	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00079	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007c	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0007f	5b		 pop	 ebx
$LN15@FlushVicti:
  00080	5f		 pop	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 219  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?FlushVictimList@CPythonPlayerEventHandler@@QAEXXZ ENDP	; CPythonPlayerEventHandler::FlushVictimList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ
_TEXT	SEGMENT
?GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ PROC	; CPythonPlayerEventHandler::GetSingleton, COMDAT

; 9    : 	static CPythonPlayerEventHandler s_kPlayerEventHandler;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4IA
  00005	a8 01		 test	 al, 1
  00007	75 1a		 jne	 SHORT $LN4@GetSinglet
  00009	83 c8 01	 or	 eax, 1
  0000c	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4IA, eax
  00011	e8 00 00 00 00	 call	 ??0CPythonPlayerEventHandler@@IAE@XZ ; CPythonPlayerEventHandler::CPythonPlayerEventHandler
  00016	68 00 00 00 00	 push	 OFFSET ??__Fs_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ@YAXXZ ; `CPythonPlayerEventHandler::GetSingleton'::`2'::`dynamic atexit destructor for 's_kPlayerEventHandler''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	83 c4 04	 add	 esp, 4
$LN4@GetSinglet:

; 10   : 	return s_kPlayerEventHandler;

  00023	b8 00 00 00 00	 mov	 eax, OFFSET ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A

; 11   : }

  00028	c3		 ret	 0
?GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ ENDP	; CPythonPlayerEventHandler::GetSingleton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\actorinstance.h
;	COMDAT ??0IEventHandler@CActorInstance@@QAE@XZ
_TEXT	SEGMENT
??0IEventHandler@CActorInstance@@QAE@XZ PROC		; CActorInstance::IEventHandler::IEventHandler, COMDAT
; _this$ = ecx

; 46   : 				IEventHandler() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IEventHandler@CActorInstance@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0IEventHandler@CActorInstance@@QAE@XZ ENDP		; CActorInstance::IEventHandler::IEventHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\actorinstance.h
;	COMDAT ??1IEventHandler@CActorInstance@@UAE@XZ
_TEXT	SEGMENT
??1IEventHandler@CActorInstance@@UAE@XZ PROC		; CActorInstance::IEventHandler::~IEventHandler, COMDAT
; _this$ = ecx

; 47   : 				virtual ~IEventHandler() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IEventHandler@CActorInstance@@6B@
  00006	c3		 ret	 0
??1IEventHandler@CActorInstance@@UAE@XZ ENDP		; CActorInstance::IEventHandler::~IEventHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\actorinstance.h
;	COMDAT ??_GIEventHandler@CActorInstance@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GIEventHandler@CActorInstance@@UAEPAXI@Z PROC	; CActorInstance::IEventHandler::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 47   : 				virtual ~IEventHandler() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7IEventHandler@CActorInstance@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GIEventHandler@CActorInstance@@UAEPAXI@Z ENDP	; CActorInstance::IEventHandler::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ??0IFlyEventHandler@@QAE@XZ
_TEXT	SEGMENT
??0IFlyEventHandler@@QAE@XZ PROC			; IFlyEventHandler::IFlyEventHandler, COMDAT
; _this$ = ecx

; 6    : 	IFlyEventHandler() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IFlyEventHandler@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0IFlyEventHandler@@QAE@XZ ENDP			; IFlyEventHandler::IFlyEventHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ??1IFlyEventHandler@@UAE@XZ
_TEXT	SEGMENT
??1IFlyEventHandler@@UAE@XZ PROC			; IFlyEventHandler::~IFlyEventHandler, COMDAT
; _this$ = ecx

; 7    : 	virtual ~IFlyEventHandler() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IFlyEventHandler@@6B@
  00006	c3		 ret	 0
??1IFlyEventHandler@@UAE@XZ ENDP			; IFlyEventHandler::~IFlyEventHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ?OnSetFlyTarget@IFlyEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnSetFlyTarget@IFlyEventHandler@@UAEXXZ PROC		; IFlyEventHandler::OnSetFlyTarget, COMDAT
; _this$ = ecx

; 10   : 	virtual void OnSetFlyTarget() {}

  00000	c3		 ret	 0
?OnSetFlyTarget@IFlyEventHandler@@UAEXXZ ENDP		; IFlyEventHandler::OnSetFlyTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ?OnShoot@IFlyEventHandler@@UAEXK@Z
_TEXT	SEGMENT
_dwSkillIndex$ = 8					; size = 4
?OnShoot@IFlyEventHandler@@UAEXK@Z PROC			; IFlyEventHandler::OnShoot, COMDAT
; _this$ = ecx

; 11   : 	virtual void OnShoot(DWORD dwSkillIndex) {}

  00000	c2 04 00	 ret	 4
?OnShoot@IFlyEventHandler@@UAEXK@Z ENDP			; IFlyEventHandler::OnShoot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ?OnNoTarget@IFlyEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnNoTarget@IFlyEventHandler@@UAEXXZ PROC		; IFlyEventHandler::OnNoTarget, COMDAT
; _this$ = ecx

; 13   : 	virtual void OnNoTarget() {}

  00000	c3		 ret	 0
?OnNoTarget@IFlyEventHandler@@UAEXXZ ENDP		; IFlyEventHandler::OnNoTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ?OnNoArrow@IFlyEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnNoArrow@IFlyEventHandler@@UAEXXZ PROC		; IFlyEventHandler::OnNoArrow, COMDAT
; _this$ = ecx

; 14   : 	virtual void OnNoArrow() {}

  00000	c3		 ret	 0
?OnNoArrow@IFlyEventHandler@@UAEXXZ ENDP		; IFlyEventHandler::OnNoArrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ?OnExplodingOutOfRange@IFlyEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnExplodingOutOfRange@IFlyEventHandler@@UAEXXZ PROC	; IFlyEventHandler::OnExplodingOutOfRange, COMDAT
; _this$ = ecx

; 17   : 	virtual void OnExplodingOutOfRange() {}

  00000	c3		 ret	 0
?OnExplodingOutOfRange@IFlyEventHandler@@UAEXXZ ENDP	; IFlyEventHandler::OnExplodingOutOfRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ?OnExplodingAtBackground@IFlyEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnExplodingAtBackground@IFlyEventHandler@@UAEXXZ PROC	; IFlyEventHandler::OnExplodingAtBackground, COMDAT
; _this$ = ecx

; 18   : 	virtual void OnExplodingAtBackground() {}

  00000	c3		 ret	 0
?OnExplodingAtBackground@IFlyEventHandler@@UAEXXZ ENDP	; IFlyEventHandler::OnExplodingAtBackground
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ?OnExplodingAtAnotherTarget@IFlyEventHandler@@UAEXKK@Z
_TEXT	SEGMENT
_dwSkillIndex$ = 8					; size = 4
_dwVID$ = 12						; size = 4
?OnExplodingAtAnotherTarget@IFlyEventHandler@@UAEXKK@Z PROC ; IFlyEventHandler::OnExplodingAtAnotherTarget, COMDAT
; _this$ = ecx

; 19   : 	virtual void OnExplodingAtAnotherTarget(DWORD dwSkillIndex, DWORD dwVID) {}

  00000	c2 08 00	 ret	 8
?OnExplodingAtAnotherTarget@IFlyEventHandler@@UAEXKK@Z ENDP ; IFlyEventHandler::OnExplodingAtAnotherTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ?OnExplodingAtTarget@IFlyEventHandler@@UAEXK@Z
_TEXT	SEGMENT
_dwSkillIndex$ = 8					; size = 4
?OnExplodingAtTarget@IFlyEventHandler@@UAEXK@Z PROC	; IFlyEventHandler::OnExplodingAtTarget, COMDAT
; _this$ = ecx

; 20   : 	virtual void OnExplodingAtTarget(DWORD dwSkillIndex) {}

  00000	c2 04 00	 ret	 4
?OnExplodingAtTarget@IFlyEventHandler@@UAEXK@Z ENDP	; IFlyEventHandler::OnExplodingAtTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ??_GIFlyEventHandler@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GIFlyEventHandler@@UAEPAXI@Z PROC			; IFlyEventHandler::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 7    : 	virtual ~IFlyEventHandler() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7IFlyEventHandler@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GIFlyEventHandler@@UAEPAXI@Z ENDP			; IFlyEventHandler::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h
;	COMDAT ??0CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@QAE@XZ
_TEXT	SEGMENT
??0CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@QAE@XZ PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::CNormalBowAttack_FlyEventHandler_AutoClear, COMDAT
; _this$ = ecx

; 57   : 				CNormalBowAttack_FlyEventHandler_AutoClear() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@QAE@XZ ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::CNormalBowAttack_FlyEventHandler_AutoClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h
;	COMDAT ??1CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAE@XZ
_TEXT	SEGMENT
??1CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAE@XZ PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::~CNormalBowAttack_FlyEventHandler_AutoClear, COMDAT
; _this$ = ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h

; 7    : 	virtual ~IFlyEventHandler() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IFlyEventHandler@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h

; 58   : 				virtual ~CNormalBowAttack_FlyEventHandler_AutoClear() {}

  00006	c3		 ret	 0
??1CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAE@XZ ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::~CNormalBowAttack_FlyEventHandler_AutoClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h
;	COMDAT ?OnNoTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnNoTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnNoTarget, COMDAT
; _this$ = ecx

; 66   : 				virtual void OnNoTarget() { /*Tracenf("Shoot : targetÀÌ ¾ø½À´Ï´Ù.");*/ }

  00000	c3		 ret	 0
?OnNoTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnNoTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h
;	COMDAT ?OnExplodingOutOfRange@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnExplodingOutOfRange@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingOutOfRange, COMDAT
; _this$ = ecx

; 67   : 				virtual void OnExplodingOutOfRange() { /*Tracenf("Shoot : »çÁ¤°Å¸®°¡ ³¡³µ½À´Ï´Ù.");*/ }

  00000	c3		 ret	 0
?OnExplodingOutOfRange@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingOutOfRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h
;	COMDAT ?OnExplodingAtBackground@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnExplodingAtBackground@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtBackground, COMDAT
; _this$ = ecx

; 68   : 				virtual void OnExplodingAtBackground() { /*Tracenf("Shoot : ¹è°æ¿¡ ¸Â¾Ò½À´Ï´Ù.");*/ }

  00000	c3		 ret	 0
?OnExplodingAtBackground@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtBackground
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
;	COMDAT ??_GCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEPAXI@Z PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 7    : 	virtual ~IFlyEventHandler() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7IFlyEventHandler@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GCNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEPAXI@Z ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ@YAXXZ
text$yd	SEGMENT
??__Fs_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ@YAXXZ PROC ; `CPythonPlayerEventHandler::GetSingleton'::`2'::`dynamic atexit destructor for 's_kPlayerEventHandler'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A
  00005	e9 00 00 00 00	 jmp	 ??1CPythonPlayerEventHandler@@UAE@XZ ; CPythonPlayerEventHandler::~CPythonPlayerEventHandler
??__Fs_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ@YAXXZ ENDP ; `CPythonPlayerEventHandler::GetSingleton'::`2'::`dynamic atexit destructor for 's_kPlayerEventHandler''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\actorinstance.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ??1CPythonPlayerEventHandler@@UAE@XZ
_TEXT	SEGMENT
??1CPythonPlayerEventHandler@@UAE@XZ PROC		; CPythonPlayerEventHandler::~CPythonPlayerEventHandler, COMDAT
; _this$ = ecx

; 14   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CPythonPlayerEventHandler@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyhandler.h

; 7    : 	virtual ~IFlyEventHandler() {}

  00009	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], OFFSET ??_7IFlyEventHandler@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00010	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00013	85 c0		 test	 eax, eax
  00015	74 1e		 je	 SHORT $LN22@CPythonPla
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0002e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN22@CPythonPla:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\actorinstance.h

; 47   : 				virtual ~IEventHandler() {}

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7IEventHandler@CActorInstance@@6B@
  0003b	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 15   : }

  0003c	c3		 ret	 0
??1CPythonPlayerEventHandler@@UAE@XZ ENDP		; CPythonPlayerEventHandler::~CPythonPlayerEventHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCPythonPlayerEventHandler@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPythonPlayerEventHandler@@UAEPAXI@Z PROC		; CPythonPlayerEventHandler::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPythonPlayerEventHandler@@UAE@XZ ; CPythonPlayerEventHandler::~CPythonPlayerEventHandler
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCPythonPlayerEventHandler@@UAEPAXI@Z ENDP		; CPythonPlayerEventHandler::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnClearAffects@CPythonPlayerEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnClearAffects@CPythonPlayerEventHandler@@UAEXXZ PROC	; CPythonPlayerEventHandler::OnClearAffects, COMDAT
; _this$ = ecx

; 19   : 	CPythonPlayer::Instance().ClearAffects();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e9 00 00 00 00	 jmp	 ?ClearAffects@CPythonPlayer@@QAEXXZ ; CPythonPlayer::ClearAffects
?OnClearAffects@CPythonPlayerEventHandler@@UAEXXZ ENDP	; CPythonPlayerEventHandler::OnClearAffects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnSetAffect@CPythonPlayerEventHandler@@UAEXI@Z
_TEXT	SEGMENT
_uAffect$ = 8						; size = 4
?OnSetAffect@CPythonPlayerEventHandler@@UAEXI@Z PROC	; CPythonPlayerEventHandler::OnSetAffect, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 	CPythonPlayer::Instance().SetAffect(uAffect);

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 25   : }

  00009	5d		 pop	 ebp

; 24   : 	CPythonPlayer::Instance().SetAffect(uAffect);

  0000a	e9 00 00 00 00	 jmp	 ?SetAffect@CPythonPlayer@@QAEXI@Z ; CPythonPlayer::SetAffect
?OnSetAffect@CPythonPlayerEventHandler@@UAEXI@Z ENDP	; CPythonPlayerEventHandler::OnSetAffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnResetAffect@CPythonPlayerEventHandler@@UAEXI@Z
_TEXT	SEGMENT
_uAffect$ = 8						; size = 4
?OnResetAffect@CPythonPlayerEventHandler@@UAEXI@Z PROC	; CPythonPlayerEventHandler::OnResetAffect, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 29   : 	CPythonPlayer::Instance().ResetAffect(uAffect);

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 30   : }

  00009	5d		 pop	 ebp

; 29   : 	CPythonPlayer::Instance().ResetAffect(uAffect);

  0000a	e9 00 00 00 00	 jmp	 ?ResetAffect@CPythonPlayer@@QAEXI@Z ; CPythonPlayer::ResetAffect
?OnResetAffect@CPythonPlayerEventHandler@@UAEXI@Z ENDP	; CPythonPlayerEventHandler::OnResetAffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnSyncing@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
_TEXT	SEGMENT
_c_rkState$ = 8						; size = 4
?OnSyncing@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z PROC ; CPythonPlayerEventHandler::OnSyncing, COMDAT
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	const TPixelPosition& c_rkPPosCurSyncing=c_rkState.kPPosSelf;
; 35   : 	m_kPPosPrevWaiting=c_rkPPosCurSyncing;

  00003	8b 45 08	 mov	 eax, DWORD PTR _c_rkState$[ebp]
  00006	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000a	66 0f d6 41 1c	 movq	 QWORD PTR [ecx+28], xmm0
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00012	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 36   : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?OnSyncing@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ENDP ; CPythonPlayerEventHandler::OnSyncing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnWaiting@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
_TEXT	SEGMENT
_c_rkState$ = 8						; size = 4
?OnWaiting@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z PROC ; CPythonPlayerEventHandler::OnWaiting, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 40   : 	DWORD dwCurTime=ELTimer_GetMSec();

  0000a	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 41   : 	if (m_dwNextWaitingNotifyTime>dwCurTime)

  0000f	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00012	77 6e		 ja	 SHORT $LN3@OnWaiting

; 42   : 		return;
; 43   : 
; 44   : 	m_dwNextWaitingNotifyTime=dwCurTime+100;
; 45   : 
; 46   : 	const TPixelPosition& c_rkPPosCurWaiting=c_rkState.kPPosSelf;
; 47   : 	float dx=m_kPPosPrevWaiting.x-c_rkPPosCurWaiting.x;

  00014	8b 7d 08	 mov	 edi, DWORD PTR _c_rkState$[ebp]
  00017	83 c0 64	 add	 eax, 100		; 00000064H
  0001a	f3 0f 10 4e 1c	 movss	 xmm1, DWORD PTR [esi+28]

; 48   : 	float dy=m_kPPosPrevWaiting.y-c_rkPPosCurWaiting.y;

  0001f	f3 0f 10 46 20	 movss	 xmm0, DWORD PTR [esi+32]
  00024	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00027	f3 0f 5c 47 04	 subss	 xmm0, DWORD PTR [edi+4]
  0002c	f3 0f 5c 0f	 subss	 xmm1, DWORD PTR [edi]

; 49   : 	float len=sqrt(dx*dx+dy*dy);

  00030	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00034	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00038	f3 0f 58 c1	 addss	 xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0003c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0003f	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00044	0f 57 c9	 xorps	 xmm1, xmm1
  00047	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 51   : 	if (len<1.0f)

  0004b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00053	0f 2f c1	 comiss	 xmm0, xmm1
  00056	77 2a		 ja	 SHORT $LN3@OnWaiting

; 52   : 		return;
; 53   : 
; 54   : 	m_kPPosPrevWaiting=c_rkPPosCurWaiting;

  00058	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]

; 55   : 
; 56   : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 57   : 	rkNetStream.SendCharacterStatePacket(c_rkState.kPPosSelf, c_rkState.fAdvRotSelf, CInstanceBase::FUNC_WAIT, 0);

  0005c	6a 00		 push	 0
  0005e	66 0f d6 46 1c	 movq	 QWORD PTR [esi+28], xmm0
  00063	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00066	6a 00		 push	 0
  00068	51		 push	 ecx
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  0006f	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00072	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [edi+12]
  00077	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007c	57		 push	 edi
  0007d	e8 00 00 00 00	 call	 ?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ; CPythonNetworkStream::SendCharacterStatePacket
$LN3@OnWaiting:

; 58   : 
; 59   : 	//Trace("waiting\n");
; 60   : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?OnWaiting@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ENDP ; CPythonPlayerEventHandler::OnWaiting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnMoving@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
_TEXT	SEGMENT
_c_rkState$ = 8						; size = 4
?OnMoving@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z PROC ; CPythonPlayerEventHandler::OnMoving, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 64   : 	DWORD dwCurTime=ELTimer_GetMSec();		

  00006	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 65   : 	if (m_dwNextMovingNotifyTime>dwCurTime)

  0000b	39 46 18	 cmp	 DWORD PTR [esi+24], eax
  0000e	77 26		 ja	 SHORT $LN2@OnMoving

; 66   : 		return;
; 67   : 	
; 68   : 	m_dwNextMovingNotifyTime=dwCurTime+300;

  00010	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00015	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 69   : 	
; 70   : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 71   : 	rkNetStream.SendCharacterStatePacket(c_rkState.kPPosSelf, c_rkState.fAdvRotSelf, CInstanceBase::FUNC_MOVE, 0);

  00018	8b 45 08	 mov	 eax, DWORD PTR _c_rkState$[ebp]
  0001b	6a 00		 push	 0
  0001d	6a 01		 push	 1
  0001f	51		 push	 ecx
  00020	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  0002b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ; CPythonNetworkStream::SendCharacterStatePacket
$LN2@OnMoving:
  00036	5e		 pop	 esi

; 72   : 
; 73   : //	Trace("moving\n");
; 74   : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?OnMoving@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ENDP ; CPythonPlayerEventHandler::OnMoving
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnMove@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
_TEXT	SEGMENT
_c_rkState$ = 8						; size = 4
?OnMove@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z PROC ; CPythonPlayerEventHandler::OnMove, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 78   : 	DWORD dwCurTime=ELTimer_GetMSec();

  00006	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 79   : 	m_dwNextWaitingNotifyTime=dwCurTime+100;
; 80   : 	m_dwNextMovingNotifyTime=dwCurTime+300;
; 81   : 
; 82   : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 83   : 	rkNetStream.SendCharacterStatePacket(c_rkState.kPPosSelf, c_rkState.fAdvRotSelf, CInstanceBase::FUNC_MOVE, 0);

  0000b	6a 00		 push	 0
  0000d	6a 01		 push	 1
  0000f	51		 push	 ecx
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00016	8d 50 64	 lea	 edx, DWORD PTR [eax+100]
  00019	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0001e	89 56 14	 mov	 DWORD PTR [esi+20], edx
  00021	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR _c_rkState$[ebp]
  00027	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0002c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ; CPythonNetworkStream::SendCharacterStatePacket
  00037	5e		 pop	 esi

; 84   : 
; 85   : //	Trace("move\n");
; 86   : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?OnMove@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ENDP ; CPythonPlayerEventHandler::OnMove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnStop@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
_TEXT	SEGMENT
_c_rkState$ = 8						; size = 4
?OnStop@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z PROC ; CPythonPlayerEventHandler::OnStop, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 91   : 	rkNetStream.SendCharacterStatePacket(c_rkState.kPPosSelf, c_rkState.fAdvRotSelf, CInstanceBase::FUNC_WAIT, 0);

  00003	8b 45 08	 mov	 eax, DWORD PTR _c_rkState$[ebp]
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00016	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ; CPythonNetworkStream::SendCharacterStatePacket

; 92   : 
; 93   : //	Trace("stop\n");
; 94   : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?OnStop@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ENDP ; CPythonPlayerEventHandler::OnStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnWarp@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z
_TEXT	SEGMENT
_c_rkState$ = 8						; size = 4
?OnWarp@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z PROC ; CPythonPlayerEventHandler::OnWarp, COMDAT
; _this$ = ecx

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 99   : 	rkNetStream.SendCharacterStatePacket(c_rkState.kPPosSelf, c_rkState.fAdvRotSelf, CInstanceBase::FUNC_WAIT, 0);

  00003	8b 45 08	 mov	 eax, DWORD PTR _c_rkState$[ebp]
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00016	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ; CPythonNetworkStream::SendCharacterStatePacket

; 100  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?OnWarp@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@@Z ENDP ; CPythonPlayerEventHandler::OnWarp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnAttack@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@G@Z
_TEXT	SEGMENT
_c_rkState$ = 8						; size = 4
_wMotionIndex$ = 12					; size = 2
?OnAttack@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@G@Z PROC ; CPythonPlayerEventHandler::OnAttack, COMDAT
; _this$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 104  : //	Tracef("CPythonPlayerEventHandler::OnAttack [%d]\n", wMotionIndex);
; 105  : 	assert(wMotionIndex < 255);
; 106  : 
; 107  : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 108  : 	rkNetStream.SendCharacterStatePacket(c_rkState.kPPosSelf, c_rkState.fAdvRotSelf, CInstanceBase::FUNC_COMBO, wMotionIndex);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _wMotionIndex$[ebp]
  00006	0f b7 c0	 movzx	 eax, ax
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR _c_rkState$[ebp]
  0000d	6a 03		 push	 3
  0000f	51		 push	 ecx
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00016	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0001b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ; CPythonNetworkStream::SendCharacterStatePacket

; 109  : 
; 110  : #ifdef __ATTACK_SPEED_CHECK__
; 111  : 	static DWORD s_dwLastTime=timeGetTime();
; 112  : 
; 113  : 	DWORD dwCurTime=timeGetTime();
; 114  : 	Tracef("%d\n", dwCurTime-s_dwLastTime);
; 115  : 	s_dwLastTime=dwCurTime;
; 116  : #endif
; 117  : 
; 118  : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?OnAttack@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@G@Z ENDP ; CPythonPlayerEventHandler::OnAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnUseSkill@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@II@Z
_TEXT	SEGMENT
_c_rkState$ = 8						; size = 4
_uMotSkill$ = 12					; size = 4
_uArg$ = 16						; size = 4
?OnUseSkill@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@II@Z PROC ; CPythonPlayerEventHandler::OnUseSkill, COMDAT
; _this$ = ecx

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 123  : 	rkNetStream.SendCharacterStatePacket(c_rkState.kPPosSelf, c_rkState.fAdvRotSelf, CInstanceBase::FUNC_SKILL|uMotSkill, uArg);

  00003	ff 75 10	 push	 DWORD PTR _uArg$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _uMotSkill$[ebp]
  00009	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0000e	50		 push	 eax
  0000f	8b 45 08	 mov	 eax, DWORD PTR _c_rkState$[ebp]
  00012	51		 push	 ecx
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00019	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0001e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?SendCharacterStatePacket@CPythonNetworkStream@@QAE_NABUD3DXVECTOR3@@MII@Z ; CPythonNetworkStream::SendCharacterStatePacket

; 124  : }

  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
?OnUseSkill@CPythonPlayerEventHandler@@UAEXABUSState@IEventHandler@CActorInstance@@II@Z ENDP ; CPythonPlayerEventHandler::OnUseSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnUpdate@CPythonPlayerEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnUpdate@CPythonPlayerEventHandler@@UAEXXZ PROC	; CPythonPlayerEventHandler::OnUpdate, COMDAT
; _this$ = ecx

; 128  : }

  00000	c3		 ret	 0
?OnUpdate@CPythonPlayerEventHandler@@UAEXXZ ENDP	; CPythonPlayerEventHandler::OnUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnChangeShape@CPythonPlayerEventHandler@@UAEXXZ
_TEXT	SEGMENT
?OnChangeShape@CPythonPlayerEventHandler@@UAEXXZ PROC	; CPythonPlayerEventHandler::OnChangeShape, COMDAT
; _this$ = ecx

; 132  : 	CPythonPlayer::Instance().NEW_Stop();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00006	e9 00 00 00 00	 jmp	 ?NEW_Stop@CPythonPlayer@@QAEXXZ ; CPythonPlayer::NEW_Stop
?OnChangeShape@CPythonPlayerEventHandler@@UAEXXZ ENDP	; CPythonPlayerEventHandler::OnChangeShape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnHit@CPythonPlayerEventHandler@@UAEXIAAVCActorInstance@@H@Z
_TEXT	SEGMENT
_kVictim$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_uSkill$ = 8						; size = 4
_rkActorVictim$ = 12					; size = 4
_isSendPacket$ = 16					; size = 4
?OnHit@CPythonPlayerEventHandler@@UAEXIAAVCActorInstance@@H@Z PROC ; CPythonPlayerEventHandler::OnHit, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _rkActorVictim$[ebp]
  00015	8b d9		 mov	 ebx, ecx
  00017	57		 push	 edi

; 137  : 	DWORD dwVIDVictim=rkActorVictim.GetVirtualID();

  00018	8b ce		 mov	 ecx, esi
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	ff 50 48	 call	 DWORD PTR [eax+72]

; 138  : 
; 139  : 	// Update Target
; 140  : 	CPythonPlayer::Instance().SetTarget(dwVIDVictim, FALSE);

  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00025	8b f8		 mov	 edi, eax
  00027	83 c1 04	 add	 ecx, 4
  0002a	6a 00		 push	 0
  0002c	57		 push	 edi
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	ff 52 60	 call	 DWORD PTR [edx+96]

; 141  : 	// Update Target
; 142  : 
; 143  : 	if (isSendPacket)

  00032	83 7d 10 00	 cmp	 DWORD PTR _isSendPacket$[ebp], 0
  00036	74 0f		 je	 SHORT $LN3@OnHit

; 144  : 	{
; 145  : //#define ATTACK_TIME_LOG
; 146  : #ifdef ATTACK_TIME_LOG
; 147  : 		static std::map<DWORD, float> s_prevTimed;
; 148  : 		float curTime = timeGetTime() / 1000.0f;
; 149  : 		bool isFirst = false;
; 150  : 		if (s_prevTimed.end() == s_prevTimed.find(dwVIDVictim))
; 151  : 		{
; 152  : 			s_prevTimed[dwVIDVictim] = curTime;
; 153  : 			isFirst = true;
; 154  : 		}
; 155  : 		float diffTime = curTime-s_prevTimed[dwVIDVictim];
; 156  : 		if (diffTime < 0.1f && !isFirst)
; 157  : 		{
; 158  : 			TraceError("ATTACK(SPEED_HACK): %.4f(%.4f) %d", curTime, diffTime, dwVIDVictim);
; 159  : 		}
; 160  : 		else
; 161  : 		{
; 162  : 			TraceError("ATTACK: %.4f(%.4f) %d", curTime, diffTime, dwVIDVictim);
; 163  : 		}
; 164  : 		
; 165  : 		s_prevTimed[dwVIDVictim] = curTime;
; 166  : #endif
; 167  : 		CPythonNetworkStream& rkStream=CPythonNetworkStream::Instance();
; 168  : 		rkStream.SendAttackPacket(uSkill, dwVIDVictim);

  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  0003e	57		 push	 edi
  0003f	ff 75 08	 push	 DWORD PTR _uSkill$[ebp]
  00042	e8 00 00 00 00	 call	 ?SendAttackPacket@CPythonNetworkStream@@QAE_NIK@Z ; CPythonNetworkStream::SendAttackPacket
$LN3@OnHit:

; 169  : 	}
; 170  : 
; 171  : 	if (!rkActorVictim.IsPushing())

  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?IsPushing@CActorInstance@@QAE_NXZ ; CActorInstance::IsPushing
  0004e	84 c0		 test	 al, al
  00050	74 51		 je	 SHORT $LN4@OnHit

; 172  : 		return;
; 173  : 
; 174  : 	// °Å´ë ¸ó½ºÅÍ ¹Ð¸² Á¦¿Ü
; 175  : 	extern bool IS_HUGE_RACE(unsigned int vnum);
; 176  : 	if (IS_HUGE_RACE(rkActorVictim.GetRace()))

  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?GetRace@CActorInstance@@QAEKXZ ; CActorInstance::GetRace
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?IS_HUGE_RACE@@YA_NI@Z	; IS_HUGE_RACE
  0005f	83 c4 04	 add	 esp, 4
  00062	84 c0		 test	 al, al
  00064	75 3d		 jne	 SHORT $LN4@OnHit

; 177  : 		return;
; 178  : 
; 179  : 
; 180  : 	CPythonCharacterManager::Instance().AdjustCollisionWithOtherObjects(&rkActorVictim);

  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0006c	83 c1 08	 add	 ecx, 8
  0006f	56		 push	 esi
  00070	8b 01		 mov	 eax, DWORD PTR [ecx]
  00072	ff 50 04	 call	 DWORD PTR [eax+4]

; 181  : 
; 182  : 	const TPixelPosition& kPPosLast=rkActorVictim.NEW_GetLastPixelPositionRef();

  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?NEW_GetLastPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetLastPixelPositionRef

; 183  : 
; 184  : 	SVictim kVictim;
; 185  : 	kVictim.m_dwVID=dwVIDVictim;
; 186  : 	kVictim.m_lPixelX=long(kPPosLast.x);
; 187  : 	kVictim.m_lPixelY=long(kPPosLast.y);
; 188  : 
; 189  : 	rkActorVictim.TEMP_Push(kVictim.m_lPixelX, kVictim.m_lPixelY);

  0007c	8b ce		 mov	 ecx, esi
  0007e	89 7d f0	 mov	 DWORD PTR _kVictim$[ebp], edi
  00081	f3 0f 2c 10	 cvttss2si edx, DWORD PTR [eax]
  00085	f3 0f 2c 40 04	 cvttss2si eax, DWORD PTR [eax+4]
  0008a	89 55 f4	 mov	 DWORD PTR _kVictim$[ebp+4], edx
  0008d	50		 push	 eax
  0008e	52		 push	 edx
  0008f	89 45 f8	 mov	 DWORD PTR _kVictim$[ebp+8], eax
  00092	e8 00 00 00 00	 call	 ?TEMP_Push@CActorInstance@@QAEXHH@Z ; CActorInstance::TEMP_Push

; 190  : 
; 191  : 	m_kVctkVictim.push_back(kVictim);

  00097	8d 45 f0	 lea	 eax, DWORD PTR _kVictim$[ebp]
  0009a	50		 push	 eax
  0009b	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0009e	e8 00 00 00 00	 call	 ?push_back@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXABUSVictim@CPythonPlayerEventHandler@@@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::push_back
$LN4@OnHit:

; 192  : }

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	33 cd		 xor	 ecx, ebp
  000aa	5b		 pop	 ebx
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?OnHit@CPythonPlayerEventHandler@@UAEXIAAVCActorInstance@@H@Z ENDP ; CPythonPlayerEventHandler::OnHit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ??0CPythonPlayerEventHandler@@IAE@XZ
_TEXT	SEGMENT
??0CPythonPlayerEventHandler@@IAE@XZ PROC		; CPythonPlayerEventHandler::CPythonPlayerEventHandler, COMDAT
; _this$dead$ = ecx

; 222  : {

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A, OFFSET ??_7CPythonPlayerEventHandler@@6B@

; 226  : }

  0000a	b8 00 00 00 00	 mov	 eax, OFFSET ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  0000f	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A+4, 0

; 483  : 		_Mylast = pointer();

  00019	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A+8, 0

; 484  : 		_Myend = pointer();

  00023	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A+12, 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.h

; 57   : 				CNormalBowAttack_FlyEventHandler_AutoClear() {}

  0002d	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A+40, OFFSET ??_7CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp

; 223  : 	m_dwPrevComboIndex=0;

  00037	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A+16, 0

; 224  : 	m_dwNextMovingNotifyTime=0;

  00041	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A+24, 0

; 225  : 	m_dwNextWaitingNotifyTime=0;

  0004b	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kPlayerEventHandler@?1??GetSingleton@CPythonPlayerEventHandler@@SAAAV2@XZ@4V2@A+20, 0

; 226  : }

  00055	c3		 ret	 0
??0CPythonPlayerEventHandler@@IAE@XZ ENDP		; CPythonPlayerEventHandler::CPythonPlayerEventHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnSetFlyTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ
_TEXT	SEGMENT
_s$ = -20						; size = 16
$T1 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?OnSetFlyTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnSetFlyTarget, COMDAT
; _this$ = ecx

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b f9		 mov	 edi, ecx

; 234  : 	SState s;
; 235  : 	m_pInstMain->NEW_GetPixelPosition(&s.kPPosSelf);

  00014	8d 45 ec	 lea	 eax, DWORD PTR _s$[ebp]
  00017	50		 push	 eax
  00018	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001b	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 236  : 	s.fAdvRotSelf=m_pInstMain->GetGraphicThingInstancePtr()->GetTargetRotation();

  00020	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00023	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 ?GetTargetRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetTargetRotation

; 237  : 
; 238  : 	CPythonNetworkStream& rpns=CPythonNetworkStream::Instance();

  0002f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00035	dd d8		 fstp	 ST(0)

; 239  : 	rpns.SendFlyTargetingPacket(m_pInstTarget->GetVirtualID(), m_pInstTarget->GetGraphicThingInstancePtr()->OnGetFlyTargetPosition());

  00037	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0003a	e8 00 00 00 00	 call	 ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
  0003f	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  00042	52		 push	 edx
  00043	8d 88 dc 01 00
	00		 lea	 ecx, DWORD PTR [eax+476]
  00049	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004b	ff 50 04	 call	 DWORD PTR [eax+4]
  0004e	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  00057	50		 push	 eax
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?SendFlyTargetingPacket@CPythonNetworkStream@@QAE_NKABUD3DXVECTOR3@@@Z ; CPythonNetworkStream::SendFlyTargetingPacket

; 240  : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	5f		 pop	 edi
  00063	33 cd		 xor	 ecx, ebp
  00065	5e		 pop	 esi
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?OnSetFlyTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXXZ ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnSetFlyTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SState@IEventHandler@CActorInstance@@QAE@XZ
_TEXT	SEGMENT
??0SState@IEventHandler@CActorInstance@@QAE@XZ PROC	; CActorInstance::IEventHandler::SState::SState, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SState@IEventHandler@CActorInstance@@QAE@XZ ENDP	; CActorInstance::IEventHandler::SState::SState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnShoot@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z
_TEXT	SEGMENT
_dwSkillIndex$ = 8					; size = 4
?OnShoot@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnShoot, COMDAT
; _this$ = ecx

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  : 	CPythonNetworkStream& rpns=CPythonNetworkStream::Instance();
; 244  : 	rpns.SendShootPacket(dwSkillIndex);

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton

; 245  : }

  00009	5d		 pop	 ebp

; 243  : 	CPythonNetworkStream& rpns=CPythonNetworkStream::Instance();
; 244  : 	rpns.SendShootPacket(dwSkillIndex);

  0000a	e9 00 00 00 00	 jmp	 ?SendShootPacket@CPythonNetworkStream@@QAE_NI@Z ; CPythonNetworkStream::SendShootPacket
?OnShoot@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnShoot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?Set@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@QAEXPAV2@PAVCInstanceBase@@1@Z
_TEXT	SEGMENT
_pParent$ = 8						; size = 4
_pInstMain$ = 12					; size = 4
_pInstTarget$ = 16					; size = 4
?Set@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@QAEXPAV2@PAVCInstanceBase@@1@Z PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::Set, COMDAT
; _this$ = ecx

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 249  : 	m_pParent=(pParent);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pParent$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 250  : 	m_pInstMain=(pInstMain);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pInstMain$[ebp]
  0000c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 251  : 	m_pInstTarget=(pInstTarget);

  0000f	8b 45 10	 mov	 eax, DWORD PTR _pInstTarget$[ebp]
  00012	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 252  : }

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?Set@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@QAEXPAV2@PAVCInstanceBase@@1@Z ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnExplodingAtAnotherTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXKK@Z
_TEXT	SEGMENT
_dwSkillIndex$ = 8					; size = 4
_dwVID$ = 12						; size = 4
?OnExplodingAtAnotherTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXKK@Z PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtAnotherTarget, COMDAT
; _this$ = ecx

; 261  : 	return;
; 262  : 
; 263  : 	Tracef("Shoot : ´Ù¸¥ target¿¡ ¸Â¾Ò½À´Ï´Ù : %d, %d\n", dwSkillIndex, dwVID);
; 264  : 
; 265  : 	CPythonNetworkStream& rkStream=CPythonNetworkStream::Instance();
; 266  : 	rkStream.SendAttackPacket(dwSkillIndex, dwVID);
; 267  : 
; 268  : 	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();
; 269  : 	CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(dwVID);
; 270  : 	if (pInstance)
; 271  : 	{
; 272  : 		pInstance->GetGraphicThingInstanceRef().OnShootDamage();
; 273  : 	}
; 274  : }

  00000	c2 08 00	 ret	 8
?OnExplodingAtAnotherTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXKK@Z ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtAnotherTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayereventhandler.cpp
;	COMDAT ?OnExplodingAtTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z
_TEXT	SEGMENT
_dwSkillIndex$ = 8					; size = 4
?OnExplodingAtTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z PROC ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtTarget, COMDAT
; _this$ = ecx

; 277  : //	Tracef("Shoot : ¿øÇÏ´Â target¿¡ ¸Â¾Ò½À´Ï´Ù : %d, %d\n", dwSkillIndex, m_pInstTarget->GetVirtualID());
; 278  : //	CPythonNetworkStream& rkStream=CPythonNetworkStream::Instance();
; 279  : //	rkStream.SendAttackPacket(dwSkillIndex, m_pInstTarget->GetVirtualID());
; 280  : }

  00000	c2 04 00	 ret	 4
?OnExplodingAtTarget@CNormalBowAttack_FlyEventHandler_AutoClear@CPythonPlayerEventHandler@@UAEXK@Z ENDP ; CPythonPlayerEventHandler::CNormalBowAttack_FlyEventHandler_AutoClear::OnExplodingAtTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::~vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::~vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1149 : 		}

  00015	c3		 ret	 0
?size@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBE_NXZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??A?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEAAUSVictim@CPythonPlayerEventHandler@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEAAUSVictim@CPythonPlayerEventHandler@@I@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1210 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEAAUSVictim@CPythonPlayerEventHandler@@I@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXABUSVictim@CPythonPlayerEventHandler@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXABUSVictim@CPythonPlayerEventHandler@@@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4c		 jae	 SHORT $LN4@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 46		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	d1 fa		 sar	 edx, 1
  00022	8b fa		 mov	 edi, edx
  00024	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00027	03 fa		 add	 edi, edx

; 1247 : 			if (this->_Mylast == this->_Myend)

  00029	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002c	75 08		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  0002e	51		 push	 ecx
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  0003b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0003e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00041	85 c9		 test	 ecx, ecx
  00043	74 3a		 je	 SHORT $LN49@push_back
  00045	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00049	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0004d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00053	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN4@push_back:

; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  0005d	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00060	75 08		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00062	51		 push	 ecx
  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0006a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 0e		 je	 SHORT $LN49@push_back
  00071	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00075	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00079	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0007f	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?push_back@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXABUSVictim@CPythonPlayerEventHandler@@@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXXZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXPAUSVictim@CPythonPlayerEventHandler@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXPAUSVictim@CPythonPlayerEventHandler@@0@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXPAUSVictim@CPythonPlayerEventHandler@@0@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBE_NPBUSVictim@CPythonPlayerEventHandler@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBE_NPBUSVictim@CPythonPlayerEventHandler@@@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBE_NPBUSVictim@CPythonPlayerEventHandler@@@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?_Reserve@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	56		 push	 esi

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00009	57		 push	 edi
  0000a	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  0000d	8b d7		 mov	 edx, edi
  0000f	2b d6		 sub	 edx, esi
  00011	f7 ea		 imul	 edx
  00013	d1 fa		 sar	 edx, 1
  00015	8b c2		 mov	 eax, edx
  00017	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001a	03 c2		 add	 eax, edx

; 1613 : 		if (_Unused_capacity() < _Count)

  0001c	83 f8 01	 cmp	 eax, 1
  0001f	73 5e		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	2b 31		 sub	 esi, DWORD PTR [ecx]
  00023	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00028	f7 ee		 imul	 esi
  0002a	53		 push	 ebx
  0002b	d1 fa		 sar	 edx, 1

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0002d	bb 55 55 55 15	 mov	 ebx, 357913941		; 15555555H

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00032	8b f2		 mov	 esi, edx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00034	8b c3		 mov	 eax, ebx

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00036	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00039	03 f2		 add	 esi, edx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0003b	2b c6		 sub	 eax, esi
  0003d	83 f8 01	 cmp	 eax, 1
  00040	72 42		 jb	 SHORT $LN42@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00042	2b 39		 sub	 edi, DWORD PTR [ecx]
  00044	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00049	f7 ef		 imul	 edi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	46		 inc	 esi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0004c	d1 fa		 sar	 edx, 1
  0004e	8b c2		 mov	 eax, edx
  00050	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00053	03 c2		 add	 eax, edx

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00055	8b d0		 mov	 edx, eax
  00057	d1 ea		 shr	 edx, 1
  00059	2b da		 sub	 ebx, edx
  0005b	3b d8		 cmp	 ebx, eax
  0005d	5b		 pop	 ebx
  0005e	73 12		 jae	 SHORT $LN27@Reserve
  00060	33 c0		 xor	 eax, eax

; 1576 : 		if (_Capacity < _Count)

  00062	3b c6		 cmp	 eax, esi
  00064	0f 42 c6	 cmovb	 eax, esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reallocate
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  0006f	c2 04 00	 ret	 4
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00072	03 c2		 add	 eax, edx

; 1576 : 		if (_Capacity < _Count)

  00074	3b c6		 cmp	 eax, esi
  00076	0f 42 c6	 cmovb	 eax, esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	c2 04 00	 ret	 4
$LN42@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00089	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN44@Reserve:
$LN41@Reserve:
  0008e	cc		 int	 3
?_Reserve@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXXZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXXZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEXPAUSVictim@CPythonPlayerEventHandler@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEXPAUSVictim@CPythonPlayerEventHandler@@0@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEXPAUSVictim@CPythonPlayerEventHandler@@0@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAE@XZ PROC ; std::allocator<CPythonPlayerEventHandler::SVictim>::allocator<CPythonPlayerEventHandler::SVictim>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAE@XZ ENDP ; std::allocator<CPythonPlayerEventHandler::SVictim>::allocator<CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@QAE@ABV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@QAE@ABV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@QAE@ABV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >::_Getal, COMDAT
; _this$dead$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	d1 fa		 sar	 edx, 1
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1016 : 		}

  00016	c3		 ret	 0
?_Unused_capacity@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size, COMDAT
; _this$dead$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEII@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	f7 ea		 imul	 edx
  0000f	56		 push	 esi
  00010	d1 fa		 sar	 edx, 1

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00012	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00017	8b f2		 mov	 esi, edx
  00019	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001c	03 f2		 add	 esi, edx

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0001e	8b ce		 mov	 ecx, esi
  00020	d1 e9		 shr	 ecx, 1
  00022	2b c1		 sub	 eax, ecx
  00024	3b c6		 cmp	 eax, esi
  00026	73 10		 jae	 SHORT $LN4@Grow_to
  00028	33 f6		 xor	 esi, esi

; 1576 : 		if (_Capacity < _Count)

  0002a	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0002d	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00038	03 f1		 add	 esi, ecx

; 1576 : 		if (_Capacity < _Count)

  0003a	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0003d	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi

; 1579 : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?_Grow_to@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEII@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Cat$1 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00005	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  0000b	33 ff		 xor	 edi, edi

; 25   : 	if (_Count == 0)

  0000d	85 f6		 test	 esi, esi
  0000f	74 1d		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fe 55 55 55
	15		 cmp	 esi, 357913941		; 15555555H
  00017	77 6e		 ja	 SHORT $LN59@Reallocate
  00019	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0001c	c1 e0 02	 shl	 eax, 2
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	8b f8		 mov	 edi, eax
  00027	83 c4 04	 add	 esp, 4
  0002a	85 ff		 test	 edi, edi
  0002c	74 59		 je	 SHORT $LN59@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0002e	ff 75 08	 push	 DWORD PTR __Cat$1[ebp]
  00031	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00034	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00036	83 ec 08	 sub	 esp, 8
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@U12@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::allocator<CPythonPlayerEventHandler::SVictim>,CPythonPlayerEventHandler::SVictim>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0003f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00042	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00047	2b 0b		 sub	 ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00049	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0004c	f7 e9		 imul	 ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  0004e	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00050	d1 fa		 sar	 edx, 1
  00052	8b ca		 mov	 ecx, edx
  00054	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00057	03 ca		 add	 ecx, edx
  00059	89 4d 08	 mov	 DWORD PTR __Size$1$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  0005c	85 c0		 test	 eax, eax
  0005e	74 0c		 je	 SHORT $LN54@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  00069	83 c4 04	 add	 esp, 4
$LN54@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0006c	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  0006f	89 3b		 mov	 DWORD PTR [ebx], edi
  00071	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  00074	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00077	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0007a	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00082	5b		 pop	 ebx

; 1609 : 		}

  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN59@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00087	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN61@Reallocate:
$LN58@Reallocate:
  0008c	cc		 int	 3
?_Reallocate@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEXXZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IBEXXZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::deallocate, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CPythonPlayerEventHandler::SVictim> >::_Vector_val<std::_Simple_types<CPythonPlayerEventHandler::SVictim> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CPythonPlayerEventHandler::SVictim> >::_Vector_val<std::_Simple_types<CPythonPlayerEventHandler::SVictim> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1011 : 		}

  00015	c3		 ret	 0
?capacity@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@I@Z PROC ; std::allocator<CPythonPlayerEventHandler::SVictim>::deallocate, COMDAT
; _this$dead$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@I@Z ENDP ; std::allocator<CPythonPlayerEventHandler::SVictim>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEPAUSVictim@CPythonPlayerEventHandler@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEPAUSVictim@CPythonPlayerEventHandler@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::allocate, COMDAT
; _this$dead$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00011	77 1b		 ja	 SHORT $LN14@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 02	 shl	 eax, 2
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00028	8b c1		 mov	 eax, ecx

; 848  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00033	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEPAUSVictim@CPythonPlayerEventHandler@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size, COMDAT
; _this$dead$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEPAUSVictim@CPythonPlayerEventHandler@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEPAUSVictim@CPythonPlayerEventHandler@@I@Z PROC ; std::allocator<CPythonPlayerEventHandler::SVictim>::allocate, COMDAT
; _this$dead$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00011	77 1b		 ja	 SHORT $LN11@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 02	 shl	 eax, 2
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00028	8b c1		 mov	 eax, ecx

; 579  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00033	cc		 int	 3
?allocate@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEPAUSVictim@CPythonPlayerEventHandler@@I@Z ENDP ; std::allocator<CPythonPlayerEventHandler::SVictim>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAIABV?$allocator@USVictim@CPythonPlayerEventHandler@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAIABV?$allocator@USVictim@CPythonPlayerEventHandler@@@2@@Z PROC ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size, COMDAT
; __Al$dead$ = ecx

; 735  : 		return (_Al.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAIABV?$allocator@USVictim@CPythonPlayerEventHandler@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QBEIXZ PROC ; std::allocator<CPythonPlayerEventHandler::SVictim>::max_size, COMDAT
; _this$dead$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QBEIXZ ENDP ; std::allocator<CPythonPlayerEventHandler::SVictim>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUSVictim@CPythonPlayerEventHandler@@@std@@YAPBUSVictim@CPythonPlayerEventHandler@@ABU12@@Z
_TEXT	SEGMENT
??$addressof@$$CBUSVictim@CPythonPlayerEventHandler@@@std@@YAPBUSVictim@CPythonPlayerEventHandler@@ABU12@@Z PROC ; std::addressof<CPythonPlayerEventHandler::SVictim const >, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@$$CBUSVictim@CPythonPlayerEventHandler@@@std@@YAPBUSVictim@CPythonPlayerEventHandler@@ABU12@@Z ENDP ; std::addressof<CPythonPlayerEventHandler::SVictim const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@AAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@AAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USVictim@CPythonPlayerEventHandler@@ABU12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USVictim@CPythonPlayerEventHandler@@ABU12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim const &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@USVictim@CPythonPlayerEventHandler@@ABU12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAXPAUSVictim@CPythonPlayerEventHandler@@0AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAXPAUSVictim@CPythonPlayerEventHandler@@0AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAXPAUSVictim@CPythonPlayerEventHandler@@0AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAUSVictim@CPythonPlayerEventHandler@@@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEPAUSVictim@CPythonPlayerEventHandler@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUSVictim@CPythonPlayerEventHandler@@@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEPAUSVictim@CPythonPlayerEventHandler@@PAU23@00@Z PROC ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Umove<CPythonPlayerEventHandler::SVictim *>, COMDAT
; _this$dead$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000c	83 ec 08	 sub	 esp, 8
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@U12@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::allocator<CPythonPlayerEventHandler::SVictim>,CPythonPlayerEventHandler::SVictim>
  00017	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUSVictim@CPythonPlayerEventHandler@@@?$vector@USVictim@CPythonPlayerEventHandler@@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@IAEPAUSVictim@CPythonPlayerEventHandler@@PAU23@00@Z ENDP ; std::vector<CPythonPlayerEventHandler::SVictim,std::allocator<CPythonPlayerEventHandler::SVictim> >::_Umove<CPythonPlayerEventHandler::SVictim *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@USVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@IPAU12@@Z
_TEXT	SEGMENT
??$_Allocate@USVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@IPAU12@@Z PROC ; std::_Allocate<CPythonPlayerEventHandler::SVictim>, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 55 55 55
	15		 cmp	 ecx, 357913941		; 15555555H
  00006	77 13		 ja	 SHORT $LN1@Allocate
  00008	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0000b	c1 e0 02	 shl	 eax, 2
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001b	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00020	c3		 ret	 0
??$_Allocate@USVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@IPAU12@@Z ENDP ; std::_Allocate<CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAUSVictim@CPythonPlayerEventHandler@@@std@@YAAAUSVictim@CPythonPlayerEventHandler@@AAU12@@Z
_TEXT	SEGMENT
??$forward@AAUSVictim@CPythonPlayerEventHandler@@@std@@YAAAUSVictim@CPythonPlayerEventHandler@@AAU12@@Z PROC ; std::forward<CPythonPlayerEventHandler::SVictim &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAUSVictim@CPythonPlayerEventHandler@@@std@@YAAAUSVictim@CPythonPlayerEventHandler@@AAU12@@Z ENDP ; std::forward<CPythonPlayerEventHandler::SVictim &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@AAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@AAU34@@Z PROC ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 11		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000e	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@AAU34@@Z ENDP ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABUSVictim@CPythonPlayerEventHandler@@@std@@YAABUSVictim@CPythonPlayerEventHandler@@ABU12@@Z
_TEXT	SEGMENT
??$forward@ABUSVictim@CPythonPlayerEventHandler@@@std@@YAABUSVictim@CPythonPlayerEventHandler@@ABU12@@Z PROC ; std::forward<CPythonPlayerEventHandler::SVictim const &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@ABUSVictim@CPythonPlayerEventHandler@@@std@@YAABUSVictim@CPythonPlayerEventHandler@@ABU12@@Z ENDP ; std::forward<CPythonPlayerEventHandler::SVictim const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USVictim@CPythonPlayerEventHandler@@ABU12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USVictim@CPythonPlayerEventHandler@@ABU12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	85 d2		 test	 edx, edx
  00005	74 11		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000e	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$construct@USVictim@CPythonPlayerEventHandler@@ABU12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@USVictim@CPythonPlayerEventHandler@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSVictim@CPythonPlayerEventHandler@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@USVictim@CPythonPlayerEventHandler@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSVictim@CPythonPlayerEventHandler@@0@Z PROC ; std::_Ptr_cat<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@USVictim@CPythonPlayerEventHandler@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSVictim@CPythonPlayerEventHandler@@0@Z ENDP ; std::_Ptr_cat<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAXPAUSVictim@CPythonPlayerEventHandler@@0AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAXPAUSVictim@CPythonPlayerEventHandler@@0AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAXPAUSVictim@CPythonPlayerEventHandler@@0AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = 8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 08	 push	 DWORD PTR __Cat$1[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@U12@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::allocator<CPythonPlayerEventHandler::SVictim>,CPythonPlayerEventHandler::SVictim>
  00011	83 c4 10	 add	 esp, 16			; 00000010H

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Uninitialized_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@ABU34@@Z PROC ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct, COMDAT
; _this$dead$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 594  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?construct@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@ABU34@@Z ENDP ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@AAU23@@Z PROC ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 601  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@USVictim@CPythonPlayerEventHandler@@AAU12@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@AAU23@@Z ENDP ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USVictim@CPythonPlayerEventHandler@@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@USVictim@CPythonPlayerEventHandler@@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::destroy<CPythonPlayerEventHandler::SVictim>, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@USVictim@CPythonPlayerEventHandler@@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::destroy<CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUSVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@@Z
_TEXT	SEGMENT
??$_Unchecked@PAUSVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@@Z PROC ; std::_Unchecked<CPythonPlayerEventHandler::SVictim *>, COMDAT
; __Src$ = ecx

; 281  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 282  : 	}

  00002	c3		 ret	 0
??$_Unchecked@PAUSVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@@Z ENDP ; std::_Unchecked<CPythonPlayerEventHandler::SVictim *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z PROC ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	83 ec 08	 sub	 esp, 8
  0000a	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@U12@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::allocator<CPythonPlayerEventHandler::SVictim>,CPythonPlayerEventHandler::SVictim>
  00012	83 c4 10	 add	 esp, 16			; 00000010H

; 485  : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@U?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@@Z ENDP ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUSVictim@CPythonPlayerEventHandler@@PAU12@@std@@YAAAPAUSVictim@CPythonPlayerEventHandler@@AAPAU12@PAU12@@Z
_TEXT	SEGMENT
??$_Rechecked@PAUSVictim@CPythonPlayerEventHandler@@PAU12@@std@@YAAAPAUSVictim@CPythonPlayerEventHandler@@AAPAU12@PAU12@@Z PROC ; std::_Rechecked<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 289  : 	_Dest = _Src;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 290  : 	return (_Dest);

  00002	8b c1		 mov	 eax, ecx

; 291  : 	}

  00004	c3		 ret	 0
??$_Rechecked@PAUSVictim@CPythonPlayerEventHandler@@PAU12@@std@@YAAAPAUSVictim@CPythonPlayerEventHandler@@AAPAU12@PAU12@@Z ENDP ; std::_Rechecked<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USVictim@CPythonPlayerEventHandler@@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@@Z
_TEXT	SEGMENT
??$destroy@USVictim@CPythonPlayerEventHandler@@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@@Z PROC ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::destroy<CPythonPlayerEventHandler::SVictim>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@USVictim@CPythonPlayerEventHandler@@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@@Z ENDP ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::destroy<CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUSVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@@Z
_TEXT	SEGMENT
??$_Val_type@PAUSVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@@Z PROC ; std::_Val_type<CPythonPlayerEventHandler::SVictim *>, COMDAT
; ___formal$dead$ = ecx

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUSVictim@CPythonPlayerEventHandler@@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@@Z ENDP ; std::_Val_type<CPythonPlayerEventHandler::SVictim *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@U12@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$dead$ = 16					; size = 4
___formal$ = 20						; size = 1
??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@U12@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::allocator<CPythonPlayerEventHandler::SVictim>,CPythonPlayerEventHandler::SVictim>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f2		 cmp	 esi, edx
  0000b	74 1f		 je	 SHORT $LN4@Uninit_mov
  0000d	8d 49 00	 npad	 3
$LL6@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00010	85 c0		 test	 eax, eax
  00012	74 0e		 je	 SHORT $LN24@Uninit_mov
  00014	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  00018	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN24@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00022	83 c6 0c	 add	 esi, 12			; 0000000cH
  00025	83 c0 0c	 add	 eax, 12			; 0000000cH
  00028	3b f2		 cmp	 esi, edx
  0002a	75 e4		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:
  0002c	5e		 pop	 esi

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);
; 451  : 	}

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$_Uninit_move@PAUSVictim@CPythonPlayerEventHandler@@PAU12@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@U12@@std@@YAPAUSVictim@CPythonPlayerEventHandler@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CPythonPlayerEventHandler::SVictim *,CPythonPlayerEventHandler::SVictim *,std::allocator<CPythonPlayerEventHandler::SVictim>,CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USVictim@CPythonPlayerEventHandler@@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@USVictim@CPythonPlayerEventHandler@@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@@Z PROC ; std::allocator<CPythonPlayerEventHandler::SVictim>::destroy<CPythonPlayerEventHandler::SVictim>, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@USVictim@CPythonPlayerEventHandler@@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@@Z ENDP ; std::allocator<CPythonPlayerEventHandler::SVictim>::destroy<CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$_Wrap_alloc@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@USVictim@CPythonPlayerEventHandler@@@std@@YA$$QAUSVictim@CPythonPlayerEventHandler@@AAU12@@Z
_TEXT	SEGMENT
??$forward@USVictim@CPythonPlayerEventHandler@@@std@@YA$$QAUSVictim@CPythonPlayerEventHandler@@AAU12@@Z PROC ; std::forward<CPythonPlayerEventHandler::SVictim>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@USVictim@CPythonPlayerEventHandler@@@std@@YA$$QAUSVictim@CPythonPlayerEventHandler@@AAU12@@Z ENDP ; std::forward<CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 11		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000e	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$allocator_traits@V?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@@std@@SAXAAV?$allocator@USVictim@CPythonPlayerEventHandler@@@1@PAUSVictim@CPythonPlayerEventHandler@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<CPythonPlayerEventHandler::SVictim> >::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@$$QAU23@@Z PROC ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 601  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@USVictim@CPythonPlayerEventHandler@@U12@@?$allocator@USVictim@CPythonPlayerEventHandler@@@std@@QAEXPAUSVictim@CPythonPlayerEventHandler@@$$QAU23@@Z ENDP ; std::allocator<CPythonPlayerEventHandler::SVictim>::construct<CPythonPlayerEventHandler::SVictim,CPythonPlayerEventHandler::SVictim>
_TEXT	ENDS
END
