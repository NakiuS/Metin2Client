; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\MovieMan.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09MGJJCKGJ@intro?4mpg?$AA@		; `string'
PUBLIC	??_C@_0BM@JFEKAACJ@TutorialMovie?2Tutorial0?4mpg?$AA@ ; `string'
PUBLIC	??_C@_0BM@FOBGNDIM@TutorialMovie?2Tutorial1?4mpg?$AA@ ; `string'
PUBLIC	??_C@_0BM@NIICKBCC@TutorialMovie?2Tutorial2?4mpg?$AA@ ; `string'
PUBLIC	??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@		; `string'
PUBLIC	??_C@_03GJLKJKAN@mpg?$AA@			; `string'
PUBLIC	??_C@_04OEEJDDPO@mp43?$AA@			; `string'
PUBLIC	??_C@_1BM@KFENCCEP@?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?5?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@GEEOHGFK@?$AAS?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@DBOEKKK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@CMEFDNDD@?$AAA?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@ ; `string'
EXTRN	_IID_IBasicAudio:BYTE
EXTRN	_DMOCATEGORY_VIDEO_DECODER:BYTE
EXTRN	_IID_IDMOWrapperFilter:BYTE
EXTRN	_CLSID_DMOWrapperFilter:BYTE
EXTRN	_IID_IBaseFilter:BYTE
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_IID_IMultiMediaStream:BYTE
EXTRN	_CLSID_AviSplitter:BYTE
EXTRN	_CLSID_MPEG1Splitter:BYTE
EXTRN	_CLSID_CMpegVideoCodec:BYTE
EXTRN	_CLSID_CMpegAudioCodec:BYTE
EXTRN	_tolower:PROC
EXTRN	?GetFileExtension@@YAXPBDHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GetFileExtension
EXTRN	_MSPID_PrimaryAudio:BYTE
EXTRN	_wcsncpy:PROC
EXTRN	_wcsnlen:PROC
EXTRN	_wcsncat:PROC
EXTRN	__imp__GetCurrentDirectoryW@8:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_CLSID_AMMultiMediaStream:BYTE
EXTRN	_IID_IAMMultiMediaStream:BYTE
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	__imp__GetAsyncKeyState@4:PROC
EXTRN	__imp__SetRect@20:PROC
EXTRN	__imp__OffsetRect@12:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__ClientToScreen@8:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	_IID_IDirectDrawMediaStream:BYTE
EXTRN	_MSPID_PrimaryVideo:BYTE
EXTRN	__imp__DirectDrawCreate@12:PROC
EXTRN	__imp__StretchBlt@44:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__FillRect@12:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__CreateSolidBrush@4:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__PatBlt@24:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	?GetWindowHandle@CMSWindow@@QAEPAUHWND__@@XZ:PROC ; CMSWindow::GetWindowHandle
;	COMDAT ??_C@_1BM@CMEFDNDD@?$AAA?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@CMEFDNDD@?$AAA?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@ DB 'A'
	DB	00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'D', 00H
	DB	'e', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@DBOEKKK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@DBOEKKK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@ DB 'V'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'D', 00H
	DB	'e', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@GEEOHGFK@?$AAS?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GEEOHGFK@?$AAS?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe?$AAr?$AA?$AA@ DB 'S'
	DB	00H, 'p', 00H, 'l', 00H, 'i', 00H, 't', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@KFENCCEP@?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?5?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@KFENCCEP@?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?5?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@ DB 'S'
	DB	00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEEJDDPO@mp43?$AA@
CONST	SEGMENT
??_C@_04OEEJDDPO@mp43?$AA@ DB 'mp43', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJLKJKAN@mpg?$AA@
CONST	SEGMENT
??_C@_03GJLKJKAN@mpg?$AA@ DB 'mpg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@ DB '\', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NIICKBCC@TutorialMovie?2Tutorial2?4mpg?$AA@
CONST	SEGMENT
??_C@_0BM@NIICKBCC@TutorialMovie?2Tutorial2?4mpg?$AA@ DB 'TutorialMovie\T'
	DB	'utorial2.mpg', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FOBGNDIM@TutorialMovie?2Tutorial1?4mpg?$AA@
CONST	SEGMENT
??_C@_0BM@FOBGNDIM@TutorialMovie?2Tutorial1?4mpg?$AA@ DB 'TutorialMovie\T'
	DB	'utorial1.mpg', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JFEKAACJ@TutorialMovie?2Tutorial0?4mpg?$AA@
CONST	SEGMENT
??_C@_0BM@JFEKAACJ@TutorialMovie?2Tutorial0?4mpg?$AA@ DB 'TutorialMovie\T'
	DB	'utorial0.mpg', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MGJJCKGJ@intro?4mpg?$AA@
CONST	SEGMENT
??_C@_09MGJJCKGJ@intro?4mpg?$AA@ DB 'intro.mpg', 00H	; `string'
_CLSID_MP3AudioCodec DD 038be3000H
	DW	0dbf4H
	DW	011d0H
	DB	086H
	DB	0eH
	DB	00H
	DB	0a0H
	DB	024H
	DB	0cfH
	DB	0efH
	DB	06dH
_CLSID_MP4VideoCodec DD 082ccd3e0H
	DW	0f71aH
	DW	011d0H
	DB	09fH
	DB	0e5H
	DB	00H
	DB	060H
	DB	097H
	DB	078H
	DB	0eaH
	DB	066H
_CLSID_MP43DMOCodec DD 0cba9e78bH
	DW	049a3H
	DW	049eaH
	DB	093H
	DB	0d4H
	DB	06bH
	DB	0cbH
	DB	0a8H
	DB	0c4H
	DB	0deH
	DB	07H
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	_IsEqualGUID
PUBLIC	??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
PUBLIC	?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++
PUBLIC	??E?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator++
PUBLIC	?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unchecked
PUBLIC	??$_Transform@PADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@PAD0V10@P6AHH@Z@Z ; std::_Transform<char *,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
PUBLIC	??$_Unchecked@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Unchecked<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator!=
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@00P6AHH@Z@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
PUBLIC	?BuildFilterGraphManually@CMovieMan@@AAEJPA_WPAUIAMMultiMediaStream@@U_GUID@@22@Z ; CMovieMan::BuildFilterGraphManually
PUBLIC	?RenderPostEffectFadeOut@CMovieMan@@AAEJPAUIDirectDrawSurface@@HK@Z ; CMovieMan::RenderPostEffectFadeOut
PUBLIC	?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z ; CMovieMan::RenderFileToMMStream
PUBLIC	?RenderStreamToSurface@CMovieMan@@AAEJPAUIDirectDrawSurface@@PAUIDirectDrawMediaStream@@PAUIMultiMediaStream@@_NHK@Z ; CMovieMan::RenderStreamToSurface
PUBLIC	?CalcBackgroundRect@CMovieMan@@AAEXABUtagRECT@@AAU2@1@Z ; CMovieMan::CalcBackgroundRect
PUBLIC	?CalcMovieRect@CMovieMan@@AAEXHHAAUtagRECT@@@Z	; CMovieMan::CalcMovieRect
PUBLIC	?GetWindowRect@CMovieMan@@AAEXAAUtagRECT@@@Z	; CMovieMan::GetWindowRect
PUBLIC	?PlayMovie@CMovieMan@@AAEHPBD_NHK@Z		; CMovieMan::PlayMovie
PUBLIC	?PlayLogo@CMovieMan@@QAEXPBD@Z			; CMovieMan::PlayLogo
PUBLIC	?GDIBlt@CMovieMan@@AAEXPAUIDirectDrawSurface@@PAUtagRECT@@@Z ; CMovieMan::GDIBlt
PUBLIC	?GDIFillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z	; CMovieMan::GDIFillRect
PUBLIC	?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z	; CMovieMan::FillRect
PUBLIC	?Instance@CPythonApplication@@SAAAV1@XZ		; CPythonApplication::Instance
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z$0
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.h
;	COMDAT ?Instance@CPythonApplication@@SAAAV1@XZ
_TEXT	SEGMENT
?Instance@CPythonApplication@@SAAAV1@XZ PROC		; CPythonApplication::Instance, COMDAT

; 142  : 			assert(ms_pInstance != NULL);
; 143  : 			return *ms_pInstance;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance

; 144  : 		}

  00005	c3		 ret	 0
?Instance@CPythonApplication@@SAAAV1@XZ ENDP		; CPythonApplication::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z
_TEXT	SEGMENT
_colorFillBltFX$ = -100					; size = 100
_fillRect$ = 8						; size = 4
_fillColor$ = 12					; size = 4
?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z PROC		; CMovieMan::FillRect, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx

; 54   : 	assert(m_pPrimarySurface);
; 55   : 
; 56   : 	if (fillRect.bottom == fillRect.top || fillRect.left == fillRect.right)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _fillRect$[ebp]
  0000a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0000d	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  00010	0f 84 83 00 00
	00		 je	 $LN3@FillRect
  00016	8b 03		 mov	 eax, DWORD PTR [ebx]
  00018	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  0001b	74 7c		 je	 SHORT $LN3@FillRect

; 57   : 	{
; 58   : 		// 채울 필요 없음
; 59   : 		return;
; 60   : 	}
; 61   : 
; 62   : 	DDBLTFX colorFillBltFX;
; 63   : 	colorFillBltFX.dwSize = sizeof(DDBLTFX);
; 64   : 	colorFillBltFX.dwFillColor = fillColor;
; 65   : 	if (!m_usingRGB32 || FAILED(m_pPrimarySurface->Blt(&fillRect, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &colorFillBltFX)))

  0001d	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00021	8b 55 0c	 mov	 edx, DWORD PTR _fillColor$[ebp]
  00024	c7 45 9c 64 00
	00 00		 mov	 DWORD PTR _colorFillBltFX$[ebp], 100 ; 00000064H
  0002b	89 55 ec	 mov	 DWORD PTR _colorFillBltFX$[ebp+80], edx
  0002e	74 1e		 je	 SHORT $LN1@FillRect
  00030	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00033	8d 55 9c	 lea	 edx, DWORD PTR _colorFillBltFX$[ebp]
  00036	52		 push	 edx
  00037	68 00 04 00 01	 push	 16778240		; 01000400H
  0003c	6a 00		 push	 0
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	6a 00		 push	 0
  00042	53		 push	 ebx
  00043	50		 push	 eax
  00044	ff 51 14	 call	 DWORD PTR [ecx+20]
  00047	85 c0		 test	 eax, eax
  00049	79 4e		 jns	 SHORT $LN3@FillRect
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _fillColor$[ebp]
$LN1@FillRect:

; 71   : 
; 72   : inline void CMovieMan::GDIFillRect( RECT& fillRect, DWORD fillColor )
; 73   : {
; 74   : 	HBRUSH fillBrush = CreateSolidBrush(
; 75   : 		RGB((fillColor >> 16) & 255, (fillColor >> 8) & 255, fillColor & 255)
; 76   : 		);

  0004e	8b c2		 mov	 eax, edx
  00050	c1 e8 08	 shr	 eax, 8
  00053	0f b6 c8	 movzx	 ecx, al
  00056	0f b6 c2	 movzx	 eax, dl
  00059	c1 e0 08	 shl	 eax, 8
  0005c	0b c8		 or	 ecx, eax
  0005e	c1 ea 10	 shr	 edx, 16			; 00000010H
  00061	56		 push	 esi
  00062	c1 e1 08	 shl	 ecx, 8
  00065	0f b6 c2	 movzx	 eax, dl
  00068	57		 push	 edi
  00069	0b c8		 or	 ecx, eax
  0006b	51		 push	 ecx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4

; 77   : 
; 78   : 	HDC desktopDC = GetDC(0);

  00072	6a 00		 push	 0
  00074	8b f8		 mov	 edi, eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4

; 79   : 	::FillRect(desktopDC, &fillRect, fillBrush);

  0007c	57		 push	 edi
  0007d	8b f0		 mov	 esi, eax
  0007f	53		 push	 ebx
  00080	56		 push	 esi
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 80   : 	ReleaseDC(0, desktopDC);

  00087	56		 push	 esi
  00088	6a 00		 push	 0
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 81   : 
; 82   : 	DeleteObject(fillBrush);

  00090	57		 push	 edi
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
$LN3@FillRect:
  00099	5b		 pop	 ebx

; 66   : 	{
; 67   : 		GDIFillRect(fillRect, fillColor);
; 68   : 		return;
; 69   : 	}
; 70   : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z ENDP		; CMovieMan::FillRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?GDIFillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z
_TEXT	SEGMENT
_fillRect$ = 8						; size = 4
_fillColor$ = 12					; size = 4
?GDIFillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z PROC	; CMovieMan::GDIFillRect, COMDAT
; _this$dead$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   : 	HBRUSH fillBrush = CreateSolidBrush(
; 75   : 		RGB((fillColor >> 16) & 255, (fillColor >> 8) & 255, fillColor & 255)
; 76   : 		);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _fillColor$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	c1 e8 08	 shr	 eax, 8
  0000b	0f b6 c8	 movzx	 ecx, al
  0000e	0f b6 c2	 movzx	 eax, dl
  00011	c1 e0 08	 shl	 eax, 8
  00014	0b c8		 or	 ecx, eax
  00016	c1 ea 10	 shr	 edx, 16			; 00000010H
  00019	56		 push	 esi
  0001a	c1 e1 08	 shl	 ecx, 8
  0001d	0f b6 c2	 movzx	 eax, dl
  00020	57		 push	 edi
  00021	0b c8		 or	 ecx, eax
  00023	51		 push	 ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4

; 77   : 
; 78   : 	HDC desktopDC = GetDC(0);

  0002a	6a 00		 push	 0
  0002c	8b f8		 mov	 edi, eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4

; 79   : 	::FillRect(desktopDC, &fillRect, fillBrush);

  00034	57		 push	 edi
  00035	ff 75 08	 push	 DWORD PTR _fillRect$[ebp]
  00038	8b f0		 mov	 esi, eax
  0003a	56		 push	 esi
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 80   : 	ReleaseDC(0, desktopDC);

  00041	56		 push	 esi
  00042	6a 00		 push	 0
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 81   : 
; 82   : 	DeleteObject(fillBrush);

  0004a	57		 push	 edi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 83   : }

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?GDIFillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z ENDP	; CMovieMan::GDIFillRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?GDIBlt@CMovieMan@@AAEXPAUIDirectDrawSurface@@PAUtagRECT@@@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_surfaceDC$ = -4					; size = 4
_pSrcSurface$ = 8					; size = 4
_pDestRect$ = 12					; size = 4
?GDIBlt@CMovieMan@@AAEXPAUIDirectDrawSurface@@PAUtagRECT@@@Z PROC ; CMovieMan::GDIBlt, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 90   : 	HDC surfaceDC;
; 91   : 	HDC desktopDC = GetDC(0);

  00008	6a 00		 push	 0
  0000a	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4

; 92   : 	if (SUCCEEDED(pSrcSurface->GetDC(&surfaceDC)))

  00013	8b 7d 08	 mov	 edi, DWORD PTR _pSrcSurface$[ebp]
  00016	8b d8		 mov	 ebx, eax
  00018	8d 45 fc	 lea	 eax, DWORD PTR _surfaceDC$[ebp]
  0001b	50		 push	 eax
  0001c	57		 push	 edi
  0001d	8b 17		 mov	 edx, DWORD PTR [edi]
  0001f	ff 52 44	 call	 DWORD PTR [edx+68]
  00022	85 c0		 test	 eax, eax
  00024	78 3a		 js	 SHORT $LN1@GDIBlt

; 93   : 	{
; 94   : 		StretchBlt(desktopDC, pDestRect->left, pDestRect->top, pDestRect->right - pDestRect->left, pDestRect->bottom - pDestRect->top,
; 95   : 			surfaceDC, 0, 0, m_movieWidth, m_movieHeight, SRCCOPY);

  00026	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _pDestRect$[ebp]
  0002c	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00031	ff 70 0c	 push	 DWORD PTR [eax+12]
  00034	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00037	ff 70 08	 push	 DWORD PTR [eax+8]
  0003a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	ff 75 fc	 push	 DWORD PTR _surfaceDC$[ebp]
  00044	2b c2		 sub	 eax, edx
  00046	50		 push	 eax
  00047	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004c	50		 push	 eax
  0004d	52		 push	 edx
  0004e	ff 31		 push	 DWORD PTR [ecx]
  00050	53		 push	 ebx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchBlt@44

; 96   : 		pSrcSurface->ReleaseDC(surfaceDC);

  00057	ff 75 fc	 push	 DWORD PTR _surfaceDC$[ebp]
  0005a	8b 07		 mov	 eax, DWORD PTR [edi]
  0005c	57		 push	 edi
  0005d	ff 50 68	 call	 DWORD PTR [eax+104]
$LN1@GDIBlt:

; 97   : 	}
; 98   : 	ReleaseDC(0, desktopDC);

  00060	53		 push	 ebx
  00061	6a 00		 push	 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  00069	5f		 pop	 edi
  0006a	5b		 pop	 ebx

; 99   : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
?GDIBlt@CMovieMan@@AAEXPAUIDirectDrawSurface@@PAUtagRECT@@@Z ENDP ; CMovieMan::GDIBlt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?PlayLogo@CMovieMan@@QAEXPBD@Z
_TEXT	SEGMENT
_pcszName$ = 8						; size = 4
?PlayLogo@CMovieMan@@QAEXPBD@Z PROC			; CMovieMan::PlayLogo, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  : 	PlayMovie(pcszName);

  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	ff 75 08	 push	 DWORD PTR _pcszName$[ebp]
  00009	e8 00 00 00 00	 call	 ?PlayMovie@CMovieMan@@AAEHPBD_NHK@Z ; CMovieMan::PlayMovie

; 104  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?PlayLogo@CMovieMan@@QAEXPBD@Z ENDP			; CMovieMan::PlayLogo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?PlayMovie@CMovieMan@@AAEHPBD_NHK@Z
_TEXT	SEGMENT
_pDD$ = -296						; size = 4
_pDDClipper$ = -292					; size = 4
_pDDStream$1 = -288					; size = 4
_pMMStream$ = -284					; size = 4
_cpFileName$GSCopy$1$ = -280				; size = 4
_pSurface$2 = -280					; size = 4
_this$GSCopy$1$ = -276					; size = 4
_pPrimaryVidStream$3 = -272				; size = 4
_hr$1$ = -268						; size = 4
tv419 = -264						; size = 4
_msg$ = -260						; size = 28
_ddsd$ = -232						; size = 108
_ddsdBackSurface$4 = -120				; size = 108
__$ArrayPad$ = -4					; size = 4
_cpFileName$ = 8					; size = 4
_bSkipAllowed$dead$ = 12				; size = 1
_nPostEffectID$dead$ = 16				; size = 4
_dwPostEffectData$dead$ = 20				; size = 4
?PlayMovie@CMovieMan@@AAEHPBD_NHK@Z PROC		; CMovieMan::PlayMovie, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 28 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+300], eax
  0001a	8b 45 08	 mov	 eax, DWORD PTR _cpFileName$[ebp]
  0001d	53		 push	 ebx
  0001e	56		 push	 esi
  0001f	8b f1		 mov	 esi, ecx
  00021	89 44 24 1c	 mov	 DWORD PTR _cpFileName$GSCopy$1$[esp+308], eax

; 132  : 	HWND hWnd = CPythonApplication::Instance().GetWindowHandle();

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  0002b	57		 push	 edi
  0002c	89 74 24 24	 mov	 DWORD PTR _this$GSCopy$1$[esp+312], esi
  00030	e8 00 00 00 00	 call	 ?GetWindowHandle@CMSWindow@@QAEPAUHWND__@@XZ ; CMSWindow::GetWindowHandle
  00035	8b d8		 mov	 ebx, eax

; 133  : 
; 134  : 	IDirectDraw *pDD = NULL;

  00037	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _pDD$[esp+312], 0

; 135  : 	DirectDrawCreate(NULL, &pDD, NULL);

  0003f	6a 00		 push	 0
  00041	8d 44 24 14	 lea	 eax, DWORD PTR _pDD$[esp+316]
  00045	50		 push	 eax
  00046	6a 00		 push	 0
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DirectDrawCreate@12

; 136  : 	pDD->SetCooperativeLevel(hWnd, DDSCL_NORMAL);

  0004e	8b 4c 24 10	 mov	 ecx, DWORD PTR _pDD$[esp+312]
  00052	6a 08		 push	 8
  00054	53		 push	 ebx
  00055	51		 push	 ecx
  00056	8b 11		 mov	 edx, DWORD PTR [ecx]
  00058	ff 52 50	 call	 DWORD PTR [edx+80]

; 137  : 
; 138  : 	DDSURFACEDESC ddsd;
; 139  : 	ZeroMemory(&ddsd, sizeof(ddsd));

  0005b	6a 6c		 push	 108			; 0000006cH
  0005d	8d 44 24 54	 lea	 eax, DWORD PTR _ddsd$[esp+316]
  00061	6a 00		 push	 0
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memset

; 140  : 	ddsd.dwSize = sizeof(ddsd);
; 141  : 	ddsd.dwFlags = DDSD_CAPS;
; 142  : 	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
; 143  : 	if (FAILED(pDD->CreateSurface(&ddsd, &m_pPrimarySurface, NULL)))

  00069	8b 44 24 1c	 mov	 eax, DWORD PTR _pDD$[esp+324]
  0006d	8d 7e 20	 lea	 edi, DWORD PTR [esi+32]
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	c7 44 24 50 6c
	00 00 00	 mov	 DWORD PTR _ddsd$[esp+312], 108 ; 0000006cH
  0007b	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR _ddsd$[esp+316], 1
  00083	8d 54 24 50	 lea	 edx, DWORD PTR _ddsd$[esp+312]
  00087	c7 84 24 b8 00
	00 00 00 02 00
	00		 mov	 DWORD PTR _ddsd$[esp+416], 512 ; 00000200H
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	6a 00		 push	 0
  00096	57		 push	 edi
  00097	52		 push	 edx
  00098	50		 push	 eax
  00099	89 7c 24 40	 mov	 DWORD PTR tv419[esp+328], edi
  0009d	ff 51 18	 call	 DWORD PTR [ecx+24]
  000a0	85 c0		 test	 eax, eax
  000a2	79 23		 jns	 SHORT $LN12@PlayMovie

; 144  : 	{
; 145  : 		pDD->Release();

  000a4	8b 44 24 10	 mov	 eax, DWORD PTR _pDD$[esp+312]
  000a8	50		 push	 eax
  000a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ab	ff 51 08	 call	 DWORD PTR [ecx+8]

; 146  : 		return FALSE;

  000ae	33 c0		 xor	 eax, eax

; 237  : }

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+300]
  000ba	33 cc		 xor	 ecx, esp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 10 00	 ret	 16			; 00000010H
$LN12@PlayMovie:

; 147  : 	}
; 148  : 
; 149  : 	// 32비트인지 알아본다
; 150  : 	ZeroMemory(&ddsd, sizeof(ddsd));

  000c7	6a 6c		 push	 108			; 0000006cH
  000c9	8d 44 24 54	 lea	 eax, DWORD PTR _ddsd$[esp+316]
  000cd	6a 00		 push	 0
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _memset

; 151  : 	ddsd.dwSize = sizeof(ddsd);
; 152  : 	ddsd.dwFlags = DDSD_PIXELFORMAT;
; 153  : 	m_pPrimarySurface->GetSurfaceDesc(&ddsd);

  000d5	8b 07		 mov	 eax, DWORD PTR [edi]
  000d7	8d 54 24 5c	 lea	 edx, DWORD PTR _ddsd$[esp+324]
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	c7 44 24 50 6c
	00 00 00	 mov	 DWORD PTR _ddsd$[esp+312], 108 ; 0000006cH
  000e6	c7 44 24 54 00
	10 00 00	 mov	 DWORD PTR _ddsd$[esp+316], 4096 ; 00001000H
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	52		 push	 edx
  000f1	50		 push	 eax
  000f2	ff 51 58	 call	 DWORD PTR [ecx+88]

; 154  : 	ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
; 155  : 	m_usingRGB32 = (ddsd.ddpfPixelFormat.dwRGBBitCount == 32);

  000f5	83 bc 24 a4 00
	00 00 20	 cmp	 DWORD PTR _ddsd$[esp+396], 32 ; 00000020H

; 156  : 
; 157  : 	IDirectDrawClipper *pDDClipper = NULL;
; 158  : 	HRESULT hr = pDD->CreateClipper(0, &pDDClipper, NULL);

  000fd	8d 54 24 14	 lea	 edx, DWORD PTR _pDDClipper$[esp+312]
  00101	6a 00		 push	 0
  00103	0f 94 c0	 sete	 al
  00106	c7 84 24 9c 00
	00 00 20 00 00
	00		 mov	 DWORD PTR _ddsd$[esp+388], 32 ; 00000020H
  00111	88 46 04	 mov	 BYTE PTR [esi+4], al
  00114	8b 44 24 14	 mov	 eax, DWORD PTR _pDD$[esp+316]
  00118	52		 push	 edx
  00119	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _pDDClipper$[esp+320], 0
  00121	6a 00		 push	 0
  00123	8b 08		 mov	 ecx, DWORD PTR [eax]
  00125	50		 push	 eax
  00126	ff 51 10	 call	 DWORD PTR [ecx+16]

; 159  : 	if (SUCCEEDED(hr))

  00129	85 c0		 test	 eax, eax
  0012b	78 19		 js	 SHORT $LN11@PlayMovie

; 160  : 	{
; 161  : 		pDDClipper->SetHWnd(0, hWnd);

  0012d	8b 44 24 14	 mov	 eax, DWORD PTR _pDDClipper$[esp+312]
  00131	53		 push	 ebx
  00132	6a 00		 push	 0
  00134	50		 push	 eax
  00135	8b 08		 mov	 ecx, DWORD PTR [eax]
  00137	ff 51 20	 call	 DWORD PTR [ecx+32]

; 162  : 		m_pPrimarySurface->SetClipper(pDDClipper);

  0013a	8b 07		 mov	 eax, DWORD PTR [edi]
  0013c	ff 74 24 14	 push	 DWORD PTR _pDDClipper$[esp+312]
  00140	50		 push	 eax
  00141	8b 08		 mov	 ecx, DWORD PTR [eax]
  00143	ff 51 70	 call	 DWORD PTR [ecx+112]
$LN11@PlayMovie:

; 163  : 	}
; 164  : 
; 165  : 	IMultiMediaStream *pMMStream = NULL;
; 166  : 	hr = RenderFileToMMStream(cpFileName, &pMMStream, pDD);

  00146	ff 74 24 10	 push	 DWORD PTR _pDD$[esp+312]
  0014a	8d 44 24 20	 lea	 eax, DWORD PTR _pMMStream$[esp+316]
  0014e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _pMMStream$[esp+316], 0
  00156	50		 push	 eax
  00157	ff 74 24 28	 push	 DWORD PTR _cpFileName$GSCopy$1$[esp+320]
  0015b	8b ce		 mov	 ecx, esi
  0015d	e8 00 00 00 00	 call	 ?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z ; CMovieMan::RenderFileToMMStream
  00162	89 44 24 2c	 mov	 DWORD PTR _hr$1$[esp+312], eax

; 167  : 	if (SUCCEEDED(hr))

  00166	85 c0		 test	 eax, eax
  00168	0f 88 63 01 00
	00		 js	 $LN10@PlayMovie

; 168  : 	{
; 169  : 		IMediaStream *pPrimaryVidStream = NULL;
; 170  : 		HRESULT hr = pMMStream->GetMediaStream(MSPID_PrimaryVideo, &pPrimaryVidStream);

  0016e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pMMStream$[esp+312]
  00172	8d 44 24 28	 lea	 eax, DWORD PTR _pPrimaryVidStream$3[esp+312]
  00176	50		 push	 eax
  00177	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _pPrimaryVidStream$3[esp+316], 0
  0017f	68 00 00 00 00	 push	 OFFSET _MSPID_PrimaryVideo
  00184	8b 11		 mov	 edx, DWORD PTR [ecx]
  00186	51		 push	 ecx
  00187	ff 52 10	 call	 DWORD PTR [edx+16]

; 171  : 		if (SUCCEEDED(hr))

  0018a	85 c0		 test	 eax, eax
  0018c	0f 88 35 01 00
	00		 js	 $LN9@PlayMovie

; 172  : 		{
; 173  : 			IDirectDrawMediaStream *pDDStream = NULL;
; 174  : 			pPrimaryVidStream->QueryInterface(IID_IDirectDrawMediaStream, (void **) &pDDStream);

  00192	8b 44 24 28	 mov	 eax, DWORD PTR _pPrimaryVidStream$3[esp+312]
  00196	8d 54 24 18	 lea	 edx, DWORD PTR _pDDStream$1[esp+312]
  0019a	52		 push	 edx
  0019b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _pDDStream$1[esp+316], 0
  001a3	68 00 00 00 00	 push	 OFFSET _IID_IDirectDrawMediaStream
  001a8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001aa	50		 push	 eax
  001ab	ff 11		 call	 DWORD PTR [ecx]

; 175  : 			pPrimaryVidStream->Release();

  001ad	8b 44 24 28	 mov	 eax, DWORD PTR _pPrimaryVidStream$3[esp+312]
  001b1	50		 push	 eax
  001b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b4	ff 51 08	 call	 DWORD PTR [ecx+8]

; 176  : 
; 177  : 			ddsd.dwSize = sizeof(ddsd);
; 178  : 			hr = pDDStream->GetFormat(&ddsd, NULL, NULL, NULL);

  001b7	8b 44 24 18	 mov	 eax, DWORD PTR _pDDStream$1[esp+312]
  001bb	8d 54 24 50	 lea	 edx, DWORD PTR _ddsd$[esp+312]
  001bf	6a 00		 push	 0
  001c1	6a 00		 push	 0
  001c3	6a 00		 push	 0
  001c5	c7 44 24 5c 6c
	00 00 00	 mov	 DWORD PTR _ddsd$[esp+324], 108 ; 0000006cH
  001cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cf	52		 push	 edx
  001d0	50		 push	 eax
  001d1	ff 51 24	 call	 DWORD PTR [ecx+36]

; 179  : 			if (SUCCEEDED(hr))

  001d4	85 c0		 test	 eax, eax
  001d6	0f 88 e1 00 00
	00		 js	 $LN7@PlayMovie

; 180  : 			{
; 181  : 				// 동영상 크기와 윈도우 크기를 기준으로 동영상 재생될 적당한 영역을 설정
; 182  : 				m_movieWidth = ddsd.dwWidth;
; 183  : 				m_movieHeight = ddsd.dwHeight;

  001dc	8b 44 24 24	 mov	 eax, DWORD PTR _this$GSCopy$1$[esp+312]
  001e0	8b 7c 24 5c	 mov	 edi, DWORD PTR _ddsd$[esp+324]
  001e4	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  001e7	8b 74 24 58	 mov	 esi, DWORD PTR _ddsd$[esp+320]

; 184  : 
; 185  : 				// 백버퍼는 무조건 RGB32로 만들고 PrimarySurface와 형식이 다르면
; 186  : 				// GDI fallback 해서 StretchBlt 한다
; 187  : 				DDSURFACEDESC ddsdBackSurface;
; 188  : 				ZeroMemory(&ddsdBackSurface, sizeof(ddsdBackSurface));

  001eb	6a 6c		 push	 108			; 0000006cH
  001ed	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  001f0	8d 84 24 c4 00
	00 00		 lea	 eax, DWORD PTR _ddsdBackSurface$4[esp+316]
  001f7	6a 00		 push	 0
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 _memset

; 189  : 				ddsdBackSurface.ddpfPixelFormat.dwSize = sizeof(ddsdBackSurface.ddpfPixelFormat);
; 190  : 				ddsdBackSurface.ddpfPixelFormat.dwFlags = DDPF_RGB;
; 191  : 				ddsdBackSurface.ddpfPixelFormat.dwRGBBitCount = 32;
; 192  : 				ddsdBackSurface.ddpfPixelFormat.dwRBitMask = 255 << 16;
; 193  : 				ddsdBackSurface.ddpfPixelFormat.dwGBitMask = 255 << 8;
; 194  : 				ddsdBackSurface.ddpfPixelFormat.dwBBitMask = 255;
; 195  : 				ddsdBackSurface.dwSize = sizeof(ddsdBackSurface);
; 196  : 				ddsdBackSurface.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
; 197  : 				ddsdBackSurface.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
; 198  : 				ddsdBackSurface.dwHeight = m_movieHeight;
; 199  : 				ddsdBackSurface.dwWidth = m_movieWidth;
; 200  : 
; 201  : 				IDirectDrawSurface *pSurface;
; 202  : 				hr = pDD->CreateSurface(&ddsdBackSurface, &pSurface, NULL);

  001ff	8b 44 24 1c	 mov	 eax, DWORD PTR _pDD$[esp+324]
  00203	8d 54 24 2c	 lea	 edx, DWORD PTR _pSurface$2[esp+324]
  00207	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020a	c7 84 24 08 01
	00 00 20 00 00
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+384], 32 ; 00000020H
  00215	c7 84 24 0c 01
	00 00 40 00 00
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+388], 64 ; 00000040H
  00220	c7 84 24 14 01
	00 00 20 00 00
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+396], 32 ; 00000020H
  0022b	c7 84 24 18 01
	00 00 00 00 ff
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+400], 16711680 ; 00ff0000H
  00236	6a 00		 push	 0
  00238	52		 push	 edx
  00239	c7 84 24 24 01
	00 00 00 ff 00
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+412], 65280 ; 0000ff00H
  00244	8d 94 24 c8 00
	00 00		 lea	 edx, DWORD PTR _ddsdBackSurface$4[esp+320]
  0024b	c7 84 24 28 01
	00 00 ff 00 00
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+416], 255 ; 000000ffH
  00256	c7 84 24 c8 00
	00 00 6c 00 00
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+320], 108 ; 0000006cH
  00261	c7 84 24 cc 00
	00 00 07 10 00
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+324], 4103 ; 00001007H
  0026c	c7 84 24 30 01
	00 00 40 08 00
	00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+424], 2112 ; 00000840H
  00277	89 b4 24 d0 00
	00 00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+328], esi
  0027e	89 bc 24 d4 00
	00 00		 mov	 DWORD PTR _ddsdBackSurface$4[esp+332], edi
  00285	8b 08		 mov	 ecx, DWORD PTR [eax]
  00287	52		 push	 edx
  00288	50		 push	 eax
  00289	ff 51 18	 call	 DWORD PTR [ecx+24]

; 203  : 				if (SUCCEEDED(hr))
; 204  : 				{ 
; 205  : 					RenderStreamToSurface(pSurface, pDDStream, pMMStream, bSkipAllowed, nPostEffectID, dwPostEffectData);

  0028c	8b 74 24 24	 mov	 esi, DWORD PTR _this$GSCopy$1$[esp+312]
  00290	85 c0		 test	 eax, eax
  00292	78 25		 js	 SHORT $LN28@PlayMovie
  00294	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00297	8b ce		 mov	 ecx, esi
  00299	ff 74 24 28	 push	 DWORD PTR _pMMStream$[esp+324]
  0029d	ff 74 24 28	 push	 DWORD PTR _pDDStream$1[esp+328]
  002a1	ff 74 24 34	 push	 DWORD PTR _pSurface$2[esp+332]
  002a5	e8 00 00 00 00	 call	 ?RenderStreamToSurface@CMovieMan@@AAEJPAUIDirectDrawSurface@@PAUIDirectDrawMediaStream@@PAUIMultiMediaStream@@_NHK@Z ; CMovieMan::RenderStreamToSurface

; 206  : 					pSurface->Release();

  002aa	8b 44 24 20	 mov	 eax, DWORD PTR _pSurface$2[esp+312]
  002ae	50		 push	 eax
  002af	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b1	ff 51 08	 call	 DWORD PTR [ecx+8]
  002b4	8d 7e 20	 lea	 edi, DWORD PTR [esi+32]
  002b7	eb 04		 jmp	 SHORT $LN7@PlayMovie
$LN28@PlayMovie:
  002b9	8b 7c 24 30	 mov	 edi, DWORD PTR tv419[esp+312]
$LN7@PlayMovie:

; 207  : 				}
; 208  : 			}
; 209  : 			pDDStream->Release();

  002bd	8b 44 24 18	 mov	 eax, DWORD PTR _pDDStream$1[esp+312]
  002c1	50		 push	 eax
  002c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c4	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN9@PlayMovie:

; 210  : 		}
; 211  : 		pMMStream->Release();

  002c7	8b 44 24 1c	 mov	 eax, DWORD PTR _pMMStream$[esp+312]
  002cb	50		 push	 eax
  002cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ce	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN10@PlayMovie:

; 212  : 	}
; 213  : 
; 214  : 	m_pPrimarySurface->Release();

  002d1	8b 07		 mov	 eax, DWORD PTR [edi]
  002d3	50		 push	 eax
  002d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d6	ff 51 08	 call	 DWORD PTR [ecx+8]

; 215  : 	m_pPrimarySurface = NULL;
; 216  : 
; 217  : 	if (m_pBasicAudio)

  002d9	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  002dc	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  002e2	85 c9		 test	 ecx, ecx
  002e4	74 0d		 je	 SHORT $LN6@PlayMovie

; 218  : 	{
; 219  : 		m_pBasicAudio->Release();

  002e6	8b 01		 mov	 eax, DWORD PTR [ecx]
  002e8	51		 push	 ecx
  002e9	ff 50 08	 call	 DWORD PTR [eax+8]

; 220  : 		m_pBasicAudio = NULL;

  002ec	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
$LN6@PlayMovie:

; 221  : 	}
; 222  : 
; 223  : 	if (pDDClipper)

  002f3	8b 4c 24 14	 mov	 ecx, DWORD PTR _pDDClipper$[esp+312]
  002f7	85 c9		 test	 ecx, ecx
  002f9	74 0e		 je	 SHORT $LN5@PlayMovie

; 224  : 	{
; 225  : 		pDDClipper->Release();

  002fb	8b 01		 mov	 eax, DWORD PTR [ecx]
  002fd	51		 push	 ecx
  002fe	ff 50 08	 call	 DWORD PTR [eax+8]

; 226  : 		pDDClipper = NULL;

  00301	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _pDDClipper$[esp+312], 0
$LN5@PlayMovie:

; 227  : 	}
; 228  : 
; 229  : 	pDD->Release(); 

  00309	8b 44 24 10	 mov	 eax, DWORD PTR _pDD$[esp+312]
  0030d	50		 push	 eax
  0030e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00310	ff 51 08	 call	 DWORD PTR [ecx+8]
  00313	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PeekMessageA@20
  00319	8d a4 24 00 00
	00 00		 npad	 7
$LL4@PlayMovie:

; 230  : 
; 231  : 	// 키보드, 마우스 버퍼 비우기
; 232  : 	MSG msg;
; 233  : 	while (PeekMessage(&msg, hWnd, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE));

  00320	6a 01		 push	 1
  00322	68 09 01 00 00	 push	 265			; 00000109H
  00327	68 00 01 00 00	 push	 256			; 00000100H
  0032c	53		 push	 ebx
  0032d	8d 44 24 44	 lea	 eax, DWORD PTR _msg$[esp+328]
  00331	50		 push	 eax
  00332	ff d6		 call	 esi
  00334	85 c0		 test	 eax, eax
  00336	75 e8		 jne	 SHORT $LL4@PlayMovie
  00338	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL2@PlayMovie:

; 234  : 	while (PeekMessage(&msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE));

  00340	6a 01		 push	 1
  00342	68 0e 02 00 00	 push	 526			; 0000020eH
  00347	68 00 02 00 00	 push	 512			; 00000200H
  0034c	53		 push	 ebx
  0034d	8d 44 24 44	 lea	 eax, DWORD PTR _msg$[esp+328]
  00351	50		 push	 eax
  00352	ff d6		 call	 esi
  00354	85 c0		 test	 eax, eax
  00356	75 e8		 jne	 SHORT $LL2@PlayMovie

; 235  : 
; 236  : 	return SUCCEEDED(hr);

  00358	39 44 24 2c	 cmp	 DWORD PTR _hr$1$[esp+312], eax

; 237  : }

  0035c	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+312]
  00363	5f		 pop	 edi
  00364	5e		 pop	 esi
  00365	0f 9d c0	 setge	 al
  00368	5b		 pop	 ebx
  00369	33 cc		 xor	 ecx, esp
  0036b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00370	8b e5		 mov	 esp, ebp
  00372	5d		 pop	 ebp
  00373	c2 10 00	 ret	 16			; 00000010H
?PlayMovie@CMovieMan@@AAEHPBD_NHK@Z ENDP		; CMovieMan::PlayMovie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?GetWindowRect@CMovieMan@@AAEXAAUtagRECT@@@Z
_TEXT	SEGMENT
_p$ = -12						; size = 8
_windowRect$ = 8					; size = 4
?GetWindowRect@CMovieMan@@AAEXAAUtagRECT@@@Z PROC	; CMovieMan::GetWindowRect, COMDAT
; _this$dead$ = ecx

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 244  : 	HWND hWnd = CPythonApplication::Instance().GetWindowHandle();

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 ?GetWindowHandle@CMSWindow@@QAEPAUHWND__@@XZ ; CMSWindow::GetWindowHandle
  00012	8b f8		 mov	 edi, eax

; 245  : 	POINT p;
; 246  : 
; 247  : 	//
; 248  : 	// Get the position of the upper-left client coordinate (in screen space).
; 249  : 	//
; 250  : 	p.x = 0;

  00014	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 251  : 	p.y = 0;
; 252  : 	ClientToScreen( hWnd, &p );

  0001b	8d 45 f4	 lea	 eax, DWORD PTR _p$[ebp]
  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+4], 0
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8

; 253  : 
; 254  : 	//
; 255  : 	// Get the client rectangle of the window.
; 256  : 	//
; 257  : 	GetClientRect( hWnd, &windowRect );

  0002d	ff 75 08	 push	 DWORD PTR _windowRect$[ebp]
  00030	57		 push	 edi
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 258  : 
; 259  : 	// clientRect를 ClientToScreen 하는 것과 같음
; 260  : 	OffsetRect( &windowRect, p.x, p.y );

  00037	ff 75 f8	 push	 DWORD PTR _p$[ebp+4]
  0003a	ff 75 f4	 push	 DWORD PTR _p$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR _windowRect$[ebp]
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 261  : }

  00046	5f		 pop	 edi
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?GetWindowRect@CMovieMan@@AAEXAAUtagRECT@@@Z ENDP	; CMovieMan::GetWindowRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?CalcMovieRect@CMovieMan@@AAEXHHAAUtagRECT@@@Z
_TEXT	SEGMENT
_movieRect$GSCopy$1$ = -28				; size = 4
_windowRect$ = -24					; size = 16
__$ArrayPad$ = -8					; size = 4
_srcWidth$ = 8						; size = 4
_srcHeight$ = 12					; size = 4
_movieRect$ = 16					; size = 4
?CalcMovieRect@CMovieMan@@AAEXHHAAUtagRECT@@@Z PROC	; CMovieMan::CalcMovieRect, COMDAT
; _this$dead$ = ecx

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _movieRect$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	89 45 e4	 mov	 DWORD PTR _movieRect$GSCopy$1$[ebp], eax

; 268  : 	RECT windowRect;
; 269  : 	GetWindowRect(windowRect);

  00018	8d 45 e8	 lea	 eax, DWORD PTR _windowRect$[ebp]
  0001b	57		 push	 edi
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?GetWindowRect@CMovieMan@@AAEXAAUtagRECT@@@Z ; CMovieMan::GetWindowRect

; 270  : 
; 271  : 	int nMovieWidth, nMovieHeight;
; 272  : 	if (srcWidth >= srcHeight)
; 273  : 	{
; 274  : 		nMovieWidth = (windowRect.right - windowRect.left);

  00022	8b 75 f0	 mov	 esi, DWORD PTR _windowRect$[ebp+8]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _srcWidth$[ebp]
  00028	8b 55 0c	 mov	 edx, DWORD PTR _srcHeight$[ebp]
  0002b	2b 75 e8	 sub	 esi, DWORD PTR _windowRect$[ebp]
  0002e	3b ca		 cmp	 ecx, edx
  00030	7c 1a		 jl	 SHORT $LN4@CalcMovieR
  00032	8b de		 mov	 ebx, esi

; 275  : 		nMovieHeight =  srcHeight * nMovieWidth / srcWidth;

  00034	8b c3		 mov	 eax, ebx
  00036	0f af c2	 imul	 eax, edx
  00039	99		 cdq
  0003a	f7 f9		 idiv	 ecx

; 276  : 		if( nMovieHeight > windowRect.bottom - windowRect.top )

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _windowRect$[ebp+12]
  0003f	2b 4d ec	 sub	 ecx, DWORD PTR _windowRect$[ebp+4]
  00042	8b f8		 mov	 edi, eax
  00044	3b f9		 cmp	 edi, ecx
  00046	7e 1d		 jle	 SHORT $LN1@CalcMovieR

; 277  : 			nMovieHeight = windowRect.bottom - windowRect.top;

  00048	8b f9		 mov	 edi, ecx

; 278  : 	}
; 279  : 	else

  0004a	eb 19		 jmp	 SHORT $LN1@CalcMovieR
$LN4@CalcMovieR:

; 280  : 	{
; 281  : 		nMovieHeight = (windowRect.bottom - windowRect.top);

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR _windowRect$[ebp+12]
  0004f	2b 4d ec	 sub	 ecx, DWORD PTR _windowRect$[ebp+4]
  00052	8b f9		 mov	 edi, ecx

; 282  : 		nMovieWidth =  srcWidth * nMovieHeight / srcHeight;

  00054	8b c7		 mov	 eax, edi
  00056	0f af 45 08	 imul	 eax, DWORD PTR _srcWidth$[ebp]
  0005a	99		 cdq
  0005b	f7 7d 0c	 idiv	 DWORD PTR _srcHeight$[ebp]
  0005e	8b d8		 mov	 ebx, eax

; 283  : 		if( nMovieWidth > windowRect.right - windowRect.left )

  00060	3b de		 cmp	 ebx, esi
  00062	0f 4f de	 cmovg	 ebx, esi
$LN1@CalcMovieR:

; 284  : 			nMovieWidth = windowRect.right - windowRect.left;
; 285  : 	}
; 286  : 	movieRect.left = windowRect.left + ((windowRect.right - windowRect.left) - nMovieWidth) / 2;

  00065	2b f3		 sub	 esi, ebx

; 287  : 	movieRect.top = windowRect.top + ((windowRect.bottom - windowRect.top) - nMovieHeight) / 2;

  00067	2b cf		 sub	 ecx, edi
  00069	8b c6		 mov	 eax, esi
  0006b	8b 75 e8	 mov	 esi, DWORD PTR _windowRect$[ebp]
  0006e	99		 cdq
  0006f	2b c2		 sub	 eax, edx
  00071	d1 f8		 sar	 eax, 1
  00073	03 f0		 add	 esi, eax
  00075	8b 45 e4	 mov	 eax, DWORD PTR _movieRect$GSCopy$1$[ebp]
  00078	89 30		 mov	 DWORD PTR [eax], esi
  0007a	8b c1		 mov	 eax, ecx
  0007c	8b 4d ec	 mov	 ecx, DWORD PTR _windowRect$[ebp+4]
  0007f	99		 cdq
  00080	2b c2		 sub	 eax, edx
  00082	8b 55 e4	 mov	 edx, DWORD PTR _movieRect$GSCopy$1$[ebp]
  00085	d1 f8		 sar	 eax, 1
  00087	03 c8		 add	 ecx, eax

; 288  : 	movieRect.right = movieRect.left + nMovieWidth;

  00089	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  0008c	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0008f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 289  : 	movieRect.bottom = movieRect.top + nMovieHeight;

  00092	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 290  : }

  00095	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	33 cd		 xor	 ecx, ebp
  0009c	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0009f	5b		 pop	 ebx
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 0c 00	 ret	 12			; 0000000cH
?CalcMovieRect@CMovieMan@@AAEXHHAAUtagRECT@@@Z ENDP	; CMovieMan::CalcMovieRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?CalcBackgroundRect@CMovieMan@@AAEXABUtagRECT@@AAU2@1@Z
_TEXT	SEGMENT
_lowerRect$GSCopy$1$ = -28				; size = 4
_windowRect$ = -24					; size = 16
__$ArrayPad$ = -8					; size = 4
_movieRect$ = 8						; size = 4
_upperRect$ = 12					; size = 4
_lowerRect$ = 16					; size = 4
?CalcBackgroundRect@CMovieMan@@AAEXABUtagRECT@@AAU2@1@Z PROC ; CMovieMan::CalcBackgroundRect, COMDAT
; _this$ = ecx

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _lowerRect$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _upperRect$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _movieRect$[ebp]
  0001c	8b f1		 mov	 esi, ecx
  0001e	89 45 e4	 mov	 DWORD PTR _lowerRect$GSCopy$1$[ebp], eax

; 297  : 	RECT windowRect;
; 298  : 	GetWindowRect(windowRect);

  00021	8d 45 e8	 lea	 eax, DWORD PTR _windowRect$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?GetWindowRect@CMovieMan@@AAEXAAUtagRECT@@@Z ; CMovieMan::GetWindowRect

; 299  : 
; 300  : 	if (m_movieWidth > m_movieHeight)

  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]

; 301  : 	{
; 302  : 		// 위아래 두개
; 303  : 		SetRect(&upperRect, windowRect.left, windowRect.top, windowRect.right, movieRect.top);

  00030	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetRect@20
  00036	7e 1d		 jle	 SHORT $LN2@CalcBackgr
  00038	ff 77 04	 push	 DWORD PTR [edi+4]
  0003b	ff 75 f0	 push	 DWORD PTR _windowRect$[ebp+8]
  0003e	ff 75 ec	 push	 DWORD PTR _windowRect$[ebp+4]
  00041	ff 75 e8	 push	 DWORD PTR _windowRect$[ebp]
  00044	53		 push	 ebx
  00045	ff d6		 call	 esi

; 304  : 		SetRect(&lowerRect, windowRect.left, movieRect.bottom, windowRect.right, windowRect.bottom);

  00047	ff 75 f4	 push	 DWORD PTR _windowRect$[ebp+12]
  0004a	ff 75 f0	 push	 DWORD PTR _windowRect$[ebp+8]
  0004d	ff 77 0c	 push	 DWORD PTR [edi+12]
  00050	ff 75 e8	 push	 DWORD PTR _windowRect$[ebp]

; 305  : 	}
; 306  : 	else

  00053	eb 1a		 jmp	 SHORT $LN5@CalcBackgr
$LN2@CalcBackgr:

; 307  : 	{
; 308  : 		// 좌우 두개
; 309  : 		SetRect(&upperRect, windowRect.left, windowRect.top, movieRect.left, windowRect.bottom);

  00055	ff 75 f4	 push	 DWORD PTR _windowRect$[ebp+12]
  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	ff 75 ec	 push	 DWORD PTR _windowRect$[ebp+4]
  0005d	ff 75 e8	 push	 DWORD PTR _windowRect$[ebp]
  00060	53		 push	 ebx
  00061	ff d6		 call	 esi

; 310  : 		SetRect(&lowerRect, movieRect.right, windowRect.top, windowRect.right, windowRect.bottom);

  00063	ff 75 f4	 push	 DWORD PTR _windowRect$[ebp+12]
  00066	ff 75 f0	 push	 DWORD PTR _windowRect$[ebp+8]
  00069	ff 75 ec	 push	 DWORD PTR _windowRect$[ebp+4]
  0006c	ff 77 08	 push	 DWORD PTR [edi+8]
$LN5@CalcBackgr:
  0006f	ff 75 e4	 push	 DWORD PTR _lowerRect$GSCopy$1$[ebp]
  00072	ff d6		 call	 esi

; 311  : 	}
; 312  : }

  00074	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	33 cd		 xor	 ecx, ebp
  0007b	5b		 pop	 ebx
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 0c 00	 ret	 12			; 0000000cH
?CalcBackgroundRect@CMovieMan@@AAEXABUtagRECT@@AAU2@1@Z ENDP ; CMovieMan::CalcBackgroundRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?RenderStreamToSurface@CMovieMan@@AAEJPAUIDirectDrawSurface@@PAUIDirectDrawMediaStream@@PAUIMultiMediaStream@@_NHK@Z
_TEXT	SEGMENT
_pMMStream$GSCopy$1$ = -68				; size = 4
_hr$1$ = -64						; size = 4
_surfaceDC$1 = -60					; size = 4
_pSample$ = -56						; size = 4
_upperRect$2 = -52					; size = 16
_lowerRect$3 = -36					; size = 16
_movieRect$4 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_pSurface$ = 8						; size = 4
_pDDStream$ = 12					; size = 4
_pMMStream$ = 16					; size = 4
_bSkipAllowed$dead$ = 20				; size = 1
_nPostEffectID$dead$ = 24				; size = 4
_dwPostEffectData$dead$ = 28				; size = 4
?RenderStreamToSurface@CMovieMan@@AAEJPAUIDirectDrawSurface@@PAUIDirectDrawMediaStream@@PAUIMultiMediaStream@@_NHK@Z PROC ; CMovieMan::RenderStreamToSurface, COMDAT
; _this$ = ecx

; 318  : {    

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _pDDStream$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 10	 mov	 ebx, DWORD PTR _pMMStream$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _pSurface$[ebp]

; 319  : 	#define KEY_DOWN(vk)	(GetAsyncKeyState(vk) & 0x8000)
; 320  : 
; 321  : 	IDirectDrawStreamSample *pSample = NULL;
; 322  : 	HRESULT hr = pDDStream->CreateSample(pSurface, NULL, 0, &pSample);

  0001b	8b 02		 mov	 eax, DWORD PTR [edx]
  0001d	57		 push	 edi
  0001e	8b f9		 mov	 edi, ecx
  00020	89 5d bc	 mov	 DWORD PTR _pMMStream$GSCopy$1$[ebp], ebx
  00023	8d 4d c8	 lea	 ecx, DWORD PTR _pSample$[ebp]
  00026	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _pSample$[ebp], 0
  0002d	51		 push	 ecx
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	56		 push	 esi
  00033	52		 push	 edx
  00034	ff 50 34	 call	 DWORD PTR [eax+52]
  00037	89 45 c0	 mov	 DWORD PTR _hr$1$[ebp], eax

; 323  : 	if (SUCCEEDED(hr))

  0003a	85 c0		 test	 eax, eax
  0003c	0f 88 0f 01 00
	00		 js	 $LN9@RenderStre

; 324  : 	{
; 325  : 		// 최초 한번 검은색으로 배경을 칠해준다
; 326  : 		RECT movieRect;
; 327  : 		RECT upperRect, lowerRect;
; 328  : 		CalcMovieRect(m_movieWidth, m_movieHeight, movieRect);

  00042	8d 45 ec	 lea	 eax, DWORD PTR _movieRect$4[ebp]
  00045	50		 push	 eax
  00046	ff 77 0c	 push	 DWORD PTR [edi+12]
  00049	ff 77 08	 push	 DWORD PTR [edi+8]
  0004c	e8 00 00 00 00	 call	 ?CalcMovieRect@CMovieMan@@AAEXHHAAUtagRECT@@@Z ; CMovieMan::CalcMovieRect

; 329  : 		CalcBackgroundRect(movieRect, upperRect, lowerRect);

  00051	8d 45 dc	 lea	 eax, DWORD PTR _lowerRect$3[ebp]
  00054	8b cf		 mov	 ecx, edi
  00056	50		 push	 eax
  00057	8d 45 cc	 lea	 eax, DWORD PTR _upperRect$2[ebp]
  0005a	50		 push	 eax
  0005b	8d 45 ec	 lea	 eax, DWORD PTR _movieRect$4[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?CalcBackgroundRect@CMovieMan@@AAEXABUtagRECT@@AAU2@1@Z ; CMovieMan::CalcBackgroundRect

; 330  : 		FillRect(upperRect, 0);

  00064	6a 00		 push	 0
  00066	8d 45 cc	 lea	 eax, DWORD PTR _upperRect$2[ebp]
  00069	8b cf		 mov	 ecx, edi
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z ; CMovieMan::FillRect

; 331  : 		FillRect(lowerRect, 0);

  00071	6a 00		 push	 0
  00073	8d 45 dc	 lea	 eax, DWORD PTR _lowerRect$3[ebp]
  00076	8b cf		 mov	 ecx, edi
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z ; CMovieMan::FillRect

; 332  : 
; 333  : 		pMMStream->SetState(STREAMSTATE_RUN);

  0007e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00080	6a 01		 push	 1
  00082	53		 push	 ebx
  00083	ff 50 1c	 call	 DWORD PTR [eax+28]

; 334  : 		while (pSample->Update(0, NULL, NULL, NULL) == S_OK)

  00086	8b 45 c8	 mov	 eax, DWORD PTR _pSample$[ebp]
  00089	6a 00		 push	 0
  0008b	6a 00		 push	 0
  0008d	6a 00		 push	 0
  0008f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00091	6a 00		 push	 0
  00093	50		 push	 eax
  00094	ff 51 18	 call	 DWORD PTR [ecx+24]
  00097	85 c0		 test	 eax, eax
  00099	0f 85 9e 00 00
	00		 jne	 $LN4@RenderStre
  0009f	90		 npad	 1
$LL8@RenderStre:

; 335  : 		{
; 336  : 			// 윈도우 중앙을 기준으로 꽉차게 그린다
; 337  : 			CalcMovieRect(m_movieWidth, m_movieHeight, movieRect);

  000a0	8d 45 ec	 lea	 eax, DWORD PTR _movieRect$4[ebp]
  000a3	50		 push	 eax
  000a4	ff 77 0c	 push	 DWORD PTR [edi+12]
  000a7	ff 77 08	 push	 DWORD PTR [edi+8]
  000aa	e8 00 00 00 00	 call	 ?CalcMovieRect@CMovieMan@@AAEXHHAAUtagRECT@@@Z ; CMovieMan::CalcMovieRect

; 338  : 			if (FAILED(m_pPrimarySurface->Blt(&movieRect, pSurface, NULL, DDBLT_WAIT, NULL)))

  000af	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000b2	8d 55 ec	 lea	 edx, DWORD PTR _movieRect$4[ebp]
  000b5	6a 00		 push	 0
  000b7	68 00 00 00 01	 push	 16777216		; 01000000H
  000bc	6a 00		 push	 0
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	56		 push	 esi
  000c1	52		 push	 edx
  000c2	50		 push	 eax
  000c3	ff 51 14	 call	 DWORD PTR [ecx+20]
  000c6	85 c0		 test	 eax, eax
  000c8	79 57		 jns	 SHORT $LN5@RenderStre

; 91   : 	HDC desktopDC = GetDC(0);

  000ca	6a 00		 push	 0
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4

; 92   : 	if (SUCCEEDED(pSrcSurface->GetDC(&surfaceDC)))

  000d2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d4	8b d8		 mov	 ebx, eax
  000d6	8d 45 c4	 lea	 eax, DWORD PTR _surfaceDC$1[ebp]
  000d9	50		 push	 eax
  000da	56		 push	 esi
  000db	ff 51 44	 call	 DWORD PTR [ecx+68]
  000de	85 c0		 test	 eax, eax
  000e0	78 36		 js	 SHORT $LN12@RenderStre

; 93   : 	{
; 94   : 		StretchBlt(desktopDC, pDestRect->left, pDestRect->top, pDestRect->right - pDestRect->left, pDestRect->bottom - pDestRect->top,
; 95   : 			surfaceDC, 0, 0, m_movieWidth, m_movieHeight, SRCCOPY);

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _movieRect$4[ebp+12]
  000e5	8b 55 f0	 mov	 edx, DWORD PTR _movieRect$4[ebp+4]
  000e8	2b c2		 sub	 eax, edx
  000ea	8b 4d ec	 mov	 ecx, DWORD PTR _movieRect$4[ebp]
  000ed	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  000f2	ff 77 0c	 push	 DWORD PTR [edi+12]
  000f5	ff 77 08	 push	 DWORD PTR [edi+8]
  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	ff 75 c4	 push	 DWORD PTR _surfaceDC$1[ebp]
  000ff	50		 push	 eax
  00100	8b 45 f4	 mov	 eax, DWORD PTR _movieRect$4[ebp+8]
  00103	2b c1		 sub	 eax, ecx
  00105	50		 push	 eax
  00106	52		 push	 edx
  00107	51		 push	 ecx
  00108	53		 push	 ebx
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchBlt@44

; 96   : 		pSrcSurface->ReleaseDC(surfaceDC);

  0010f	ff 75 c4	 push	 DWORD PTR _surfaceDC$1[ebp]
  00112	8b 06		 mov	 eax, DWORD PTR [esi]
  00114	56		 push	 esi
  00115	ff 50 68	 call	 DWORD PTR [eax+104]
$LN12@RenderStre:

; 97   : 	}
; 98   : 	ReleaseDC(0, desktopDC);

  00118	53		 push	 ebx
  00119	6a 00		 push	 0
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$LN5@RenderStre:

; 334  : 		while (pSample->Update(0, NULL, NULL, NULL) == S_OK)

  00121	8b 45 c8	 mov	 eax, DWORD PTR _pSample$[ebp]
  00124	6a 00		 push	 0
  00126	6a 00		 push	 0
  00128	6a 00		 push	 0
  0012a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012c	6a 00		 push	 0
  0012e	50		 push	 eax
  0012f	ff 51 18	 call	 DWORD PTR [ecx+24]
  00132	85 c0		 test	 eax, eax
  00134	0f 84 66 ff ff
	ff		 je	 $LL8@RenderStre
  0013a	8b 5d bc	 mov	 ebx, DWORD PTR _pMMStream$GSCopy$1$[ebp]
$LN4@RenderStre:

; 339  : 			{
; 340  : 				GDIBlt(pSurface, &movieRect);
; 341  : 			}
; 342  : 
; 343  : 			// 중간에 스킵 가능하면 키보드ESC/마우스 입력시 탈출
; 344  : 			if (bSkipAllowed && (KEY_DOWN(VK_LBUTTON) || KEY_DOWN(VK_ESCAPE) || KEY_DOWN(VK_SPACE)))
; 345  : 			{
; 346  : 				break;
; 347  : 			}
; 348  : 		}
; 349  : 
; 350  : 		// 동영상 재생 종료시에 2초 동안 페이드아웃
; 351  : 		switch(nPostEffectID)
; 352  : 		{
; 353  : 		case MOVIEMAN_POSTEFFECT_FADEOUT:
; 354  : 			RenderPostEffectFadeOut(pSurface, MOVIEMAN_FADE_DURATION, dwPostEffectData);
; 355  : 			break;
; 356  : 		}
; 357  : 
; 358  : 		pMMStream->SetState(STREAMSTATE_STOP);

  0013d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0013f	6a 00		 push	 0
  00141	53		 push	 ebx
  00142	ff 50 1c	 call	 DWORD PTR [eax+28]

; 359  : 		pSample->Release();

  00145	8b 45 c8	 mov	 eax, DWORD PTR _pSample$[ebp]
  00148	50		 push	 eax
  00149	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014b	ff 51 08	 call	 DWORD PTR [ecx+8]

; 360  : 	}
; 361  : 
; 362  : 	return hr;

  0014e	8b 45 c0	 mov	 eax, DWORD PTR _hr$1$[ebp]
$LN9@RenderStre:

; 363  : }

  00151	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
  00156	33 cd		 xor	 ecx, ebp
  00158	5b		 pop	 ebx
  00159	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 18 00	 ret	 24			; 00000018H
?RenderStreamToSurface@CMovieMan@@AAEJPAUIDirectDrawSurface@@PAUIDirectDrawMediaStream@@PAUIMultiMediaStream@@_NHK@Z ENDP ; CMovieMan::RenderStreamToSurface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z
_TEXT	SEGMENT
$T2 = -1116						; size = 4
_ppMMStream$GSCopy$1$ = -1112				; size = 4
_this$GSCopy$1$ = -1108					; size = 4
_pAMStream$ = -1104					; size = 4
_ext$ = -1100						; size = 24
_wsDir$ = -1076						; size = 522
_wPath$ = -548						; size = 522
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_cpFilename$ = 8					; size = 4
_ppMMStream$ = 12					; size = 4
_pDD$ = 16						; size = 4
?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z PROC ; CMovieMan::RenderFileToMMStream, COMDAT
; _this$ = ecx

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 50 04 00
	00		 sub	 esp, 1104		; 00000450H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 8d ac fb ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00034	8b 45 0c	 mov	 eax, DWORD PTR _ppMMStream$[ebp]
  00037	8b 75 08	 mov	 esi, DWORD PTR _cpFilename$[ebp]
  0003a	8b 7d 10	 mov	 edi, DWORD PTR _pDD$[ebp]
  0003d	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _ppMMStream$GSCopy$1$[ebp], eax

; 367  : 	IAMMultiMediaStream *pAMStream;
; 368  : 	HRESULT hr = CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER, IID_IAMMultiMediaStream, (void **) &pAMStream);

  00043	8d 85 b0 fb ff
	ff		 lea	 eax, DWORD PTR _pAMStream$[ebp]
  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET _IID_IAMMultiMediaStream
  0004f	6a 01		 push	 1
  00051	6a 00		 push	 0
  00053	68 00 00 00 00	 push	 OFFSET _CLSID_AMMultiMediaStream
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 369  : 	if (FAILED(hr))

  0005e	85 c0		 test	 eax, eax
  00060	0f 88 e2 02 00
	00		 js	 $LN7@RenderFile

; 370  : 	{
; 371  : 		return hr;
; 372  : 	}
; 373  : 
; 374  : 	WCHAR wPath[MAX_PATH + 1];
; 375  : 	MultiByteToWideChar(CP_ACP, 0, cpFilename, -1, wPath, MAX_PATH + 1);

  00066	68 05 01 00 00	 push	 261			; 00000105H
  0006b	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wPath$[ebp]
  00071	50		 push	 eax
  00072	6a ff		 push	 -1
  00074	56		 push	 esi
  00075	6a 00		 push	 0
  00077	6a 00		 push	 0
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 376  : 	//
; 377  : 	WCHAR wsDir[MAX_PATH + 1];
; 378  : 	::memset(wsDir, 0, sizeof(wsDir));

  0007f	68 0a 02 00 00	 push	 522			; 0000020aH
  00084	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _wsDir$[ebp]
  0008a	6a 00		 push	 0
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _memset
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 379  : 	::GetCurrentDirectoryW( MAX_PATH, wsDir );

  00095	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _wsDir$[ebp]
  0009b	50		 push	 eax
  0009c	68 04 01 00 00	 push	 260			; 00000104H
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentDirectoryW@8

; 380  : 	::wcsncat( wsDir, L"\\", sizeof(WCHAR)*1 );

  000a7	6a 02		 push	 2
  000a9	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _wsDir$[ebp]
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _wcsncat
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 381  : 	::wcsncat( wsDir, wPath, sizeof(WCHAR)*::wcsnlen(wPath, MAX_PATH) );

  000bd	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wPath$[ebp]
  000c3	68 04 01 00 00	 push	 260			; 00000104H
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _wcsnlen
  000ce	03 c0		 add	 eax, eax
  000d0	50		 push	 eax
  000d1	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wPath$[ebp]
  000d7	50		 push	 eax
  000d8	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _wsDir$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _wcsncat
  000e4	83 c4 14	 add	 esp, 20			; 00000014H

; 382  : 	::memset(wPath, 0, sizeof(wPath));

  000e7	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wPath$[ebp]
  000ed	68 0a 02 00 00	 push	 522			; 0000020aH
  000f2	6a 00		 push	 0
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _memset
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 383  : 	::wcsncpy( wPath, wsDir, sizeof(WCHAR)*::wcsnlen(wsDir, MAX_PATH) );

  000fd	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _wsDir$[ebp]
  00103	68 04 01 00 00	 push	 260			; 00000104H
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _wcsnlen
  0010e	03 c0		 add	 eax, eax
  00110	50		 push	 eax
  00111	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR _wsDir$[ebp]
  00117	50		 push	 eax
  00118	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wPath$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _wcsncpy

; 384  : 	//
; 385  : 
; 386  : 	pAMStream->Initialize(STREAMTYPE_READ, AMMSF_NOGRAPHTHREAD, NULL);

  00124	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pAMStream$[ebp]
  0012a	83 c4 14	 add	 esp, 20			; 00000014H
  0012d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012f	6a 00		 push	 0
  00131	6a 01		 push	 1
  00133	6a 00		 push	 0
  00135	50		 push	 eax
  00136	ff 51 30	 call	 DWORD PTR [ecx+48]

; 387  : 	pAMStream->AddMediaStream(pDD, &MSPID_PrimaryVideo, 0, NULL);

  00139	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pAMStream$[ebp]
  0013f	6a 00		 push	 0
  00141	6a 00		 push	 0
  00143	68 00 00 00 00	 push	 OFFSET _MSPID_PrimaryVideo
  00148	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014a	57		 push	 edi
  0014b	50		 push	 eax
  0014c	ff 51 3c	 call	 DWORD PTR [ecx+60]

; 388  : 	pAMStream->AddMediaStream(NULL, &MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL);

  0014f	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pAMStream$[ebp]
  00155	6a 00		 push	 0
  00157	6a 01		 push	 1
  00159	68 00 00 00 00	 push	 OFFSET _MSPID_PrimaryAudio
  0015e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00160	6a 00		 push	 0
  00162	50		 push	 eax
  00163	ff 51 3c	 call	 DWORD PTR [ecx+60]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00166	c7 85 c8 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR _ext$[ebp+20], 15 ; 0000000fH

; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00170	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _ext$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0017a	c6 85 b4 fb ff
	ff 00		 mov	 BYTE PTR _ext$[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp

; 391  : 	GetFileExtension(cpFilename, strlen(cpFilename), &ext);

  00181	8b ce		 mov	 ecx, esi
  00183	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0018a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0018d	8d 49 00	 npad	 3
$LL194@RenderFile:
  00190	8a 01		 mov	 al, BYTE PTR [ecx]
  00192	41		 inc	 ecx
  00193	84 c0		 test	 al, al
  00195	75 f9		 jne	 SHORT $LL194@RenderFile
  00197	8d 85 b4 fb ff
	ff		 lea	 eax, DWORD PTR _ext$[ebp]
  0019d	2b ca		 sub	 ecx, edx
  0019f	50		 push	 eax
  001a0	51		 push	 ecx
  001a1	56		 push	 esi
  001a2	e8 00 00 00 00	 call	 ?GetFileExtension@@YAXPBDHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetFileExtension
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  001a7	8b bd c8 fb ff
	ff		 mov	 edi, DWORD PTR _ext$[ebp+20]
  001ad	8d 85 b4 fb ff
	ff		 lea	 eax, DWORD PTR _ext$[ebp]
  001b3	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ext$[ebp]
  001b9	8d 8d b4 fb ff
	ff		 lea	 ecx, DWORD PTR _ext$[ebp]

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));

  001bf	8b b5 c4 fb ff
	ff		 mov	 esi, DWORD PTR _ext$[ebp+16]

; 513  : 			: this->_Bx._Buf);

  001c5	8d 95 b4 fb ff
	ff		 lea	 edx, DWORD PTR _ext$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp

; 391  : 	GetFileExtension(cpFilename, strlen(cpFilename), &ext);

  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  001ce	83 ff 10	 cmp	 edi, 16			; 00000010H
  001d1	0f 43 c3	 cmovae	 eax, ebx
  001d4	0f 43 cb	 cmovae	 ecx, ebx

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));

  001d7	03 c6		 add	 eax, esi

; 513  : 			: this->_Bx._Buf);

  001d9	83 ff 10	 cmp	 edi, 16			; 00000010H
  001dc	0f 43 d3	 cmovae	 edx, ebx

; 215  : 		return (this->_Ptr == _Right._Ptr);

  001df	3b d0		 cmp	 edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 961  : 	if (_First != _Last)

  001e1	74 23		 je	 SHORT $LN113@RenderFile

; 962  : 		return (_Transform(_Unchecked(_First), _Unchecked(_Last),
; 963  : 			_Dest, _Func));

  001e3	51		 push	 ecx
  001e4	51		 push	 ecx
  001e5	50		 push	 eax
  001e6	8d 8d a4 fb ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001ec	e8 00 00 00 00	 call	 ??$_Transform@PADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@PAD0V10@P6AHH@Z@Z ; std::_Transform<char *,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
  001f1	8b bd c8 fb ff
	ff		 mov	 edi, DWORD PTR _ext$[ebp+20]
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fa	8b b5 c4 fb ff
	ff		 mov	 esi, DWORD PTR _ext$[ebp+16]
  00200	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ext$[ebp]
$LN113@RenderFile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00206	83 ff 10	 cmp	 edi, 16			; 00000010H
  00209	8d 8d b4 fb ff
	ff		 lea	 ecx, DWORD PTR _ext$[ebp]

; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);

  0020f	b8 03 00 00 00	 mov	 eax, 3

; 520  : 			: this->_Bx._Buf);

  00214	0f 43 cb	 cmovae	 ecx, ebx

; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);

  00217	3b f0		 cmp	 esi, eax
  00219	0f 42 c6	 cmovb	 eax, esi
  0021c	50		 push	 eax
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_03GJLKJKAN@mpg?$AA@
  00222	51		 push	 ecx
  00223	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

  0022b	85 c0		 test	 eax, eax
  0022d	75 5c		 jne	 SHORT $LN141@RenderFile
  0022f	83 fe 03	 cmp	 esi, 3
  00232	72 57		 jb	 SHORT $LN141@RenderFile
  00234	83 fe 03	 cmp	 esi, 3
  00237	0f 95 c0	 setne	 al

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);

  0023a	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp

; 393  : 	if (ext == "mpg")

  0023c	75 4d		 jne	 SHORT $LN141@RenderFile

; 394  : 	{
; 395  : 		// 2007-08-01, nuclei
; 396  : 		// MPG만 재생한다고 가정하고 매뉴얼로 각종 코덱을 연결해 
; 397  : 		// 외부 코덱(ffdshow 등)에 영향을 받지 않도록 한다
; 398  : 		// (기타 파일도 재생은 되지만 코덱에 영향을 받을 수 있음)
; 399  : 		hr = BuildFilterGraphManually(wPath, pAMStream, CLSID_MPEG1Splitter, CLSID_CMpegVideoCodec, CLSID_CMpegAudioCodec);

  0023e	f3 0f 6f 05 00
	00 00 00	 movdqu	 xmm0, XMMWORD PTR _CLSID_CMpegAudioCodec
  00246	83 ec 10	 sub	 esp, 16			; 00000010H
  00249	8b c4		 mov	 eax, esp
  0024b	83 ec 10	 sub	 esp, 16			; 00000010H
  0024e	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  00252	8b c4		 mov	 eax, esp
  00254	f3 0f 6f 05 00
	00 00 00	 movdqu	 xmm0, XMMWORD PTR _CLSID_CMpegVideoCodec
  0025c	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  00260	f3 0f 6f 05 00
	00 00 00	 movdqu	 xmm0, XMMWORD PTR _CLSID_MPEG1Splitter
$LN200@RenderFile:
  00268	8b 8d ac fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0026e	83 ec 10	 sub	 esp, 16			; 00000010H
  00271	8b c4		 mov	 eax, esp
  00273	ff b5 b0 fb ff
	ff		 push	 DWORD PTR _pAMStream$[ebp]
  00279	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0027d	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _wPath$[ebp]
  00283	50		 push	 eax
  00284	e8 00 00 00 00	 call	 ?BuildFilterGraphManually@CMovieMan@@AAEJPA_WPAUIAMMultiMediaStream@@U_GUID@@22@Z ; CMovieMan::BuildFilterGraphManually

; 401  : 	else if (ext == "mp43")

  00289	eb 7c		 jmp	 SHORT $LN197@RenderFile
$LN141@RenderFile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0028b	83 ff 10	 cmp	 edi, 16			; 00000010H
  0028e	8d 8d b4 fb ff
	ff		 lea	 ecx, DWORD PTR _ext$[ebp]

; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);

  00294	b8 04 00 00 00	 mov	 eax, 4

; 520  : 			: this->_Bx._Buf);

  00299	0f 43 cb	 cmovae	 ecx, ebx

; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);

  0029c	3b f0		 cmp	 esi, eax
  0029e	0f 42 c6	 cmovb	 eax, esi
  002a1	50		 push	 eax
  002a2	68 00 00 00 00	 push	 OFFSET ??_C@_04OEEJDDPO@mp43?$AA@
  002a7	51		 push	 ecx
  002a8	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  002ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

  002b0	85 c0		 test	 eax, eax
  002b2	75 3e		 jne	 SHORT $LN3@RenderFile
  002b4	83 fe 04	 cmp	 esi, 4
  002b7	72 39		 jb	 SHORT $LN3@RenderFile
  002b9	83 fe 04	 cmp	 esi, 4
  002bc	0f 95 c0	 setne	 al

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);

  002bf	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp

; 401  : 	else if (ext == "mp43")

  002c1	75 2f		 jne	 SHORT $LN3@RenderFile

; 402  : 	{
; 403  : 		// 2007-08-12, nuclei
; 404  : 		// MPEG-4, MP3 코덱을 이용한 AVI의 재생 추가(확장자는 .mp43으로 해야함)
; 405  : 		hr = BuildFilterGraphManually(wPath, pAMStream, CLSID_AviSplitter, CLSID_MP4VideoCodec, CLSID_MP3AudioCodec);

  002c3	f3 0f 6f 05 00
	00 00 00	 movdqu	 xmm0, XMMWORD PTR _CLSID_MP3AudioCodec
  002cb	83 ec 10	 sub	 esp, 16			; 00000010H
  002ce	8b c4		 mov	 eax, esp
  002d0	83 ec 10	 sub	 esp, 16			; 00000010H
  002d3	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  002d7	8b c4		 mov	 eax, esp
  002d9	f3 0f 6f 05 00
	00 00 00	 movdqu	 xmm0, XMMWORD PTR _CLSID_MP4VideoCodec
  002e1	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  002e5	f3 0f 6f 05 00
	00 00 00	 movdqu	 xmm0, XMMWORD PTR _CLSID_AviSplitter

; 406  : 	}
; 407  : 	else

  002ed	e9 76 ff ff ff	 jmp	 $LN200@RenderFile
$LN3@RenderFile:

; 408  : 	{
; 409  : 		hr = pAMStream->OpenFile(wPath, 0);

  002f2	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pAMStream$[ebp]
  002f8	8d 95 dc fd ff
	ff		 lea	 edx, DWORD PTR _wPath$[ebp]
  002fe	6a 00		 push	 0
  00300	52		 push	 edx
  00301	50		 push	 eax
  00302	8b 08		 mov	 ecx, DWORD PTR [eax]
  00304	ff 51 40	 call	 DWORD PTR [ecx+64]
$LN197@RenderFile:
  00307	8b f0		 mov	 esi, eax

; 410  : 	}
; 411  : 
; 412  : 	// 재생 성공시 hr은 S_OK
; 413  : 	if (SUCCEEDED(hr))

  00309	85 f6		 test	 esi, esi
  0030b	78 16		 js	 SHORT $LN1@RenderFile

; 414  : 	{
; 415  : 		pAMStream->QueryInterface(IID_IMultiMediaStream, (void**) ppMMStream);

  0030d	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pAMStream$[ebp]
  00313	ff b5 a8 fb ff
	ff		 push	 DWORD PTR _ppMMStream$GSCopy$1$[ebp]
  00319	68 00 00 00 00	 push	 OFFSET _IID_IMultiMediaStream
  0031e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00320	50		 push	 eax
  00321	ff 11		 call	 DWORD PTR [ecx]
$LN1@RenderFile:

; 416  : 	}
; 417  : 
; 418  : 	pAMStream->Release();

  00323	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pAMStream$[ebp]
  00329	50		 push	 eax
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	ff 51 08	 call	 DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0032f	83 bd c8 fb ff
	ff 10		 cmp	 DWORD PTR _ext$[ebp+20], 16 ; 00000010H
  00336	72 0e		 jb	 SHORT $LN182@RenderFile
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00338	ff b5 b4 fb ff
	ff		 push	 DWORD PTR _ext$[ebp]
  0033e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00343	83 c4 04	 add	 esp, 4
$LN182@RenderFile:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp

; 420  : 	return hr;

  00346	8b c6		 mov	 eax, esi
$LN7@RenderFile:

; 421  : }

  00348	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0034b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00352	59		 pop	 ecx
  00353	5f		 pop	 edi
  00354	5e		 pop	 esi
  00355	5b		 pop	 ebx
  00356	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00359	33 cd		 xor	 ecx, ebp
  0035b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00360	8b e5		 mov	 esp, ebp
  00362	5d		 pop	 ebp
  00363	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z$0:
  00000	8d 8d b4 fb ff
	ff		 lea	 ecx, DWORD PTR _ext$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a a0 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1120]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RenderFileToMMStream@CMovieMan@@AAEJPBDPAPAUIMultiMediaStream@@PAUIDirectDraw@@@Z ENDP ; CMovieMan::RenderFileToMMStream
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?RenderPostEffectFadeOut@CMovieMan@@AAEJPAUIDirectDrawSurface@@HK@Z
_TEXT	SEGMENT
_fadeBegin$1$ = -220					; size = 4
_surfaceDC$1 = -216					; size = 4
_fadeOutColorBlue$1$ = -212				; size = 4
_fadeProgress$1$ = -208					; size = 4
_pSurface$GSCopy$1$ = -204				; size = 4
_pCopiedSrcSurBuf$1$ = -200				; size = 4
_x$1$ = -196						; size = 4
_pSrcSurfaceBuf$1$ = -196				; size = 4
_desktopDC$1$ = -192					; size = 4
_y$1$ = -192						; size = 4
_lockedSurfaceDesc$ = -188				; size = 108
_lowerRect$2 = -72					; size = 16
_upperRect$3 = -56					; size = 16
_windowRect$ = -40					; size = 16
_movieRect$4 = -24					; size = 16
__$ArrayPad$ = -8					; size = 4
_pSurface$ = 8						; size = 4
_fadeOutDuration$dead$ = 12				; size = 4
_fadeOutColor$dead$ = 16				; size = 4
?RenderPostEffectFadeOut@CMovieMan@@AAEJPAUIDirectDrawSurface@@HK@Z PROC ; CMovieMan::RenderPostEffectFadeOut, COMDAT
; _this$ = ecx

; 427  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _pSurface$[ebp]
  00019	8b d9		 mov	 ebx, ecx
  0001b	89 bd 34 ff ff
	ff		 mov	 DWORD PTR _pSurface$GSCopy$1$[ebp], edi

; 428  : 	// Lock 걸기 위해 초기화
; 429  : 	DDSURFACEDESC lockedSurfaceDesc;
; 430  : 
; 431  : 	int *pCopiedSrcSurBuf = NULL;

  00021	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pCopiedSrcSurBuf$1$[ebp], 0

; 432  : 	LONG fadeBegin = GetTickCount();

  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00031	8b f0		 mov	 esi, eax
  00033	89 b5 24 ff ff
	ff		 mov	 DWORD PTR _fadeBegin$1$[ebp], esi

; 433  : 	float fadeProgress = 0.0;
; 434  : 	while ((fadeProgress = ((float)((LONG)GetTickCount()) - fadeBegin) / fadeOutDuration) < 1.0)

  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003f	66 0f 6e ce	 movd	 xmm1, esi
  00043	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00046	66 0f 6e c0	 movd	 xmm0, eax
  0004a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0004d	f3 0f 5c c1	 subss	 xmm0, xmm1
  00051	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00059	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@44a28000
  00061	0f 2f c8	 comiss	 xmm1, xmm0
  00064	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fadeProgress$1$[ebp], xmm0
  0006c	0f 86 63 03 00
	00		 jbe	 $LN12@RenderPost
$LL13@RenderPost:

; 435  : 	{
; 436  : 		ZeroMemory(&lockedSurfaceDesc, sizeof(lockedSurfaceDesc));

  00072	6a 6c		 push	 108			; 0000006cH
  00074	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _lockedSurfaceDesc$[ebp]
  0007a	6a 00		 push	 0
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _memset

; 437  : 		lockedSurfaceDesc.dwSize = sizeof(lockedSurfaceDesc);
; 438  : 		HRESULT hr = pSurface->Lock(NULL, &lockedSurfaceDesc, DDLOCK_WAIT | DDLOCK_NOSYSLOCK | DDLOCK_READONLY, NULL);

  00082	8b 07		 mov	 eax, DWORD PTR [edi]
  00084	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _lockedSurfaceDesc$[ebp]
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	c7 85 44 ff ff
	ff 6c 00 00 00	 mov	 DWORD PTR _lockedSurfaceDesc$[ebp], 108 ; 0000006cH
  00097	6a 00		 push	 0
  00099	68 11 08 00 00	 push	 2065			; 00000811H
  0009e	51		 push	 ecx
  0009f	6a 00		 push	 0
  000a1	57		 push	 edi
  000a2	ff 50 64	 call	 DWORD PTR [eax+100]

; 439  : 		if (FAILED(hr))

  000a5	85 c0		 test	 eax, eax
  000a7	0f 88 4e 03 00
	00		 js	 $LN14@RenderPost

; 440  : 		{
; 441  : 			return hr;
; 442  : 		}
; 443  : 
; 444  : 		// 최초 1회에 서피스 복사하고 복사본에 FadeOut 처리한다
; 445  : 		if (!pCopiedSrcSurBuf)

  000ad	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pCopiedSrcSurBuf$1$[ebp]
  000b3	85 c0		 test	 eax, eax
  000b5	75 37		 jne	 SHORT $LN10@RenderPost

; 446  : 		{
; 447  : 			if (!(pCopiedSrcSurBuf = (int*)malloc((LONG)lockedSurfaceDesc.lPitch * m_movieHeight)))

  000b7	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  000ba	0f af bd 54 ff
	ff ff		 imul	 edi, DWORD PTR _lockedSurfaceDesc$[ebp+16]
  000c1	57		 push	 edi
  000c2	e8 00 00 00 00	 call	 _malloc
  000c7	83 c4 04	 add	 esp, 4
  000ca	89 85 38 ff ff
	ff		 mov	 DWORD PTR _pCopiedSrcSurBuf$1$[ebp], eax
  000d0	85 c0		 test	 eax, eax
  000d2	0f 84 d0 02 00
	00		 je	 $LN23@RenderPost

; 451  : 			}
; 452  : 			CopyMemory(pCopiedSrcSurBuf, lockedSurfaceDesc.lpSurface, (LONG)lockedSurfaceDesc.lPitch * m_movieHeight);

  000d8	57		 push	 edi
  000d9	ff b5 68 ff ff
	ff		 push	 DWORD PTR _lockedSurfaceDesc$[ebp+36]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memcpy
  000e5	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _pCopiedSrcSurBuf$1$[ebp]
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@RenderPost:

; 453  : 		}
; 454  : 
; 455  : 		// 픽셀 플랏팅(32비트)
; 456  : 		int *pSrcSurfaceBuf = pCopiedSrcSurBuf;
; 457  : 		int *pDestSurfaceBuf = (int*)lockedSurfaceDesc.lpSurface;
; 458  : 
; 459  : 		int fadeOutColorRed = (int)(((fadeOutColor >> 16) & 255) * fadeProgress);
; 460  : 		int fadeOutColorGreen = (int)(((fadeOutColor >> 8) & 255) * fadeProgress);
; 461  : 		int fadeOutColorBlue = (int)((fadeOutColor & 255) * fadeProgress);
; 462  : 		for(int y = 0; y < m_movieHeight; ++y)

  000ee	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  000f2	0f 57 c9	 xorps	 xmm1, xmm1
  000f5	f3 0f 10 95 30
	ff ff ff	 movss	 xmm2, DWORD PTR _fadeProgress$1$[ebp]
  000fd	8b bd 68 ff ff
	ff		 mov	 edi, DWORD PTR _lockedSurfaceDesc$[ebp+36]
  00103	0f 28 c2	 movaps	 xmm0, xmm2
  00106	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0010a	89 85 3c ff ff
	ff		 mov	 DWORD PTR _pSrcSurfaceBuf$1$[ebp], eax
  00110	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$1$[ebp], 0
  0011a	f3 0f 2c c0	 cvttss2si eax, xmm0
  0011e	89 85 2c ff ff
	ff		 mov	 DWORD PTR _fadeOutColorBlue$1$[ebp], eax
  00124	0f 8e 35 01 00
	00		 jle	 $LN6@RenderPost
  0012a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0012d	8b b5 3c ff ff
	ff		 mov	 esi, DWORD PTR _pSrcSurfaceBuf$1$[ebp]
$LL8@RenderPost:

; 463  : 		{
; 464  : 			for(int x = 0; x < m_movieWidth; ++x)

  00133	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$1$[ebp], 0
  0013d	85 c9		 test	 ecx, ecx
  0013f	0f 8e d7 00 00
	00		 jle	 $LN3@RenderPost
  00145	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0014d	66 0f 6e d8	 movd	 xmm3, eax
  00151	f3 0f 5c ca	 subss	 xmm1, xmm2
  00155	66 0f 6e e0	 movd	 xmm4, eax
  00159	66 0f 6e e8	 movd	 xmm5, eax
  0015d	0f 5b db	 cvtdq2ps xmm3, xmm3
  00160	0f 5b e4	 cvtdq2ps xmm4, xmm4
  00163	0f 5b ed	 cvtdq2ps xmm5, xmm5
$LL5@RenderPost:

; 465  : 			{
; 466  : 				DWORD srcPixel = *pSrcSurfaceBuf;

  00166	8b 16		 mov	 edx, DWORD PTR [esi]

; 467  : 				*pDestSurfaceBuf = RGB(
; 468  : 					(srcPixel & 255) * (1 - fadeProgress) + fadeOutColorBlue,
; 469  : 					((srcPixel >> 8) & 255) * (1 - fadeProgress) + fadeOutColorGreen,
; 470  : 					((srcPixel >> 16) & 255) * (1 - fadeProgress) + fadeOutColorRed);

  00168	8b c2		 mov	 eax, edx
  0016a	c1 e8 10	 shr	 eax, 16			; 00000010H

; 471  : 				pSrcSurfaceBuf++;

  0016d	83 c6 04	 add	 esi, 4
  00170	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00175	66 0f 6e c0	 movd	 xmm0, eax
  00179	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0017d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00180	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00189	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0018d	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00191	f3 0f 58 c3	 addss	 xmm0, xmm3
  00195	f3 0f 2c c0	 cvttss2si eax, xmm0
  00199	0f b6 c8	 movzx	 ecx, al
  0019c	8b c2		 mov	 eax, edx
  0019e	c1 e8 08	 shr	 eax, 8
  001a1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001a6	c1 e1 08	 shl	 ecx, 8
  001a9	66 0f 6e c0	 movd	 xmm0, eax
  001ad	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001b1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001b4	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  001bd	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001c1	f3 0f 59 c1	 mulss	 xmm0, xmm1
  001c5	f3 0f 58 c4	 addss	 xmm0, xmm4
  001c9	f3 0f 2c c0	 cvttss2si eax, xmm0
  001cd	0f b6 c0	 movzx	 eax, al
  001d0	0b c8		 or	 ecx, eax
  001d2	0f b6 c2	 movzx	 eax, dl
  001d5	c1 e1 08	 shl	 ecx, 8
  001d8	66 0f 6e c0	 movd	 xmm0, eax
  001dc	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001e0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001e3	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  001ec	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001f0	f3 0f 59 c1	 mulss	 xmm0, xmm1
  001f4	f3 0f 58 c5	 addss	 xmm0, xmm5
  001f8	f3 0f 2c c0	 cvttss2si eax, xmm0
  001fc	0f b6 c0	 movzx	 eax, al
  001ff	0b c8		 or	 ecx, eax
  00201	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _x$1$[ebp]
  00207	89 0f		 mov	 DWORD PTR [edi], ecx
  00209	40		 inc	 eax

; 472  : 				pDestSurfaceBuf++;

  0020a	83 c7 04	 add	 edi, 4
  0020d	89 85 3c ff ff
	ff		 mov	 DWORD PTR _x$1$[ebp], eax
  00213	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  00216	0f 8c 4a ff ff
	ff		 jl	 $LL5@RenderPost
$LN3@RenderPost:

; 473  : 			}
; 474  : 			pSrcSurfaceBuf += (lockedSurfaceDesc.lPitch / 4) - m_movieWidth;

  0021c	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _lockedSurfaceDesc$[ebp+16]
  00222	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00225	99		 cdq
  00226	83 e2 03	 and	 edx, 3
  00229	03 c2		 add	 eax, edx
  0022b	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _y$1$[ebp]
  00231	c1 f8 02	 sar	 eax, 2
  00234	42		 inc	 edx
  00235	2b c1		 sub	 eax, ecx
  00237	89 95 40 ff ff
	ff		 mov	 DWORD PTR _y$1$[ebp], edx
  0023d	c1 e0 02	 shl	 eax, 2
  00240	03 f0		 add	 esi, eax

; 475  : 			pDestSurfaceBuf += (lockedSurfaceDesc.lPitch / 4) - m_movieWidth;

  00242	03 f8		 add	 edi, eax
  00244	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _fadeOutColorBlue$1$[ebp]
  0024a	3b 53 0c	 cmp	 edx, DWORD PTR [ebx+12]
  0024d	0f 8c e0 fe ff
	ff		 jl	 $LL8@RenderPost

; 453  : 		}
; 454  : 
; 455  : 		// 픽셀 플랏팅(32비트)
; 456  : 		int *pSrcSurfaceBuf = pCopiedSrcSurBuf;
; 457  : 		int *pDestSurfaceBuf = (int*)lockedSurfaceDesc.lpSurface;
; 458  : 
; 459  : 		int fadeOutColorRed = (int)(((fadeOutColor >> 16) & 255) * fadeProgress);
; 460  : 		int fadeOutColorGreen = (int)(((fadeOutColor >> 8) & 255) * fadeProgress);
; 461  : 		int fadeOutColorBlue = (int)((fadeOutColor & 255) * fadeProgress);
; 462  : 		for(int y = 0; y < m_movieHeight; ++y)

  00253	8b b5 24 ff ff
	ff		 mov	 esi, DWORD PTR _fadeBegin$1$[ebp]
  00259	8b bd 68 ff ff
	ff		 mov	 edi, DWORD PTR _lockedSurfaceDesc$[ebp+36]
$LN6@RenderPost:

; 476  : 		}
; 477  : 		pSurface->Unlock(lockedSurfaceDesc.lpSurface);

  0025f	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _pSurface$GSCopy$1$[ebp]
  00265	57		 push	 edi
  00266	8b f9		 mov	 edi, ecx
  00268	57		 push	 edi
  00269	8b 01		 mov	 eax, DWORD PTR [ecx]
  0026b	ff 90 80 00 00
	00		 call	 DWORD PTR [eax+128]

; 478  : 
; 479  : 		// 색상이 바뀐 동영상 이미지 그리기
; 480  : 		RECT movieRect;
; 481  : 		CalcMovieRect(m_movieWidth, m_movieHeight, movieRect);

  00271	8d 45 e8	 lea	 eax, DWORD PTR _movieRect$4[ebp]
  00274	50		 push	 eax
  00275	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00278	ff 73 08	 push	 DWORD PTR [ebx+8]
  0027b	e8 00 00 00 00	 call	 ?CalcMovieRect@CMovieMan@@AAEXHHAAUtagRECT@@@Z ; CMovieMan::CalcMovieRect

; 482  : 		if (FAILED(m_pPrimarySurface->Blt(&movieRect, pSurface, NULL, DDBLT_WAIT, NULL)))

  00280	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00283	8d 55 e8	 lea	 edx, DWORD PTR _movieRect$4[ebp]
  00286	6a 00		 push	 0
  00288	68 00 00 00 01	 push	 16777216		; 01000000H
  0028d	6a 00		 push	 0
  0028f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00291	57		 push	 edi
  00292	52		 push	 edx
  00293	50		 push	 eax
  00294	ff 51 14	 call	 DWORD PTR [ecx+20]
  00297	85 c0		 test	 eax, eax
  00299	79 6e		 jns	 SHORT $LN17@RenderPost

; 91   : 	HDC desktopDC = GetDC(0);

  0029b	6a 00		 push	 0
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4

; 92   : 	if (SUCCEEDED(pSrcSurface->GetDC(&surfaceDC)))

  002a3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002a5	89 85 40 ff ff
	ff		 mov	 DWORD PTR _desktopDC$1$[ebp], eax
  002ab	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _surfaceDC$1[ebp]
  002b1	50		 push	 eax
  002b2	57		 push	 edi
  002b3	ff 51 44	 call	 DWORD PTR [ecx+68]
  002b6	85 c0		 test	 eax, eax
  002b8	78 41		 js	 SHORT $LN16@RenderPost

; 93   : 	{
; 94   : 		StretchBlt(desktopDC, pDestRect->left, pDestRect->top, pDestRect->right - pDestRect->left, pDestRect->bottom - pDestRect->top,
; 95   : 			surfaceDC, 0, 0, m_movieWidth, m_movieHeight, SRCCOPY);

  002ba	8b 45 f4	 mov	 eax, DWORD PTR _movieRect$4[ebp+12]
  002bd	8b 55 ec	 mov	 edx, DWORD PTR _movieRect$4[ebp+4]
  002c0	2b c2		 sub	 eax, edx
  002c2	8b 4d e8	 mov	 ecx, DWORD PTR _movieRect$4[ebp]
  002c5	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  002ca	ff 73 0c	 push	 DWORD PTR [ebx+12]
  002cd	ff 73 08	 push	 DWORD PTR [ebx+8]
  002d0	6a 00		 push	 0
  002d2	6a 00		 push	 0
  002d4	ff b5 28 ff ff
	ff		 push	 DWORD PTR _surfaceDC$1[ebp]
  002da	50		 push	 eax
  002db	8b 45 f0	 mov	 eax, DWORD PTR _movieRect$4[ebp+8]
  002de	2b c1		 sub	 eax, ecx
  002e0	50		 push	 eax
  002e1	52		 push	 edx
  002e2	51		 push	 ecx
  002e3	ff b5 40 ff ff
	ff		 push	 DWORD PTR _desktopDC$1$[ebp]
  002e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchBlt@44

; 96   : 		pSrcSurface->ReleaseDC(surfaceDC);

  002ef	ff b5 28 ff ff
	ff		 push	 DWORD PTR _surfaceDC$1[ebp]
  002f5	8b 07		 mov	 eax, DWORD PTR [edi]
  002f7	57		 push	 edi
  002f8	ff 50 68	 call	 DWORD PTR [eax+104]
$LN16@RenderPost:

; 97   : 	}
; 98   : 	ReleaseDC(0, desktopDC);

  002fb	ff b5 40 ff ff
	ff		 push	 DWORD PTR _desktopDC$1$[ebp]
  00301	6a 00		 push	 0
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$LN17@RenderPost:

; 483  : 		{
; 484  : 			GDIBlt(pSurface, &movieRect);
; 485  : 		}
; 486  : 
; 487  : 		// 위 또는 좌측 빈칸 색채우기
; 488  : 		RECT upperRect, lowerRect;
; 489  : 		CalcBackgroundRect(movieRect, upperRect, lowerRect);

  00309	8d 45 b8	 lea	 eax, DWORD PTR _lowerRect$2[ebp]
  0030c	8b cb		 mov	 ecx, ebx
  0030e	50		 push	 eax
  0030f	8d 45 c8	 lea	 eax, DWORD PTR _upperRect$3[ebp]
  00312	50		 push	 eax
  00313	8d 45 e8	 lea	 eax, DWORD PTR _movieRect$4[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 ?CalcBackgroundRect@CMovieMan@@AAEXABUtagRECT@@AAU2@1@Z ; CMovieMan::CalcBackgroundRect

; 490  : 		FillRect(upperRect, (fadeOutColorRed << 16) | (fadeOutColorGreen << 8) | fadeOutColorBlue);

  0031c	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _fadeOutColorBlue$1$[ebp]
  00322	8b cb		 mov	 ecx, ebx
  00324	8b f8		 mov	 edi, eax
  00326	c1 e7 08	 shl	 edi, 8
  00329	0b f8		 or	 edi, eax
  0032b	c1 e7 08	 shl	 edi, 8
  0032e	0b f8		 or	 edi, eax
  00330	8d 45 c8	 lea	 eax, DWORD PTR _upperRect$3[ebp]
  00333	57		 push	 edi
  00334	50		 push	 eax
  00335	e8 00 00 00 00	 call	 ?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z ; CMovieMan::FillRect

; 491  : 		FillRect(lowerRect, (fadeOutColorRed << 16) | (fadeOutColorGreen << 8) | fadeOutColorBlue);

  0033a	57		 push	 edi
  0033b	8d 45 b8	 lea	 eax, DWORD PTR _lowerRect$2[ebp]
  0033e	8b cb		 mov	 ecx, ebx
  00340	50		 push	 eax
  00341	e8 00 00 00 00	 call	 ?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z ; CMovieMan::FillRect

; 492  : 		
; 493  : 		// 음량 조절
; 494  : 		if (m_pBasicAudio)

  00346	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  00349	85 d2		 test	 edx, edx
  0034b	74 1b		 je	 SHORT $LN1@RenderPost

; 495  : 		{
; 496  : 			m_pBasicAudio->put_Volume((long)(-10000 * fadeProgress));

  0034d	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _fadeProgress$1$[ebp]
  00355	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@c61c4000
  0035d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0035f	f3 0f 2c c0	 cvttss2si eax, xmm0
  00363	50		 push	 eax
  00364	52		 push	 edx
  00365	ff 51 1c	 call	 DWORD PTR [ecx+28]
$LN1@RenderPost:

; 433  : 	float fadeProgress = 0.0;
; 434  : 	while ((fadeProgress = ((float)((LONG)GetTickCount()) - fadeBegin) / fadeOutDuration) < 1.0)

  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0036e	66 0f 6e ce	 movd	 xmm1, esi
  00372	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00375	66 0f 6e c0	 movd	 xmm0, eax
  00379	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0037c	f3 0f 5c c1	 subss	 xmm0, xmm1
  00380	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00388	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@44a28000
  00390	0f 2f c8	 comiss	 xmm1, xmm0
  00393	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fadeProgress$1$[ebp], xmm0
  0039b	76 38		 jbe	 SHORT $LN12@RenderPost
  0039d	8b bd 34 ff ff
	ff		 mov	 edi, DWORD PTR _pSurface$GSCopy$1$[ebp]
  003a3	e9 ca fc ff ff	 jmp	 $LL13@RenderPost
$LN23@RenderPost:

; 448  : 			{
; 449  : 				pSurface->Unlock(lockedSurfaceDesc.lpSurface);

  003a8	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _pSurface$GSCopy$1$[ebp]
  003ae	ff b5 68 ff ff
	ff		 push	 DWORD PTR _lockedSurfaceDesc$[ebp+36]
  003b4	51		 push	 ecx
  003b5	8b 01		 mov	 eax, DWORD PTR [ecx]
  003b7	ff 90 80 00 00
	00		 call	 DWORD PTR [eax+128]

; 450  : 				return E_OUTOFMEMORY;

  003bd	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH

; 509  : }

  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 cd		 xor	 ecx, ebp
  003ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c2 0c 00	 ret	 12			; 0000000cH
$LN12@RenderPost:

; 497  : 		}
; 498  : 	}
; 499  : 
; 500  : 	// 메모리 해제
; 501  : 	free(pCopiedSrcSurBuf);

  003d5	ff b5 38 ff ff
	ff		 push	 DWORD PTR _pCopiedSrcSurBuf$1$[ebp]
  003db	e8 00 00 00 00	 call	 _free
  003e0	83 c4 04	 add	 esp, 4

; 502  : 
; 503  : 	// 마지막엔 1.0을 기준으로 완전히 FadeOut된 화면 그리기
; 504  : 	RECT windowRect;
; 505  : 	GetWindowRect(windowRect);

  003e3	8d 45 d8	 lea	 eax, DWORD PTR _windowRect$[ebp]
  003e6	50		 push	 eax
  003e7	e8 00 00 00 00	 call	 ?GetWindowRect@CMovieMan@@AAEXAAUtagRECT@@@Z ; CMovieMan::GetWindowRect

; 506  : 	FillRect(windowRect, fadeOutColor);

  003ec	6a 00		 push	 0
  003ee	8d 45 d8	 lea	 eax, DWORD PTR _windowRect$[ebp]
  003f1	8b cb		 mov	 ecx, ebx
  003f3	50		 push	 eax
  003f4	e8 00 00 00 00	 call	 ?FillRect@CMovieMan@@AAEXAAUtagRECT@@K@Z ; CMovieMan::FillRect

; 507  : 
; 508  : 	return S_OK;

  003f9	33 c0		 xor	 eax, eax
$LN14@RenderPost:

; 509  : }

  003fb	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fe	5f		 pop	 edi
  003ff	5e		 pop	 esi
  00400	33 cd		 xor	 ecx, ebp
  00402	5b		 pop	 ebx
  00403	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00408	8b e5		 mov	 esp, ebp
  0040a	5d		 pop	 ebp
  0040b	c2 0c 00	 ret	 12			; 0000000cH
?RenderPostEffectFadeOut@CMovieMan@@AAEJPAUIDirectDrawSurface@@HK@Z ENDP ; CMovieMan::RenderPostEffectFadeOut
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
; File c:\program files (x86)\microsoft sdks\windows\v7.1a\include\guiddef.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp
;	COMDAT ?BuildFilterGraphManually@CMovieMan@@AAEJPA_WPAUIAMMultiMediaStream@@U_GUID@@22@Z
_TEXT	SEGMENT
_wpFilename$GSCopy$1$ = -364				; size = 4
_pWrap$1 = -360						; size = 4
_pSourceFilter$ = -356					; size = 4
_pSplitterAudioOutPin$ = -352				; size = 4
_pAudioFilter$ = -348					; size = 4
_pSplitterFilter$ = -344				; size = 4
_pVideoFilter$ = -340					; size = 4
_pOutPin$ = -336					; size = 4
_pGraphBuilder$ = -332					; size = 4
_pInPin$ = -328						; size = 4
_pEnumPins$ = -324					; size = 4
_pinInfo$2 = -320					; size = 264
_clsidSplitter$GSCopy$ = -56				; size = 16
_clsidAudioCodec$GSCopy$ = -40				; size = 16
_clsidVideoCodec$GSCopy$ = -24				; size = 16
__$ArrayPad$ = -4					; size = 4
_wpFilename$ = 8					; size = 4
_pAMStream$ = 12					; size = 4
_clsidSplitter$ = 16					; size = 16
_clsidVideoCodec$ = 32					; size = 16
_clsidAudioCodec$ = 48					; size = 16
?BuildFilterGraphManually@CMovieMan@@AAEJPA_WPAUIAMMultiMediaStream@@U_GUID@@22@Z PROC ; CMovieMan::BuildFilterGraphManually, COMDAT
; _this$ = ecx

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	f3 0f 6f 45 10	 movdqu	 xmm0, XMMWORD PTR _clsidSplitter$[ebp]
  00018	8b 55 0c	 mov	 edx, DWORD PTR _pAMStream$[ebp]
  0001b	8b 45 08	 mov	 eax, DWORD PTR _wpFilename$[ebp]
  0001e	53		 push	 ebx
  0001f	f3 0f 7f 45 c8	 movdqu	 XMMWORD PTR _clsidSplitter$GSCopy$[ebp], xmm0
  00024	56		 push	 esi
  00025	f3 0f 6f 45 20	 movdqu	 xmm0, XMMWORD PTR _clsidVideoCodec$[ebp]
  0002a	57		 push	 edi
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 85 94 fe ff
	ff		 mov	 DWORD PTR _wpFilename$GSCopy$1$[ebp], eax

; 521  : 	IGraphBuilder* pGraphBuilder = NULL;
; 522  : 	pAMStream->GetFilterGraph(&pGraphBuilder);

  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _pGraphBuilder$[ebp]
  0003b	f3 0f 7f 45 e8	 movdqu	 XMMWORD PTR _clsidVideoCodec$GSCopy$[ebp], xmm0
  00040	51		 push	 ecx
  00041	f3 0f 6f 45 30	 movdqu	 xmm0, XMMWORD PTR _clsidAudioCodec$[ebp]
  00046	52		 push	 edx
  00047	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pGraphBuilder$[ebp], 0
  00051	f3 0f 7f 45 d8	 movdqu	 XMMWORD PTR _clsidAudioCodec$GSCopy$[ebp], xmm0
  00056	ff 50 34	 call	 DWORD PTR [eax+52]

; 523  : 
; 524  : 	assert(pGraphBuilder);
; 525  : 
; 526  : //#ifdef _DEBUG
; 527  : //	DWORD dwRegister;
; 528  : //	AddToRot(pGraphBuilder, &dwRegister);
; 529  : //#endif
; 530  : 
; 531  : 	IBaseFilter *pSourceFilter = NULL;
; 532  : 	IBaseFilter *pSplitterFilter = NULL;
; 533  : 	IBaseFilter *pVideoFilter = NULL;
; 534  : 	IBaseFilter *pAudioFilter = NULL;
; 535  : 
; 536  : 	CoCreateInstance(clsidSplitter, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void **) &pSplitterFilter);

  00059	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CoCreateInstance@20
  0005f	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _pSplitterFilter$[ebp]
  00065	50		 push	 eax
  00066	68 00 00 00 00	 push	 OFFSET _IID_IBaseFilter
  0006b	6a 01		 push	 1
  0006d	6a 00		 push	 0
  0006f	8d 45 c8	 lea	 eax, DWORD PTR _clsidSplitter$GSCopy$[ebp]
  00072	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pSourceFilter$[ebp], 0
  0007c	50		 push	 eax
  0007d	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pSplitterFilter$[ebp], 0
  00087	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pVideoFilter$[ebp], 0
  00091	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pAudioFilter$[ebp], 0
  0009b	ff d7		 call	 edi

; 537  : 	CoCreateInstance(clsidVideoCodec, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void **) &pVideoFilter);

  0009d	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _pVideoFilter$[ebp]
  000a3	50		 push	 eax
  000a4	68 00 00 00 00	 push	 OFFSET _IID_IBaseFilter
  000a9	6a 01		 push	 1
  000ab	6a 00		 push	 0
  000ad	8d 45 e8	 lea	 eax, DWORD PTR _clsidVideoCodec$GSCopy$[ebp]
  000b0	50		 push	 eax
  000b1	ff d7		 call	 edi

; 538  : 	CoCreateInstance(clsidAudioCodec, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void **) &pAudioFilter);

  000b3	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _pAudioFilter$[ebp]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET _IID_IBaseFilter
  000bf	6a 01		 push	 1
  000c1	6a 00		 push	 0
  000c3	8d 45 d8	 lea	 eax, DWORD PTR _clsidAudioCodec$GSCopy$[ebp]
  000c6	50		 push	 eax
  000c7	ff d7		 call	 edi

; 539  : 
; 540  : 	// 만약 MP43 디코더가 없다면 DMO 코덱을 대신 넣어준다
; 541  : 	// MONSTER팀에서 발견된 케이스(코덱을 누군가 강제로 삭제)
; 542  : 	if (!pVideoFilter && IsEqualGUID(clsidVideoCodec, CLSID_MP4VideoCodec))

  000c9	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR _pVideoFilter$[ebp], 0
  000d0	75 77		 jne	 SHORT $LN10@BuildFilte
; File c:\program files (x86)\microsoft sdks\windows\v7.1a\include\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  000d2	8d 4d e8	 lea	 ecx, DWORD PTR _clsidVideoCodec$GSCopy$[ebp]
  000d5	ba 00 00 00 00	 mov	 edx, OFFSET _CLSID_MP4VideoCodec
  000da	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  000df	90		 npad	 1
$LL23@BuildFilte:
  000e0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e2	3b 02		 cmp	 eax, DWORD PTR [edx]
  000e4	75 63		 jne	 SHORT $LN10@BuildFilte
  000e6	83 c1 04	 add	 ecx, 4
  000e9	83 c2 04	 add	 edx, 4
  000ec	83 ee 04	 sub	 esi, 4
  000ef	73 ef		 jae	 SHORT $LL23@BuildFilte
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.cpp

; 545  : 		HRESULT hr = CoCreateInstance(CLSID_DMOWrapperFilter, NULL, CLSCTX_INPROC, IID_IBaseFilter, (void **)&pVideoFilter);

  000f1	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _pVideoFilter$[ebp]
  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET _IID_IBaseFilter
  000fd	6a 03		 push	 3
  000ff	6a 00		 push	 0
  00101	68 00 00 00 00	 push	 OFFSET _CLSID_DMOWrapperFilter
  00106	ff d7		 call	 edi

; 546  : 		if (SUCCEEDED(hr)) 

  00108	85 c0		 test	 eax, eax
  0010a	78 3d		 js	 SHORT $LN10@BuildFilte

; 547  : 		{
; 548  : 			IDMOWrapperFilter *pWrap;
; 549  : 			hr = pVideoFilter->QueryInterface(IID_IDMOWrapperFilter, (void **)&pWrap);

  0010c	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _pVideoFilter$[ebp]
  00112	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR _pWrap$1[ebp]
  00118	52		 push	 edx
  00119	68 00 00 00 00	 push	 OFFSET _IID_IDMOWrapperFilter
  0011e	50		 push	 eax
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	ff 11		 call	 DWORD PTR [ecx]

; 550  : 			if (SUCCEEDED(hr))

  00123	85 c0		 test	 eax, eax
  00125	78 22		 js	 SHORT $LN10@BuildFilte

; 551  : 			{
; 552  : 				hr = pWrap->Init(CLSID_MP43DMOCodec, DMOCATEGORY_VIDEO_DECODER);

  00127	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _pWrap$1[ebp]
  0012d	68 00 00 00 00	 push	 OFFSET _DMOCATEGORY_VIDEO_DECODER
  00132	68 00 00 00 00	 push	 OFFSET _CLSID_MP43DMOCodec
  00137	50		 push	 eax
  00138	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013a	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 553  : 				pWrap->Release();

  0013d	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _pWrap$1[ebp]
  00143	50		 push	 eax
  00144	8b 08		 mov	 ecx, DWORD PTR [eax]
  00146	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN10@BuildFilte:

; 554  : 			}
; 555  : 		}
; 556  : 	}
; 557  : 
; 558  : 	pGraphBuilder->AddSourceFilter(wpFilename, L"Source Filter", &pSourceFilter);

  00149	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  0014f	8d 95 9c fe ff
	ff		 lea	 edx, DWORD PTR _pSourceFilter$[ebp]
  00155	52		 push	 edx
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@KFENCCEP@?$AAS?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?5?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@
  0015b	ff b5 94 fe ff
	ff		 push	 DWORD PTR _wpFilename$GSCopy$1$[ebp]
  00161	8b 08		 mov	 ecx, DWORD PTR [eax]
  00163	50		 push	 eax
  00164	ff 51 38	 call	 DWORD PTR [ecx+56]

; 559  : 	pGraphBuilder->AddFilter(pSplitterFilter, L"Splitter");

  00167	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@GEEOHGFK@?$AAS?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe?$AAr?$AA?$AA@
  00172	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _pSplitterFilter$[ebp]
  00178	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017a	50		 push	 eax
  0017b	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 560  : 	pGraphBuilder->AddFilter(pVideoFilter, L"Video Decoder");

  0017e	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@DBOEKKK@?$AAV?$AAi?$AAd?$AAe?$AAo?$AA?5?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@
  00189	ff b5 ac fe ff
	ff		 push	 DWORD PTR _pVideoFilter$[ebp]
  0018f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00191	50		 push	 eax
  00192	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 561  : 	pGraphBuilder->AddFilter(pAudioFilter, L"Audio Decoder");

  00195	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@CMEFDNDD@?$AAA?$AAu?$AAd?$AAi?$AAo?$AA?5?$AAD?$AAe?$AAc?$AAo?$AAd?$AAe?$AAr?$AA?$AA@
  001a0	ff b5 a4 fe ff
	ff		 push	 DWORD PTR _pAudioFilter$[ebp]
  001a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a8	50		 push	 eax
  001a9	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 562  : 
; 563  : 	assert(m_pBasicAudio == NULL);
; 564  : 	pGraphBuilder->QueryInterface(IID_IBasicAudio, (void**) &m_pBasicAudio);

  001ac	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _pGraphBuilder$[ebp]
  001b2	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  001b5	50		 push	 eax
  001b6	68 00 00 00 00	 push	 OFFSET _IID_IBasicAudio
  001bb	51		 push	 ecx
  001bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  001be	ff 12		 call	 DWORD PTR [edx]

; 565  : 
; 566  : 	// Connect "Source" -> "Splitter"
; 567  : 	IPin *pInPin = NULL;
; 568  : 	IPin *pOutPin = NULL;
; 569  : 	IPin *pSplitterVideoOutPin = NULL;
; 570  : 	IPin *pSplitterAudioOutPin = NULL;
; 571  : 	IEnumPins *pEnumPins = NULL;
; 572  : 	pSourceFilter->EnumPins(&pEnumPins);

  001c0	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _pSourceFilter$[ebp]
  001c6	8d 95 bc fe ff
	ff		 lea	 edx, DWORD PTR _pEnumPins$[ebp]
  001cc	33 f6		 xor	 esi, esi
  001ce	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pInPin$[ebp], 0
  001d8	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pOutPin$[ebp], 0
  001e2	89 b5 a0 fe ff
	ff		 mov	 DWORD PTR _pSplitterAudioOutPin$[ebp], esi
  001e8	89 b5 bc fe ff
	ff		 mov	 DWORD PTR _pEnumPins$[ebp], esi
  001ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f0	52		 push	 edx
  001f1	50		 push	 eax
  001f2	ff 51 28	 call	 DWORD PTR [ecx+40]

; 573  : 	pEnumPins->Next(1, &pOutPin, NULL);

  001f5	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  001fb	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _pOutPin$[ebp]
  00201	56		 push	 esi
  00202	52		 push	 edx
  00203	6a 01		 push	 1
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	50		 push	 eax
  00208	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 574  : 	pEnumPins->Release();

  0020b	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  00211	50		 push	 eax
  00212	8b 08		 mov	 ecx, DWORD PTR [eax]
  00214	ff 51 08	 call	 DWORD PTR [ecx+8]

; 575  : 	pSplitterFilter->EnumPins(&pEnumPins);

  00217	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _pSplitterFilter$[ebp]
  0021d	8d 95 bc fe ff
	ff		 lea	 edx, DWORD PTR _pEnumPins$[ebp]
  00223	52		 push	 edx
  00224	50		 push	 eax
  00225	8b 08		 mov	 ecx, DWORD PTR [eax]
  00227	ff 51 28	 call	 DWORD PTR [ecx+40]

; 576  : 	pEnumPins->Next(1, &pInPin, NULL);

  0022a	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  00230	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR _pInPin$[ebp]
  00236	56		 push	 esi
  00237	52		 push	 edx
  00238	6a 01		 push	 1
  0023a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023c	50		 push	 eax
  0023d	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 577  : 	pEnumPins->Release();

  00240	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  00246	50		 push	 eax
  00247	8b 08		 mov	 ecx, DWORD PTR [eax]
  00249	ff 51 08	 call	 DWORD PTR [ecx+8]

; 578  : 	HRESULT hr = pGraphBuilder->Connect(pOutPin, pInPin);

  0024c	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  00252	ff b5 b8 fe ff
	ff		 push	 DWORD PTR _pInPin$[ebp]
  00258	ff b5 b0 fe ff
	ff		 push	 DWORD PTR _pOutPin$[ebp]
  0025e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00260	50		 push	 eax
  00261	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00264	8b f8		 mov	 edi, eax

; 579  : 	pInPin->Release();

  00266	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _pInPin$[ebp]
  0026c	51		 push	 ecx
  0026d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0026f	ff 52 08	 call	 DWORD PTR [edx+8]

; 580  : 	pOutPin->Release();

  00272	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _pOutPin$[ebp]
  00278	51		 push	 ecx
  00279	8b 11		 mov	 edx, DWORD PTR [ecx]
  0027b	ff 52 08	 call	 DWORD PTR [edx+8]

; 581  : 	if (SUCCEEDED(hr))

  0027e	85 ff		 test	 edi, edi
  00280	0f 88 eb 01 00
	00		 js	 $LN25@BuildFilte

; 582  : 	{
; 583  : 		// 연결후에만 Output 핀들이 나타난다
; 584  : 		pSplitterFilter->EnumPins(&pEnumPins);

  00286	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _pSplitterFilter$[ebp]
  0028c	8d 95 bc fe ff
	ff		 lea	 edx, DWORD PTR _pEnumPins$[ebp]
  00292	52		 push	 edx
  00293	50		 push	 eax
  00294	8b 08		 mov	 ecx, DWORD PTR [eax]
  00296	ff 51 28	 call	 DWORD PTR [ecx+40]

; 585  : 		PIN_INFO pinInfo;
; 586  : 		while( SUCCEEDED(pEnumPins->Next(1, &pInPin, NULL)) )

  00299	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  0029f	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR _pInPin$[ebp]
  002a5	56		 push	 esi
  002a6	52		 push	 edx
  002a7	6a 01		 push	 1
  002a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ab	50		 push	 eax
  002ac	ff 51 0c	 call	 DWORD PTR [ecx+12]
  002af	85 c0		 test	 eax, eax
  002b1	78 6e		 js	 SHORT $LN7@BuildFilte
$LL8@BuildFilte:

; 587  : 		{
; 588  : 			pInPin->QueryPinInfo(&pinInfo);

  002b3	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _pInPin$[ebp]
  002b9	8d 95 c0 fe ff
	ff		 lea	 edx, DWORD PTR _pinInfo$2[ebp]
  002bf	52		 push	 edx
  002c0	50		 push	 eax
  002c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c3	ff 51 20	 call	 DWORD PTR [ecx+32]

; 589  : 			pinInfo.pFilter->Release();

  002c6	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _pinInfo$2[ebp]
  002cc	50		 push	 eax
  002cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002cf	ff 51 08	 call	 DWORD PTR [ecx+8]

; 590  : 			if (pinInfo.dir == PINDIR_OUTPUT)

  002d2	83 bd c4 fe ff
	ff 01		 cmp	 DWORD PTR _pinInfo$2[ebp+4], 1
  002d9	74 29		 je	 SHORT $LN18@BuildFilte

; 595  : 				break;
; 596  : 			}
; 597  : 			pInPin->Release();

  002db	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _pInPin$[ebp]
  002e1	50		 push	 eax
  002e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e4	ff 51 08	 call	 DWORD PTR [ecx+8]
  002e7	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  002ed	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR _pInPin$[ebp]
  002f3	6a 00		 push	 0
  002f5	52		 push	 edx
  002f6	6a 01		 push	 1
  002f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fa	50		 push	 eax
  002fb	ff 51 0c	 call	 DWORD PTR [ecx+12]
  002fe	85 c0		 test	 eax, eax
  00300	79 b1		 jns	 SHORT $LL8@BuildFilte

; 590  : 			if (pinInfo.dir == PINDIR_OUTPUT)

  00302	eb 1d		 jmp	 SHORT $LN7@BuildFilte
$LN18@BuildFilte:

; 591  : 			{
; 592  : 				// Pin의 순서를 비디오-오디오로 가정
; 593  : 				pSplitterVideoOutPin = pInPin;
; 594  : 				pEnumPins->Next(1, &pSplitterAudioOutPin, NULL);

  00304	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  0030a	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR _pSplitterAudioOutPin$[ebp]
  00310	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _pInPin$[ebp]
  00316	6a 00		 push	 0
  00318	52		 push	 edx
  00319	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031b	6a 01		 push	 1
  0031d	50		 push	 eax
  0031e	ff 51 0c	 call	 DWORD PTR [ecx+12]
$LN7@BuildFilte:

; 598  : 		}
; 599  : 		pEnumPins->Release();

  00321	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  00327	50		 push	 eax
  00328	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032a	ff 51 08	 call	 DWORD PTR [ecx+8]

; 600  : 
; 601  : 		// Splitter -> Video/Audio codecs
; 602  : 		pVideoFilter->EnumPins(&pEnumPins);

  0032d	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _pVideoFilter$[ebp]
  00333	8d 95 bc fe ff
	ff		 lea	 edx, DWORD PTR _pEnumPins$[ebp]
  00339	52		 push	 edx
  0033a	50		 push	 eax
  0033b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033d	ff 51 28	 call	 DWORD PTR [ecx+40]

; 603  : 		pEnumPins->Next(1, &pInPin, NULL);

  00340	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  00346	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR _pInPin$[ebp]
  0034c	6a 00		 push	 0
  0034e	52		 push	 edx
  0034f	6a 01		 push	 1
  00351	8b 08		 mov	 ecx, DWORD PTR [eax]
  00353	50		 push	 eax
  00354	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 604  : 		pEnumPins->Next(1, &pOutPin, NULL);

  00357	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  0035d	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _pOutPin$[ebp]
  00363	6a 00		 push	 0
  00365	52		 push	 edx
  00366	6a 01		 push	 1
  00368	8b 08		 mov	 ecx, DWORD PTR [eax]
  0036a	50		 push	 eax
  0036b	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 605  : 		pEnumPins->Release();

  0036e	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  00374	50		 push	 eax
  00375	8b 08		 mov	 ecx, DWORD PTR [eax]
  00377	ff 51 08	 call	 DWORD PTR [ecx+8]

; 606  : 		hr = pGraphBuilder->Connect(pSplitterVideoOutPin, pInPin);

  0037a	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  00380	ff b5 b8 fe ff
	ff		 push	 DWORD PTR _pInPin$[ebp]
  00386	56		 push	 esi
  00387	8b 08		 mov	 ecx, DWORD PTR [eax]
  00389	50		 push	 eax
  0038a	ff 51 2c	 call	 DWORD PTR [ecx+44]
  0038d	8b f8		 mov	 edi, eax

; 607  : 		if (SUCCEEDED(hr))

  0038f	85 ff		 test	 edi, edi
  00391	0f 88 d0 00 00
	00		 js	 $LN24@BuildFilte

; 608  : 		{
; 609  : 			// 비디오 렌더
; 610  : 			hr = pGraphBuilder->Render(pOutPin);

  00397	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  0039d	ff b5 b0 fe ff
	ff		 push	 DWORD PTR _pOutPin$[ebp]
  003a3	50		 push	 eax
  003a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a6	ff 51 30	 call	 DWORD PTR [ecx+48]
  003a9	8b f8		 mov	 edi, eax

; 611  : 			pInPin->Release();

  003ab	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _pInPin$[ebp]
  003b1	50		 push	 eax
  003b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b4	ff 51 08	 call	 DWORD PTR [ecx+8]

; 612  : 			pOutPin->Release();

  003b7	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _pOutPin$[ebp]
  003bd	50		 push	 eax
  003be	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c0	ff 51 08	 call	 DWORD PTR [ecx+8]

; 613  : 
; 614  : 			// 오디오는 파일에 따라 없을 수도 있다
; 615  : 			if (pSplitterAudioOutPin && pAudioFilter)

  003c3	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR _pSplitterAudioOutPin$[ebp], 0
  003ca	0f 84 97 00 00
	00		 je	 $LN24@BuildFilte
  003d0	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _pAudioFilter$[ebp]
  003d6	85 c9		 test	 ecx, ecx
  003d8	0f 84 89 00 00
	00		 je	 $LN24@BuildFilte

; 616  : 			{
; 617  : 				pAudioFilter->EnumPins(&pEnumPins);

  003de	8b 01		 mov	 eax, DWORD PTR [ecx]
  003e0	8d 95 bc fe ff
	ff		 lea	 edx, DWORD PTR _pEnumPins$[ebp]
  003e6	52		 push	 edx
  003e7	51		 push	 ecx
  003e8	ff 50 28	 call	 DWORD PTR [eax+40]

; 618  : 				pEnumPins->Next(1, &pInPin, NULL);

  003eb	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  003f1	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR _pInPin$[ebp]
  003f7	6a 00		 push	 0
  003f9	52		 push	 edx
  003fa	6a 01		 push	 1
  003fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  003fe	50		 push	 eax
  003ff	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 619  : 				pEnumPins->Next(1, &pOutPin, NULL);

  00402	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  00408	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _pOutPin$[ebp]
  0040e	6a 00		 push	 0
  00410	52		 push	 edx
  00411	6a 01		 push	 1
  00413	8b 08		 mov	 ecx, DWORD PTR [eax]
  00415	50		 push	 eax
  00416	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 620  : 				pEnumPins->Release();

  00419	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pEnumPins$[ebp]
  0041f	50		 push	 eax
  00420	8b 08		 mov	 ecx, DWORD PTR [eax]
  00422	ff 51 08	 call	 DWORD PTR [ecx+8]

; 621  : 				pGraphBuilder->Connect(pSplitterAudioOutPin, pInPin);

  00425	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  0042b	ff b5 b8 fe ff
	ff		 push	 DWORD PTR _pInPin$[ebp]
  00431	ff b5 a0 fe ff
	ff		 push	 DWORD PTR _pSplitterAudioOutPin$[ebp]
  00437	8b 08		 mov	 ecx, DWORD PTR [eax]
  00439	50		 push	 eax
  0043a	ff 51 2c	 call	 DWORD PTR [ecx+44]

; 622  : 				// 오디오 렌더는 실패해도 넘어갈 수 있음
; 623  : 				pGraphBuilder->Render(pOutPin);

  0043d	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  00443	ff b5 b0 fe ff
	ff		 push	 DWORD PTR _pOutPin$[ebp]
  00449	50		 push	 eax
  0044a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0044c	ff 51 30	 call	 DWORD PTR [ecx+48]

; 624  : 				pInPin->Release();

  0044f	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _pInPin$[ebp]
  00455	50		 push	 eax
  00456	8b 08		 mov	 ecx, DWORD PTR [eax]
  00458	ff 51 08	 call	 DWORD PTR [ecx+8]

; 625  : 				pOutPin->Release();

  0045b	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _pOutPin$[ebp]
  00461	50		 push	 eax
  00462	8b 08		 mov	 ecx, DWORD PTR [eax]
  00464	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN24@BuildFilte:

; 626  : 			}
; 627  : 		}
; 628  : 	}
; 629  : 
; 630  : 	// 해제
; 631  : //#ifdef _DEBUG
; 632  : //	RemoveFromRot(dwRegister);
; 633  : //#endif
; 634  : 
; 635  : 	if (pSplitterVideoOutPin)

  00467	85 f6		 test	 esi, esi
  00469	74 06		 je	 SHORT $LN25@BuildFilte

; 636  : 	{
; 637  : 		pSplitterVideoOutPin->Release();

  0046b	8b 06		 mov	 eax, DWORD PTR [esi]
  0046d	56		 push	 esi
  0046e	ff 50 08	 call	 DWORD PTR [eax+8]
$LN25@BuildFilte:

; 638  : 	}
; 639  : 	if (pSplitterAudioOutPin)

  00471	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _pSplitterAudioOutPin$[ebp]
  00477	85 c9		 test	 ecx, ecx
  00479	74 06		 je	 SHORT $LN2@BuildFilte

; 640  : 	{
; 641  : 		pSplitterAudioOutPin->Release();

  0047b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0047d	51		 push	 ecx
  0047e	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@BuildFilte:

; 642  : 	}
; 643  : 	pVideoFilter->Release();

  00481	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _pVideoFilter$[ebp]
  00487	50		 push	 eax
  00488	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048a	ff 51 08	 call	 DWORD PTR [ecx+8]

; 644  : 	if (pAudioFilter)

  0048d	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _pAudioFilter$[ebp]
  00493	85 c9		 test	 ecx, ecx
  00495	74 06		 je	 SHORT $LN1@BuildFilte

; 645  : 	{
; 646  : 		pAudioFilter->Release();

  00497	8b 01		 mov	 eax, DWORD PTR [ecx]
  00499	51		 push	 ecx
  0049a	ff 50 08	 call	 DWORD PTR [eax+8]
$LN1@BuildFilte:

; 647  : 	}
; 648  : 	pSplitterFilter->Release();

  0049d	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _pSplitterFilter$[ebp]
  004a3	50		 push	 eax
  004a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  004a6	ff 51 08	 call	 DWORD PTR [ecx+8]

; 649  : 	pSourceFilter->Release();

  004a9	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _pSourceFilter$[ebp]
  004af	50		 push	 eax
  004b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  004b2	ff 51 08	 call	 DWORD PTR [ecx+8]

; 650  : 	pGraphBuilder->Release();

  004b5	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _pGraphBuilder$[ebp]
  004bb	50		 push	 eax
  004bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  004be	ff 51 08	 call	 DWORD PTR [ecx+8]

; 651  : 	
; 652  : 	return hr;
; 653  : }

  004c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c4	8b c7		 mov	 eax, edi
  004c6	5f		 pop	 edi
  004c7	5e		 pop	 esi
  004c8	33 cd		 xor	 ecx, ebp
  004ca	5b		 pop	 ebx
  004cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d0	8b e5		 mov	 esp, ebp
  004d2	5d		 pop	 ebp
  004d3	c2 38 00	 ret	 56			; 00000038H
?BuildFilterGraphManually@CMovieMan@@AAEJPA_WPAUIAMMultiMediaStream@@U_GUID@@22@Z ENDP ; CMovieMan::BuildFilterGraphManually
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@00P6AHH@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@00P6AHH@Z@Z PROC ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>, COMDAT
; ___$ReturnUdt$ = ecx
; __Func$dead$ = edx

; 960  : 	{	// transform [_First, _Last) with _Func

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 215  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 960  : 	{	// transform [_First, _Last) with _Func

  0000a	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 215  : 		return (this->_Ptr == _Right._Ptr);

  0000c	3b d0		 cmp	 edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 961  : 	if (_First != _Last)

  0000e	74 12		 je	 SHORT $LN1@transform

; 962  : 		return (_Transform(_Unchecked(_First), _Unchecked(_Last),
; 963  : 			_Dest, _Func));

  00010	51		 push	 ecx
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Transform@PADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@PAD0V10@P6AHH@Z@Z ; std::_Transform<char *,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 	return (_Dest);

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 965  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN1@transform:

; 964  : 	return (_Dest);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00025	89 06		 mov	 DWORD PTR [esi], eax
  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi

; 965  : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@00P6AHH@Z@Z ENDP ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2488 : 	{	// test for string vs. NTCS equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00009	75 04		 jne	 SHORT $LN7@operator
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 10		 jmp	 SHORT $LN8@operator
$LN7@operator:
  0000f	8b c2		 mov	 eax, edx
  00011	56		 push	 esi
  00012	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL9@operator:
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	40		 inc	 eax
  00018	84 c9		 test	 cl, cl
  0001a	75 f9		 jne	 SHORT $LL9@operator
  0001c	2b c6		 sub	 eax, esi
  0001e	5e		 pop	 esi
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00022	50		 push	 eax
  00023	52		 push	 edx
  00024	ff 71 10	 push	 DWORD PTR [ecx+16]
  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2489 : 	return (_Left.compare(_Right) == 0);

  0002e	f7 d8		 neg	 eax
  00030	1b c0		 sbb	 eax, eax
  00032	40		 inc	 eax

; 2490 : 	}

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator!=, COMDAT
; _this$ = ecx

; 219  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 215  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 220  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 215  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 220  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 221  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??$_Unchecked@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 406  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 407  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 408  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Transform@PADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@PAD0V10@P6AHH@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -4					; size = 4
tv142 = 8						; size = 4
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Func$dead$ = 16					; size = 4
??$_Transform@PADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@PAD0V10@P6AHH@Z@Z PROC ; std::_Transform<char *,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 948  : 	{	// transform [_First, _Last) with _Func

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b fa		 mov	 edi, edx
  00009	33 f6		 xor	 esi, esi
  0000b	8b d1		 mov	 edx, ecx
  0000d	33 db		 xor	 ebx, ebx
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  00012	2b cf		 sub	 ecx, edi
  00014	89 55 fc	 mov	 DWORD PTR ___$ReturnUdt$1$[ebp], edx
  00017	3b 7d 08	 cmp	 edi, DWORD PTR __Last$[ebp]
  0001a	0f 47 ce	 cmova	 ecx, esi
  0001d	89 4d 08	 mov	 DWORD PTR tv142[ebp], ecx

; 949  : 	for (; _First != _Last; ++_First, ++_Dest)

  00020	85 c9		 test	 ecx, ecx
  00022	74 2d		 je	 SHORT $LN18@Transform
  00024	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
$LL8@Transform:

; 950  : 		*_Dest = _Func(*_First);

  00027	0f be 07	 movsx	 eax, BYTE PTR [edi]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _tolower
  00030	88 06		 mov	 BYTE PTR [esi], al
  00032	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 120  : 		++this->_Ptr;

  00035	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 949  : 	for (; _First != _Last; ++_First, ++_Dest)

  00038	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 120  : 		++this->_Ptr;

  00039	46		 inc	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 950  : 		*_Dest = _Func(*_First);

  0003a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 120  : 		++this->_Ptr;

  0003d	89 75 0c	 mov	 DWORD PTR __Dest$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 949  : 	for (; _First != _Last; ++_First, ++_Dest)

  00040	3b 5d 08	 cmp	 ebx, DWORD PTR tv142[ebp]
  00043	75 e2		 jne	 SHORT $LL8@Transform

; 951  : 	return (_Dest);

  00045	8b 45 fc	 mov	 eax, DWORD PTR ___$ReturnUdt$1$[ebp]
  00048	5f		 pop	 edi
  00049	89 30		 mov	 DWORD PTR [eax], esi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx

; 952  : 	}

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN18@Transform:

; 951  : 	return (_Dest);

  00051	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	89 02		 mov	 DWORD PTR [edx], eax
  00058	8b c2		 mov	 eax, edx
  0005a	5b		 pop	 ebx

; 952  : 	}

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??$_Transform@PADV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@PAD0V10@P6AHH@Z@Z ENDP ; std::_Transform<char *,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ
_TEXT	SEGMENT
?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unchecked, COMDAT
; _this$ = ecx

; 330  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 331  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??E?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator++, COMDAT
; _this$ = ecx

; 120  : 		++this->_Ptr;

  00000	ff 01		 inc	 DWORD PTR [ecx]

; 345  : 		++*(_Mybase *)this;
; 346  : 		return (*this);

  00002	8b c1		 mov	 eax, ecx

; 347  : 		}

  00004	c3		 ret	 0
??E?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++, COMDAT
; _this$ = ecx

; 103  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 104  : 		if (this->_Getcont() == 0
; 105  : 			|| this->_Ptr == 0
; 106  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 107  : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 108  : 			{	// report error
; 109  : 			_DEBUG_ERROR("string iterator not incrementable");
; 110  : 			_SCL_SECURE_OUT_OF_RANGE;
; 111  : 			}
; 112  : 
; 113  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 114  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 115  : 		_SCL_SECURE_VALIDATE_RANGE(
; 116  : 			this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 117  : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 118  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 119  : 
; 120  : 		++this->_Ptr;

  00000	ff 01		 inc	 DWORD PTR [ecx]

; 121  : 		return (*this);

  00002	8b c1		 mov	 eax, ecx

; 122  : 		}

  00004	c3		 ret	 0
??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 335  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 336  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 72   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 73   : 		if (this->_Getcont() == 0
; 74   : 			|| this->_Ptr == 0
; 75   : 			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 76   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 77   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 78   : 			{	// report error
; 79   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 80   : 			_SCL_SECURE_OUT_OF_RANGE;
; 81   : 			}
; 82   : 
; 83   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 84   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(
; 86   : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr
; 87   : 			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 88   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 89   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 90   : 
; 91   : 		_Analysis_assume_(this->_Ptr != 0);
; 92   : 
; 93   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 94   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 265  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 213  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 216  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft sdks\windows\v7.1a\include\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	8b 55 08	 mov	 edx, DWORD PTR _rguid1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00009	56		 push	 esi
  0000a	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  0000f	90		 npad	 1
$LL5@IsEqualGUI:
  00010	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00012	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00014	75 13		 jne	 SHORT $LN4@IsEqualGUI
  00016	83 c2 04	 add	 edx, 4
  00019	83 c0 04	 add	 eax, 4
  0001c	83 ee 04	 sub	 esi, 4
  0001f	73 ef		 jae	 SHORT $LL5@IsEqualGUI
  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	5e		 pop	 esi

; 162  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN4@IsEqualGUI:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00029	33 c0		 xor	 eax, eax
  0002b	5e		 pop	 esi

; 162  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_IsEqualGUID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1609 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 		}
; 56   : 
; 57   : 	typedef pointer _Unchecked_type;
; 58   : 
; 59   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 60   : 		{	// reset from unchecked iterator
; 61   : 		this->_Ptr = _Right;
; 62   : 		return (*this);
; 63   : 		}
; 64   : 
; 65   : 	_Unchecked_type _Unchecked() const
; 66   : 		{	// make an unchecked iterator
; 67   : 		return (_Unchecked_type(this->_Ptr));
; 68   : 		}
; 69   : 
; 70   : 	reference operator*() const
; 71   : 		{	// return designated object
; 72   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 73   : 		if (this->_Getcont() == 0
; 74   : 			|| this->_Ptr == 0
; 75   : 			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 76   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 77   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 78   : 			{	// report error
; 79   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 80   : 			_SCL_SECURE_OUT_OF_RANGE;
; 81   : 			}
; 82   : 
; 83   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 84   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(
; 86   : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr
; 87   : 			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 88   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 89   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 90   : 
; 91   : 		_Analysis_assume_(this->_Ptr != 0);
; 92   : 
; 93   : 		return (*this->_Ptr);
; 94   : 		}
; 95   : 
; 96   : 	pointer operator->() const
; 97   : 		{	// return pointer to class object
; 98   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 99   : 		}
; 100  : 
; 101  : 	_Myiter& operator++()
; 102  : 		{	// preincrement
; 103  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 104  : 		if (this->_Getcont() == 0
; 105  : 			|| this->_Ptr == 0
; 106  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 107  : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 108  : 			{	// report error
; 109  : 			_DEBUG_ERROR("string iterator not incrementable");
; 110  : 			_SCL_SECURE_OUT_OF_RANGE;
; 111  : 			}
; 112  : 
; 113  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 114  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 115  : 		_SCL_SECURE_VALIDATE_RANGE(
; 116  : 			this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 117  : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 118  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 119  : 
; 120  : 		++this->_Ptr;
; 121  : 		return (*this);
; 122  : 		}
; 123  : 
; 124  : 	_Myiter operator++(int)
; 125  : 		{	// postincrement
; 126  : 		_Myiter _Tmp = *this;
; 127  : 		++*this;
; 128  : 		return (_Tmp);
; 129  : 		}
; 130  : 
; 131  : 	_Myiter& operator--()
; 132  : 		{	// predecrement
; 133  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 134  : 		if (this->_Getcont() == 0
; 135  : 			|| this->_Ptr == 0
; 136  : 			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
; 137  : 			{	// report error
; 138  : 			_DEBUG_ERROR("string iterator not decrementable");
; 139  : 			_SCL_SECURE_OUT_OF_RANGE;
; 140  : 			}
; 141  : 
; 142  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 143  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 144  : 		_SCL_SECURE_VALIDATE_RANGE(
; 145  : 			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);
; 146  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 147  : 
; 148  : 		--this->_Ptr;
; 149  : 		return (*this);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter operator--(int)
; 153  : 		{	// postdecrement
; 154  : 		_Myiter _Tmp = *this;
; 155  : 		--*this;
; 156  : 		return (_Tmp);
; 157  : 		}
; 158  : 
; 159  : 	_Myiter& operator+=(difference_type _Off)
; 160  : 		{	// increment by integer
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 		if (this->_Getcont() == 0
; 163  : 			|| this->_Ptr == 0
; 164  : 			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
; 165  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 166  : 				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
; 167  : 			{	// report error
; 168  : 			_DEBUG_ERROR("string iterator + offset out of range");
; 169  : 			_SCL_SECURE_OUT_OF_RANGE;
; 170  : 			}
; 171  : 
; 172  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 173  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 174  : 		_SCL_SECURE_VALIDATE_RANGE(
; 175  : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off
; 176  : 				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()
; 177  : 					+ ((_Mystr *)this->_Getcont())->_Mysize);
; 178  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 179  : 
; 180  : 		_Ptr += _Off;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myiter operator+(difference_type _Off) const
; 185  : 		{	// return this + integer
; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);
; 188  : 		}
; 189  : 
; 190  : 	_Myiter& operator-=(difference_type _Off)
; 191  : 		{	// decrement by integer
; 192  : 		return (*this += -_Off);
; 193  : 		}
; 194  : 
; 195  : 	_Myiter operator-(difference_type _Off) const
; 196  : 		{	// return this - integer
; 197  : 		_Myiter _Tmp = *this;
; 198  : 		return (_Tmp -= _Off);
; 199  : 		}
; 200  : 
; 201  : 	difference_type operator-(const _Myiter& _Right) const
; 202  : 		{	// return difference of iterators
; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);
; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);
; 216  : 		}
; 217  : 
; 218  : 	bool operator!=(const _Myiter& _Right) const
; 219  : 		{	// test for iterator inequality
; 220  : 		return (!(*this == _Right));
; 221  : 		}
; 222  : 
; 223  : 	bool operator<(const _Myiter& _Right) const
; 224  : 		{	// test if this < _Right
; 225  : 		_Compat(_Right);
; 226  : 		return (this->_Ptr < _Right._Ptr);
; 227  : 		}
; 228  : 
; 229  : 	bool operator>(const _Myiter& _Right) const
; 230  : 		{	// test if this > _Right
; 231  : 		return (_Right < *this);
; 232  : 		}
; 233  : 
; 234  : 	bool operator<=(const _Myiter& _Right) const
; 235  : 		{	// test if this <= _Right
; 236  : 		return (!(_Right < *this));
; 237  : 		}
; 238  : 
; 239  : 	bool operator>=(const _Myiter& _Right) const
; 240  : 		{	// test if this >= _Right
; 241  : 		return (!(*this < _Right));
; 242  : 		}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 245  : 	void _Compat(const _Myiter& _Right) const
; 246  : 		{	// test for compatible iterator pair
; 247  : 		if (this->_Getcont() == 0
; 248  : 			|| this->_Getcont() != _Right._Getcont())
; 249  : 			{	// report error
; 250  : 			_DEBUG_ERROR("string iterators incompatible");
; 251  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 252  : 			}
; 253  : 		}
; 254  : 
; 255  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 256  : 	void _Compat(const _Myiter& _Right) const
; 257  : 		{	// test for compatible iterator pair
; 258  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 259  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 260  : 		}
; 261  : 
; 262  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 263  : 	void _Compat(const _Myiter&) const
; 264  : 		{	// test for compatible iterator pair
; 265  : 		}
; 266  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 267  : 
; 268  : 	pointer _Ptr;	// pointer to element in string
; 269  : 	};
; 270  : 
; 271  : template<class _Mystr> inline
; 272  : 	typename _String_const_iterator<_Mystr>::_Unchecked_type
; 273  : 		_Unchecked(_String_const_iterator<_Mystr> _Iter)
; 274  : 	{	// convert to unchecked
; 275  : 	return (_Iter._Unchecked());
; 276  : 	}
; 277  : 
; 278  : template<class _Mystr> inline
; 279  : 	_String_const_iterator<_Mystr>
; 280  : 		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
; 281  : 			typename _String_const_iterator<_Mystr>
; 282  : 				::_Unchecked_type _Right)
; 283  : 	{	// convert to checked
; 284  : 	return (_Iter._Rechecked(_Right));
; 285  : 	}
; 286  : 
; 287  : template<class _Mystr> inline
; 288  : 	_String_const_iterator<_Mystr> operator+(
; 289  : 		typename _String_const_iterator<_Mystr>
; 290  : 			::difference_type _Off,
; 291  : 		_String_const_iterator<_Mystr> _Next)
; 292  : 	{	// add offset to iterator
; 293  : 	return (_Next += _Off);
; 294  : 	}
; 295  : 
; 296  : 		// TEMPLATE CLASS _String_iterator
; 297  : template<class _Mystr>
; 298  : 	class _String_iterator
; 299  : 		: public _String_const_iterator<_Mystr>
; 300  : 	{	// iterator for mutable string
; 301  : public:
; 302  : 	typedef _String_iterator<_Mystr> _Myiter;
; 303  : 	typedef _String_const_iterator<_Mystr> _Mybase;
; 304  : 	typedef random_access_iterator_tag iterator_category;
; 305  : 
; 306  : 	typedef typename _Mystr::value_type value_type;
; 307  : 	typedef typename _Mystr::difference_type difference_type;
; 308  : 	typedef typename _Mystr::pointer pointer;
; 309  : 	typedef typename _Mystr::reference reference;
; 310  : 
; 311  : 	_String_iterator()
; 312  : 		{	// construct with null string pointer
; 313  : 		}
; 314  : 
; 315  : 	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
; 316  : 		: _Mybase(_Parg, _Pstring)
; 317  : 		{	// construct with pointer _Parg
; 318  : 		}
; 319  : 
; 320  : 	typedef pointer _Unchecked_type;
; 321  : 
; 322  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 323  : 		{	// reset from unchecked iterator
; 324  : 		this->_Ptr = _Right;
; 325  : 		return (*this);
; 326  : 		}
; 327  : 
; 328  : 	_Unchecked_type _Unchecked() const
; 329  : 		{	// make an unchecked iterator
; 330  : 		return (_Unchecked_type(this->_Ptr));
; 331  : 		}
; 332  : 
; 333  : 	reference operator*() const
; 334  : 		{	// return designated object
; 335  : 		return ((reference)**(_Mybase *)this);
; 336  : 		}
; 337  : 
; 338  : 	pointer operator->() const
; 339  : 		{	// return pointer to class object
; 340  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 341  : 		}
; 342  : 
; 343  : 	_Myiter& operator++()
; 344  : 		{	// preincrement
; 345  : 		++*(_Mybase *)this;
; 346  : 		return (*this);
; 347  : 		}
; 348  : 
; 349  : 	_Myiter operator++(int)
; 350  : 		{	// postincrement
; 351  : 		_Myiter _Tmp = *this;
; 352  : 		++*this;
; 353  : 		return (_Tmp);
; 354  : 		}
; 355  : 
; 356  : 	_Myiter& operator--()
; 357  : 		{	// predecrement
; 358  : 		--*(_Mybase *)this;
; 359  : 		return (*this);
; 360  : 		}
; 361  : 
; 362  : 	_Myiter operator--(int)
; 363  : 		{	// postdecrement
; 364  : 		_Myiter _Tmp = *this;
; 365  : 		--*this;
; 366  : 		return (_Tmp);
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator+=(difference_type _Off)
; 370  : 		{	// increment by integer
; 371  : 		*(_Mybase *)this += _Off;
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator+(difference_type _Off) const
; 376  : 		{	// return this + integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp += _Off);
; 379  : 		}
; 380  : 
; 381  : 	_Myiter& operator-=(difference_type _Off)
; 382  : 		{	// decrement by integer
; 383  : 		return (*this += -_Off);
; 384  : 		}
; 385  : 
; 386  : 	_Myiter operator-(difference_type _Off) const
; 387  : 		{	// return this - integer
; 388  : 		_Myiter _Tmp = *this;
; 389  : 		return (_Tmp -= _Off);
; 390  : 		}
; 391  : 
; 392  : 	difference_type operator-(const _Mybase& _Right) const
; 393  : 		{	// return difference of iterators
; 394  : 		return ((_Mybase)*this - _Right);
; 395  : 		}
; 396  : 
; 397  : 	reference operator[](difference_type _Off) const
; 398  : 		{	// subscript
; 399  : 		return (*(*this + _Off));
; 400  : 		}
; 401  : 	};
; 402  : 
; 403  : template<class _Mystr> inline
; 404  : 	typename _String_iterator<_Mystr>::_Unchecked_type
; 405  : 		_Unchecked(_String_iterator<_Mystr> _Iter)
; 406  : 	{	// convert to unchecked
; 407  : 	return (_Iter._Unchecked());
; 408  : 	}
; 409  : 
; 410  : template<class _Mystr> inline
; 411  : 	_String_iterator<_Mystr>
; 412  : 		_Rechecked(_String_iterator<_Mystr>& _Iter,
; 413  : 			typename _String_iterator<_Mystr>
; 414  : 				::_Unchecked_type _Right)
; 415  : 	{	// convert to checked
; 416  : 	return (_Iter._Rechecked(_Right));
; 417  : 	}
; 418  : 
; 419  : template<class _Mystr> inline
; 420  : 	_String_iterator<_Mystr> operator+(
; 421  : 		typename _String_iterator<_Mystr>
; 422  : 			::difference_type _Off,
; 423  : 		_String_iterator<_Mystr> _Next)
; 424  : 	{	// add offset to iterator
; 425  : 	return (_Next += _Off);
; 426  : 	}
; 427  : 
; 428  : 		// basic_string TYPE WRAPPERS
; 429  : template<class _Value_type,
; 430  : 	class _Size_type,
; 431  : 	class _Difference_type,
; 432  : 	class _Pointer,
; 433  : 	class _Const_pointer,
; 434  : 	class _Reference,
; 435  : 	class _Const_reference>
; 436  : 	struct _String_iter_types
; 437  : 	{	// wraps types needed by iterators
; 438  : 	typedef _Value_type value_type;
; 439  : 	typedef _Size_type size_type;
; 440  : 	typedef _Difference_type difference_type;
; 441  : 	typedef _Pointer pointer;
; 442  : 	typedef _Const_pointer const_pointer;
; 443  : 	typedef _Reference reference;
; 444  : 	typedef _Const_reference const_reference;
; 445  : 	};
; 446  : 
; 447  : template<class _Ty,
; 448  : 	class _Alloc0>
; 449  : 	struct _String_base_types
; 450  : 	{	// types needed for a container base
; 451  : 	typedef _Alloc0 _Alloc;
; 452  : 	typedef _String_base_types<_Ty, _Alloc> _Myt;
; 453  : 
; 454  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 455  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 456  : 
; 457  : 
; 458  : 	typedef typename _Alty::pointer _Tptr;
; 459  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 460  : 
; 461  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 462  : 		_Simple_types<typename _Alty::value_type>,
; 463  : 		_String_iter_types<typename _Alty::value_type,
; 464  : 			typename _Alty::size_type,
; 465  : 			typename _Alty::difference_type,
; 466  : 			typename _Alty::pointer,
; 467  : 			typename _Alty::const_pointer,
; 468  : 			typename _Alty::reference,
; 469  : 			typename _Alty::const_reference> >::type
; 470  : 		_Val_types;
; 471  : 	};
; 472  : 
; 473  : 		// TEMPLATE CLASS _String_val
; 474  : template<class _Val_types>
; 475  : 	class _String_val
; 476  : 		: public _Container_base
; 477  : 	{	// base class for basic_string to hold data
; 478  : public:
; 479  : 	typedef _String_val<_Val_types> _Myt;
; 480  : 
; 481  : 	typedef typename _Val_types::value_type value_type;
; 482  : 	typedef typename _Val_types::size_type size_type;
; 483  : 	typedef typename _Val_types::difference_type difference_type;
; 484  : 	typedef typename _Val_types::pointer pointer;
; 485  : 	typedef typename _Val_types::const_pointer const_pointer;
; 486  : 	typedef typename _Val_types::reference reference;
; 487  : 	typedef typename _Val_types::const_reference const_reference;
; 488  : 
; 489  : 	typedef _String_iterator<_Myt> iterator;
; 490  : 	typedef _String_const_iterator<_Myt> const_iterator;
; 491  : 
; 492  : 	_String_val()
; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;
; 495  : 		_Myres = 0;
; 496  : 		}
; 497  : 
; 498  : 	enum
; 499  : 		{	// length of internal buffer, [1, 16]
; 500  : 		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
; 501  : 			: 16 / sizeof (value_type)};
; 502  : 	enum
; 503  : 		{	// roundup mask for allocated buffers, [0, 15]
; 504  : 		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
; 505  : 			: sizeof (value_type) <= 2 ? 7
; 506  : 			: sizeof (value_type) <= 4 ? 3
; 507  : 			: sizeof (value_type) <= 8 ? 1 : 0};
; 508  : 
; 509  : 	value_type *_Myptr()
; 510  : 		{	// determine current pointer to buffer for mutable string
; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 10		 jb	 SHORT $LN5@end
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));

  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	03 c8		 add	 ecx, eax

; 54   : 		this->_Ptr = _Parg;

  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 1611 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN5@end:

; 55   : 		}
; 56   : 
; 57   : 	typedef pointer _Unchecked_type;
; 58   : 
; 59   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 60   : 		{	// reset from unchecked iterator
; 61   : 		this->_Ptr = _Right;
; 62   : 		return (*this);
; 63   : 		}
; 64   : 
; 65   : 	_Unchecked_type _Unchecked() const
; 66   : 		{	// make an unchecked iterator
; 67   : 		return (_Unchecked_type(this->_Ptr));
; 68   : 		}
; 69   : 
; 70   : 	reference operator*() const
; 71   : 		{	// return designated object
; 72   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 73   : 		if (this->_Getcont() == 0
; 74   : 			|| this->_Ptr == 0
; 75   : 			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 76   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 77   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 78   : 			{	// report error
; 79   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 80   : 			_SCL_SECURE_OUT_OF_RANGE;
; 81   : 			}
; 82   : 
; 83   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 84   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(
; 86   : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr
; 87   : 			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 88   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 89   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 90   : 
; 91   : 		_Analysis_assume_(this->_Ptr != 0);
; 92   : 
; 93   : 		return (*this->_Ptr);
; 94   : 		}
; 95   : 
; 96   : 	pointer operator->() const
; 97   : 		{	// return pointer to class object
; 98   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 99   : 		}
; 100  : 
; 101  : 	_Myiter& operator++()
; 102  : 		{	// preincrement
; 103  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 104  : 		if (this->_Getcont() == 0
; 105  : 			|| this->_Ptr == 0
; 106  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 107  : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 108  : 			{	// report error
; 109  : 			_DEBUG_ERROR("string iterator not incrementable");
; 110  : 			_SCL_SECURE_OUT_OF_RANGE;
; 111  : 			}
; 112  : 
; 113  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 114  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 115  : 		_SCL_SECURE_VALIDATE_RANGE(
; 116  : 			this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 117  : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 118  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 119  : 
; 120  : 		++this->_Ptr;
; 121  : 		return (*this);
; 122  : 		}
; 123  : 
; 124  : 	_Myiter operator++(int)
; 125  : 		{	// postincrement
; 126  : 		_Myiter _Tmp = *this;
; 127  : 		++*this;
; 128  : 		return (_Tmp);
; 129  : 		}
; 130  : 
; 131  : 	_Myiter& operator--()
; 132  : 		{	// predecrement
; 133  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 134  : 		if (this->_Getcont() == 0
; 135  : 			|| this->_Ptr == 0
; 136  : 			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
; 137  : 			{	// report error
; 138  : 			_DEBUG_ERROR("string iterator not decrementable");
; 139  : 			_SCL_SECURE_OUT_OF_RANGE;
; 140  : 			}
; 141  : 
; 142  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 143  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 144  : 		_SCL_SECURE_VALIDATE_RANGE(
; 145  : 			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);
; 146  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 147  : 
; 148  : 		--this->_Ptr;
; 149  : 		return (*this);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter operator--(int)
; 153  : 		{	// postdecrement
; 154  : 		_Myiter _Tmp = *this;
; 155  : 		--*this;
; 156  : 		return (_Tmp);
; 157  : 		}
; 158  : 
; 159  : 	_Myiter& operator+=(difference_type _Off)
; 160  : 		{	// increment by integer
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 		if (this->_Getcont() == 0
; 163  : 			|| this->_Ptr == 0
; 164  : 			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
; 165  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 166  : 				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
; 167  : 			{	// report error
; 168  : 			_DEBUG_ERROR("string iterator + offset out of range");
; 169  : 			_SCL_SECURE_OUT_OF_RANGE;
; 170  : 			}
; 171  : 
; 172  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 173  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 174  : 		_SCL_SECURE_VALIDATE_RANGE(
; 175  : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off
; 176  : 				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()
; 177  : 					+ ((_Mystr *)this->_Getcont())->_Mysize);
; 178  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 179  : 
; 180  : 		_Ptr += _Off;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myiter operator+(difference_type _Off) const
; 185  : 		{	// return this + integer
; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);
; 188  : 		}
; 189  : 
; 190  : 	_Myiter& operator-=(difference_type _Off)
; 191  : 		{	// decrement by integer
; 192  : 		return (*this += -_Off);
; 193  : 		}
; 194  : 
; 195  : 	_Myiter operator-(difference_type _Off) const
; 196  : 		{	// return this - integer
; 197  : 		_Myiter _Tmp = *this;
; 198  : 		return (_Tmp -= _Off);
; 199  : 		}
; 200  : 
; 201  : 	difference_type operator-(const _Myiter& _Right) const
; 202  : 		{	// return difference of iterators
; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);
; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);
; 216  : 		}
; 217  : 
; 218  : 	bool operator!=(const _Myiter& _Right) const
; 219  : 		{	// test for iterator inequality
; 220  : 		return (!(*this == _Right));
; 221  : 		}
; 222  : 
; 223  : 	bool operator<(const _Myiter& _Right) const
; 224  : 		{	// test if this < _Right
; 225  : 		_Compat(_Right);
; 226  : 		return (this->_Ptr < _Right._Ptr);
; 227  : 		}
; 228  : 
; 229  : 	bool operator>(const _Myiter& _Right) const
; 230  : 		{	// test if this > _Right
; 231  : 		return (_Right < *this);
; 232  : 		}
; 233  : 
; 234  : 	bool operator<=(const _Myiter& _Right) const
; 235  : 		{	// test if this <= _Right
; 236  : 		return (!(_Right < *this));
; 237  : 		}
; 238  : 
; 239  : 	bool operator>=(const _Myiter& _Right) const
; 240  : 		{	// test if this >= _Right
; 241  : 		return (!(*this < _Right));
; 242  : 		}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 245  : 	void _Compat(const _Myiter& _Right) const
; 246  : 		{	// test for compatible iterator pair
; 247  : 		if (this->_Getcont() == 0
; 248  : 			|| this->_Getcont() != _Right._Getcont())
; 249  : 			{	// report error
; 250  : 			_DEBUG_ERROR("string iterators incompatible");
; 251  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 252  : 			}
; 253  : 		}
; 254  : 
; 255  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 256  : 	void _Compat(const _Myiter& _Right) const
; 257  : 		{	// test for compatible iterator pair
; 258  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 259  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 260  : 		}
; 261  : 
; 262  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 263  : 	void _Compat(const _Myiter&) const
; 264  : 		{	// test for compatible iterator pair
; 265  : 		}
; 266  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 267  : 
; 268  : 	pointer _Ptr;	// pointer to element in string
; 269  : 	};
; 270  : 
; 271  : template<class _Mystr> inline
; 272  : 	typename _String_const_iterator<_Mystr>::_Unchecked_type
; 273  : 		_Unchecked(_String_const_iterator<_Mystr> _Iter)
; 274  : 	{	// convert to unchecked
; 275  : 	return (_Iter._Unchecked());
; 276  : 	}
; 277  : 
; 278  : template<class _Mystr> inline
; 279  : 	_String_const_iterator<_Mystr>
; 280  : 		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
; 281  : 			typename _String_const_iterator<_Mystr>
; 282  : 				::_Unchecked_type _Right)
; 283  : 	{	// convert to checked
; 284  : 	return (_Iter._Rechecked(_Right));
; 285  : 	}
; 286  : 
; 287  : template<class _Mystr> inline
; 288  : 	_String_const_iterator<_Mystr> operator+(
; 289  : 		typename _String_const_iterator<_Mystr>
; 290  : 			::difference_type _Off,
; 291  : 		_String_const_iterator<_Mystr> _Next)
; 292  : 	{	// add offset to iterator
; 293  : 	return (_Next += _Off);
; 294  : 	}
; 295  : 
; 296  : 		// TEMPLATE CLASS _String_iterator
; 297  : template<class _Mystr>
; 298  : 	class _String_iterator
; 299  : 		: public _String_const_iterator<_Mystr>
; 300  : 	{	// iterator for mutable string
; 301  : public:
; 302  : 	typedef _String_iterator<_Mystr> _Myiter;
; 303  : 	typedef _String_const_iterator<_Mystr> _Mybase;
; 304  : 	typedef random_access_iterator_tag iterator_category;
; 305  : 
; 306  : 	typedef typename _Mystr::value_type value_type;
; 307  : 	typedef typename _Mystr::difference_type difference_type;
; 308  : 	typedef typename _Mystr::pointer pointer;
; 309  : 	typedef typename _Mystr::reference reference;
; 310  : 
; 311  : 	_String_iterator()
; 312  : 		{	// construct with null string pointer
; 313  : 		}
; 314  : 
; 315  : 	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
; 316  : 		: _Mybase(_Parg, _Pstring)
; 317  : 		{	// construct with pointer _Parg
; 318  : 		}
; 319  : 
; 320  : 	typedef pointer _Unchecked_type;
; 321  : 
; 322  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 323  : 		{	// reset from unchecked iterator
; 324  : 		this->_Ptr = _Right;
; 325  : 		return (*this);
; 326  : 		}
; 327  : 
; 328  : 	_Unchecked_type _Unchecked() const
; 329  : 		{	// make an unchecked iterator
; 330  : 		return (_Unchecked_type(this->_Ptr));
; 331  : 		}
; 332  : 
; 333  : 	reference operator*() const
; 334  : 		{	// return designated object
; 335  : 		return ((reference)**(_Mybase *)this);
; 336  : 		}
; 337  : 
; 338  : 	pointer operator->() const
; 339  : 		{	// return pointer to class object
; 340  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 341  : 		}
; 342  : 
; 343  : 	_Myiter& operator++()
; 344  : 		{	// preincrement
; 345  : 		++*(_Mybase *)this;
; 346  : 		return (*this);
; 347  : 		}
; 348  : 
; 349  : 	_Myiter operator++(int)
; 350  : 		{	// postincrement
; 351  : 		_Myiter _Tmp = *this;
; 352  : 		++*this;
; 353  : 		return (_Tmp);
; 354  : 		}
; 355  : 
; 356  : 	_Myiter& operator--()
; 357  : 		{	// predecrement
; 358  : 		--*(_Mybase *)this;
; 359  : 		return (*this);
; 360  : 		}
; 361  : 
; 362  : 	_Myiter operator--(int)
; 363  : 		{	// postdecrement
; 364  : 		_Myiter _Tmp = *this;
; 365  : 		--*this;
; 366  : 		return (_Tmp);
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator+=(difference_type _Off)
; 370  : 		{	// increment by integer
; 371  : 		*(_Mybase *)this += _Off;
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator+(difference_type _Off) const
; 376  : 		{	// return this + integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp += _Off);
; 379  : 		}
; 380  : 
; 381  : 	_Myiter& operator-=(difference_type _Off)
; 382  : 		{	// decrement by integer
; 383  : 		return (*this += -_Off);
; 384  : 		}
; 385  : 
; 386  : 	_Myiter operator-(difference_type _Off) const
; 387  : 		{	// return this - integer
; 388  : 		_Myiter _Tmp = *this;
; 389  : 		return (_Tmp -= _Off);
; 390  : 		}
; 391  : 
; 392  : 	difference_type operator-(const _Mybase& _Right) const
; 393  : 		{	// return difference of iterators
; 394  : 		return ((_Mybase)*this - _Right);
; 395  : 		}
; 396  : 
; 397  : 	reference operator[](difference_type _Off) const
; 398  : 		{	// subscript
; 399  : 		return (*(*this + _Off));
; 400  : 		}
; 401  : 	};
; 402  : 
; 403  : template<class _Mystr> inline
; 404  : 	typename _String_iterator<_Mystr>::_Unchecked_type
; 405  : 		_Unchecked(_String_iterator<_Mystr> _Iter)
; 406  : 	{	// convert to unchecked
; 407  : 	return (_Iter._Unchecked());
; 408  : 	}
; 409  : 
; 410  : template<class _Mystr> inline
; 411  : 	_String_iterator<_Mystr>
; 412  : 		_Rechecked(_String_iterator<_Mystr>& _Iter,
; 413  : 			typename _String_iterator<_Mystr>
; 414  : 				::_Unchecked_type _Right)
; 415  : 	{	// convert to checked
; 416  : 	return (_Iter._Rechecked(_Right));
; 417  : 	}
; 418  : 
; 419  : template<class _Mystr> inline
; 420  : 	_String_iterator<_Mystr> operator+(
; 421  : 		typename _String_iterator<_Mystr>
; 422  : 			::difference_type _Off,
; 423  : 		_String_iterator<_Mystr> _Next)
; 424  : 	{	// add offset to iterator
; 425  : 	return (_Next += _Off);
; 426  : 	}
; 427  : 
; 428  : 		// basic_string TYPE WRAPPERS
; 429  : template<class _Value_type,
; 430  : 	class _Size_type,
; 431  : 	class _Difference_type,
; 432  : 	class _Pointer,
; 433  : 	class _Const_pointer,
; 434  : 	class _Reference,
; 435  : 	class _Const_reference>
; 436  : 	struct _String_iter_types
; 437  : 	{	// wraps types needed by iterators
; 438  : 	typedef _Value_type value_type;
; 439  : 	typedef _Size_type size_type;
; 440  : 	typedef _Difference_type difference_type;
; 441  : 	typedef _Pointer pointer;
; 442  : 	typedef _Const_pointer const_pointer;
; 443  : 	typedef _Reference reference;
; 444  : 	typedef _Const_reference const_reference;
; 445  : 	};
; 446  : 
; 447  : template<class _Ty,
; 448  : 	class _Alloc0>
; 449  : 	struct _String_base_types
; 450  : 	{	// types needed for a container base
; 451  : 	typedef _Alloc0 _Alloc;
; 452  : 	typedef _String_base_types<_Ty, _Alloc> _Myt;
; 453  : 
; 454  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 455  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 456  : 
; 457  : 
; 458  : 	typedef typename _Alty::pointer _Tptr;
; 459  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 460  : 
; 461  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 462  : 		_Simple_types<typename _Alty::value_type>,
; 463  : 		_String_iter_types<typename _Alty::value_type,
; 464  : 			typename _Alty::size_type,
; 465  : 			typename _Alty::difference_type,
; 466  : 			typename _Alty::pointer,
; 467  : 			typename _Alty::const_pointer,
; 468  : 			typename _Alty::reference,
; 469  : 			typename _Alty::const_reference> >::type
; 470  : 		_Val_types;
; 471  : 	};
; 472  : 
; 473  : 		// TEMPLATE CLASS _String_val
; 474  : template<class _Val_types>
; 475  : 	class _String_val
; 476  : 		: public _Container_base
; 477  : 	{	// base class for basic_string to hold data
; 478  : public:
; 479  : 	typedef _String_val<_Val_types> _Myt;
; 480  : 
; 481  : 	typedef typename _Val_types::value_type value_type;
; 482  : 	typedef typename _Val_types::size_type size_type;
; 483  : 	typedef typename _Val_types::difference_type difference_type;
; 484  : 	typedef typename _Val_types::pointer pointer;
; 485  : 	typedef typename _Val_types::const_pointer const_pointer;
; 486  : 	typedef typename _Val_types::reference reference;
; 487  : 	typedef typename _Val_types::const_reference const_reference;
; 488  : 
; 489  : 	typedef _String_iterator<_Myt> iterator;
; 490  : 	typedef _String_const_iterator<_Myt> const_iterator;
; 491  : 
; 492  : 	_String_val()
; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;
; 495  : 		_Myres = 0;
; 496  : 		}
; 497  : 
; 498  : 	enum
; 499  : 		{	// length of internal buffer, [1, 16]
; 500  : 		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
; 501  : 			: 16 / sizeof (value_type)};
; 502  : 	enum
; 503  : 		{	// roundup mask for allocated buffers, [0, 15]
; 504  : 		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
; 505  : 			: sizeof (value_type) <= 2 ? 7
; 506  : 			: sizeof (value_type) <= 4 ? 3
; 507  : 			: sizeof (value_type) <= 8 ? 1 : 0};
; 508  : 
; 509  : 	value_type *_Myptr()
; 510  : 		{	// determine current pointer to buffer for mutable string
; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

  00019	8b c1		 mov	 eax, ecx

; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));

  0001b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0001e	03 c8		 add	 ecx, eax

; 54   : 		this->_Ptr = _Parg;

  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1611 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 51   : 	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 		{	// construct with pointer _Parg
; 53   : 		this->_Adopt(_Pstring);
; 54   : 		this->_Ptr = _Parg;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 55   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 317  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   : 		this->_Ptr = _Parg;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 318  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1599 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 		}
; 56   : 
; 57   : 	typedef pointer _Unchecked_type;
; 58   : 
; 59   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 60   : 		{	// reset from unchecked iterator
; 61   : 		this->_Ptr = _Right;
; 62   : 		return (*this);
; 63   : 		}
; 64   : 
; 65   : 	_Unchecked_type _Unchecked() const
; 66   : 		{	// make an unchecked iterator
; 67   : 		return (_Unchecked_type(this->_Ptr));
; 68   : 		}
; 69   : 
; 70   : 	reference operator*() const
; 71   : 		{	// return designated object
; 72   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 73   : 		if (this->_Getcont() == 0
; 74   : 			|| this->_Ptr == 0
; 75   : 			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 76   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 77   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 78   : 			{	// report error
; 79   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 80   : 			_SCL_SECURE_OUT_OF_RANGE;
; 81   : 			}
; 82   : 
; 83   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 84   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(
; 86   : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr
; 87   : 			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 88   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 89   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 90   : 
; 91   : 		_Analysis_assume_(this->_Ptr != 0);
; 92   : 
; 93   : 		return (*this->_Ptr);
; 94   : 		}
; 95   : 
; 96   : 	pointer operator->() const
; 97   : 		{	// return pointer to class object
; 98   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 99   : 		}
; 100  : 
; 101  : 	_Myiter& operator++()
; 102  : 		{	// preincrement
; 103  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 104  : 		if (this->_Getcont() == 0
; 105  : 			|| this->_Ptr == 0
; 106  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 107  : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 108  : 			{	// report error
; 109  : 			_DEBUG_ERROR("string iterator not incrementable");
; 110  : 			_SCL_SECURE_OUT_OF_RANGE;
; 111  : 			}
; 112  : 
; 113  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 114  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 115  : 		_SCL_SECURE_VALIDATE_RANGE(
; 116  : 			this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 117  : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 118  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 119  : 
; 120  : 		++this->_Ptr;
; 121  : 		return (*this);
; 122  : 		}
; 123  : 
; 124  : 	_Myiter operator++(int)
; 125  : 		{	// postincrement
; 126  : 		_Myiter _Tmp = *this;
; 127  : 		++*this;
; 128  : 		return (_Tmp);
; 129  : 		}
; 130  : 
; 131  : 	_Myiter& operator--()
; 132  : 		{	// predecrement
; 133  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 134  : 		if (this->_Getcont() == 0
; 135  : 			|| this->_Ptr == 0
; 136  : 			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
; 137  : 			{	// report error
; 138  : 			_DEBUG_ERROR("string iterator not decrementable");
; 139  : 			_SCL_SECURE_OUT_OF_RANGE;
; 140  : 			}
; 141  : 
; 142  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 143  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 144  : 		_SCL_SECURE_VALIDATE_RANGE(
; 145  : 			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);
; 146  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 147  : 
; 148  : 		--this->_Ptr;
; 149  : 		return (*this);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter operator--(int)
; 153  : 		{	// postdecrement
; 154  : 		_Myiter _Tmp = *this;
; 155  : 		--*this;
; 156  : 		return (_Tmp);
; 157  : 		}
; 158  : 
; 159  : 	_Myiter& operator+=(difference_type _Off)
; 160  : 		{	// increment by integer
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 		if (this->_Getcont() == 0
; 163  : 			|| this->_Ptr == 0
; 164  : 			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
; 165  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 166  : 				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
; 167  : 			{	// report error
; 168  : 			_DEBUG_ERROR("string iterator + offset out of range");
; 169  : 			_SCL_SECURE_OUT_OF_RANGE;
; 170  : 			}
; 171  : 
; 172  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 173  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 174  : 		_SCL_SECURE_VALIDATE_RANGE(
; 175  : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off
; 176  : 				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()
; 177  : 					+ ((_Mystr *)this->_Getcont())->_Mysize);
; 178  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 179  : 
; 180  : 		_Ptr += _Off;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myiter operator+(difference_type _Off) const
; 185  : 		{	// return this + integer
; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);
; 188  : 		}
; 189  : 
; 190  : 	_Myiter& operator-=(difference_type _Off)
; 191  : 		{	// decrement by integer
; 192  : 		return (*this += -_Off);
; 193  : 		}
; 194  : 
; 195  : 	_Myiter operator-(difference_type _Off) const
; 196  : 		{	// return this - integer
; 197  : 		_Myiter _Tmp = *this;
; 198  : 		return (_Tmp -= _Off);
; 199  : 		}
; 200  : 
; 201  : 	difference_type operator-(const _Myiter& _Right) const
; 202  : 		{	// return difference of iterators
; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);
; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);
; 216  : 		}
; 217  : 
; 218  : 	bool operator!=(const _Myiter& _Right) const
; 219  : 		{	// test for iterator inequality
; 220  : 		return (!(*this == _Right));
; 221  : 		}
; 222  : 
; 223  : 	bool operator<(const _Myiter& _Right) const
; 224  : 		{	// test if this < _Right
; 225  : 		_Compat(_Right);
; 226  : 		return (this->_Ptr < _Right._Ptr);
; 227  : 		}
; 228  : 
; 229  : 	bool operator>(const _Myiter& _Right) const
; 230  : 		{	// test if this > _Right
; 231  : 		return (_Right < *this);
; 232  : 		}
; 233  : 
; 234  : 	bool operator<=(const _Myiter& _Right) const
; 235  : 		{	// test if this <= _Right
; 236  : 		return (!(_Right < *this));
; 237  : 		}
; 238  : 
; 239  : 	bool operator>=(const _Myiter& _Right) const
; 240  : 		{	// test if this >= _Right
; 241  : 		return (!(*this < _Right));
; 242  : 		}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 245  : 	void _Compat(const _Myiter& _Right) const
; 246  : 		{	// test for compatible iterator pair
; 247  : 		if (this->_Getcont() == 0
; 248  : 			|| this->_Getcont() != _Right._Getcont())
; 249  : 			{	// report error
; 250  : 			_DEBUG_ERROR("string iterators incompatible");
; 251  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 252  : 			}
; 253  : 		}
; 254  : 
; 255  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 256  : 	void _Compat(const _Myiter& _Right) const
; 257  : 		{	// test for compatible iterator pair
; 258  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 259  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 260  : 		}
; 261  : 
; 262  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 263  : 	void _Compat(const _Myiter&) const
; 264  : 		{	// test for compatible iterator pair
; 265  : 		}
; 266  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 267  : 
; 268  : 	pointer _Ptr;	// pointer to element in string
; 269  : 	};
; 270  : 
; 271  : template<class _Mystr> inline
; 272  : 	typename _String_const_iterator<_Mystr>::_Unchecked_type
; 273  : 		_Unchecked(_String_const_iterator<_Mystr> _Iter)
; 274  : 	{	// convert to unchecked
; 275  : 	return (_Iter._Unchecked());
; 276  : 	}
; 277  : 
; 278  : template<class _Mystr> inline
; 279  : 	_String_const_iterator<_Mystr>
; 280  : 		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
; 281  : 			typename _String_const_iterator<_Mystr>
; 282  : 				::_Unchecked_type _Right)
; 283  : 	{	// convert to checked
; 284  : 	return (_Iter._Rechecked(_Right));
; 285  : 	}
; 286  : 
; 287  : template<class _Mystr> inline
; 288  : 	_String_const_iterator<_Mystr> operator+(
; 289  : 		typename _String_const_iterator<_Mystr>
; 290  : 			::difference_type _Off,
; 291  : 		_String_const_iterator<_Mystr> _Next)
; 292  : 	{	// add offset to iterator
; 293  : 	return (_Next += _Off);
; 294  : 	}
; 295  : 
; 296  : 		// TEMPLATE CLASS _String_iterator
; 297  : template<class _Mystr>
; 298  : 	class _String_iterator
; 299  : 		: public _String_const_iterator<_Mystr>
; 300  : 	{	// iterator for mutable string
; 301  : public:
; 302  : 	typedef _String_iterator<_Mystr> _Myiter;
; 303  : 	typedef _String_const_iterator<_Mystr> _Mybase;
; 304  : 	typedef random_access_iterator_tag iterator_category;
; 305  : 
; 306  : 	typedef typename _Mystr::value_type value_type;
; 307  : 	typedef typename _Mystr::difference_type difference_type;
; 308  : 	typedef typename _Mystr::pointer pointer;
; 309  : 	typedef typename _Mystr::reference reference;
; 310  : 
; 311  : 	_String_iterator()
; 312  : 		{	// construct with null string pointer
; 313  : 		}
; 314  : 
; 315  : 	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
; 316  : 		: _Mybase(_Parg, _Pstring)
; 317  : 		{	// construct with pointer _Parg
; 318  : 		}
; 319  : 
; 320  : 	typedef pointer _Unchecked_type;
; 321  : 
; 322  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 323  : 		{	// reset from unchecked iterator
; 324  : 		this->_Ptr = _Right;
; 325  : 		return (*this);
; 326  : 		}
; 327  : 
; 328  : 	_Unchecked_type _Unchecked() const
; 329  : 		{	// make an unchecked iterator
; 330  : 		return (_Unchecked_type(this->_Ptr));
; 331  : 		}
; 332  : 
; 333  : 	reference operator*() const
; 334  : 		{	// return designated object
; 335  : 		return ((reference)**(_Mybase *)this);
; 336  : 		}
; 337  : 
; 338  : 	pointer operator->() const
; 339  : 		{	// return pointer to class object
; 340  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 341  : 		}
; 342  : 
; 343  : 	_Myiter& operator++()
; 344  : 		{	// preincrement
; 345  : 		++*(_Mybase *)this;
; 346  : 		return (*this);
; 347  : 		}
; 348  : 
; 349  : 	_Myiter operator++(int)
; 350  : 		{	// postincrement
; 351  : 		_Myiter _Tmp = *this;
; 352  : 		++*this;
; 353  : 		return (_Tmp);
; 354  : 		}
; 355  : 
; 356  : 	_Myiter& operator--()
; 357  : 		{	// predecrement
; 358  : 		--*(_Mybase *)this;
; 359  : 		return (*this);
; 360  : 		}
; 361  : 
; 362  : 	_Myiter operator--(int)
; 363  : 		{	// postdecrement
; 364  : 		_Myiter _Tmp = *this;
; 365  : 		--*this;
; 366  : 		return (_Tmp);
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator+=(difference_type _Off)
; 370  : 		{	// increment by integer
; 371  : 		*(_Mybase *)this += _Off;
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator+(difference_type _Off) const
; 376  : 		{	// return this + integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp += _Off);
; 379  : 		}
; 380  : 
; 381  : 	_Myiter& operator-=(difference_type _Off)
; 382  : 		{	// decrement by integer
; 383  : 		return (*this += -_Off);
; 384  : 		}
; 385  : 
; 386  : 	_Myiter operator-(difference_type _Off) const
; 387  : 		{	// return this - integer
; 388  : 		_Myiter _Tmp = *this;
; 389  : 		return (_Tmp -= _Off);
; 390  : 		}
; 391  : 
; 392  : 	difference_type operator-(const _Mybase& _Right) const
; 393  : 		{	// return difference of iterators
; 394  : 		return ((_Mybase)*this - _Right);
; 395  : 		}
; 396  : 
; 397  : 	reference operator[](difference_type _Off) const
; 398  : 		{	// subscript
; 399  : 		return (*(*this + _Off));
; 400  : 		}
; 401  : 	};
; 402  : 
; 403  : template<class _Mystr> inline
; 404  : 	typename _String_iterator<_Mystr>::_Unchecked_type
; 405  : 		_Unchecked(_String_iterator<_Mystr> _Iter)
; 406  : 	{	// convert to unchecked
; 407  : 	return (_Iter._Unchecked());
; 408  : 	}
; 409  : 
; 410  : template<class _Mystr> inline
; 411  : 	_String_iterator<_Mystr>
; 412  : 		_Rechecked(_String_iterator<_Mystr>& _Iter,
; 413  : 			typename _String_iterator<_Mystr>
; 414  : 				::_Unchecked_type _Right)
; 415  : 	{	// convert to checked
; 416  : 	return (_Iter._Rechecked(_Right));
; 417  : 	}
; 418  : 
; 419  : template<class _Mystr> inline
; 420  : 	_String_iterator<_Mystr> operator+(
; 421  : 		typename _String_iterator<_Mystr>
; 422  : 			::difference_type _Off,
; 423  : 		_String_iterator<_Mystr> _Next)
; 424  : 	{	// add offset to iterator
; 425  : 	return (_Next += _Off);
; 426  : 	}
; 427  : 
; 428  : 		// basic_string TYPE WRAPPERS
; 429  : template<class _Value_type,
; 430  : 	class _Size_type,
; 431  : 	class _Difference_type,
; 432  : 	class _Pointer,
; 433  : 	class _Const_pointer,
; 434  : 	class _Reference,
; 435  : 	class _Const_reference>
; 436  : 	struct _String_iter_types
; 437  : 	{	// wraps types needed by iterators
; 438  : 	typedef _Value_type value_type;
; 439  : 	typedef _Size_type size_type;
; 440  : 	typedef _Difference_type difference_type;
; 441  : 	typedef _Pointer pointer;
; 442  : 	typedef _Const_pointer const_pointer;
; 443  : 	typedef _Reference reference;
; 444  : 	typedef _Const_reference const_reference;
; 445  : 	};
; 446  : 
; 447  : template<class _Ty,
; 448  : 	class _Alloc0>
; 449  : 	struct _String_base_types
; 450  : 	{	// types needed for a container base
; 451  : 	typedef _Alloc0 _Alloc;
; 452  : 	typedef _String_base_types<_Ty, _Alloc> _Myt;
; 453  : 
; 454  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 455  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 456  : 
; 457  : 
; 458  : 	typedef typename _Alty::pointer _Tptr;
; 459  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 460  : 
; 461  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 462  : 		_Simple_types<typename _Alty::value_type>,
; 463  : 		_String_iter_types<typename _Alty::value_type,
; 464  : 			typename _Alty::size_type,
; 465  : 			typename _Alty::difference_type,
; 466  : 			typename _Alty::pointer,
; 467  : 			typename _Alty::const_pointer,
; 468  : 			typename _Alty::reference,
; 469  : 			typename _Alty::const_reference> >::type
; 470  : 		_Val_types;
; 471  : 	};
; 472  : 
; 473  : 		// TEMPLATE CLASS _String_val
; 474  : template<class _Val_types>
; 475  : 	class _String_val
; 476  : 		: public _Container_base
; 477  : 	{	// base class for basic_string to hold data
; 478  : public:
; 479  : 	typedef _String_val<_Val_types> _Myt;
; 480  : 
; 481  : 	typedef typename _Val_types::value_type value_type;
; 482  : 	typedef typename _Val_types::size_type size_type;
; 483  : 	typedef typename _Val_types::difference_type difference_type;
; 484  : 	typedef typename _Val_types::pointer pointer;
; 485  : 	typedef typename _Val_types::const_pointer const_pointer;
; 486  : 	typedef typename _Val_types::reference reference;
; 487  : 	typedef typename _Val_types::const_reference const_reference;
; 488  : 
; 489  : 	typedef _String_iterator<_Myt> iterator;
; 490  : 	typedef _String_const_iterator<_Myt> const_iterator;
; 491  : 
; 492  : 	_String_val()
; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;
; 495  : 		_Myres = 0;
; 496  : 		}
; 497  : 
; 498  : 	enum
; 499  : 		{	// length of internal buffer, [1, 16]
; 500  : 		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
; 501  : 			: 16 / sizeof (value_type)};
; 502  : 	enum
; 503  : 		{	// roundup mask for allocated buffers, [0, 15]
; 504  : 		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
; 505  : 			: sizeof (value_type) <= 2 ? 7
; 506  : 			: sizeof (value_type) <= 4 ? 3
; 507  : 			: sizeof (value_type) <= 8 ? 1 : 0};
; 508  : 
; 509  : 	value_type *_Myptr()
; 510  : 		{	// determine current pointer to buffer for mutable string
; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 54   : 		this->_Ptr = _Parg;

  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 55   : 		}
; 56   : 
; 57   : 	typedef pointer _Unchecked_type;
; 58   : 
; 59   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 60   : 		{	// reset from unchecked iterator
; 61   : 		this->_Ptr = _Right;
; 62   : 		return (*this);
; 63   : 		}
; 64   : 
; 65   : 	_Unchecked_type _Unchecked() const
; 66   : 		{	// make an unchecked iterator
; 67   : 		return (_Unchecked_type(this->_Ptr));
; 68   : 		}
; 69   : 
; 70   : 	reference operator*() const
; 71   : 		{	// return designated object
; 72   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 73   : 		if (this->_Getcont() == 0
; 74   : 			|| this->_Ptr == 0
; 75   : 			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 76   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 77   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 78   : 			{	// report error
; 79   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 80   : 			_SCL_SECURE_OUT_OF_RANGE;
; 81   : 			}
; 82   : 
; 83   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 84   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(
; 86   : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr
; 87   : 			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 88   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 89   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 90   : 
; 91   : 		_Analysis_assume_(this->_Ptr != 0);
; 92   : 
; 93   : 		return (*this->_Ptr);
; 94   : 		}
; 95   : 
; 96   : 	pointer operator->() const
; 97   : 		{	// return pointer to class object
; 98   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 99   : 		}
; 100  : 
; 101  : 	_Myiter& operator++()
; 102  : 		{	// preincrement
; 103  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 104  : 		if (this->_Getcont() == 0
; 105  : 			|| this->_Ptr == 0
; 106  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 107  : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
; 108  : 			{	// report error
; 109  : 			_DEBUG_ERROR("string iterator not incrementable");
; 110  : 			_SCL_SECURE_OUT_OF_RANGE;
; 111  : 			}
; 112  : 
; 113  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 114  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 115  : 		_SCL_SECURE_VALIDATE_RANGE(
; 116  : 			this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 117  : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 118  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 119  : 
; 120  : 		++this->_Ptr;
; 121  : 		return (*this);
; 122  : 		}
; 123  : 
; 124  : 	_Myiter operator++(int)
; 125  : 		{	// postincrement
; 126  : 		_Myiter _Tmp = *this;
; 127  : 		++*this;
; 128  : 		return (_Tmp);
; 129  : 		}
; 130  : 
; 131  : 	_Myiter& operator--()
; 132  : 		{	// predecrement
; 133  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 134  : 		if (this->_Getcont() == 0
; 135  : 			|| this->_Ptr == 0
; 136  : 			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
; 137  : 			{	// report error
; 138  : 			_DEBUG_ERROR("string iterator not decrementable");
; 139  : 			_SCL_SECURE_OUT_OF_RANGE;
; 140  : 			}
; 141  : 
; 142  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 143  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 144  : 		_SCL_SECURE_VALIDATE_RANGE(
; 145  : 			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);
; 146  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 147  : 
; 148  : 		--this->_Ptr;
; 149  : 		return (*this);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter operator--(int)
; 153  : 		{	// postdecrement
; 154  : 		_Myiter _Tmp = *this;
; 155  : 		--*this;
; 156  : 		return (_Tmp);
; 157  : 		}
; 158  : 
; 159  : 	_Myiter& operator+=(difference_type _Off)
; 160  : 		{	// increment by integer
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 		if (this->_Getcont() == 0
; 163  : 			|| this->_Ptr == 0
; 164  : 			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
; 165  : 			|| ((_Mystr *)this->_Getcont())->_Myptr()
; 166  : 				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
; 167  : 			{	// report error
; 168  : 			_DEBUG_ERROR("string iterator + offset out of range");
; 169  : 			_SCL_SECURE_OUT_OF_RANGE;
; 170  : 			}
; 171  : 
; 172  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 173  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 174  : 		_SCL_SECURE_VALIDATE_RANGE(
; 175  : 			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off
; 176  : 				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()
; 177  : 					+ ((_Mystr *)this->_Getcont())->_Mysize);
; 178  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 179  : 
; 180  : 		_Ptr += _Off;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myiter operator+(difference_type _Off) const
; 185  : 		{	// return this + integer
; 186  : 		_Myiter _Tmp = *this;
; 187  : 		return (_Tmp += _Off);
; 188  : 		}
; 189  : 
; 190  : 	_Myiter& operator-=(difference_type _Off)
; 191  : 		{	// decrement by integer
; 192  : 		return (*this += -_Off);
; 193  : 		}
; 194  : 
; 195  : 	_Myiter operator-(difference_type _Off) const
; 196  : 		{	// return this - integer
; 197  : 		_Myiter _Tmp = *this;
; 198  : 		return (_Tmp -= _Off);
; 199  : 		}
; 200  : 
; 201  : 	difference_type operator-(const _Myiter& _Right) const
; 202  : 		{	// return difference of iterators
; 203  : 		_Compat(_Right);
; 204  : 		return (this->_Ptr - _Right._Ptr);
; 205  : 		}
; 206  : 
; 207  : 	reference operator[](difference_type _Off) const
; 208  : 		{	// subscript
; 209  : 		return (*(*this + _Off));
; 210  : 		}
; 211  : 
; 212  : 	bool operator==(const _Myiter& _Right) const
; 213  : 		{	// test for iterator equality
; 214  : 		_Compat(_Right);
; 215  : 		return (this->_Ptr == _Right._Ptr);
; 216  : 		}
; 217  : 
; 218  : 	bool operator!=(const _Myiter& _Right) const
; 219  : 		{	// test for iterator inequality
; 220  : 		return (!(*this == _Right));
; 221  : 		}
; 222  : 
; 223  : 	bool operator<(const _Myiter& _Right) const
; 224  : 		{	// test if this < _Right
; 225  : 		_Compat(_Right);
; 226  : 		return (this->_Ptr < _Right._Ptr);
; 227  : 		}
; 228  : 
; 229  : 	bool operator>(const _Myiter& _Right) const
; 230  : 		{	// test if this > _Right
; 231  : 		return (_Right < *this);
; 232  : 		}
; 233  : 
; 234  : 	bool operator<=(const _Myiter& _Right) const
; 235  : 		{	// test if this <= _Right
; 236  : 		return (!(_Right < *this));
; 237  : 		}
; 238  : 
; 239  : 	bool operator>=(const _Myiter& _Right) const
; 240  : 		{	// test if this >= _Right
; 241  : 		return (!(*this < _Right));
; 242  : 		}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 245  : 	void _Compat(const _Myiter& _Right) const
; 246  : 		{	// test for compatible iterator pair
; 247  : 		if (this->_Getcont() == 0
; 248  : 			|| this->_Getcont() != _Right._Getcont())
; 249  : 			{	// report error
; 250  : 			_DEBUG_ERROR("string iterators incompatible");
; 251  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 252  : 			}
; 253  : 		}
; 254  : 
; 255  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 256  : 	void _Compat(const _Myiter& _Right) const
; 257  : 		{	// test for compatible iterator pair
; 258  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 259  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 260  : 		}
; 261  : 
; 262  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 263  : 	void _Compat(const _Myiter&) const
; 264  : 		{	// test for compatible iterator pair
; 265  : 		}
; 266  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 267  : 
; 268  : 	pointer _Ptr;	// pointer to element in string
; 269  : 	};
; 270  : 
; 271  : template<class _Mystr> inline
; 272  : 	typename _String_const_iterator<_Mystr>::_Unchecked_type
; 273  : 		_Unchecked(_String_const_iterator<_Mystr> _Iter)
; 274  : 	{	// convert to unchecked
; 275  : 	return (_Iter._Unchecked());
; 276  : 	}
; 277  : 
; 278  : template<class _Mystr> inline
; 279  : 	_String_const_iterator<_Mystr>
; 280  : 		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
; 281  : 			typename _String_const_iterator<_Mystr>
; 282  : 				::_Unchecked_type _Right)
; 283  : 	{	// convert to checked
; 284  : 	return (_Iter._Rechecked(_Right));
; 285  : 	}
; 286  : 
; 287  : template<class _Mystr> inline
; 288  : 	_String_const_iterator<_Mystr> operator+(
; 289  : 		typename _String_const_iterator<_Mystr>
; 290  : 			::difference_type _Off,
; 291  : 		_String_const_iterator<_Mystr> _Next)
; 292  : 	{	// add offset to iterator
; 293  : 	return (_Next += _Off);
; 294  : 	}
; 295  : 
; 296  : 		// TEMPLATE CLASS _String_iterator
; 297  : template<class _Mystr>
; 298  : 	class _String_iterator
; 299  : 		: public _String_const_iterator<_Mystr>
; 300  : 	{	// iterator for mutable string
; 301  : public:
; 302  : 	typedef _String_iterator<_Mystr> _Myiter;
; 303  : 	typedef _String_const_iterator<_Mystr> _Mybase;
; 304  : 	typedef random_access_iterator_tag iterator_category;
; 305  : 
; 306  : 	typedef typename _Mystr::value_type value_type;
; 307  : 	typedef typename _Mystr::difference_type difference_type;
; 308  : 	typedef typename _Mystr::pointer pointer;
; 309  : 	typedef typename _Mystr::reference reference;
; 310  : 
; 311  : 	_String_iterator()
; 312  : 		{	// construct with null string pointer
; 313  : 		}
; 314  : 
; 315  : 	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
; 316  : 		: _Mybase(_Parg, _Pstring)
; 317  : 		{	// construct with pointer _Parg
; 318  : 		}
; 319  : 
; 320  : 	typedef pointer _Unchecked_type;
; 321  : 
; 322  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 323  : 		{	// reset from unchecked iterator
; 324  : 		this->_Ptr = _Right;
; 325  : 		return (*this);
; 326  : 		}
; 327  : 
; 328  : 	_Unchecked_type _Unchecked() const
; 329  : 		{	// make an unchecked iterator
; 330  : 		return (_Unchecked_type(this->_Ptr));
; 331  : 		}
; 332  : 
; 333  : 	reference operator*() const
; 334  : 		{	// return designated object
; 335  : 		return ((reference)**(_Mybase *)this);
; 336  : 		}
; 337  : 
; 338  : 	pointer operator->() const
; 339  : 		{	// return pointer to class object
; 340  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 341  : 		}
; 342  : 
; 343  : 	_Myiter& operator++()
; 344  : 		{	// preincrement
; 345  : 		++*(_Mybase *)this;
; 346  : 		return (*this);
; 347  : 		}
; 348  : 
; 349  : 	_Myiter operator++(int)
; 350  : 		{	// postincrement
; 351  : 		_Myiter _Tmp = *this;
; 352  : 		++*this;
; 353  : 		return (_Tmp);
; 354  : 		}
; 355  : 
; 356  : 	_Myiter& operator--()
; 357  : 		{	// predecrement
; 358  : 		--*(_Mybase *)this;
; 359  : 		return (*this);
; 360  : 		}
; 361  : 
; 362  : 	_Myiter operator--(int)
; 363  : 		{	// postdecrement
; 364  : 		_Myiter _Tmp = *this;
; 365  : 		--*this;
; 366  : 		return (_Tmp);
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator+=(difference_type _Off)
; 370  : 		{	// increment by integer
; 371  : 		*(_Mybase *)this += _Off;
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator+(difference_type _Off) const
; 376  : 		{	// return this + integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp += _Off);
; 379  : 		}
; 380  : 
; 381  : 	_Myiter& operator-=(difference_type _Off)
; 382  : 		{	// decrement by integer
; 383  : 		return (*this += -_Off);
; 384  : 		}
; 385  : 
; 386  : 	_Myiter operator-(difference_type _Off) const
; 387  : 		{	// return this - integer
; 388  : 		_Myiter _Tmp = *this;
; 389  : 		return (_Tmp -= _Off);
; 390  : 		}
; 391  : 
; 392  : 	difference_type operator-(const _Mybase& _Right) const
; 393  : 		{	// return difference of iterators
; 394  : 		return ((_Mybase)*this - _Right);
; 395  : 		}
; 396  : 
; 397  : 	reference operator[](difference_type _Off) const
; 398  : 		{	// subscript
; 399  : 		return (*(*this + _Off));
; 400  : 		}
; 401  : 	};
; 402  : 
; 403  : template<class _Mystr> inline
; 404  : 	typename _String_iterator<_Mystr>::_Unchecked_type
; 405  : 		_Unchecked(_String_iterator<_Mystr> _Iter)
; 406  : 	{	// convert to unchecked
; 407  : 	return (_Iter._Unchecked());
; 408  : 	}
; 409  : 
; 410  : template<class _Mystr> inline
; 411  : 	_String_iterator<_Mystr>
; 412  : 		_Rechecked(_String_iterator<_Mystr>& _Iter,
; 413  : 			typename _String_iterator<_Mystr>
; 414  : 				::_Unchecked_type _Right)
; 415  : 	{	// convert to checked
; 416  : 	return (_Iter._Rechecked(_Right));
; 417  : 	}
; 418  : 
; 419  : template<class _Mystr> inline
; 420  : 	_String_iterator<_Mystr> operator+(
; 421  : 		typename _String_iterator<_Mystr>
; 422  : 			::difference_type _Off,
; 423  : 		_String_iterator<_Mystr> _Next)
; 424  : 	{	// add offset to iterator
; 425  : 	return (_Next += _Off);
; 426  : 	}
; 427  : 
; 428  : 		// basic_string TYPE WRAPPERS
; 429  : template<class _Value_type,
; 430  : 	class _Size_type,
; 431  : 	class _Difference_type,
; 432  : 	class _Pointer,
; 433  : 	class _Const_pointer,
; 434  : 	class _Reference,
; 435  : 	class _Const_reference>
; 436  : 	struct _String_iter_types
; 437  : 	{	// wraps types needed by iterators
; 438  : 	typedef _Value_type value_type;
; 439  : 	typedef _Size_type size_type;
; 440  : 	typedef _Difference_type difference_type;
; 441  : 	typedef _Pointer pointer;
; 442  : 	typedef _Const_pointer const_pointer;
; 443  : 	typedef _Reference reference;
; 444  : 	typedef _Const_reference const_reference;
; 445  : 	};
; 446  : 
; 447  : template<class _Ty,
; 448  : 	class _Alloc0>
; 449  : 	struct _String_base_types
; 450  : 	{	// types needed for a container base
; 451  : 	typedef _Alloc0 _Alloc;
; 452  : 	typedef _String_base_types<_Ty, _Alloc> _Myt;
; 453  : 
; 454  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 455  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 456  : 
; 457  : 
; 458  : 	typedef typename _Alty::pointer _Tptr;
; 459  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 460  : 
; 461  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 462  : 		_Simple_types<typename _Alty::value_type>,
; 463  : 		_String_iter_types<typename _Alty::value_type,
; 464  : 			typename _Alty::size_type,
; 465  : 			typename _Alty::difference_type,
; 466  : 			typename _Alty::pointer,
; 467  : 			typename _Alty::const_pointer,
; 468  : 			typename _Alty::reference,
; 469  : 			typename _Alty::const_reference> >::type
; 470  : 		_Val_types;
; 471  : 	};
; 472  : 
; 473  : 		// TEMPLATE CLASS _String_val
; 474  : template<class _Val_types>
; 475  : 	class _String_val
; 476  : 		: public _Container_base
; 477  : 	{	// base class for basic_string to hold data
; 478  : public:
; 479  : 	typedef _String_val<_Val_types> _Myt;
; 480  : 
; 481  : 	typedef typename _Val_types::value_type value_type;
; 482  : 	typedef typename _Val_types::size_type size_type;
; 483  : 	typedef typename _Val_types::difference_type difference_type;
; 484  : 	typedef typename _Val_types::pointer pointer;
; 485  : 	typedef typename _Val_types::const_pointer const_pointer;
; 486  : 	typedef typename _Val_types::reference reference;
; 487  : 	typedef typename _Val_types::const_reference const_reference;
; 488  : 
; 489  : 	typedef _String_iterator<_Myt> iterator;
; 490  : 	typedef _String_const_iterator<_Myt> const_iterator;
; 491  : 
; 492  : 	_String_val()
; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;
; 495  : 		_Myres = 0;
; 496  : 		}
; 497  : 
; 498  : 	enum
; 499  : 		{	// length of internal buffer, [1, 16]
; 500  : 		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
; 501  : 			: 16 / sizeof (value_type)};
; 502  : 	enum
; 503  : 		{	// roundup mask for allocated buffers, [0, 15]
; 504  : 		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
; 505  : 			: sizeof (value_type) <= 2 ? 7
; 506  : 			: sizeof (value_type) <= 4 ? 3
; 507  : 			: sizeof (value_type) <= 8 ? 1 : 0};
; 508  : 
; 509  : 	value_type *_Myptr()
; 510  : 		{	// determine current pointer to buffer for mutable string
; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

  0000a	72 02		 jb	 SHORT $LN5@begin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@begin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 54   : 		this->_Ptr = _Parg;

  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
END
